;;; -*- package: CC -*-;;;;;;; Extended apropos's subviews;;;(in-package "CC");;;;;;; Help button;;;(defvar *help-buffer*  (let ((buffer (make-buffer)))    (buffer-insert-file buffer "cc:modules;extended-apropos;HELP")    (ccl::%buffer-set-read-only buffer t)    buffer))(defvar *help-window*  nil)(defclass help-button (button-dialog-item)    ()  (:default-initargs    :dialog-item-text "?"))(defmethod help-string ((self help-button))  (format nil "Brings up a window containing documentation on how to use ~               this dialog, including a step by step tutorial of some of ~               its features."))(defmethod dialog-item-action ((self help-button))  (cond ((or (null *help-window*)             (null (wptr *help-window*)))         (make-instance 'fred-window           :window-title "Extended Apropos Help"           :buffer *help-buffer*           :scratch-p t           :save-buffer-p t))        (t (set-window-layer *help-window* 0)           (window-show *help-window*))));;;;;;; Apropos title;;;(defclass apropos-title (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "Search for all symbols whose:"))(defmethod help-string ((self apropos-title))  (help-string *apropos*));;;;;;; Name subview;;;(defclass name-subview (apropos-contour-view)    ())(defmethod help-string ((self name-subview))  (help-string *apropos*))(defmethod install-view-in-window ((self name-subview) window)  (declare (ignore window))  (add-subviews self    (make-instance 'name-title :view-position #@( 25 1))    (make-instance 'name-menu  :view-position #@(175 0))    (make-instance 'name-text  :view-position #@(328 3))));;;;;;; Name title;;;(defclass name-title (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "name"))(defmethod help-string ((self name-title))  (help-string *apropos*));;;;;;; Name menu;;;(defclass name-menu (selection-pop-up)    ()  (:default-initargs    :list '((:contains    "contains")            (:starts-with "starts with")            (:ends-in     "ends in"))    :view-nick-name 'name-menu    :view-size #@(140 20)))(defmethod help-string ((self name-menu))  "Use this menu to describe symbols you want to search for.")(defun name-filter (&optional from-apropos-list)  (let* ((test (selected-item (apropos-view 'name-menu)))         (text (dialog-item-text (apropos-view 'name-text)))         (tlen (length text)))    (function      (lambda (symbol)        (let* ((name (symbol-name symbol))               (slen (length name)))          (and (or from-apropos-list (<= tlen slen))               (case test                 (:contains (or from-apropos-list                                (search text name :test (function char-equal))))                 (:starts-with (string-equal text name :end2 tlen))                 (:ends-in (string-equal text name :start2 (- slen tlen))))))))));;;;;;; Name text;;;(defclass name-text (editable-text-dialog-item)    ()  (:default-initargs    :view-nick-name 'name-text    :view-size #@(133 14)))(defmethod help-string ((self name-text))  "The substring that will be searched for.");;;;;;; Criterion subview;;;(defclass criterion-subview (apropos-contour-view)    ((arg1)     (arg2))  (:default-initargs    :view-nick-name 'criterion-subview))(defmethod help-string ((self criterion-subview))  (help-string *apropos*))(defun criterion-action ()  (let ((view (apropos-view 'criterion-subview))        (menu (selected-item (apropos-view 'criterion-menu))))    (with-slots (arg1 arg2) view      (when arg1 (remove-subviews view arg1))      (when arg2 (remove-subviews view arg2))      (case menu        (:represents          (add-subviews view            (setf arg1 (make-instance 'represents-menu :view-position #@(175 0)))            (setf arg2 (make-instance 'value-menu      :view-position #@(325 0)))))        (:documentation          (add-subviews view            (setf arg1 (make-instance 'documentation-menu           :view-position #@(175 0)))            (setf arg2 (make-instance 'documentation-available-menu :view-position #@(325 0)))))        (:definition          (add-subviews view            (setf arg1 (make-instance 'definition-prompt :view-position #@(175 1)))            (setf arg2 (make-instance 'definition-menu   :view-position #@(325 0)))))        (:property-list          (add-subviews view            (setf arg1 (make-instance 'property-list-menu       :view-position #@(175 0)))            (setf arg2 (make-instance 'property-list-bound-menu :view-position #@(325 0)))))        (:satisfies          (add-subviews view            (setf arg1 (make-instance 'satisfies-prompt    :view-position #@(175 1)))            (setf arg2 (make-instance 'satisfies-predicate :view-position #@(328 3)))))))))(defmethod install-view-in-window ((self criterion-subview) window)  (declare (ignore window))  (with-slots (arg1 arg2) self    (add-subviews self      (make-instance 'criterion-check-box :view-position #@(  0 1))      (make-instance 'criterion-menu      :view-position #@( 25 0))      (setf arg1 (make-instance 'represents-menu :view-position #@(175 0)))      (setf arg2 (make-instance 'value-menu      :view-position #@(325 0))))))(defun criterion-filter ()  (let ((checked-p (check-box-checked-p (apropos-view 'criterion-check-box)))        (criterion (selected-item (apropos-view 'criterion-menu))))    (if (not checked-p)        (function true)      (case criterion        (:represents (represents-filter))        (:documentation (documentation-filter))        (:definition (definition-filter))        (:property-list (property-list-filter))        (:satisfies (satisfies-filter))))));;;;;;; Criterion check box;;;(defclass criterion-check-box (check-box-dialog-item)    ()  (:default-initargs    :view-nick-name 'criterion-check-box))(defmethod help-string ((self criterion-check-box))  "Specifies wheter or not this line is to be used in the search.")(defmethod dialog-item-action :after ((self criterion-check-box))  (auto-search-action));;;;;;; Criterion menu;;;(defclass criterion-menu (selection-pop-up)    ()  (:default-initargs    :list '((:represents    "name represents")            (:documentation "documentation")            (:definition    "definition")            (:property-list "property list")            nil            (:satisfies     "self satisfies"))    :menu-item-action 'criterion-action    :view-nick-name 'criterion-menu    :view-size #@(140 20)))(defmethod help-string ((self criterion-menu))  "Use this menu to describe symbols you want to search for.");;;;;;; Represents menu;;;(defclass represents-menu (selection-pop-up)    ()  (:default-initargs    :list '((:value       "a value type:")            (:function    "a function type:")            (:macro       "a macro type:")            nil            (:class       "a class:")            (:condition   "a condition:")            nil            (:macintosh   "a macintosh")            (:common-lisp "a common lisp"))    :menu-item-action 'represents-action    :view-nick-name 'represents-menu    :view-size #@(140 20)))(defmethod help-string ((self represents-menu))  "Use this menu to describe symbols you want to search for.")(defun represents-action ()  (let ((criterion (apropos-view 'criterion-subview))        (represents (selected-item (apropos-view 'represents-menu))))    (with-slots (arg2) criterion      (when arg2 (remove-subviews criterion arg2))      (add-subviews criterion        (setf arg2              (make-instance (case represents                               (:value       'value-menu)                               (:function    'function-menu)                               (:macro       'macro-menu)                               (:class       'class-menu)                               (:condition   'condition-menu)                               (:macintosh   'macintosh-menu)                               (:common-lisp 'common-lisp-menu))                :view-position #@(325 0)))))))(defun represents-filter ()  (case (selected-item (apropos-view 'represents-menu))    (:value       (value-filter))    (:function    (function-filter))    (:macro       (macro-filter))    (:class       (class-filter))    (:condition   (condition-filter))    (:macintosh   (macintosh-filter))    (:common-lisp (common-lisp-filter))));;;;;;; Value menu;;;(defclass value-menu (selection-pop-up)    ()  (:default-initargs    :list '((:any      "any")            (:bound    "bound")            nil            (:variable "variable")            (:constant "constant"))    :view-nick-name 'value-menu    :view-size #@(140 20)))(defmethod help-string ((self value-menu))  "Use this menu to describe symbols you want to search for.")(defun value-filter ()  (let ((binding-type (selected-item (apropos-view 'value-menu))))    (function      (lambda (symbol)        (case binding-type          (:any      (proclaimed-special-p symbol))          (:bound    (boundp symbol))          (:variable (and (proclaimed-special-p symbol) (not (constantp symbol))))          (:constant (constantp symbol)))))));;;;;;; Function menu;;;(defclass function-menu (selection-pop-up)    ()  (:default-initargs    :list '((:any      "any")            nil            (:function "function")            (:generic  "generic function"))    :view-nick-name 'function-menu    :view-size #@(140 20)))(defmethod help-string ((self function-menu))  "Use this menu to describe symbols you want to search for.")(defun function-filter ()  (let ((binding-type (selected-item (apropos-view 'function-menu))))    (function      (lambda (symbol)        (case binding-type          (:any (functional-p symbol))          (:function (function-p symbol))          (:generic (generic-function-p symbol)))))))(defun functional-p (symbol)  (and (fboundp symbol)       (not (macro-function symbol))       (not (special-form-p symbol))))(defun function-p (symbol)  (and (functional-p symbol)       (not (subtypep (type-of (symbol-function symbol))                      'standard-generic-function))))(defun generic-function-p (symbol)  (and (functional-p symbol)       (subtypep (type-of (symbol-function symbol))                 'standard-generic-function)));;;;;;; Macro menu;;;(defclass macro-menu (selection-pop-up)    ()  (:default-initargs    :list '((:any            "any")            nil            (:macro          "macro")            (:special-form   "special form")            (:compiler-macro "compiler macro"))    :view-nick-name 'macro-menu    :view-size #@(140 20)))(defmethod help-string ((self macro-menu))  "Use this menu to describe symbols you want to search for.")(defun macro-filter ()  (let ((binding-type (selected-item (apropos-view 'macro-menu))))    (function      (lambda (symbol)        (case binding-type          (:any (or (macro-function symbol)                    (special-form-p symbol)                    (compiler-macro-function symbol)))          (:macro          (macro-function symbol))          (:special-form   (special-form-p symbol))          (:compiler-macro (compiler-macro-function symbol)))))));;;;;;; Class menu;;;(defclass class-menu (selection-pop-up)    ()  (:default-initargs    :list '((:any            "any")            nil            (standard-class  "standard-class")            (built-in-class  "built-in-class")            (structure-class "structure-class"))    :view-nick-name 'class-menu    :view-size #@(140 20)))(defmethod help-string ((self class-menu))  "Use this menu to describe symbols you want to search for.")(defun class-filter ()  (let ((class (selected-item (apropos-view 'class-menu))))    (function      (lambda (symbol)        (let ((class-of-symbol (find-class symbol nil)))          (and class-of-symbol               (or (eq class :any)                   (subtypep (type-of class-of-symbol)                             class))))))));;;;;;; Condition menu;;;(defclass condition-menu (selection-pop-up)    ()  (:default-initargs    :list '((condition         "any")            nil            (error             "error")            (warning           "warning")            (compiler-warning  "compiler-warning")            nil            (simple-condition  "simple-condition")            (serious-condition "serious-condition"))    :view-nick-name 'condition-menu    :view-size #@(140 20)))(defmethod help-string ((self condition-menu))  "Use this menu to describe symbols you want to search for.")(defun condition-filter ()  (let ((condition (selected-item (apropos-view 'condition-menu))))    (function      (lambda (symbol)        (subtypep symbol condition)))));;;;;;; Macintosh menu;;;(defclass macintosh-menu (selection-pop-up)    ()  (:default-initargs    :list '((:record  "record type")            (:mactype "mactype"))    :view-nick-name 'macintosh-menu    :view-size #@(140 20)))(defmethod help-string ((self macintosh-menu))  "Use this menu to describe symbols you want to search for.")(defun macintosh-filter ()  (let ((what (selected-item (apropos-view 'macintosh-menu))))    (function      (lambda (symbol)        (case what          (:record (record-type-p symbol))          (:mactype (mactype-p symbol)))))));;;;;;; Common lisp menu;;;(defclass common-lisp-menu (selection-pop-up)    ()  (:default-initargs    :list '((:type-specifier "type specifier")            (:declaration    "declaration"))    :view-nick-name 'common-lisp-menu    :view-size #@(140 20)))(defmethod help-string ((self common-lisp-menu))  "Use this menu to describe symbols you want to search for.")(defun common-lisp-filter ()  (let ((what (selected-item (apropos-view 'common-lisp-menu))))    (function      (lambda (symbol)        (case what          (:type-specifier (type-specifier-p symbol))          (:declaration (member symbol ccl::*nx-known-declarations*)))))));;;;;;; Documentation menu;;;(defclass documentation-menu (selection-pop-up)    ()  (:default-initargs    :list '((:is "is")            (:contains "contains"))    :menu-item-action 'documentation-action    :view-nick-name 'documentation-menu    :view-size #@(140 20)))(defmethod help-string ((self documentation-menu))  "Use this menu to describe symbols you want to search for.")(defun documentation-action ()  (let ((criterion (apropos-view 'criterion-subview))        (what (selected-item (apropos-view 'documentation-menu))))    (with-slots (arg2) criterion      (when arg2 (remove-subviews criterion arg2))      (add-subviews criterion        (setf arg2              (case what                (:is                  (make-instance 'documentation-available-menu                    :view-position #@(325 0)))                (:contains                  (make-instance 'documentation-text                    :view-position #@(328 3)))))))))(defun documentation-filter ()  (let ((what (selected-item (apropos-view 'documentation-menu))))    (case what      (:is (documentation-available-filter))      (:contains (documentation-contains-filter)))));;;;;;; Documentation available menu;;;(defclass documentation-available-menu (selection-pop-up)    ()  (:default-initargs    :list '((:available "available")            (:not-available "not available"))    :view-nick-name 'documentation-available-menu    :view-size #@(140 20)))(defmethod help-string ((self documentation-available-menu))  "Use this menu to describe symbols you want to search for.")(defun documentation-available-filter ()  (let ((what (selected-item (apropos-view 'documentation-available-menu))))    (function      (lambda (symbol)        (case what          (:available (gethash symbol *fast-help*))          (:not-available (not (gethash symbol *fast-help*))))))));;;;;;; Documentation text;;;(defclass documentation-text (editable-text-dialog-item)    ()  (:default-initargs    :view-nick-name 'documentation-text    :view-size #@(133 14)))(defmethod help-string ((self documentation-text))  "The documentation substring that will be searched for.")(defun documentation-contains-filter ()  (let ((string (dialog-item-text (apropos-view 'documentation-text))))    (function      (lambda (symbol)        (let ((doc (documentation symbol nil)))          (and doc               (search string doc :test (function char-equal))))))));;;;;;; Definition prompt;;;(defclass definition-prompt (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "can be"))(defmethod help-string ((self definition-prompt))  (help-string *apropos*));;;;;;; Definition menu;;;(defclass definition-menu (selection-pop-up)    ()  (:default-initargs    :list '((:edited     "edited")            (:uncompiled "uncompiled"))    :view-nick-name 'definition-menu    :view-size #@(140 20)))(defmethod help-string ((self definition-menu))  "Use this menu to describe symbols you want to search for.")(defun definition-filter ()  (let ((test (selected-item (apropos-view 'definition-menu))))    (function      (lambda (symbol)        (case test          (:edited (edit-definition-p symbol))          (:uncompiled (uncompile-function symbol)))))));;;;;;; Property list menu;;;(defclass property-list-menu (selection-pop-up)    ()  (:default-initargs    :list '((:is       "is")            (:property "has property"))    :menu-item-action 'property-list-action    :view-nick-name 'property-list-menu    :view-size #@(140 20)))(defmethod help-string ((self property-list-menu))  "Use this menu to describe symbols you want to search for.")(defun property-list-action ()  (let ((criterion (apropos-view 'criterion-subview))        (item (selected-item (apropos-view 'property-list-menu))))    (with-slots (arg2) criterion      (when arg2 (remove-subviews criterion arg2))      (add-subviews criterion        (setq arg2              (case item                (:is       (make-instance 'property-list-bound-menu :view-position #@(325 0)))                (:property (make-instance 'property-list-property   :view-position #@(328 3)))))))))(defun property-list-filter ()  (let ((test (selected-item (apropos-view 'property-list-menu))))    (case test      (:is (property-list-bound-filter))      (:property (property-list-property-filter)))));;;;;;; Property list bound menu;;;(defclass property-list-bound-menu (selection-pop-up)    ()  (:default-initargs    :list '((:bound   "bound")            (:unbound "unbound"))    :view-nick-name 'property-list-bound-menu    :view-size #@(140 20)))(defmethod help-string ((self property-list-menu))  "Use this menu to describe symbols you want to search for.")(defun property-list-bound-filter ()  (let ((test (selected-item (apropos-view 'property-list-bound-menu))))    (function      (lambda (symbol)        (case test          (:bound (symbol-plist symbol))          (:unbound (not (symbol-plist symbol))))))));;;;;;; Property list property;;;(defclass property-list-property (editable-text-dialog-item)    ()  (:default-initargs    :view-nick-name 'property-list-property    :view-size #@(133 14)))(defmethod help-string ((self property-list-property))  "The property that will be searched for.")(defun property-list-property-filter ()  (let ((property (read-from-string (dialog-item-text (apropos-view 'property-list-property)))))    (function      (lambda (symbol)        (neq (get symbol property 'no-property-found)             'no-property-found)))));;;;;;; Satisfies prompt;;;(defclass satisfies-prompt (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "the predicate"))(defmethod help-string ((self satisfies-prompt))  (help-string *apropos*));;;;;;; Satisfies predicate;;;(defclass satisfies-predicate (editable-text-dialog-item)    ()  (:default-initargs    :view-nick-name 'satisfies-predicate    :view-size #@(133 14)))(defmethod help-string ((self satisfies-predicate))  "Symbols found will have to satisfy this lisp predicate.")(defun satisfies-filter ()  (let ((predicate (read-from-string (dialog-item-text (apropos-view 'satisfies-predicate)))))    (symbol-function predicate)));;;;;;; Package subview;;;(defclass package-subview (apropos-contour-view)    ()  (:default-initargs    :view-nick-name 'package-subview))(defmethod help-string ((self package-subview))  (help-string *apropos*))(defmethod install-view-in-window ((self package-subview) window)  (declare (ignore window))  (add-subviews self    (make-instance 'package-text :view-position #@( 0 1))    (make-instance 'package-menu :view-position #@(70 0))));;;;;;; Package text;;;(defclass package-text (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "Search in"))(defmethod help-string ((self package-text))  (help-string *apropos*));;;;;;; Package menu;;;(defclass package-menu (selection-pop-up)    ()  (:default-initargs    :list `((nil "all packages")            nil            ,@(all-packages))    :menu-item-action 'package-action    :view-nick-name 'package-menu    :view-size #@(175 20)))(defmethod initialize-instance :after ((menu package-menu) &key)  (setf (ccl::pop-up-menu-default-item menu)        (+ (position *default-package* (slot-value menu 'list)                     :key (function car))             1)))(defmethod help-string ((self package-menu))  (format nil "Use this menu to specify which package(s) to search into.~%~%~               This menu is not automatically updated when new packages are ~               either created or deleted. Closing and reopening the apropos ~               dialog will update the list of packages."))(defun package-action ()  (setf *default-package*        (selected-item (apropos-view 'package-menu))))(defun package-and-heritage-filter ()  (let ((package  (selected-item (apropos-view 'package-menu)))        (heritage (selected-item (apropos-view 'heritage-menu))))    (function      (lambda (symbol)        (let ((package (or package (symbol-package symbol))))          (or (eq heritage :all)              (multiple-value-bind (ignore symbol-type)                                    (find-symbol (symbol-name symbol)                                                package)                (declare (ignore ignore))                (eq symbol-type heritage))))))))(defun reinstall-package-menu ()  (let ((view (apropos-view 'package-subview)))    (remove-subviews view (apropos-view 'package-menu))    (add-subviews    view (make-instance 'package-menu                            :view-position #@(70 0)))))(defun all-packages ()  (sort    (mapcar (function              (lambda (package)                (list package                      (concatenate 'string                                   "pkg "                                   (string-downcase (package-name package))))))            (list-all-packages))    (function string-lessp)    :key (function second)));;;;;;; Heritage subview;;;(defclass heritage-subview (apropos-contour-view)    ())(defmethod help-string ((self heritage-subview))  (help-string *apropos*))(defmethod install-view-in-window ((self heritage-subview) window)  (declare (ignore window))  (add-subviews self    (make-instance 'heritage-text :view-position #@( 0 1))    (make-instance 'heritage-menu :view-position #@(70 0))));;;;;;; Heritage text;;;(defclass heritage-text (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "Show"))(defmethod help-string ((self heritage-text))  (help-string *apropos*));;;;;;; Heritage menu;;;(defclass heritage-menu (selection-pop-up)    ()  (:default-initargs    :list '((:all       "all symbols")            nil            (:external  "only external symbols")            (:internal  "only internal symbols")            (:inherited "only inherited symbols"))    :view-nick-name 'heritage-menu    :view-size #@(175 20)))(defmethod help-string ((self heritage-menu))  "Only those kind of symbols will be showed.");;;;;;; Search subview;;;(defclass search-subview (apropos-contour-view)    ())(defmethod help-string ((self search-subview))  (help-string *apropos*))(defmethod install-view-in-window ((self search-subview) window)  (declare (ignore window))  (add-subviews self    (make-instance 'refine-button  :view-position #@(  4  4))    (make-instance 'augment-button :view-position #@( 64  4))    (make-instance 'remove-button  :view-position #@(140  4))    (make-instance 'anchor-button  :view-position #@(  4 32))    (make-instance 'global-button  :view-position #@( 73 32))    (make-instance 'search-button  :view-position #@(141 32))));;;;;;; Refine button;;;(defclass refine-button (button-dialog-item)    ()  (:default-initargs    :dialog-item-text "Refine"    :dialog-item-action    (function      (lambda (self)        (declare (ignore self))        (eval-enqueue '(refine-action))))))(defmethod help-string ((self refine-button))  (format nil "Searches through the already found symbols ~               for the ones that match the current search criteria."))(defun refine-action ()  (let ((*working* t))    (new-symbols (apropos-filter (found-symbols) (global-filter)))    (able-action-buttons)));;;;;;; Augment button;;;(defclass augment-button (button-dialog-item)    ()  (:default-initargs    :dialog-item-text "Augment"    :dialog-item-action    (function      (lambda (self)        (declare (ignore self))        (eval-enqueue '(augment-action))))))(defmethod help-string ((self augment-button))  (format nil "Finds all symbols in the current search domain ~               that match the current search criteria and adds them to the ~               ones already found."))(defun augment-action ()  (let ((*working* t))    (new-symbols (union (found-symbols) (search-domain)))    (able-action-buttons)));;;;;;; Remove button;;;(defclass remove-button (button-dialog-item)    ()  (:default-initargs    :dialog-item-text "Remove"    :dialog-item-action    (function      (lambda (self)        (declare (ignore self))        (eval-enqueue '(remove-action))))))(defmethod help-string ((self remove-button))  (format nil "Searches through the already found symbols ~               for the ones that do not match the current search criteria."))(defun remove-action ()  (let ((*working* t))    (new-symbols (apropos-filter (found-symbols) (inverse (global-filter))))    (able-action-buttons)));;;;;;; Anchor button;;;(defclass anchor-button (button-dialog-item)    ()  (:default-initargs    :dialog-item-text "Anchor"))(defmethod help-string ((self anchor-button))  "Anchors the last found symbols as the domain for later searches.")(defmethod dialog-item-action ((self anchor-button))  (setf *search-domain* (found-symbols))  (dialog-item-enable (apropos-view 'global-button)));;;;;;; Global button;;;(defclass global-button (button-dialog-item)    ()  (:default-initargs    :view-nick-name 'global-button    :dialog-item-text "Global"    :dialog-item-enabled-p nil))(defmethod help-string ((self global-button))  (format nil "Restores the search domain to all lisp symbols.~@[~%~%~A~]"          (unless (dialog-item-enabled-p self)            "Disabled because the search domain is already global.")))(defmethod dialog-item-action ((self global-button))  (setf *search-domain* :global)  (dialog-item-disable self));;;;;;; Search button;;;(defclass search-button (button-dialog-item)    ()  (:default-initargs    :dialog-item-text "Search"    :default-button t    :dialog-item-action    (function      (lambda (self)        (declare (ignore self))        (eval-enqueue '(search-action))))))(defmethod help-string ((self search-button))  (format nil "Finds all symbols in the current search domain ~               that match the current search criteria.~%~%~:[~               The current search domain is the global domain consisting ~               of all lisp symbols.~;~               The current search domain is not global and consists ~               of ~A symbol~:P.~]"          (neq *search-domain* :global)          (length (table-sequence (apropos-view 'symbols-table)))))(defun search-action ()  (let ((*working* t))    (new-symbols (search-domain))    (able-action-buttons)))(defun auto-search-action ()  (let ((auto *auto-search*)        (option (option-key-p)))    (when (and (not (and auto option))               (or auto option))      (search-action))))(defun global-filter (&optional from-apropos-list)  (let ((name-filter (name-filter from-apropos-list))        (criterion-filter (criterion-filter))        (package-and-heritage-filter (package-and-heritage-filter)))    (function      (lambda (symbol)        (and (funcall name-filter symbol)             (funcall package-and-heritage-filter symbol)             (funcall criterion-filter symbol))))))(defun apropos-filter (symbols filter)  (let ((value 0)        (length (length symbols))        (thermo (apropos-view 'search-thermometer)))    (setf (thermometer-max-value thermo) length)    (unwind-protect        (iter (for symbol in symbols)              (incf value)              (when (= (mod value *update-frequency*) 0)                (setf (thermometer-value thermo) value))              (when (funcall filter symbol)                (collect symbol)))      ;; to force complete filling up      (setf (thermometer-value thermo) length)      (event-dispatch)      (setf (thermometer-value thermo) 0)      (unless (and ccl::*foreground*                   (eq *apropos* (front-window)))        (ed-beep)))))(defun search-domain ()  (cond ((eq *search-domain* :global)         (apropos-filter (apropos-list ;; the string-upcase is not necessary in MCL 2.0 final                                       (string-upcase (dialog-item-text (apropos-view 'name-text)))                                       (selected-item (apropos-view 'package-menu)))                         (global-filter t)))        (t         (apropos-filter *search-domain*                         (global-filter)))));;;;;;; Search thermometer;;;(defclass search-thermometer (thermometer)    ()  (:default-initargs    :direction :vertical    :pattern *gray-pattern*    :view-nick-name 'search-thermometer    :view-size #@(10 72)))(defmethod help-string ((self search-thermometer))  "Indicates progress in the search.");;;;;;; Action subview;;;(defclass action-subview (apropos-contour-view)    ())(defmethod help-string ((self action-subview))  (help-string *apropos*))(defmethod install-view-in-window ((self action-subview) window)  (declare (ignore window))  (add-subviews self    (make-instance 'inspect-button       :view-position #@(  3  5))    (make-instance 'documentation-button :view-position #@(  3 33))    (make-instance 'definition-button    :view-position #@(  3 61))    (make-instance 'show-check-box       :view-position #@(  1 89))    (make-instance 'show-text            :view-position #@( 19 89))    (make-instance 'show-menu            :view-position #@( 60 88))))(defun dialog-item-able (dialog-item boolean)  (if boolean      (dialog-item-enable dialog-item)    (dialog-item-disable dialog-item)))(defun able-action-buttons ()  (let ((symbol (selected-symbol)))    (dialog-item-able (apropos-view 'inspect-button) symbol)    (dialog-item-able (apropos-view 'documentation-button)                      (and symbol (documentation symbol nil)))    (dialog-item-able (apropos-view 'definition-button)                      (and symbol (edit-definition-p symbol)))));;;;;;; Inspect button;;;(defclass inspect-button (button-dialog-item)    ()  (:default-initargs    :view-nick-name 'inspect-button    :dialog-item-text "Inspect"    :dialog-item-enabled-p nil))(defmethod help-string ((self inspect-button))  (format nil "Inspects the selected symbol.~@[~%~%~A~]"          (unless (dialog-item-enabled-p self)            "Disabled because no symbol is selected.")))(defmethod dialog-item-action ((self inspect-button))  (inspect (selected-symbol)));;;;;;; Documentation button;;;(defclass documentation-button (button-dialog-item)    ()  (:default-initargs    :view-nick-name 'documentation-button    :dialog-item-text "Documentation"    :dialog-item-enabled-p nil))(defmethod help-string ((self documentation-button))  (format nil "Shows documentation for the selected symbol.~@[~%~%~A~]"          (unless (dialog-item-enabled-p self)            "Disabled because no symbol is selected.")))(defmethod dialog-item-action ((self documentation-button))  (show-documentation (selected-symbol)));;;;;;; Definition button;;;(defclass definition-button (button-dialog-item)    ()  (:default-initargs    :view-nick-name 'definition-button    :dialog-item-text "Definition"    :dialog-item-enabled-p nil))(defmethod help-string ((self definition-button))  (format nil "Edits the definition of the selected symbol.~@[~%~%~A~]"          (unless (dialog-item-enabled-p self)            "Disabled because no symbol is selected.")))(defmethod dialog-item-action ((self definition-button))  (edit-definition (selected-symbol)));;;;;;; Show check box;;;(defclass show-check-box (check-box-dialog-item)    ()  (:default-initargs    :view-nick-name 'show-check-box))(defmethod help-string ((self show-check-box))  "Specifies wheter or not the following item is to be showed next to each symbol.")(defmethod dialog-item-action ((self show-check-box))  (call-next-method)  (setf *show-p* (check-box-checked-p self))  (invalidate-view (apropos-view 'symbols-table)));;;;;;; Show text;;;(defclass show-text (static-text-dialog-item)    ()  (:default-initargs    :dialog-item-text "Show"))(defmethod help-string ((self show-text))  (help-string *apropos*));;;;;;; Show menu;;;(defclass show-menu (selection-pop-up)    ()  (:default-initargs    :list '((:value   "value")            (:plist   "plist")            (:package "package"))    :menu-item-action 'show-action    :view-nick-name 'show-menu    :view-size #@(80 20)))(defmethod help-string ((self show-menu))  "The selected item will be showed for each symbol that possesses that attribute.")(defun show-action ()  (setf *show-what* (selected-item (apropos-view 'show-menu)))  (invalidate-view (apropos-view 'symbols-table)));;;;;;; Symbols table;;;(defclass symbols-table (sequence-dialog-item)    ()  (:default-initargs    :view-nick-name 'symbols-table    :view-position #@(0 4)    :view-font '("Monaco" 9 :plain)    :cell-size (make-point (- *apropos-symbols-width* 15) 11)    :selection-type :single    :table-hscrollp nil    :table-vscrollp t    :table-sequence nil    :table-print-function 'print-apropos-symbol))(defmethod help-string ((self symbols-table))  (format nil "This is the list of all symbols matching the last search.~%~%~               The list consists of ~A symbol~:P."          (length (table-sequence (apropos-view 'symbols-table)))))(defmethod dialog-item-action ((self symbols-table))  (able-action-buttons)  (let ((modifiers (compatible-modifiers)))    (cond      ((or       (double-click-p)       (equal modifiers '(nil t nil))) (inspect (selected-symbol)))      ((equal modifiers '(nil nil t))  (show-documentation (selected-symbol)))      ((equal modifiers '(nil t t))    (edit-definition (selected-symbol))))))(defun print-apropos-symbol (symbol stream)  (format stream "~S" symbol)  (when *show-p*    (case *show-what*      (:value (when (boundp symbol) (format stream ", ~S" (symbol-value symbol))))      (:plist (when (symbol-plist symbol) (format stream ", ~S" (symbol-plist symbol))))      (:package (format stream ", ~S" (symbol-package symbol))))))(defun new-symbols (list)  (let ((table (apropos-view 'symbols-table)))    (set-table-sequence table list)    (dolist (cell (selected-cells table))      (cell-deselect table cell))    (scroll-to-cell table 0 0)    (invalidate-view table)))(defun found-symbols ()  (table-sequence    (apropos-view 'symbols-table)))(defun selected-symbol ()  (let ((table (apropos-view 'symbols-table)))    (let ((cells (selected-cells table)))      (when cells        (cell-contents table (first cells))))))