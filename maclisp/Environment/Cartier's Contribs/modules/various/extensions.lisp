;;; -*- package: CC -*-;;;;;;; Extensions to Common Lisp;;;(in-package "CC");;;;;;; Syntax;;;(defmacro curry (fn x)  `(function     (lambda (y)       (,fn ,x y))))(defmacro bind (bindings &body body)  (let ((temps (gensyms bindings)))    `(let ,(mapcar (function                     (lambda (temp binding)                       `(,temp ,(car binding))))                   temps                   bindings)       (unwind-protect           (progn ,@(mapcar (function                              (lambda (binding)                                `(setf ,@binding)))                            bindings)                  ,@body)         ,@(mapcar (function                     (lambda (binding temp)                       `(setf ,(car binding) ,temp)))                   bindings                   temps)))))(defmacro preserving (places &body body)  (let ((temps (gensyms places)))    `(let ,(mapcar (function                     (lambda (temp place)                       `(,temp ,place)))                   temps                   places)       (unwind-protect           (progn ,@body)         ,@(mapcar (function                     (lambda (place temp)                       `(setf ,place ,temp)))                   places                   temps)))))(defmacro with-values (symbols instance-form &body body)  (let ((instance (gensym)))    `(let ((,instance ,instance-form))       (let ,(mapcar (function                       (lambda (symbol)                         `(,symbol (slot-value ,instance ',symbol))))                     symbols)         ,@body))))(defmacro defsubs (symbol lambda-list form)  (let ((value (gensym)))    `(progn       (defun ,symbol ,lambda-list         ,form)       (defun (setf ,symbol) (,value ,@lambda-list)         (setf ,form ,value))       ',symbol)));;;;;;; Lists;;;(defun listify (object)  (if (listp object)      object    (list object)))(defun flatten (list)  (let ((items nil))    (dolist (x list (nreverse items))      (if (listp x)          (dolist (y x)            (push y items))        (push x items)))))(defun filter (list test)  (iter (for x in list)        (when (funcall test x)          (collect x))))(defun tree-member (expr tree &key (test (function eql)))  (cond ((null tree) ())        ((atom tree) (funcall test expr tree))        (t (some (function                   (lambda (sub-tree)                     (tree-member expr sub-tree)))                 tree))))(defun lambda-variables (lambda-list)  (iter (for x in lambda-list)        (if (eq x '&aux) (terminate-iteration)))        (when (not (member x lambda-list-keywords))          (collect (if (symbolp x)                       x                     (first x))))))(defun extract-pairs (list)  (iter (for ptr on list by (function cddr))        (collect (cons (first  ptr)                       (second ptr)))))(defun trim (list elem &key (test (function eql)))  (end-trim    (front-trim list elem :test test)    elem    :test test))(defun front-trim (list elem &key (test (function eql)))  (iter (while (and list (funcall test (car list) elem)))        (setq list (cdr list)))  list)(defun end-trim (list elem &key (test (function eql)))  (let ((copy (reverse list)))    (iter (while (and copy (funcall test (car copy) elem)))          (setq copy (cdr copy)))    (nreverse copy)));;;;;;; Strings;;;(defun empty-string-p (string)  (string= string ""))(defun string-append (&rest strings)  (apply (function concatenate)         'string strings));;;;;;; Predicates;;;(defun lambdap (expr)  (and (consp expr)       (eq (car expr) 'lambda)))(defun quotep (expr)  (and (consp expr)       (eq (car expr) 'quote)))(defun external-symbol-p (symbol)  (multiple-value-bind (symb type)                       (find-symbol (symbol-name symbol)                                    (symbol-package symbol))    (declare (ignore symb))    (eq :external type)));;;;;;; Input;;;(defun empty-reader (stream char)  (declare (ignore stream char))  (values))(defmacro with-macro-characters (descriptions &body body)  (let ((olds (gensyms descriptions)))    `(let ,(iter (for old in olds)                 (for (char) in descriptions)                 (collect `(,old (multiple-value-list                                   (get-macro-character ,char)))))       (unwind-protect           (progn             ,@(iter (for (char function flag) in descriptions)                     (collect `(apply (function set-macro-character)                                      ,char ,function ,flag)))             ,@body)         ,@(iter (for old in olds)                 (for (char) in descriptions)                 (collect `(apply (function set-macro-character)                                  ,char ,old)))))))(defun read-line-until (eol-char &optional (stream *standard-input*))  (let ((char)        (line ()))    (iter (while (not (eql (setf char (read-char stream)) eol-char)))          (push char line))    (coerce (nreverse line) 'string)));;;;;;; Various;;;(defun xor (x y)  (or (and x (not y))      (and (not x) y)))(defun gensyms (list)  (mapcar (function            (lambda (ignore)              (declare (ignore ignore))              (gensym)))          list))