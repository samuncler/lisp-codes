;;; -*- package: CC -*-;;;;;;; Collections of buffer items;;;(in-package "CC")(export '(defcollection          undefcollection          font-spec-collector          make-collection-item));;;;;;; Defining new collections;;;(defvar *collections*  (make-hash-table))(defstruct collection  name  modifiers  collector  ordering  first-special)(defmacro defcollection (name &key modifiers collector                                 (ordering nil)                                 (first-special nil))  `(progn     (setf (gethash ',name *collections*)           (make-collection             :name          ',name             :modifiers     ',(compile-modifiers modifiers)             :collector     ,collector             :ordering      ,ordering             :first-special ,first-special))     ',name))(defun undefcollection (name)  (if (gethash name *collections*)      (remhash name *collections*)    (error "Unknown collection ~S." name)));;;;;;; Collection menu-items;;;(defclass collection-menu-item (menu-item)  ((mark :initarg :mark)))(defmethod menu-item-action ((mi collection-menu-item))  (with-slots (mark) mi    (let ((win (front-window))          (pos (buffer-position mark)))      (set-selection-range win pos pos)      (ccl::window-show-selection win))))(defun make-collection-item (buffer string position)  (make-instance 'collection-menu-item    :menu-item-title string    :mark (make-mark buffer position)));;;;;;; Caching the collection menus;;;(def-fred-command (:function #\F) ed-update-collections)(defun buffer-collection-menu (buffer collection)  (or (buffer-getprop buffer collection)      (let ((menu (make-popper-menu nil)))        (buffer-putprop buffer collection menu)        (buffer-update-collection buffer collection)        menu)))(defun buffer-update-collection (buffer collection)  (let ((menu (buffer-collection-menu buffer collection)))    (apply (function remove-menu-items) menu (menu-items menu))    (let ((items (funcall (collection-collector collection) buffer)))      (when items        (when (collection-ordering collection)          (setq items (sort items (collection-ordering collection)                            :key (function menu-item-title))))        (apply (function add-menu-items) menu               (if (collection-first-special collection)                   (cons (first items)                         (cons (make-instance 'menu-item                                 :menu-item-title "-")                               (rest items)))                 items))))))(defmethod ed-update-collections ((w fred-mixin))  (set-mini-buffer w "UpdatingÉ")  (let ((buffer (fred-buffer w)))    (maphash (function               (lambda (name collection)                 (declare (ignore name))                 (buffer-update-collection buffer collection)))             *collections*))  (set-mini-buffer w "UpdatingÉ done.")  (setq *show-cursor-p* nil));;;;;;; Poping up the collection;;;(defun pop-up-collection-menu (fred collection)  (pop-popper-menu    (buffer-collection-menu (fred-buffer fred) collection)))(defun find-activated-collection (modifiers)  (block found    (maphash (function               (lambda (name collection)                 (declare (ignore name))                 (when (equal modifiers (collection-modifiers collection))                   (return-from found collection))))             *collections*)    nil))(defun modifiers-list ()  (list (shift-key-p)        (control-key-p)        (option-key-p)        (command-key-p)))(eval-when (:compile-toplevel :load-toplevel :execute)(defun compile-modifiers (modifiers-list)  (flet ((boolean (x)           (if x t nil)))    (list      (boolean (member :shift   modifiers-list))      (boolean (member :control modifiers-list))      (boolean (member :option  modifiers-list))      (boolean (member :command modifiers-list))))))(defmethod window-drag-event-handler ((window fred-window) where)  (declare (ignore where))  (if (not (any-modifier-keys-p))           ;; this redundency makes the      (call-next-method)                    ;; code more robust to bugs.    (let ((modifiers (modifiers-list)))      (let ((collection (find-activated-collection modifiers)))        (cond (collection               (pop-up-collection-menu window collection))              ((and (equal modifiers '(nil nil nil t))   ;; command key                    (eq window (front-window)))          ;; keep the drag back window               (fred-pop-up-pathname window))              (t (call-next-method)))))));;;;;;; Font-spec collector;;;(defun font-spec-collector (font-spec)  (let ((list (compile-font-spec font-spec)))    (function      (lambda (buffer)        (let ((vector (buffer-get-style buffer 0 nil)))          (let ((target (find-style vector list)))            (when target              (let ((strings                     (iter (for n first (+ (* (aref vector 0) 2) 1) then (+ n 2))                           (for index = (ash (aref vector n) -8))                           (until (= index 0))                           (when (= index target)                             (let ((start (compute-position (aref vector (+ n 0)) (aref vector (+ n 1))))                                   (end   (compute-position (aref vector (+ n 2)) (aref vector (+ n 3)))))                               (unless (all-blank-p buffer start end)                                 (collect                                   (cons (buffer-substring buffer end start)                                         end))))))))                (iter (for (string . pos) in                           (remove-duplicates strings                                              :test (function string-equal)                                              :key  (function car)                                              :from-end t))                      (collect (make-collection-item buffer string pos)))))))))))(defun all-blank-p (buffer start end)  (every (function whitespacep)         (buffer-substring buffer start end)))(defun compute-position (x y)  (+ (ash (logand x #xff) 16)     (if (>= y 0)         y       (+ 65536 y))))(defun find-style (vector style)  (iter (for n from 1 to (- (* (aref vector 0) 2) 1) by 2)        (when (and (= (aref vector (+ n 0)) (first  style))                   (= (aref vector (+ n 1)) (second style)))          (return (/ (+ n 1) 2)))        (finally (return nil))))(defun compile-font-spec (font-spec)  (multiple-value-bind (x y)                       (font-codes font-spec)    (list (ash x -16)                     ;font-code          (+ (ash (logand #xff y) 8)      ;font-size             (logand #xff (ash x -8)))))) ;font-style;;;;;;; Default configuration;;;(defun toplevel< (toplevel1 toplevel2)  (let ((c1 (eql (char toplevel1 0) #\())        (c2 (eql (char toplevel2 0) #\()))    (cond ((and (not c1) c2) t)          ((and c1 (not c2)) nil)          (t (string< toplevel1 toplevel2)))))(defcollection comments  :modifiers (:control)  :collector (font-spec-collector '("Monaco" 9 :bold :underline))  :first-special t)(defcollection toplevels  :modifiers (:control :option)  :ordering  (function toplevel<)  :collector (function               (lambda (buffer)                 (iter (for (string pos) in (ccl::list-definitions (front-window)))                       (collect (make-collection-item buffer string pos))))));;;;;;; Poping up the pathname;;;(defun fred-pop-up-pathname (window)  (let ((filename (window-filename window)))    (cond ((null filename)           (ed-beep)           (format *debug-io* "~&;No file is associated to this window."))          (t (pop-up-pathname filename)))))(defun pop-up-pathname (pathname)  (let ((name (file-namestring pathname)))    (let ((item (pop-popper-menu                  (make-list-popper-menu                    (maplist (function identity)                             (cons name                                   (reverse (cdr (pathname-directory pathname)))))                    :print-function                    (function                      (lambda (list stream)                        (princ (car list) stream)))))))      (when item        (set-choose-file-default-directory          (make-pathname            :directory (cons :absolute (reverse (if (eq (car item) name)                                                    (cdr item)                                                  item)))))        (edit-select-file)))))