;;; -*- package: CC -*-;;;;;;; Regrouping files into Units;;;(defpackage "CC"  (:use "CCL"        "COMMON-LISP"        "ITERATE"))(in-package "CC")(export '(*unit-registry*          *compile-units*          defunit          undefunit          load-unit          load-unit-definition          load-unit-dependencies          load-all-unit-definitions          defined-units          loaded-units          compute-unit-dependencies          compute-unit-dependants          compile-unit          recompile-unit          delete-unit-binaries          edit-unit          edit-unit-definition          hardcopy-unit          hardcopy-unit-definition          search-unit          defindent          fred-indent))(defvar *defined-units*  (make-hash-table   :test (function equal)))(defvar *unit-registry*  nil)(defvar *compile-units*  t);;;;;;; Unit names;;;(defun canonicalize-name (name)  (string-upcase    (if (stringp name)        name      (string name))))(defun get-unit (name)  (if (unitp name)      name    (gethash (canonicalize-name name)             *defined-units*)))(defun (setf get-unit) (unit name)  (setf (gethash (canonicalize-name name)                 *defined-units*)        unit));;;;;;; Defining new units;;;(defstruct (unit             (:predicate unitp)             (:print-function print-unit))  name  requires  dependencies  definition  source-pathname  binary-pathname  components  loading  loaded)(defmacro defunit (name &rest definition)  `(progn     (mapc (function find-unit)           ',(cdr (assoc :depends-on definition)))     (setf (get-unit ',name)           (make-unit            :name            ',name            :requires        ',(cdr  (assoc :requires        definition))            :dependencies    ',(cdr  (assoc :depends-on      definition))            :source-pathname ',(cadr (assoc :source-pathname definition))            :binary-pathname ',(cadr (assoc :binary-pathname definition))            :components      ',(cdr  (assoc :components      definition))))     ',name))(defun undefunit (name)  (remhash (canonicalize-name name)           *defined-units*));;;;;;; Components;;;(defun unit-source-components (unit)  (let ((root (unit-source-pathname unit)))    (mapcar (function              (lambda (path)                (concatenate 'string root path ".lisp")))            (unit-components unit))))(defun unit-binary-components (unit)  (let ((root (unit-binary-pathname unit)))    (mapcar (function              (lambda (path)                (concatenate 'string root path ".fasl")))            (unit-components unit))))(defun unit-available-source-components (unit)  (let ((files nil))    (dolist (file (unit-source-components unit) (nreverse files))      (when (probe-file file)        (push file files)))));;;;;;; Finding unit definitions;;;(defvar *loading-all-unit-definitions*  nil)(defun find-unit (name)  (or (get-unit name)      (load-unit-definition name)))(defun load-unit-definition (name)  (let ((name (canonicalize-name name)))    (let ((file (find-unit-definition-file name)))      (if *loading-all-unit-definitions*          (format t "~&;Loading unit Definition ~S..." name)        (format t "~&;Loading source ~S..." file))      (load file :verbose nil)      (let ((unit (get-unit name)))        (cond ((null unit)               (error "File ~A failed to defined unit ~A ." file name))              (t (setf (unit-definition unit) file)                 unit))))))(defun load-all-unit-definitions ()  (let ((*loading-all-unit-definitions* t))    (dolist (dir *unit-registry* nil)      (dolist (path (directory (concatenate 'string dir "*")))        (let ((name (string-upcase (pathname-name path))))          (unless (get-unit name)            (format t "~&;Loading unit Definition ~S..." name)            (load path :verbose nil)))))))(defun find-unit-definition-file (name)  (let ((name (canonicalize-name name)))    (dolist (dir *unit-registry*)      (let ((file (concatenate 'string dir name)))        (when (or (probe-file (concatenate 'string file ".lisp"))                  (probe-file (concatenate 'string file ".fasl")))          (return-from find-unit-definition-file file))))    (error "Cannot find unit definition for ~A ." name)));;;;;;; Integrating MCL's require;;;(advise require        (let ((module (first arglist)))          (if (cc-module-name-p module)              (cc-require module)            (:do-it)))        :when :around        :name cc)(defun cc-module-name-p (module)  (let ((string (string module)))    (and (> (length string) 3)         (string-equal (subseq string 0 3)                       "CC-"))))(defun cc-require (module)  (load-unit (subseq (string module) 3))  (provide module));;;;;;; Loading units;;;(defun load-unit-dependencies (name &key (compile *compile-units*))  (let ((unit (find-unit name)))    (load-unit-requires unit)    (dolist (unit (unit-dependencies unit))      (load-unit unit :compile compile))))(defun load-unit-requires (unit)  (dolist (module (unit-requires unit))    (if (and (> (length module) 6)             (string-equal (subseq module (- (length module) 6))                           "-PATCH"))        (let ((*warn-if-redefine* nil)              (*warn-if-redefine-kernel* nil))          (require module))      (require module))))(defun load-unit-components (unit)  (with-compilation-unit ()    (dolist (component (unit-components unit))      (load-component unit component))))(defun load-unit (name &key (force nil) (compile *compile-units*))  (let ((unit (find-unit name)))    (unless (or (unit-loading unit)                (and (not force)                     (unit-loaded unit)))      (unwind-protect (progn                        (setf (unit-loading unit) t)                        (load-unit-dependencies unit :compile compile)                        (if (null compile)                            (load-unit-components unit)                          (compile-unit-internal unit (eq compile :force)))                        (setf (unit-loaded unit) t))        (setf (unit-loading unit) nil)))))(defun load-component (unit component)  (let ((text (concatenate 'string (unit-source-pathname unit) component)))    (let ((source (concatenate 'string text ".lisp"))          (binary (concatenate 'string (unit-binary-pathname unit) component ".fasl")))      (let ((file (cond                    ((null (probe-file binary)) source)                    ((null (probe-file source)) binary)                    ((> (file-write-date source) (file-write-date binary)) source)                    (t binary))))        (format t "~&;Loading ~:[source~;binary~] ~S..." (eq file binary) text)        (load file :verbose nil)))));;;;;;; Compiling units;;;(defun compile-unit (name)  (let ((unit (find-unit name)))    (load-unit-dependencies unit)    (compile-unit-internal unit nil)))(defun recompile-unit (name)  (let ((unit (find-unit name)))    (load-unit-dependencies unit)    (compile-unit-internal unit t)))(defun compile-unit-internal (unit force)  (with-compilation-unit ()    (dolist (component (unit-components unit))      (compile-component unit component force)      (load-component unit component)))  (setf (unit-loaded unit) t))(defun compile-component (unit name force)  (let ((source (concatenate 'string (unit-source-pathname unit) name ".lisp"))        (binary (concatenate 'string (unit-binary-pathname unit) name ".fasl")))    (when (and (probe-file source)               (or force                   (null (probe-file binary))                   (> (file-write-date source)                      (file-write-date binary))))      (format t "~&;Compiling file ~S..." source)      (compile-file source :output-file binary :verbose nil))))(defun delete-unit-binaries (name)  (let ((unit (find-unit name)))    (iter (for fasl in (unit-binary-components unit))          (when (delete-file fasl :if-does-not-exist nil)            (collect fasl)))));;;;;;; Utilities;;;(defun defined-units ()  (let ((result nil))    (maphash (function               (lambda (name unit)		 (declare (ignore unit))		 (push name result)))             *defined-units*)    result))(defun loaded-units ()  (let ((result nil))    (maphash (function               (lambda (name unit)		 (when (unit-loaded unit)                   (push name result))))             *defined-units*)    result))(defun compute-unit-dependencies (name)  (let ((unit (canonicalize-name name)))    (let ((dependencies nil))      (labels ((find-all (unit)                 (pushnew unit dependencies :test (function equal))                 (mapc (function find-all)                       (unit-dependencies (find-unit unit)))))        (find-all unit))      dependencies)))(defun compute-unit-dependants (name &optional (load-all-unit-definitions nil))  (when load-all-unit-definitions    (load-all-unit-definitions))  (let ((unit (canonicalize-name name)))    (let ((dependants nil))      (maphash (function                 (lambda (name sys)                   (declare (ignore sys))                   (when (member unit (compute-unit-dependencies name)                                 :test (function equal))                     (push name dependants))))               *defined-units*)      dependants)));;;;;;; User utilities;;;(defun edit-unit (name &key definition)  (mapc (function ed)        (reverse (unit-available-source-components (find-unit name))))  (when definition    (edit-unit-definition name)))(defun edit-unit-definition (name)  (ed    (unit-definition (find-unit name))))(defun hardcopy-unit (name &key definition)  (mapc (function hardcopy-file)        (unit-available-source-components (find-unit name)))  (when definition    (hardcopy-unit-definition name)))(defun hardcopy-unit-definition (name)  (hardcopy-file    (unit-definition (find-unit name))))(defun search-unit (name)  (setq ccl::%previous-search-file-file        (concatenate 'string                     (unit-source-pathname (find-unit name))                     "**;*.lisp"))  (menu-item-action    (find-menu-item (find-menu "Tools")                    "Search Files")));;;;;;; Indenting Fred;;;(defmacro defindent (package &rest couples)  `(progn     ,@(mapcar (function                 (lambda (couple)                   (destructuring-bind (string num) couple                     `(fred-indent ',(intern string package) ,num))))               couples)))(defun fred-indent (symbol num)  (let ((cons (assoc symbol *fred-special-indent-alist*)))    (if cons        (rplacd cons num)      (push (cons symbol num) *fred-special-indent-alist*)))  t);;;;;;; Internals;;;(defun hardcopy-file (file)  (let ((window nil))    (unwind-protect        (progn          (setq window (make-instance 'fred-window                         :window-show nil                         :filename file))          (window-hardcopy window nil))      (when window        (window-close window)))))(defun print-unit (unit stream depth)  (declare (ignore depth))  (print-unreadable-object (unit stream)    (format stream "Unit ~A (~A)"            (unit-name unit)            (cond ((unit-loading unit) "loading")                  ((unit-loaded  unit) "loaded")                  (t "unloaded")))))