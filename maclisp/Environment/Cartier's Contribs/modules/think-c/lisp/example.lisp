;;; -*- package: CL-USER -*-;;;;;;; Example for the MCL <-> ThinkC interface;;;(in-package "CL-USER")(defcenv example  ;;  ;; If you do not specify a resource file, it defaults to  ;; (merge-pathnames *THINK-C-FOLDER* (symbol-name module-name)).  ;;  :resource-file  "cc:modules;think-c;think-c;example.res")(defcmodule example-variables  :variables  (my-long   my-double))(defcmodule example-functions  :functions  ((test-fixnum        (:lisp) :d0)   (test-character     (:lisp) :d0)   ;;   ;; If you want your arguments to have more meaningful names   ;; you can use this alternate syntax for the arguments.   ;;   (test-list          ((list :lisp)) :novalue)   (test-struct        ((struct :lisp)) :novalue)   (test-vector        ((vector :lisp)) :novalue)   (test-string        ((string :lisp)) :novalue)   ;;   ;; The ThinkC type that corresponds to MCL's floating point   ;; is short double. I provided a way to pass ThinkC doubles   ;; between C and MCL because this is the type of the 6888*.   ;; So, if you badly need efficiency, you can use this.   ;;   (test-short-double  (:lisp) :novalue)   (test-double        (:mac) :novalue)   (test-c-structures  (:mac) :novalue)   (test-a0            (:mac) :a0)   ;;   ;; If you want ThinkC to make callbacks to Lisp, you have to be   ;; careful because a callback can give rise to a GC which can   ;; invalidate the pointers that C has in the Lisp world.   ;; Gary Byers pointed out to me that even if you dont make any   ;; callbacks to Lisp, a request to the Macintosh memory manager   ;; can possibly result in triggering a MCL garbage collect!   ;;   ;; Your C code can make callbacks to Lisp because it only gets   ;; pointers to the actual arguments, those pointers being updated   ;; automatically in case of a garbage collection.   ;;   (test-callback      (:lisp :mac) :d0)   (test-globals       () :d0)   (test-multi-segment () :d0)   (test-traps         () :a0)));;;; OPEN-CENV opens the resource file containing your code resource and reads;; the main segment of your code resource in memory. It also puts the address;; of the main segment in the symbol naming your C environment (here EXAMPLE).;; ;; LINK-CMODULE links the variables and functions you defined in;; your C module with their correct address in your C environment. The symbol;; value of the variables will contain the address of their C counterparts;; and the symbol value of the functions will contain their entry point address.;;;; It is important to understand that MCL doesn't conserve the Mac heap;; accross a SAVE-APPLICATION. This implies that in order for your C environments;; to be restored properly, the resource file must still be present even;; after a SAVE-APPLICATION.;;(open-cenv 'example);;;; LINK-CMODULE;;(link-cmodule 'example-variables 'example)(link-cmodule 'example-functions 'example);;;; CLOSE-CENV closes the resource file associated with your C environment.;; It is very important if your C environment is multi-segmented, that you do;; not close it before you are through using it, as a call to an unloaded;; segment will force the segment loader to load it from your resource file.;;(close-cenv 'example);;;; A typical debugging cycle for your C code will be the following:;; You evaluate your DEFCENV and DEFCMODULE forms only once.;;;; After that, you open your C environment with OPEN-CENV, link your C module;; with LINK-CMODULE and test your code. If there are some bugs, close your;; C environment with CLOSE-CENV, go back to ThinkC, make changes to your code;; and rebuild the code resource. The cycle then repeats itself.;;#|(test-fixnum 10)(test-character #\a)(test-character #\b)(test-character #\h)(setq l '(1 6 7 8 9))(test-list l)l(defstruct foo a b c)(setq s (make-foo :a 10 :b 20 :c 30))(test-struct s)s(setq a (make-array 5 :initial-contents '(1 2 3 4 5)))(test-vector a)a(setq s "hello how are yah")(test-string s)s(setq a 2.3)(test-short-double a)a(setq a (%make-double 2.3))(test-double a)(%get-double a)(defrecord :myrecord  (a :long)  (b :long)  (c :long))(setq a (make-record :myrecord :a 3 :b 4 :c 8))(test-c-structures a)(print-record a :myrecord)(setq p (#_newPtr 10))(test-a0 p)(defccallable gc (:void) (gc))(test-callback '(2 3 4) gc)(test-globals);;;; If you inadvertently evaluated the CLOSE-CMODULE form;; in the middle of this file, it is not to late to relink your;; module with the LINK-CMODULE form, before it crashes with an;; error of type 15!;;(test-multi-segment)(test-traps)(%get-long my-long)(%get-double my-double)(setf (%get-long my-long) 7)(test-globals)|#