;;; -*- package: CC -*-;;;;;;; New window classes;;;(in-package "CC");;;;;;; A window that hides when closed;;;(defclass hide-window-mixin ()    ())(defvar *force-close* nil)(defmethod window-close :around ((window hide-window-mixin))  (if *force-close*      (call-next-method)    (window-hide window)))(defmethod window-force-close ((window hide-window-mixin))  (let ((*force-close* t))    (window-close window)));;;;;;; A window with a background picture;;;(defclass picture-window-mixin ()    ((picture :initarg :picture)))(defmethod initialize-instance :around ((window picture-window-mixin)                                            &rest initargs &key picture view-size)  (apply (function call-next-method)         (nconc           (list window)           (when (null view-size) (list :view-size (picture-size picture)))           initargs)))(defmethod view-draw-contents :before ((window picture-window-mixin))  (with-slots (picture) window    (#_LoadResource picture)    (draw-picture window picture #@(0 0))));;;;;;; A window with a drag hand;;;(defvar *grabber-cursor*  15000)(defresources grabber-cursor "cc:resources;grabber-cursor"  ("CURS" 15000))#|(defclass hand-drag-window-mixin ()    ((when   :initarg :when   :initform nil)     (redraw :initarg :redraw :initform t)))(defmethod initialize-instance :after ((window hand-drag-window-mixin) &key)  (with-slots (when) window    (setf when (compile-modifiers when))))(defmethod view-click-event-handler ((window hand-drag-window-mixin) where)  (declare (ignore where))  (with-slots (when redraw) window    (if (not (equal when (modifiers)))        (call-next-method)      (with-cursor *grabber-cursor*        (let ((start (view-mouse-position nil))              (end) (delta))          (iter (while (mouse-down-p))                (setq end (view-mouse-position nil)                      delta (subtract-points start end)                      start end)                (when (/= delta 0)                  (let ((pos (view-scroll-position window)))                    (let ((newpos (add-points pos delta)))                      (set-view-scroll-position window newpos)                      (when redraw                        (view-draw-contents window)))))))))    (when (not redraw)      (invalidate-view window))))|#;;;;;;; About window;;;(defclass about-window (picture-window-mixin window)    ()  (:default-initargs     :window-type   :double-edge-box     :view-position :centered))(defmethod initialize-instance :around ((window about-window) &key)  (call-next-method)  (modal-dialog window))(defmethod view-click-event-handler ((window about-window) where)  (declare (ignore where))  (return-from-modal-dialog t));;;;;;; Contour mixin;;;(defclass contour-mixin ()    ())(defclass contour-window (contour-mixin window)    ())(defmethod initialize-instance ((view contour-mixin)                                   &rest initargs &key view-subviews)  (apply (function call-next-method)         view :view-size (contour-size view-subviews)         initargs))(defun contour-size (views)  (iter (for view in views)        (for pos    = (view-position view))        (for size   = (or (view-size view) (view-default-size view)))        (for left   = (point-h pos))        (for top    = (point-v pos))        (for right  = (+ left (point-h size)))        (for bottom = (+ top  (point-v size)))        (minimize left   into min-left)        (minimize top    into min-top)        (maximize right  into max-right)        (maximize bottom into max-bottom)        (finally (return (make-point (+ min-left max-right)                                     (+ min-top  max-bottom))))));;;;;;; Smooth view;;;;; Some of the code found here was taken directly or derived from;; Mike Engber's OOU. Smooth views are a very simple case of Alan Ruttenberg's;; sheet views. Due to incompatibilities between Alanr's Contribs and OOU;; (and also some CCL symbol conflicts), I was forced to reinvent a simple;; version of the wheel. Hopefully, one day I will be able to simply use;; Alanr's very nice sheet views.(defclass gworld-mixin ()    ((gworld :initarg :gworld :initform nil :accessor gworld)))(defclass smooth-view (gworld-mixin view)    ())(defclass smooth-window (gworld-mixin window)    ())(defmacro with-locked-pixels (gworld &body body)  (let ((pixMapHandle (gensym))        (state (gensym)))    `(with-macptrs ((,pixMapHandle (require-trap #_GetGWorldPixMap ,gworld)))       (let ((,state (require-trap #_GetPixelsState ,pixMapHandle)))         (unwind-protect             (if (require-trap #_LockPixels ,pixMapHandle)                 (progn ,@body)               (error "Unable to lock pixels - they've been purged!"))           (require-trap #_SetPixelsState ,pixMapHandle ,state))))))(defmacro with-current-gworld (gworld &body body)  (let ((old-port (gensym))        (old-gdev (gensym)))    `(rlet ((,old-port :pointer)            (,old-gdev :pointer))      (require-trap #_GetGWorld ,old-port ,old-gdev)      (with-macptrs ((,old-port (%get-ptr ,old-port))                     (,old-gdev (%get-ptr ,old-gdev)))        (unwind-protect            (progn              (require-trap #_SetGWorld ,gworld (%null-ptr))              ,@body)          (require-trap #_SetGWorld ,old-port ,old-gdev))))))(defmethod install-view-in-window :after ((view smooth-view) window)  (declare (ignore window))  (allocate-gworld view))(defmethod remove-view-from-window :after ((view smooth-view))  (dispose-gworld view))(defmethod initialize-instance :after ((window smooth-window) &key)  (allocate-gworld window))(defmethod window-close :after ((window smooth-window))  (dispose-gworld window))(defun allocate-gworld (view)  (rlet ((ptr :pointer (%null-ptr))         (rect :Rect :topLeft 0 :botRight (view-size view)))      (let ((ecode (#_NewGWorld ptr 0 rect (%null-ptr) (%null-ptr) 0)))        (if (= ecode 0)            (setf (gworld view)                  (%get-ptr ptr))          (error "Unable to allocate GWorld (~A)." ecode)))))(defun dispose-gworld (view)  (let ((gworld (gworld view)))    (when gworld      (#_DisposeGWorld gworld))))(defmethod view-position-in-window ((window window))  #@(0 0))(defmethod view-position-in-window ((view simple-view))  (convert-coordinates (view-position view)                       (view-container view)                       (view-window view)))(defmethod view-draw-contents :around ((view gworld-mixin))  (let ((gworld (gworld view)))    (cond      ((null gworld) (call-next-method))      (t (without-interrupts           (with-current-gworld gworld             (with-locked-pixels gworld               (call-next-method)))           (transfer-gworld-to-window view))))))(defun transfer-gworld-to-window (view)  (with-focused-view (view-window view)    (with-fore-color *black-color*      (with-back-color *white-color*        (let ((gworld (gworld view))              (position (view-position-in-window view))              (size (view-size view)))          (with-locked-pixels gworld            (rlet ((sr :rect :topleft 0 :bottomright size)                   (dr :rect :topleft position :bottomright (add-points position size)))              (#_CopyBits (pref gworld :GrafPort.portBits)                          (pref (wptr view) :GrafPort.portBits)                          sr dr 0 (%null-ptr)))))))))#|(defclass test-window (smooth-window)    ())(defmethod view-draw-contents ((window test-window))  (with-back-color *red-color*    (rlet ((rect :rect :topleft 0 :bottomright (view-size window)))      (#_EraseRect rect)))  (with-fore-color *blue-color*    (rlet ((rect :rect :top 10 :left 10 :bottom 100 :right 100))      (#_PaintRect rect)))  (with-fore-color *green-color*    (rlet ((rect :rect :top 50 :left 50 :bottom 70 :right 70))      (#_PaintRect rect))))(defclass test-view (smooth-view)    ((color :initarg :test-color)))(defmethod view-draw-contents ((view test-view))  (with-back-color (slot-value view 'color)    (rlet ((rect :rect :topleft 0 :bottomright (view-size view)))      (#_EraseRect rect))))(make-instance 'test-window  :view-position :centered  :view-size #@(400 200))(make-instance 'window  :view-position :centered  :view-size #@(500 300)  :view-subviews  (list    (make-instance 'test-view      :view-position #@(10 10)      :view-size #@(200 200)      :test-color *red-color*)    (make-instance 'view      :view-position #@(250 10)      :view-size #@(220 220)      :view-subviews      (list        (make-instance 'test-view          :view-position #@(10 10)          :view-size #@(200 200)          :test-color *blue-color*)))))|#