;;; -*- package: CC -*-;;;;;;; Remembering Textual References;;;(in-package "CC")(export '(who-calls          who-references          who-expands          who-mentions))(defun who-calls (function)  (get function :who-calls))(defun who-references (variable)  (get variable :who-references))(defun who-expands (macro)  (get macro :who-expands))(defun who-mentions (symbol)  (union (who-calls symbol)  (union (who-references symbol)         (who-expands symbol)         :test (function equal))         :test (function equal)));;;;;;; Building the Database;;;;; I do not understand why this has to be in the CCL package as it is;; only used in a COMPILER-LET that should disappear in the fasl file.;; This strange behavior occurs only in DEFSTRUCT and DEFGENERIC.(defvar ccl::*who-calls-info*  nil)(let ((ccl (find-package "CCL"))      (cl  (find-package "COMMON-LISP")))  ;; Minimal filtering of what to record  (defun note-reference-p (symbol)    (let ((pkg (symbol-package symbol)))      (and (neq pkg ccl)           (neq pkg cl)))))(defun note-reference (symbol category)  (when (and ccl::*who-calls-info*             (note-reference-p symbol))    (pushnew (cons symbol category)             (cdr ccl::*who-calls-info*)             :test (function equal))))(defun note-macro-expansion (exp form env)  (note-reference (car form) :who-expands)  (funcall exp form env));;;;;;; Toplevel Signatures;;;(defvar *signature-number*  -1)(defvar *signatures-table*  (make-hash-table))(defstruct signature  number  edition-type  editor  stringer)(defmacro define-toplevel-signature (symbol edition-type                                          &key (extractor 'general-extractor)                                               (editor    'general-editor)                                               (stringer  'general-stringer))  `(progn     (install-signature-code      ',symbol ',edition-type      ',extractor ',editor ',stringer)     ',symbol));; The package CCL beeing always present, no error;; will be generated if a fasl file containing who-calls info;; is loaded without the who-calls unit beeing present.(defun ccl::store-who-calls-info (info)  (dolist (mention (cdr info))    (pushnew (car info)             (get (car mention) (cdr mention))             :test (function equal))));; ARGLIST having nothing to sink its teeth into;; will be forced to go through the help file...(compiler-let ((*fasl-save-definitions* nil)               (*fasl-save-local-symbols* nil))(defun signature-code (standard extractor)  (function    (lambda (whole env)      (let ((info (list (funcall extractor whole))))        `(compiler-let ((ccl::*who-calls-info* (or ccl::*who-calls-info* ',info)))           (when (fboundp 'ccl::store-who-calls-info)             (ccl::store-who-calls-info ',info))           ,(funcall standard whole env)))))))(defun install-signature-code (symbol edition-type extractor editor stringer)  (setf (gethash symbol *signatures-table*)        (make-signature         :number (incf *signature-number*)         :edition-type edition-type         :editor editor         :stringer stringer))  (let ((*warn-if-redefine-kernel* nil))    (setf (macro-function symbol)          (signature-code (macro-function symbol)                          extractor))))(defun general-extractor (form)  (list (first form)        (second form)))(defun general-editor (sig)  (destructuring-bind (type symbol) sig    (edit-definition symbol (signature-edition-type                              (gethash type *signatures-table*)))))(defun general-stringer (sig)  (string-downcase    (write-to-string sig)))(defun print-signature (sig stream)  (princ (string-signature sig)         stream))(defun string-signature (sig)  (funcall (signature-stringer (gethash (car sig) *signatures-table*))           sig))(defun edit-signature (sig)  (funcall (signature-editor (gethash (car sig) *signatures-table*))           sig))(defun toplevel-lessp (x y)  (< (signature-number (gethash x *signatures-table*))     (signature-number (gethash y *signatures-table*))))(defun function-name-lessp (x y)  (cond ((and (symbolp x) (listp y)) t)        ((and (listp x) (symbolp y)) nil)        (t (string-lessp (symbol-name (if (symbolp x) x (second x)))                         (symbol-name (if (symbolp y) y (second y)))))))(defun sort-signatures (sigs)  (sort (sort (copy-list sigs) (function function-name-lessp)              :key (function second))        (function toplevel-lessp)        :key (function first)));;;;;;; Interface with FRED;;;;; for compatibility with mouse-copy.lisp(unless  (ignore-errors (find-method (function view-click-event-handler) '(:around) (mapcar 'find-class '(fred-mixin t))))  (defmethod view-click-event-handler :around ((view fred-mixin) ignore)    (declare (ignore ignore))    (when (next-method-p)      (call-next-method))))(advise (:method view-click-event-handler :around (fred-mixin t))        (if (and (shift-key-p)                 (option-key-p)                 (not (control-key-p))                 (not (command-key-p)))          (destructuring-bind (v where) arglist            (pop-up-references             (ed-current-symbol v nil (fred-point-position v where))))          (:do-it))        :when :around        :name edit-references)(defmethod pop-up-references (symbol)  (let ((references (sort-signatures (who-mentions symbol))))    (cond ((null references)           (ed-beep)           (format *debug-io* "~&;No recorded reference to ~S." symbol))          (t (edit-signature-with-search               (pop-popper-menu                 (make-list-popper-menu references                   :print-function (function print-signature)))               symbol)))))(defun edit-signature-with-search (signature symbol)  (when signature    (multiple-value-bind (pos sym win)                         (edit-signature signature)      ;; Due to a shortcomings in edit-definition when it      ;; has to open a window because of multiple choices...      (unless (eq pos t)        (cond ((null sym)               (ed-beep)               (format *debug-io* "~&;Can't find toplevel signature ~A."                       (string-signature signature)))              (t (search-string-inside-toplevel                   win (symbol-name symbol))))))))(defun search-string-inside-toplevel (window string)  (multiple-value-bind (start-toplevel end-toplevel)                       (ccl::ed-current/next-top-level-sexp window)    (let ((found (buffer-string-pos (fred-buffer window)                                    string                                    :start start-toplevel                                    :end end-toplevel)))      (cond ((null found)             (ed-beep)             (format *debug-io* "~&;Can't find the reference to ~a."                     string))            (t (set-selection-range window found                                    (+ found (length string))))))    (fred-update window)))