;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  3 10/22/97 akh  resume-application-event-handler;;  2 3/14/97  akh  launch app etal from bill;;  13 9/19/96 slh  removed comment;;  9 3/27/96  akh  changes for finder-parameters;;  7 11/15/95 gb   comment out callback initialization;;  4 2/2/95   akh  merge with leibniz patches;;  3 1/31/95  akh  bill's fix to %free-aedesc;;  2 1/17/95  akh  appleevent-idle uses without-event-processing;;  (do not edit before this line!!);; highlevel-events.lisp - Do System 7 HighLevel Events; Copyright 1990-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!; Modification History;; 10/22/97 akh   resume-application-handler from david lamkins; 11/26/96 bill  do-appleevent-handler handles wildcard handler for both class and id; -------------  4.0;  9/04/96 slh   print-documents-handler: _SetCursor -> with-cursor; 08/20/96 bill  do-appleevent sets *startup-aevents* to nil.; -------------  4.0b1; 05/06/96 bill  slh's fix to (method open-application-document (lisp-development-system t)).;                Make it look for mac-file-type of :pfsl, not :fasl, on ppc-target; 05/03/96 bill  %free-aedesc does (set-macptr-flags aedesc $flags_Normal) before calling #_AEDisposeDesc; -------------  MCL-PPC 3.9; 11/14/95 bill  AppleEvents are back for the PPC; 11/10/95 bill  Temporarily disable for the PPC the call to #_AEProcessAppleEvent;                in do-highlevel-event. Reenable it when callbacks work.; 11/1/95  gb    %equal-ostype: %get-unsigned-byte-> %get-unsigned-word.; 10/26/95 slh   de-lap: %equal-ostype;  3/30/95 slh   merge in base-app changes;--------------  3.0d18; 3/11/95 slh   use gestalt bitnum arg;-------------- 3.0d17; 06/16/93 alice ae-get-parameter-char uses %str-from-ptr-in-script, %path-from-fsspec;		 uses %std-name-and-type so quotes the same as %path-from-iopb; 05/19/93 bill Ed Lai's suggestion to make #_AEResumeTheCurrentEvent work with AppleScript.; ------------- 2.1d6; 04/24/93 bill don't eval-enqueue the call to ED in open-application-document; 03/22/93 bill cheap-cons in install-queued-reply-handler, free-cons in queued-reply-handler; 03/01/93 bill eliminate memory leak in ae-put-parameter-char; 02/26/93 bill Howard Oakley's fix to do-appleevent (explicit _AeSend);               Also, a resource for AEDesc records so we don't cons macptrs.; 12/17/92 bill cheap-cons and friends -> l1-streams; 11/20/92 gb   *application* is a lisp-development-system.; 08/24/92 bill  *signal-appleevent-errors*;--------------  2.0; 01/07/92 gb    don't require RECORDS.;12/10/91 alice %err-disp => signal-file-error;--------------- 2.0b4; 11/19/91 bill  appleevent-idle calls %run-masked-periodic-tasks & process-event.;                It also sets up the environment correctly so that event-dispatch won't do anything;                defer-appleevent-handler processes the AppleEvent immediately if *inside-aesend* is true.; 10/29/91 alice def-load-pointers => def-ccl-pointers; 10/08/91 bill  Consing for every AppleEvent was evil.;                self-addressed AppleEvents are not deferred so that they don't time out.; 09/27/91 alice %path-from-fsspec needs to quote *'s etc.;----------------- 2.0b3;  08/30/91 bill in queued-reply-handler - (setf (gethash ...) nil) -> (remhash ...);  08/19/91 bill Don't repeat (quit) if aborted out;  07/21/91 gb   move quit-event handling to where it works.  Use PREF, just to say;                we did.;  06/25/91 joe  deferred appleevent handling, queued reply handlers, add ae-get and;                ae-put stuff. Add refcons to handlers (can be any lisp object);  06/04/91 joe  Get rid of *load-next-open-doc* since the kernel handles this stuff;                revive open-application-handler since we should still probably accept;                this event.;  05/20/91 gb   No more select-process.  Kernel handles initial oapp, odoc, pdoc;                for us.;  5/20/91  joe  add unwind-protect in standard-ae-handler to prevent anyone from throwing;                beyond the callback (naughty, naughty). Add *application* object & instance;                & re-do the handlers to reflect.;  5/8/91   joe  add deinstall-applevent-handler. initialize error-string = nil in appleevent-error;  04/08/91 joe  CLOS handlers. Perform real event checking in interact-idle;                function. appleevent-error condition. change to expect keyword ostypes. ;  03/13/91 bill select-process in open-documents-handler;------------ 2.0b1;  03/05/91 bill ignore AppleEvent errors in do-event.  Assume that user;                handlers do all that is necessary.;  02/06/91 bill The system 7 folks changed FsSpec to a handle.;  01/09/91 gb   open-documents-handler doesn't try to open the help file, etc.;  12/31/90 gb   RESIDENT decl or two.;  12/26/90 joe  removed (require-interface "EVENTS");  12/13/90 bill in open-application-handler: use *startup-init-file* vice home;init;  11/17/90 joe new#|This is my understanding of the four basic AppleEvents:When a user double clicks on an application, the Finder launches andsends the OApp event. When a user double clicks on a document, and theapp hasn't been open, the Finder launches & sends an Odoc, but _not_ anOapp (weird huh?). The same is true of printing, i.e. you only get an Pdoc,but that makes more sense I guess. The quit seems to happen only if the userdoes a restart or shut-down from the finder. It appears that the launchingappleevents are available the second time event-dispatch is called.Note that the documentation in IM VI is pretty bogus. The "tutorial" in thebeginning is not consistent with the more "reference" like material in thesecond half. For example, you're supposed to call AEInteractWithUser beforethrowing up any dialog boxes, but the "tutorial" ignores this. The beta1CD says that one should look at the AEVTTESample, which seems to be mostlythere, except for some more bogus things like walking the event queue (i.e.non-AU/X compatiblity). There are a lot of things which aren't reallyexplained, such as what the finder does under different circumstances, andhow the app is supposed to react.OK. Here's how I did it:The goal is an Apple Politically Correct implementation of AEvents, whilemaintaining 6.0/7.0 compatibility and identical behavior between 1.3 & 2.0.Whew!Booting lisp is a weird thing. In our distributed lisp, startup-ccl is calledas part of the toplevel function (which also sets the toplevel-functionto #'toplevel-loop. Before this happens, restore-lisp-pointers is called, andthe sysenvirons restorer sets the :appleevents flag. If applevents are present,startup-ccl doesn't do anything, because we can't tell what were supposed to doyet. OApp assumes that the user double clicked on the app itself, so it tries toloadinit.lisp (or fasl). Odoc checks to see if it's the very first AppleEventsince launch time. It accomplishes this via the global *load-next-open-doc*which is set to t by a def-load-pointers and nil by OApp. Thus if*load-next-open-doc* is t when an Odoc event is handled, it means that theuser launched by double clicking on a document, and the document is loadedinstead of edited. Fasls are always loaded. One funny difference between 7.0and 6.0 is that opening a doc from the finder when the app is already opendoes not cause a major context switch. I guess that's the way its' supposed tobe.Unresolved questions:1. What's the right way to respond to errors. For example, what if the finderasks to quit, windows need to be saved, but the interaction mode is set sothat no user interaction is allowed? (seems like no-interaction = ignorethe event). Do we print an error message in this case? What about if the usercancels a print operation. Is that an error? What code should the handler return?2. Why aren't we getting an activate event when we print from the finder?3. What are the guarantees from the finder in terms of what events will come,when, etc. Can you depend on the launching appleevents to be present the first(seems to be second) time you look for them?|#(defvar *appleevent-quit* nil)          ; Mechanism for quitting via an appleevent(defvar *highlevel-eventhook* nil)      ; allow users to put their own highlevel                                        ; event handlers.; compare a keyword to 4 bytes inside a pointer:(defun %equal-ostype (pointer keyword &optional (offset 0))  (%equal-ostype-halfwords (symbol-name keyword)                            (%get-unsigned-word pointer offset)                           (%get-unsigned-word pointer (%i+ offset 2)))); return T if the first two bytes of simple-base-string "STR" ; match "high16" and the next two bytes match "low16".#-ppc-target(defun %equal-ostype-halfwords (string high low)  (lap-inline (string high low)    (getint arg_z)    (getint arg_y)    (move.l arg_x atemp0)    (if# (eq (cmp.w (atemp0 $v_data) arg_y))      (cmp.w (atemp0 (+ $v_data 2)) arg_z))    (setpred eq da)))#+ppc-target(defppclapfunction %equal-ostype-halfwords ((string arg_x) (high arg_y) (low arg_z))  (let ((stringbytes imm0)        (highlow imm1))    (compose-digit highlow high low)    (lwz stringbytes ppc::misc-data-offset string)    (subf imm0 stringbytes highlow)    (cntlzw imm0 imm0)                  ; see if there are 32 "leading zeros" in the difference    (srwi imm0 imm0 5)                  ; 1 if so, 0 otherwise    (insrwi imm0 imm0 1 27)             ; ppc::t-offset = #x11    (add arg_z rnil imm0)    (blr))); appleevent-error condition;(define-condition appleevent-error (error)  ((oserr :initarg :oserr :reader oserr)   (error-string :initform nil :initarg :error-string :reader error-string))  (:report   (lambda (c s)     (format s "~a (~d)~@[ - ~a~]" (%rsc-string (oserr c)) (oserr c) (error-string c))))); Define some useful functions & macros;(defmacro ae-error-str (error-string &body forms)  (let ((errsym (gensym)))    `(let ((,errsym (progn ,@forms)))       (unless (eq ,errsym #.#$noErr)         (error (make-condition 'appleevent-error :oserr ,errsym                                 :error-string ,error-string)))))); same as above, but no error string(defmacro ae-error (&body forms)  (let ((errsym (gensym)))    `(let ((,errsym (progn ,@forms)))       (unless (eq ,errsym #.#$noErr)         (error (make-condition 'appleevent-error :oserr ,errsym)))))); with-aedescs is like rlet except that it will call #_aedisposedesc on it if the; datahandle is not a %null-ptr. Thus, you can use with-aedescs & not worry (so much); about cleaning up.;(defmacro with-aedescs (vars &body body)  `(rlet ,(mapcar #'(lambda (var) `(,var :aedesc :datahandle (%null-ptr))) vars)     (unwind-protect       (progn ,@body)       ,@(mapcar #'(lambda (var) `(unless (%null-ptr-p (rref ,var aedesc.datahandle))                                    (require-trap #_aedisposedesc ,var))) vars))))(defun check-required-params (error-string theAppleEvent)  (rlet ((missed-keyword :ostype)         (actual-type :ostype)         (actual-size :signed-long))    (let ((myerr (#_AEGetAttributePtr theAppleEvent #$keyMissedKeywordAttr                  #$typeWildCard actual-type missed-keyword 4 actual-size)))      (when (eq myerr $noErr)           ; missed a parameter!        (error (make-condition 'appleevent-error :oserr #$errAEParamMissed                                :error-string error-string)))))); getting and putting lisp objects into/outof appleevents(defmacro ae-errorp-handler (errorp &body body)  (let ((condition (gensym)))    `(handler-case       (progn ,@body)       (appleevent-error (,condition)                         (if ,errorp (error ,condition) nil)))))(defun ae-get-attribute-longinteger (the-desc keyword &optional (errorp t))  (rlet ((buffer :signed-long)         (typecode :desctype)         (actualsize :size))    (ae-errorp-handler     errorp     (ae-error (#_aegetattributeptr the-desc keyword                #$typeLongInteger typecode buffer                (record-length :unsigned-long) actualsize))     (%get-signed-long buffer))))(defun ae-get-attribute-type (the-desc keyword &optional (errorp t))  (rlet ((buffer :ostype)         (typecode :desctype)         (actualsize :size))    (ae-errorp-handler     errorp     (ae-error (#_aegetattributeptr the-desc keyword #$typeType typecode                buffer (record-length :ostype) actualsize))     (%get-ostype buffer))))(defun ae-get-parameter-longinteger (the-desc keyword &optional (errorp t))  (rlet ((buffer :signed-long)         (typecode :desctype)         (actualsize :size))    (ae-errorp-handler     errorp     (ae-error (#_aegetparamptr the-desc keyword                #$typeLongInteger typecode buffer                 (record-length :signed-long) actualsize))     (%get-signed-long buffer))))(defun ae-get-parameter-type (the-desc keyword &optional (errorp t))  (rlet ((buffer :ostype)         (typecode :desctype)         (actualsize :size))    (ae-errorp-handler     errorp     (ae-error (#_aegetparamptr the-desc keyword #$typeType typecode                buffer (record-length :ostype) actualsize))     (%get-ostype buffer))))(defun ae-get-parameter-char (the-desc keyword &optional (errorp t))  (with-aedescs (buffer-desc)    (ae-errorp-handler     errorp     (ae-error (#_aegetparamdesc the-desc keyword #$typeChar buffer-desc))     (let ((datahandle (rref buffer-desc aedesc.datahandle)))       (with-dereferenced-handles ((ptr datahandle))         (%str-from-ptr-in-script ptr (#_GetHandleSize datahandle))))))); putting(defun ae-put-attribute-longinteger (the-desc keyword thing &optional (errorp t))  (rlet ((buffer :signed-long))    (%put-long buffer thing)    (ae-errorp-handler      errorp      (ae-error (#_AEPutAttributePtr the-desc keyword #$typeLongInteger buffer                 (record-length :signed-long))))))(defun ae-put-attribute-type (the-desc keyword thing &optional (errorp t))  (rlet ((buffer :ostype))    (%put-ostype buffer thing)    (ae-errorp-handler      errorp      (ae-error (#_AEPutAttributePtr the-desc keyword #$typeType buffer                 (record-length :ostype))))))(defun ae-put-parameter-longinteger (the-desc keyword thing &optional (errorp t))  (rlet ((buffer :signed-long))    (%put-long buffer thing)    (ae-errorp-handler      errorp      (ae-error (#_AEPutParamPtr the-desc keyword #$typeLongInteger buffer                 (record-length :signed-long))))))(defun ae-put-parameter-type (the-desc keyword thing &optional (errorp t))  (rlet ((buffer :ostype))    (%put-ostype buffer thing)    (ae-errorp-handler      errorp      (ae-error (#_AEPutParamPtr the-desc keyword #$typeType buffer                 (record-length :ostype))))))(defun ae-put-parameter-char (the-desc keyword string &optional (errorp t))  (with-cstrs ((cstr string))    (ae-errorp-handler      errorp      (ae-error (#_AEPutParamPtr the-desc keyword #$typeChar                 cstr (length string)))))); Here's the entry to the appleevent receiving system:;(defun do-highlevel-event (event)  (unless (and *highlevel-eventhook*               (if (consp *highlevel-eventhook*)                 (dolist (item *highlevel-eventhook*)                   (when (funcall item) (return t)))                 (funcall *highlevel-eventhook*)))    (#_aeprocessappleevent event)       ; Any errors that occur are reported by standard-appleevent-handler    (when *appleevent-quit*      (setq *appleevent-quit* nil)      (quit))))                         ; Process quit sent from MCL to MCL as an AppleEvent; We bypass the AppleEvent Manager's dispatch routine & do our own dispatching; within lisp.(defvar %appleevent-handlers% (make-hash-table :test #'eq :size 4))(defun install-appleevent-handler (class id function &optional (refcon nil))  (let ((id-table (gethash class %appleevent-handlers%)))    (unless id-table      (setq id-table (make-hash-table :test #'eq :size 1))      (setf (gethash class %appleevent-handlers%) id-table))    (setf (gethash id id-table) (cons function refcon))))(defun deinstall-appleevent-handler (class id)  (let ((id-table (gethash class %appleevent-handlers%)))    (when id-table      (setf (gethash id id-table) nil)))); We make an application CLOS object, and appleevent handlers are methods of; the instance *application*.; is in l1-initmenus today;(defparameter *application* (make-instance 'lisp-development-system))(defvar *deferred-appleevents* nil)(defvar *inside-aesend* nil)(defresource *AEDesc-resource*  :constructor  (with-macptrs ((p (make-record :AEDesc)))    (%setf-macptr (make-gcable-macptr $flags_disposptr) p)))(defvar *null-ptr*)(def-ccl-pointers *AEDesc-resource* ()  (setf *null-ptr* (%null-ptr)        (pool.data (resource.pool *AEDesc-resource*)) nil))(defun copy-aedesc (aedesc)  (if (%null-ptr-p aedesc)    *null-ptr*    (let ((res (allocate-resource *AEDesc-resource*)))      (#_BlockMove aedesc res (record-length :AEDesc))      res)))(defun %free-aedesc (aedesc &optional (dispose-p t))  (unless (%null-ptr-p aedesc)    (if dispose-p      (progn          (set-macptr-flags aedesc $flags_Normal)          (#_AEDisposeDesc aedesc))      (free-resource *aedesc-resource* aedesc)))); defer-appleevent-handler handles all appleevents & simply suspends the event; and appends the cons of the event, reply, and refcon to *deferred-appleevents*; If the event is from MCL itself, it handles it right away.(defpascal defer-appleevent-handler (:pointer theAppleEvent :pointer reply                                              :long handlerRefcon :word)  (declare (ignore handlerRefcon))  (rlet ((source :word)         (actualType :long)         (actualSize :long))    (if (or *inside-aesend*            (and (eql #$noErr (#_AEGetAttributePtr                               theAppleEvent #$keyEventSourceAttr #$TypeShortInteger actualType source 2 actualSize))                 (let ((source (%get-word source)))                   (or (eql #$kAESameProcess source)                       (eql #$kAEDirectCall source)))))      (do-appleevent theAppleEvent reply nil)      (progn        (ae-error (#_AESuspendTheCurrentEvent theAppleEvent))        (setq *deferred-appleevents* (nconc *deferred-appleevents*                                            (cheap-cons                                             (cheap-cons                                               (copy-aedesc theAppleEvent)                                              (copy-aedesc reply))                                             nil)))        #$noErr)))); do-deferred-appleevent gets called at the end of event-dispatch when events; are turned back on.(defvar *doing-deferred-appleevents* nil)       ; make things reentrant(defun do-deferred-appleevents ()  (unless *doing-deferred-appleevents*    (let ((*doing-deferred-appleevents* t))      (do ((event-info (pop-and-free *deferred-appleevents*) (pop-and-free *deferred-appleevents*)))          ((null event-info))        (let ((theAppleEvent (car (the list event-info)))              (reply (cdr (the list event-info))))          (free-cons event-info)          ; Ed Lai suggested getting rid of this. Doing so made our code work with AppleScript installed.;          (#_AESetTheCurrentEvent theAppleEvent)          (do-appleevent theAppleEvent reply t))))))(defvar *report-appleevent-errors* nil)(defvar *signal-appleevent-errors* t)(defun do-appleevent (theAppleEvent reply deferred-p)  (let ((result #$noErr)        (class nil)        (id nil)        (resumed? nil))    (block buck-stops-here              ; don't throw past here unless (and deferred-p *signal-applevent-errors*)      (labels ((resume-appleevent ()                 (unless resumed?                   (setq resumed? t)                   ; try to put the result code in the reply (the reply may be null)                   ; if the event is itself a reply!                   (unless (eql result #$noErr)         ; otherwise Toy Surprise gets unhappy                     (ae-put-parameter-longinteger reply #$keyErrorNumber result nil))                   (when deferred-p                     (#_AEResumeTheCurrentEvent theAppleEvent reply (%int-to-ptr #$kAENoDispatch) 0)                     ; It seems that you can free theAppleEvent right away, but                     ; need to wait until the client reads the reply before you can                     ; dispose of it. The AppleEvent system is NOT disposing of the reply                     ; or theAppleEvent as it is supposed to do.                     ; Actually, even freeing theAppleEvent right away seems to cause                     ; the heap to get scrambled so that (ROOM) will cause the next                     ; send from Toy Surprise to crash.                     ; Apparently, we need to wait until the server receives the                     ; reply. Then we can dispose of the two AEDesc's                     (%free-aedesc theAppleEvent nil)                     (%free-aedesc reply nil)                     (when *appleevent-quit*                       (setq *appleevent-quit* nil)   ; don't repeat if aborted out                       (quit)))))               (error-handler (c)                 (ae-put-parameter-char reply #$keyErrorString                                        (with-output-to-string (s)                                          (report-condition c s))                                        nil)                 (if (typep c 'appleevent-error)                   (setq result (oserr c))    ; return the error to the AppleEvent Manager                   (setq result #$errAEEventNotHandled))                 (resume-appleevent)                 (unless (and deferred-p *signal-appleevent-errors*)                   (when *report-appleevent-errors*                     (format *error-output* "~%> Error while handling AppleEvent: '~a' '~a'~%> "                             class id)                     (report-condition c *error-output*))                   (return-from buck-stops-here))))        (declare (dynamic-extent #'resume-appleevent #'error-handler))        (unwind-protect                     ; make sure we resume the AppleEvent if deferred-p          (handler-bind ((error #'error-handler))            (setq class (ae-get-attribute-type theAppleEvent #$keyEventClassAttr)                  id (ae-get-attribute-type theAppleEvent #$keyEventIDAttr))            (flet ((lookup (id id-table)                     (and id-table                          (or (gethash id id-table)                              (gethash :|****| id-table)))))              (let ((handler (or (lookup id (gethash class %appleevent-handlers%))                                 (lookup id (gethash :|****| %appleevent-handlers%)))))                ;; handler is queued-reply-handler for class :|aevt| id :|ansr|                ;; it loses when we get this event - why do we get it from toolserver?                ;; most of em  are (:MPS\  :|outp|)                (unless handler                  (error (make-condition 'appleevent-error :oserr #$errAEEventNotHandled                                         :error-string (format nil "No Lisp Handler for '~a' '~a'"                                                               class id))))                (funcall (car handler) *application* theAppleEvent reply (cdr handler)))))          (setq *startup-aevents* nil)          (resume-appleevent)          (unless (and deferred-p *signal-appleevent-errors*)            (return-from buck-stops-here)))))    result)); define our idle procedure for when we have to wait for something;(defpascal appleevent-idle (:pointer event :pointer sleeptime :pointer mouseRgn                                     :word)  ; This is now implemented according to the latest spec (2/11/91).  ;  (declare (ignore mouseRgn))  (without-interrupts   (without-event-processing ;let-globally ((*processing-events* *current-process*))         ; Don't handle any events     (let* ((*inhibit-abort* t)             ; only this code is allowed to look for aborts            (*interrupt-level* *interrupt-level*))          ; I'm paranoid              ; cruise down the event queue & see if there's a pending abort...       (when (abort-event-pending-p)         (setq *processing-events* nil)         (return-from appleevent-idle #$true))   ; found an abort! run for the hills!              ; Make sure user periodic tasks run.       (%run-masked-periodic-tasks)              ; We should set the value of sleeptime if it's a null event.       ; Then we're supposed to handle the event "normally"       (if (= #$nullevent (rref event eventRecord.What))         (%put-long sleeptime (wait-next-event-sleep-ticks)))       (process-event event)))   #$false)); Appleevent handlers...; These are all methods of the class appliction & are called with four arguments:; The application-object (bound to *application*), the appleevent, the reply and the; refcon. If there are any problems, the handler should signal the appleevent-error; condition (ae-error-str) which will do the appropriate thing automagically. ; This is what happens in ae-error-str. Otherwise, just return & everything; will be cool. Note that handlers are called at the end of event processing; so that interrupts are enabled, so there are no worries.; The refcon is any lisp object, not just a number. It's maintained entirely on ; the Lisp side.;; implement queued reply handlers. These are handlers for when someone decided; to receive the reply in the event queue. We keep a hashtable of return id's; and methods to call on the application object.;(defvar %queued-reply-handlers% (make-hash-table :test #'eql))(defun install-queued-reply-handler (appleevent-or-id function &optional (refcon nil))  (when (macptrp appleevent-or-id)    (setq appleevent-or-id          (ae-get-attribute-longinteger appleevent-or-id #$keyReturnIDAttr)))  (setf (gethash appleevent-or-id %queued-reply-handlers%)        (cheap-cons function refcon)))(defmethod queued-reply-handler ((a application) theAppleEvent reply handlerRefcon)  (let* ((return-id (ae-get-attribute-longinteger theAppleEvent #$keyReturnIDAttr))         (handler (gethash return-id %queued-reply-handlers%)))    (if handler      (progn        (let ((f (car handler))              (refcon (cdr handler)))          (remhash return-id %queued-reply-handlers%)          (free-cons handler)          (funcall f *application* theAppleEvent reply refcon)))      (no-queued-reply-handler a theAppleEvent reply handlerRefcon))))    (defmethod no-queued-reply-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon))  (let ((return-id (ae-get-attribute-longinteger theAppleEvent #$keyReturnIDAttr)))    (error (make-condition 'appleevent-error :oserr #$errAEEventNotHandled                           :error-string (format nil "No queued reply handler for id: ~d"                                                 return-id))))); implement the four basic handlers; here's a useful fsspec parsing tool:; note that fssspecptr is a POINTER not a handle!(defun %path-from-fsspec (fsspecptr &aux dir)  (multiple-value-bind  (name type)(%std-name-and-type (pref fsspecptr fsspec.name))    (rlet ((f2 :fsspec))      (do ((result (#_fsmakefsspec (pref fsspecptr fsspec.vrefnum)                    (pref fsspecptr fsspec.parid)                    (%null-ptr)                    f2)                   (#_fsmakefsspec (pref f2 fsspec.vrefnum)                    (pref f2 fsspec.parid)                    (%null-ptr)                    f2)))          ((not (%izerop result))           (unless (eql result #$dirNFErr)             (signal-file-error result name)))        (setq dir (cons (%path-std-quotes (pref f2 fsspec.name) nil ";*") dir))))    (%cons-pathname (cons ':absolute dir) name type)))(defmethod open-application-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (check-required-params "unexpected parameters in oapp" theAppleEvent)  ; does nothing!  )(defmethod quit-application-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (check-required-params "unexpected parameters in quit" theAppleEvent)  (cond   ((do-all-windows w                   ; see if we need to interact      (when (and (method-exists-p #'window-needs-saving-p w)                 (window-needs-saving-p w))        (return t)))    (ae-error-str "trying to quit"      (#_AEInteractWithUser #$kNoTimeOut (%null-ptr) appleevent-idle))    (unless (eq :cancel (catch :cancel                          (let ((listener *top-listener*))                            (do-all-windows w                              (if (neq w listener)                                (window-close w))))))      (setq *appleevent-quit* t)))   (t    (setq *appleevent-quit* t))))(defmethod open-documents-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (with-aedescs (doclist)    (rlet ((items :signed-long)           (aekeyword :ostype)           (actual-type :ostype)           (my-fsspec :fsspec)           (actual-size :signed-long))      (ae-error-str "trying to get the doclist in odoc"        (#_AEGetParamDesc theAppleEvent #$keyDirectObject #$typeAEList doclist))      (check-required-params "unexpected parameters in odoc" theAppleEvent)      (ae-error-str "trying to count the items in odoc"         (#_AECountItems doclist items))      (dotimes (i (%get-signed-long items))        (ae-error-str "trying to get an item in odoc"          (#_AEGetNthPtr doclist (+ i 1) #$typeFSS aekeyword actual-type my-fsspec            (record-length :fsspec) actual-size))        (let* ((path (%path-from-fsspec my-fsspec)))          (if *startup-aevents*            (if (eq (car *finder-parameters*) :open)              (setq *finder-parameters* (nconc *finder-parameters* (list path)))              (setq *finder-parameters* (list :open path)))            (open-application-document a path)))))))(defmethod print-documents-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (with-aedescs (doclist)    (rlet ((items :signed-long)           (aekeyword :ostype)           (actual-type :ostype)           (my-fsspec :fsspec)           (actual-size :signed-long))      (ae-error-str "trying to get the doclist in odoc"        (#_AEGetParamDesc theAppleEvent #$keyDirectObject #$typeAEList doclist))      (check-required-params "unexpected parameters in pdoc" theAppleEvent)      (ae-error-str "trying to count the items in pdoc"        (#_AECountItems doclist items))      ; deal with the whole interaction issue... If we can interact, then      ; throw up the print dialog.        (catch :cancel                  ; be prepared for a cancel          (ae-error-str "trying to interact in pdoc"            (#_AEInteractWithUser #$kNoTimeOut (%null-ptr) appleevent-idle))          (unless *foreground*          ; workaround - someone isn't sending us the resume!            (#_postevent (%int-to-ptr #$osEvt) (+ #x1000000 #$suspendResumeMessage)))          (unwind-protect               ; make sure PrClose gets called            (progn          ; do the print dialog              (#_PrOpen)              (prchk $err-printer-load)              (let ((pRec (get-print-record)))                (with-cursor *ARROW-CURSOR*                  (unless (#_PrJobDialog pRec)                    (throw :cancel :cancel)))))            (#_PrClose))                    (dotimes (i (%get-signed-long items))            (ae-error-str "trying to get an item in pdoc"              (#_AEGetNthPtr doclist (+ i 1) #$typeFSS aekeyword actual-type my-fsspec                (record-length :fsspec) actual-size))            (let ((path (%path-from-fsspec my-fsspec)))              (if *startup-aevents*                (if (eq (car *finder-parameters*) :print)                  (setq *finder-parameters* (nconc *finder-parameters* (list path)))                  (setq *finder-parameters* (list :print path)))                (print-application-document a (%path-from-fsspec my-fsspec)))))))))(defun hardcopy-file (path &optional (show-dialog t))  "Uses Fred to print a file"  (let ((window (pathname-to-window path)))    (cond (window (window-hardcopy window show-dialog))          (t (setq window (ed path))             (window-hardcopy window show-dialog)             (window-close window)))))  (defmethod print-application-document ((a lisp-development-system) path &optional startup)  (declare (ignore startup))  (hardcopy-file path nil))(defmethod open-application-document ((a lisp-development-system) path &optional startup)  (declare (ignore startup))  (case (mac-file-type path)    (#-ppc-target :fasl     #+ppc-target :pfsl     (with-simple-restart (continue "Skip loading finder-selected file.")             (load path)             t))    (:text (ed path)           nil))); This is called when AppleScript does "launch application ..."; open-application-handler gets called for "run application ..."(defmethod launch-application-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (check-required-params "Unexpected parameters in 'ascr' 'noop'" theAppleEvent)  ; does nothing  ); This is called with AppleScript does "tell application ... to activate"(defmethod activate-application-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (check-required-params "Unexpected parameters in 'misc' 'actv'" theAppleEvent)  (rlet ((psn :processSerialNumber              :highLongOfPSN 0              :lowLongOfPSN #$kCurrentProcess))    (#_setFrontProcess psn)))(install-appleevent-handler :|ascr| :|noop| #'launch-application-handler)(install-appleevent-handler :|misc| :|actv| #'activate-application-handler);install our handlers(install-appleevent-handler :|aevt| :|ansr| #'queued-reply-handler)(install-appleevent-handler :|aevt| :|oapp| #'open-application-handler)(install-appleevent-handler :|aevt| :|quit| #'quit-application-handler)(install-appleevent-handler :|aevt| :|odoc| #'open-documents-handler)(install-appleevent-handler :|aevt| :|pdoc| #'print-documents-handler)(export 'resume-application-handler);;; This is called when the OS8 Finder resumes a running application;;; via the user opening an already-active application.(defmethod resume-application-handler ((a application) theAppleEvent reply handlerRefcon)  (declare (ignore reply handlerRefcon) (resident))  (check-required-params "Unexpected parameters in 'aevt' 'rapp'" theAppleEvent)  ;; does nothing  )(install-appleevent-handler :|aevt| :|rapp| #'resume-application-handler)(def-ccl-pointers highlevel-events ()  (when (gestalt #$gestaltAppleEventsAttr #$gestaltAppleEventsPresent)    ; install our handler into the real AppleEvent Manager dispatch table    (#_AEInstallEventHandler #$typeWildCard #$typeWildCard     defer-appleevent-handler 0 nil))); End of l1-highlevel-events.lisp 