;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  3 4/1/97   akh  see below;;  21 9/13/96 akh  pathnamep returns conditionally, more checks for nonsense in directory namestrings;;                  pathname-host-sstr may return :unspecific;;  18 9/4/96  akh  put back pathnamep (from l0-pred);;  17 7/30/96 akh  pathname-host of string - same as (pathname-host (pathname string)) when no dir;;  15 7/26/96 akh  remove support for old logical directories;;  11 5/20/96 akh  open-res-file calls truename for alias resolution;;  9 3/9/96   akh  fix create-file when type and creator are not default;;  7 2/19/96  akh  remove :up's in %std-directory-component;;  3 10/17/95 akh  merge patches;;  2 10/12/95 akh  no more Lap for PPC;;  17 6/8/95  slh  move choose-file-ddir;;  12 5/23/95 akh  mac-file-write-date - unsigned long;;  10 5/22/95 akh  added mac-file-xx-date functions;;  3 4/6/95   akh  set-choose-file-default-directory gets full name;;  2 4/4/95   akh  no change;;  10 3/20/95 akh  add Kalmans file size utilities;;  6 3/2/95   akh  use application-file-creator;;  5 2/21/95  slh  removed naughty word (file is public now);;  4 1/30/95  akh  fixes to make-pathname, merge-pathnames from patch,;;                  and %path-getdirinfo from alias-file-patch;;  (do not edit before this line!!);; L1-files.lisp - Object oriented file stuff; Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!; Modification History;; 03/11/97 bill %file-size & file-info error if the "file" is a directory.; ------------- 4.0; 9/24/96 slh   overwrite-dialog: fix the message text some more; 09/24/96 bill overwrite-dialog now reports the file name instead of "filename".;               Thanks to John Wiseman.; ------------- 4.0b2; 9/11/96 slh   find-load-file: recognize pathname-type :unspecific, merge with;               file types before doing probe-file;09/07/96 gb    put pathnamep back in l0-pred.;07/29/96 bill  In initializing semi-pos, pathname-host-sstr ensures that pos is non-NIL before;               blindly %schar'ing.;07/01/96 bill  findfolder passes NIL, not (%null-ptr) for the create arg to #_FindFolder; 6/06/96 slh   parse-namestring fix from patch;05/24/96 bill  %path-from-params special cases the desktop folder.;05/06/96 bill  slh's fix to require. It now looks for mac-file-type of :pfsl, not :fasl;               on ppc-target.;-------------  MCL-PPC 3.9;04/03/96 bill  compile-load uses *.lisp-pathname* instead of ".lisp".;04/26/96 bill  %directory-string-list no longer accesses off the end of the string.;03/26/96  gb   lowmem accessors.;02/11/96 bill  James Anderson's fix to the "Load other file..." restart in LOAD;11/29/95 bill  #_PBxxx -> #_PBxxxSync to avoid trap emulator;11/12/95 gb    #_H* -> #_PBH* to avoid confusion with interfaces' definitions.;11/08/95 bill  #_PBExchangeFiles -> #_PBExchangeFilesSync;               #_PBSetCatInfo -> #_PBSetCatInfoSync; 6/09/95 slh   Kalman's load patches; 6/07/95 slh   move CFDs to new-file-dialogs, include old-file-dialogs due;               to bugs in CustomGetFile (thanks DTS for verifying our fears!); 6/01/95 slh   set-choose-file-default-directory: no-error optional argument;               should really have CFD callers specify whether to do logical xlations; 5/26/95 slh   alternates for :str255/63; 5/22/95 slh   %file-date: return nil if error; 5/19/95 slh   use string-equal on module strings, not string=; 5/17/95 slh   %file-date: errchk optional, for menu updating niceness; 4/26/95 slh   use old-file-dialogs module if necessary; 4/13/95 slh   sf-choose-file-hook: don't set name field - it sets the;               selection to the end of the list; 4/11/95 slh   overwrite-dialog: folded in application method; 3/24/95 slh   choose-file-dialog, choose-directory-dialog: handle :directory "vol:dir",;               "vol:dir:", and "vol:dir:file"; 3/11/95 slh   all new choose file/dir functions; 3/01/95 slh   new Choose Directory dialog - oh oh, may require System 7; 2/28/95 slh   %path-get-long-dir-info reports real error; 2/27/95 slh   sf-choose-directory-hook: new item numbers for select, cancel;-------------- 3.0d17;    ?    alice; incorporate alias-file-patch in %path-getdirinfo; fix make-pathname removing double inclusion of relative default; kalmans fix to merge-pathnames; find desktop folder the PC way, added function findfolder (vrefnum ostype);--------;07/29/93 bill  alias-path-p now takes an optional dont-resolve arg.;06/26/93 bill  put-external-scrap in choose-new-file-dialog;-------------- 3.0d11;07/13/93 alice find-load-file - call full-pathname with no-errorp nil;06/16/93 alice %path-quoted-p and %directory-list-namestring are fat string aware;06/16/93 alice %path-from-iopb calls %std-name-and-type to parse and quote name and type;06/15/93 alice %path-std-quotes - removing optimization makes him fat string aware;		could also leave it in when everyone is base.;06/15/93 alice %path-from-iopb is fat-string aware and has no more lap at expense of consing an extra string,;06/14/93 alice %reverse-component-case is fat string aware (dreadfully important).;06/11/93 alice %%str-member is fat string aware;03/01/93 alice mid-path-aliases needed to tell %path-getdirinfo that dir is already unquoted;10/16/92 alice remove-up failed for more than one, directory-string-list forgot about ; and :UP;08/06/92 alice find-load-file defend against full-pathname returning nil.;06/08/92 alice probe-file work for both "foo:bar alias:" and "foo:bar alias" ;06/05/92 alice %path-getdirinfo - look in desktop folder of all vols for aliases;		pb-resolve-alias - hacked to work for aliases on remote vols;05/20/92 alice find-load-file - fix for type specified and, untyped file exists;05/01/92 alice nuke *working-directory*; 08/04/92 bill  in compile-load: The :fasl-file, :ignore-compiler-warnings,  &;                :force-compile keywords are no longer passed along to compile-file  or load.; 07/22/92 bill  dummy definition for %path-get-long-dir-info; 07/06/92 bill  *last-choose-file-directory*: DEFVAR -> DEFLOADVAR;--------------  2.0; 03/20/92 bill  EXCHANGE-FILES exchanges the type, creator, & creation date.;                Maybe it should exchange some of the other finder info stuff.; 02/21/92 (alice from bootpatch0) don't die if "home:" gets renamed in ;                choose-file-default-directory;---------------- 2.0f2; 01/07/92 gb    don't require RECORDS.; 12/19/91 bill  :defaults NIL for make-pathname in find-module-pathnames; 12/16/91 alice choose-...-dialog remember directory if cancelled; 12/14/91 alice %load if verbose print *load-pathname* not *loading-file-source-file*; 12/11/91 gb    signal-file-error a macro, wants a fixnum as first argument.; 12/10/91 alice exchange-files gets optional errchk argument; 12/04/91 alice choose-directory-dialog erroneously said pathname-directory, make him set default also;---------------- 2.0b4; 11/17/91 alice fix find-load-file again - appear to have misplaced a change; 10/16/91 bill  %run-masked-periodic-tasks during #_SFGetFile; 10/24/91 alice directory :wild is '(:absolute :wild-inferiors); 10/23/91 alice directory-namestring instead of pathname-directory in choose-file-dialog; 10/10/91 alice pathname-version had a really dumb bug; 10/10/91 alice %std-directory-part dtrt and use it for more; 10/21/91 gb    no more #_PB; 10/06/91 alice choose-new-file mumble don't lose the name, fix choose-directory-dialog; 10/03/91 alice directory-pathname-p t if name "" and type :unspecific; 10/01/91 alice %path-from-iopb if both name and type are absent make em nil;                instead of "" and :unspecific (what will this break?); 10/01/91 alice pb-resolve-alias still botched the dir, %path-getdirinfo recurse right; 10/01/91 alice %load and find-load-file - try to get the source file right; 09/23/91 alice %std-directory doesn't transform '(:absolute) to nil ?; 09/20/91 alice %path-to-iopb and pb-resolve-alias botched the dirid; 09/11/91 alice create-file call create-directory with the FULL physical directory;----------------- 2.0b3; 09/06/91 alice signal-file-error takes args; 09/09/91 bill  error on attempt to invoke choose-file-dialog when not in *foreground*; 08/23/91 alice delete-file behave as before - if not there, no error. Add exchange-files; 08/24/91 gb   use new trap syntax.; 07/31/91 bill Jeremy's new choose-directory-dialog; 08/01/91 alice resolve aliases, changes %path-to-iopb a bit. (to do: create-file); 07/29/91 alice get-long iodirid; 07/21/91 gb   error signalling.  Mac-file-thing resolves aliases; should probably happen;               in TRUENAME or somesuch.; 07/19/91 alice %std-directory-part handle :wild, choose-file-default-directory aware of *last...; 07/15/91 alice set-choose-file-default-directory set *last-...-directory* too.; 06/12/91 bill make the :button-string to choose-new-file-dialog more persistent in sf-hook; 06/08/91 bill provide no longer puts duplicates on *module-file-alist*; 06/06/91 bill ALMS's patch to find-load-file to reduce consing.; 06/26/91 alice enough-namestring return relative directory if possible; 06/24/91 alice delete-file work for directories as foo:baz:; 06/13/91 alice merge-pathnames heeds version (do we really care); 06/12/91 alice namestring was bogus for host & version "*",;		 change file-namestring to include version & pathname (PATCH) ;		(Now files can't be named a.b.* a.b.0 or a.b.newest because both;		pathname and make-pathname toss the "version" if no host.;		Pathname, pathname-name, pathname-type all parse strings the same); 06/10/91 alice %directory-list-namestring :wild => * &  %std-directory-component no :wild => *;		%directory-string-list * => :wild;------------- 2.0b2; 05/20/91 gb   #'file-error -> #'signal-file-error.; 05/07/91 bill return :unspecific vice NIL from pathname-version; 05/03/91 bill namestring includes version,;               pathname & pathname-version-sstr parse it (more) correctly.; 05/10/91 alice choose-file-dialog  & choose-new-file-dialog - remember directory so gsb won't complain.; 04/16/91 alice pathname-type-sstr - If lonely dot, type is "". Fix pathname-version-sstr and pathname-name for trailing dots. (patch?); 04/04/91 alice choose-file-dialog  & choose-new-file-dialog closeWD ; 03/15/91 alice fix recently introduce bug in pathname-host-sstr; 02/22/91 alice error and %err-disp =>file-error where appropriate, give report-bad-arg a required type in some cases; 02/15/91 alice merge-pathnames - remove :up if merging relative, nuke (:logical "foo") if logical host ; 02/15/91 alice %directory-list-namestring - use ; for :up if logical host (patch ?); 02/12/91 alice move full-pathname to l1-pathnames for boot reasons; 02/12/91 alice find-load-file return truename and untranslated name, %load bind *load-pathname* and *load-truename* correctly; 02/08/91 alice full-pathname with no-errors t,  return nil if got an error in %expand-logical-directories (PATCH!);          no-error arg default to t again (doc says so);-------------- 2.0b1; 02/06/91 alice %directory-string-list for host; 01/25/91 alice pathname-host-sstr - error if undefined host; 01/25/91 alice per gb's suggestion %path-from-iopb quit at root, full-pathname do error if undefined MCL logical dir ; 01/25/91 alice parse-namestring do return a logical pathname when a host is provided; 01/25/91 alice merge-pathnames (re host) said dir when it meant path-dir; 01/24/91 alice create-file create missing directories (needed this for write-floppies);--------------------------2.0a5; 01/03/90 alice %directory-list-namestring use ";" if we have a logical host. directory-namestring;          funny quote if no host. %directory-string-list & pathname-directory-sstr take optional host arg too. ; 01/03/90 alice make-pathname merge dir with defaults a la merge-pathnames; 01/01/91 alice make-pathname don't do pathname-directory of NIL; 12/28/90 bill  error in choose-directory-dialog (which still doesn't do anything useful); 12/20/90 alice %directory-string-list - log:;foo; directory is relative (pg 629);          %directory-list-namestring take optional host arg (used for relative pathnames); 12/10/90 alice mods to make-pathname, merge-pathnames ,  merge-pathnames with;  defaults in mac-directory-namestring; --------------------------2.0a4; 11/10/90 gb    new fasloader.  Autoload ff-load.; 10/27/90 alice probe-file failed for top level non-local dirs; 10/25/90 alice allow ∂: in directory namestring first component, full-pathname dont return nil; 10/18/90 alice change pathname-host to return only a defined logical host & make pathname-directory agree;                parse-namestring dont ignore host, defaults; 10/16/90 gb    no more %str-length.; 09/07/90 alice namestring include host (fix all callers); 08/23/90 alice probe-file dont give back a dir unless dir pathname provided; 08/09/90 alice stop making believe we have versions; 09/16/90 bill  Add errorp arg to %open-res-file; 09/13/90 bill  compile-load,;                remove "library;interfaces:" from *module-search-path*: use require-interface; 09/11/90 bill  Finally restarts for LOAD; 09/08/90 bill  Remove the trailing newline from LOAD's verbose message and;                add a force-output so that output can be to a mini-buffer.; 09/07/90 bill  "ccl;library" -> "ccl;library:", "interfaces" logical directory; 09/06/90 bill  Joe added "library;interfaces:" to *module-search-path*; 08/09/90 alice stop making believe we have versions; 08/03/90 bill add examples & library to *logical-directory-alist*; 07/27/90 alice make file-author do what the documentation says it does.; 07/19/90 alice fix set-file-write-date to not bash other info; 07/06/90 alice gary's fix for bogus forward reference warns with included files; 07/06/90 alice bind *load-truename* and *load-pathname* in load (issue 112); 07/06/90 alice fix full-pathname to merge default-directory, remove up's where possible;                and obey the no-error arg; 06/19/90 alice fix (pathname ":") and (make-pathname :directory '(:relative)); 06/18/90 alice fix enough-namestring, defvar (not defparameter) *logical-directory-alist*; 06/15/90 alice let probe-file work for directories too!!!; 06/14/90 alice pathname faster, less garbage; 06/13/90 alice print-object (pathname) obey *print-readably*; ------ 2.0d46; 06/12/90 alice disallow symbols in pathname args, allow version :newest;06/11/90  gb   bind *readtable* in load.; 06/08/90 alice make merge-pathnames deal with logical hosts; ------ 2.0d45; 06/02/90 alice %directory-string-list  - allow multiple logical directories; 06/01/90 alice fix pathname-host, pathname and pathname-directory for logical host;06/04/90 bill in choose-**-dialog: default -> directory (that's what the doc says);              add "ccl;examples:" to *module-search-path*.;06/04/90 gb   Use with-compilation-unit in load-from-stream.;5/7/90   gz   Pathname component case.;              Structured directories.;              Logical pathnames in pathname component accessors & make-pathname.;04/30/90 gb   hoist a few decls, string-char -> base-character.;04/23/90 bill add "ccl;library:" to *module-search-path*;04/14/90 gz   %substr now takes start/end args.;04/02/90 gz   write-a-pathname -> print-object.;02/29/90 bill Add directory-exists-p;12/27/89  gz  Remove obsolete #-bccl conditionals. Init *logical-pathname-alist*;              here.  Obey *load-print* in LOAD.;12/21/89  gz  Implement cleanup issue PATHNAME-UNSPECIFIC-COMPONENT...;29-Nov-89 Mly in write-a-pathnaem: Don't use hairy format in l1.;              princ just writes namestring.;11/23/89 gz  define *logical-pathname-alist* here.;12-Nov-89 Mly *write-istruct-alist*;10/30/89 bill Rename pr-%print-pathname to write-a-pathname and add stream arg.;09/27/89 gb simple-string -> ensure-simple-string.#| 09/25/89 bill Add modeline - Add one-level cache to %path-from-iopb. This speeds               up directory by over an order of magnitude.;07/01/89 bill in delete-file (case .. (nil ..) ..) => (case .. ((nil) ..) ..);04/07/89 gb  $sp8 -> $sp. 04/01/89 gz New defpascal syntax. 3/22/89  gz Added %fasload, %faslopen. 7-apr-89 as %str-cat takes rest arg 02/26/89 gz fix in %path-std-quotes 02/23/89 gb File creator = CCL2; Time to define *default-file-creator*. 01/05/89 gz Don't pass 0-length strings to traps. 01/03/89 gz Moved #P to l1-readloop. 12/28/88 gz Use istruct-typep.  Lapify bottlenecks. streamp back to l1-streams.             Added stream-pathname.  full-namestring -> full-pathname.             Terminate loop on $dirnfErr in %path-from-iopb. 12/21/88 gz  Added %open-res-file... 11/3/88  jaj put in support for button-string in choose-**-dialog 10/18/88 gz Don't allow nil as namestring.  9/20/88 gb Ignore 0-length ioFileName in %path-GetDirInfo.  8/31/88 gz Standardize logical name expansions in %expand-logical-names,             since *logical-pathname-alist* is user-mungable.             Didn't need mac-directory-namestring-p after all...  8/30/88 gz New regime.  Also moved *file-stream* stuff to l1-streams,             wildcard stuff and less-used file fns to lib.  8/20/88 gz	added fasls; to *module-search-path*.  Declarations.                flushed %open. Don't call page-type to check structure types.  8/14/88 gb   $iofversnum-> $iofiletype. $iomisc -> $ionewname.  8/3/88  gz	include is not exactly the same as load...  7/27/88 gz	added string matching fns from level-2.  6/27/88  gb  Don't say the mpf word.  6/24/88 as  added dummy def of file-locked-p for the sake of buffer-write-file  6/23/88 jaj file-length works with weird byte sizes  6/22/88 jaj overwrite-dialog returns multiple-values (and thereby so does copy-file)              fix to file-namestring for version, merge-pathnames takes :newest              stream-eofp works for weird byte sizes              really bind *loading-file-source-file* for fasls in load  6/21/88 jaj use catch/throw-cancel macros  6/6/88  jaj include and %include are synonyms for load  5/31/88 as  ::cancel -> :cancel              (throw :cancel nil) -> (throw :cancel :cancel)  5/26/88 as  yet another get-string-from-user syntax  5/20/88 as  new get-string-from-user calling sequence  5/20/88 jaj fns dealing with time use mac-to-universal-time and              universal-to-mac-time.  copy-file returns values in              correct order. mac-directory-p works with complex strings  5/12/88 jaj  for delete-file :error-if-no-exist defaults to nil  2/26/88 jaj  library-entry-points -> library-entry-names in load  3/30/88  gz  New macptr scheme.  Flush pre-1.0 edit history.  3/1/88   gz  Eliminate compiler warnings.  2/8/88  jaj  enlarged pb for %mac-default-directory 12/22/87 gz   Franz foreign function hooks in LOAD.  12/15/87 cfry from patch of Jaj's to fix the format ~T bug:          mods to (exist *file-stream*) (stream-column *file-stream*)                   (stream-tyo *file-stream*) file-position 10/23/87 jaj  changed %mac-filename, %mac-directory to %uvrefs 10/22/87 jaj  moved with-file-or-dir out of eval-when 10/15/87 jaj  added stream-column for *file-stream* 10/13/87 cfry added INCREMENT-PATHNAME-VERSION & RENAME-FOR-OPEN           extended rename-file to work for directories.          %probe-file - fixed by Jaj. 10/12/87 cfry fixed copy-file to not create target file if source doesn't exist.          renamed *open-files* to *open-file-streams* casue that's what it is.          fixed (exist *file-streams*) to set the above global as it should have.          removed open-file-streams, an iv of *file-streams* not used now. removed the fn (defun FileStreams ()                           (ask *file-stream* open-file-streams))           which isn't called anywhere in CCL lisp files, and isn't documented.           10/11/87 jaj added internal to *module-search-path*  9/29/87 jaj moved %do-files-in-directory and do-files-in-directory here from              pathnames.lisp  9/29/87 as  find-load-file uses version without explicit type if it exists,              rather than always merging with .lisp and .fasl-----------------------------------Version 1.0---------------------------------|#(defconstant $afpAccessDenied -5000)(defconstant $paramErr -50)   ; put this with the rest when we find the rest(defconstant pathname-case-type '(member :common :local :studly))(defconstant pathname-arg-type '(or string pathname stream)); dunno if this is what we want to do(defmacro file-errchk (trap path)  `(let ((errno ,trap))     (unless (%izerop errno)       (signal-file-error errno ,path))))(defmacro signal-file-error (err-num &optional pathname &rest args)  `(%err-disp (logior (ash 2 16) (the fixnum (logand #xffff (the fixnum ,err-num))))              ,@(if pathname (list pathname))              ,@(if args args)))(defvar %logical-host-translations% '())(defvar *load-pathname* nil)(defvar *load-truename* nil)(defun %open-res-file (name &optional errorp &aux refnum)  (with-pstr (np (mac-namestring (truename name)))    (when (%izerop (%get-byte np)) (signal-file-error $err-no-file name))    (setq refnum (#_OpenResFile np))    (when (eq refnum -1)      (#_CreateResFile np)      (if errorp (reserrchk))      (setq refnum (#_OpenResFile np))))  (and (neq refnum -1) refnum))(defparameter *default-pathname-defaults* (%cons-pathname nil nil nil));Right now, the only way it's used is that an explicit ";" expands into it.;Used to merge with it before going to ROM.  Might be worth to bring that back,;it doesn't hurt anything if you don't set it.;(defparameter *working-directory* (%cons-pathname nil nil nil));These come in useful...  We should use them consistently and then document them,;thereby earning the eternal gratitude of any users who find themselves with a;ton of "foo.CL" files...(defparameter *.fasl-pathname* (%cons-pathname nil nil #-ppc-target "fasl" #+ppc-target "pfsl"))(defparameter *.lisp-pathname* (%cons-pathname nil nil "lisp"));;The following should be added to l1-files.lisp from Kalman(defun %file-size (offset path)  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (when (logbitp 4 (the fixnum (%get-byte pb $ioflAttrib)))      (error "~s is a directory" path))    (%get-long pb offset)))(defun file-resource-size (path) (%file-size $ioflRlglen path))(defun file-data-size (path) (%file-size $iofllglen path))(defun file-allocated-resource-size (path) (%file-size $ioflRpylen path))(defun file-allocated-data-size (path) (%file-size $ioflpylen path))(defun file-info (path)  "returns create-date, modify-date, resource length, data length, allocated resource length, allocated data length"  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (when (logbitp 4 (the fixnum (%get-byte pb $ioflAttrib)))      (error "~s is a directory" path))    (values (mac-to-universal-time (%get-word pb $ioFlCrDat)(%get-word pb (%i+ 2 $ioFlCrDat)))            (mac-to-universal-time (%get-word pb $ioFlMdDat)(%get-word pb (%i+ 2 $ioFlMdDat)))            (%get-long pb $ioflRlglen)            (%get-long pb $iofllglen)            (%get-long pb $ioflRpylen)            (%get-long pb $ioflpylen))))(defun overwrite-dialog (filename &optional (prompt "Create…"))  (while (y-or-n-dialog (%str-cat "File \"" (princ-to-string filename) "\" already exists.Replace it or choose a new name?" )                        :yes-text "New..."                        :no-text "Replace")    (catch-cancel      (return-from overwrite-dialog        (choose-new-file-dialog :directory filename :prompt prompt))))  filename)(defun if-exists (if-exists filename &optional (prompt "Create…"))  (case if-exists    (:error (signal-file-error $xfileexists filename))    ((:dialog :new-version :rename) (overwrite-dialog filename prompt))    ((nil) nil)    ((:ignored :overwrite :append :supersede :rename-and-delete) filename)    (t (report-bad-arg if-exists '(member :error :dialog nil :ignored :overwrite :append :supersede :rename-and-delete)))))(defun if-does-not-exist (if-does-not-exist filename)  (case if-does-not-exist     (:error (signal-file-error $err-no-file filename)) ; (%err-disp $err-no-file filename))    (:create filename)    ((nil) (return-from if-does-not-exist nil))    (t (report-bad-arg if-does-not-exist '(member :error :create nil)))));Like (or (probe-file path) error) except that does directories as directories:; (probe-file "hd:ccl:") -> nil - not so - probe-file now does directories; (truename "hd:ccl:") -> #P"hd:ccl:"#|(defun truename (path)  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (if (directory-pathname-p path)      (%put-ptr pb (%null-ptr) $ioFileName)      (progn        (%put-word pb 0 $ioFDirIndex)        (file-errchk (#_PBGetCatInfoSync  pb) path)        (%put-long pb (%get-long pb $ioFlParID) $ioDirID)))    (%path-from-iopb pb)))|#(defun truename (path)  (or (probe-file path) ; probe-file gets aliases right       (signal-file-error $err-no-file path)))(defun probe-file (path &aux (dirp (directory-pathname-p path)))  (%stack-iopb (pb np)    (multiple-value-bind (errno aliasp) (%path-to-iopb path pb)      (when (%izerop errno)        (let ((dir-result (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))))          ;(print-pb pb)          (when (or (eq dir-result dirp)                    (and dir-result aliasp))            (if dir-result               (%dir-path-from-iopb pb)              (%path-from-iopb pb))))))));Should have an option to create all directories in the path, it's not that;hard... (could call it :if-does-not-exist, except then couldn't pass it through;from open...); this is iffy re aliases(defun create-file (path &key (if-exists :error)                              (mac-file-type "TEXT")                              (mac-file-creator (application-file-creator *application*))                              &aux errno (full-path (full-pathname path :no-error nil)))  (when (directory-pathname-p path)    (return-from create-file (create-directory path :if-exists if-exists)))  (%stack-iopb (pb np)    (setq errno (%path-to-iopb full-path pb nil nil T)) ; tell it not to check file    (when (not (zerop errno))      (cond ((or (eq errno $dirnferr)(eq errno $fnferr)                 (eq errno $paramerr))  ; dir not found             ;  some fs's may not distinguish dirnf from fnf             (create-directory (directory-namestring full-path))             (%path-to-iopb full-path pb :errchk nil T))))    (setq errno (#_PBHCreateSync pb ))    (when (eq errno $dupFNErr)      (let ((newpath (if-exists if-exists (%path-from-iopb pb) "Create…")))        (or newpath            (return-from create-file nil))        (when (not (equalp full-path (full-pathname newpath :no-error nil)))          (return-from create-file (create-file newpath :if-exists :supersede                                                :mac-file-type mac-file-type                                                :mac-file-creator mac-file-creator))))      (setq errno (#_PBHDeleteSync pb))      (when (%izerop errno)(setq errno (#_PBHCreateSync pb))))    (unless (%izerop errno) (signal-file-error errno path))    (%path-to-iopb path pb :errchk)    (%put-ostype pb mac-file-type $fdType)    (%put-ostype pb mac-file-creator $fdCreator)    (file-errchk (#_PBHSetFInfoSync pb) path)    (%path-from-iopb pb)))(defun exchange-files (old new &optional (errchk t) &aux errno)  (%stack-iopb (opb onp)    (%stack-iopb (npb nnp)      (%path-to-iopb old opb :errchk)      (%path-to-iopb new npb :errchk)      (when (not (eql (%get-word opb $iovrefnum)(%get-word npb $iovrefnum)))        (signal-file-error $xnotsamevol old new))      (%put-ptr opb (%get-ptr npb $iofilename) $iodestnameptr)  ;=28      (%put-long opb (%get-long npb $iodirid) $iodestdirid)   ; =36      (setq errno (#_PBExchangeFilesSync opb))      (if (and errchk (not (%izerop errno)))        (signal-file-error errno old)        (progn          (when (eql 0 errno)            ; swap type & creator            (%stack-iopb (old-pb old-np)              (%stack-iopb (new-pb new-np)                (%path-to-iopb old old-pb :errchk)                (%path-to-iopb new new-pb :errchk)                (rlet ((old-type :long (%get-long old-pb $fdType))                       (old-creator :long (%get-long old-pb $fdCreator))                       (new-type :long (%get-long new-pb $fdType))                       (new-creator :long (%get-long new-pb $fdCreator))                       (old-date :long (%get-long old-pb $ioFlCrDat))                       (new-date :long (%get-long new-pb $ioFlCrDat)))                  ; #_PBHGetFinfo clobbers some of the path info                  (%path-to-iopb old old-pb :errchk)                  (%path-to-iopb new new-pb :errchk)                  (setf (%get-long old-pb $fdType) (%get-long new-type)                        (%get-long old-pb $fdCreator) (%get-long new-creator)                        (%get-long old-pb $ioFlCrDat) (%get-long new-date)                        (%get-long new-pb $fdType) (%get-long old-type)                        (%get-long new-pb $fdCreator) (%get-long old-creator)                        (%get-long new-pb $ioFlCrDat) (%get-long old-date)))                (file-errchk (#_PBHSetFinfoSync old-pb) old)                (file-errchk (#_PBHSetFinfoSync new-pb) new))))          errno)))))  ; old or new or both?      ; what does this mean regarding aliases - hmm maybe it means the alias,; or maybe it means both - I chose the alias cause deleting the file; before the alias makes the alias useless which would mean that the; alias should be deleted too. But one might want to delete an alias; without deleting the target. Besides, the target might not be deleteable;  -maybe an optional arg?(defun delete-file (path &key (if-does-not-exist nil) &aux errno)  (%stack-iopb (pb np)    (when (directory-pathname-p path)(setq path (dirpath-to-filepath path)))    ; is this the right thing to do?    (%path-to-iopb path pb :errchk :no-alias t)    (setq errno (#_PBHDeleteSync pb))    (when (eq errno $fnfErr)      (case if-does-not-exist        (:error (signal-file-error $err-no-file path))        ((nil) (return-from delete-file nil))        (t (report-bad-arg if-does-not-exist '(member :error nil)))))    (unless (%izerop errno) (signal-file-error errno path))    path))(defun mac-default-directory ()  (%stack-iopb (pb np)    (#_PBHGetVolSync :errchk pb)    (%dir-path-from-iopb pb)));The filename components are allowed to be present and will be ignored.;That's a feature, not a bug.  Hope this doesn't show up in a Franz test suite.(defun set-mac-default-directory (path)  (%stack-iopb (pb np)    (%path-GetDirInfo path pb :errchk)    (%put-ptr pb (%null-ptr) $ioFileName)    (#_PBHSetVolSync :errchk pb)    (#_PBHGetVolSync :errchk pb)    (%dir-path-from-iopb pb)))(defun mac-file-type (path) (%mac-file-type-or-creator $fdType path))(defun mac-file-creator (path) (%mac-file-type-or-creator $fdCreator path))(defun %mac-file-type-or-creator (offset path)  (when (directory-pathname-p path) (signal-file-error $err-no-file path))  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (%get-ostype pb offset)));Now if I was compiling this, I'd just lea arg_x and jump right in...(defun set-mac-file-type (path mac-file-type)  (%set-mac-file-type-or-creator $fdType path mac-file-type))(defun set-mac-file-creator (path mac-file-creator)  (%set-mac-file-type-or-creator $fdCreator path mac-file-creator))(defun %set-mac-file-type-or-creator (offset path ostype)  (when (directory-pathname-p path) (signal-file-error $err-no-file path))  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (%put-ostype pb ostype offset)    (file-errchk (#_PBHSetFInfoSync pb) path)    (%get-ostype pb offset)))(defun file-locked-p (path)  (when (directory-pathname-p path) (signal-file-error $err-no-file path)) ; not really  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (%ilogbitp 0 (%get-byte pb $ioFlAttrib))))(defun file-author (path)  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk))  "")(defun file-create-date (path) (%file-date $ioFlCrDat path))(defun file-write-date (path) (%file-date $ioFlMdDat path))(defun mac-file-write-date (path) (%mac-file-date $ioFlMdDat path))(defun mac-file-create-date (path) (%mac-file-date $ioFlCrDat path))(defun %mac-file-date (offset path &optional errchk)  (%stack-iopb (pb np)    (if (zerop (%path-to-iopb path pb errchk))      (%get-unsigned-long pb offset))))(defun %file-date (offset path &optional errchk)  (%stack-iopb (pb np)    (if (zerop (%path-to-iopb path pb errchk))      (mac-to-universal-time (%get-word pb offset)                             (%get-word pb (%i+ 2 offset))))))(defun set-file-create-date (path time) (%set-file-date $ioFlCrDat path time))(defun set-file-write-date (path time) (%set-file-date $ioFlMdDat path time))(defun set-mac-file-create-date (path time) (%set-file-date $ioFlCrDat path time t))(defun set-mac-file-write-date (path time) (%set-file-date $ioFlMdDat path time t))(defun %set-file-date (offset path time &optional mac-p)  (let ((dirp (directory-pathname-p path)))    (%stack-iopb (pb np)      (%path-to-iopb path pb :errchk)      (%put-full-long pb (if mac-p time (universal-to-mac-time time)) offset)      (%put-word pb (if dirp -1 0) $ioFDirIndex)      ; why below is necessary (given above) is also a mystery      (when dirp (%put-byte np 0 0))      (file-errchk (#_PBSetCatInfoSync pb) path))    time));-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_(defun directory-exists-p (path)  (%stack-iopb (pb np)    (eql 0 (%path-getDirInfo path pb))))(defloadvar *last-choose-file-directory* nil);New functions!  Maybe if we document these, people will be less confused...(defun choose-file-default-directory ()  (or (let ((dir *last-choose-file-directory*))        (and dir (probe-file dir) dir))      (let ((dir (full-pathname "home:")))        (and dir (probe-file dir) (directory-namestring dir)))      (directory-namestring (mac-default-directory))))(defvar *custom-getfile-present* nil)(def-ccl-pointers *custom-getfile-present* ()  (setq *custom-getfile-present* (gestalt #$gestaltStandardFileAttr #$gestaltStandardFile58)))(defun error-not-available (what)  (error "~A is not available with your System Software version" what))(defun load-alternate (module fn args)  ;(error-not-available 'choose-file-dialog)  (let ((*warn-if-redefine* nil)        (*warn-if-redefine-kernel* nil))    (require module))  (apply fn args))(defvar *ddir-vrefnum* 0)(defvar *ddir-dirid*   0)(defvar *ddir-name*    nil)(defun set-choose-dir-from-pb (pb)  (let ((pathname (%dir-path-from-iopb pb)))    (setq *last-choose-file-directory* (directory-namestring pathname))    pathname))(defun set-choose-file-default-directory (path &optional no-error)  (unless (and no-error               (not (directory-exists-p path)))    (%stack-iopb (pb np)      (%path-GetDirInfo path pb :errchk)      (setq *ddir-vrefnum* (%get-signed-word pb $ioVRefNum)            *ddir-dirid*   (%get-signed-long pb $ioDirID)            *ddir-name*    (mac-file-namestring path))  ; <<      (#_LMSetSFSaveDisk (- *ddir-vrefnum*))      (#_LMSetCurDirStore *ddir-dirid*)       (set-choose-dir-from-pb pb))))#| ; moved to old/new(defun choose-file-ddir ()  (%stack-block ((pb $ioPBSize))    (%put-word pb *ddir-vrefnum* $ioVRefNum)    (%put-long pb *ddir-dirid*   $ioDirID)    (set-choose-dir-from-pb pb)))|#; choose-file-dialog; choose-new-file-dialog; choose-directory-dialog(%include "ccl:library;old-file-dialogs.lisp")(defun %path-from-params (vrefnum dirid nameptr)  (%stack-block ((pb $ioPBSize))    (%put-ptr  pb nameptr $ioFileName)    (unless (and (eql dirid #$fsRtParID)                 (%null-ptr-p nameptr)                 (eql 0 (#_FindFolder vrefnum #$kDesktopFolderType nil                         (%inc-ptr pb $ioVRefnum)                         (%inc-ptr pb $ioDirID))))      (%put-word pb vrefnum $ioVRefNum)      (%put-long pb dirid   $ioDirID))    (%path-from-iopb pb)))(defun choose-new-directory-dialog (&key directory                                         (prompt "New Directory Name...")                                         (button-string "Save"))  (let ((file (choose-new-file-dialog :directory directory                                      :prompt prompt                                      :button-string button-string)))    (make-pathname :directory (namestring file))));-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_;; Cache values for %path-from-iopb(defvar %saved-ioVRefnum% nil)(defvar %saved-ioDirID% nil)(defvar %saved-directory-path% nil);Get a pathname from $ioFileName, $ioVRefnum and $ioDirID fields of a pb.;if ioFileName is null, returns a pathname with name and type null.;Otherwise returns a fully qualified pathname (no null components).;This is the basic File Manager -> Pathnames function.; note that the quoting of dot and * here is not the same as in fs-cons-pathname; fs-cons-pathname is more sensible re dots, and this guy quotes * which is correct.(defun %path-from-iopb (pb &optional use-cache-p &aux dir name type)  (unless (%null-ptr-p (%get-ptr pb $ioFileName))    (with-macptrs ((np (%get-ptr pb $ioFileName)))      (let* ((str (%get-string np)))        (multiple-value-setq (name type)          (%std-name-and-type str)))))  (when (and (eq type :unspecific)(string= name ""))    (setq name (setq type nil))) ; << patch ??  (let ((ioVRefNum (%get-word pb $ioVRefNum))        (ioDirID (%get-long pb $ioDirID)))    (if (and use-cache-p             (eq %saved-ioVRefNum% ioVRefNum)             (eql %saved-ioDirID% ioDirID))      (setq dir %saved-directory-path%)      (%stack-block ((dpb $ioHFQElSiz) (np 258))        (let (errno)          (%put-ptr dpb np $ioFileName)          (%put-word dpb -1 $ioFDirIndex)          (%put-word dpb ioVRefNum $ioVRefNum)          (%put-long dpb ioDirID $ioDirID)          (setq dir '())          (loop            (setq errno (#_PBGetCatInfoSync dpb))            (if (not (%izerop errno)) (return))            (let ((dirid (%get-long dpb $ioDrParID)))              (push (%path-std-quotes (%get-string np) nil ";*") dir)              (%put-long dpb dirid $ioDirID)              (when  (eql  #$fsrtparid dirid)                (setq errno $fnferr)(return))))          (setq dir (cons ':absolute dir))          (unless (and (or (eq errno $fnfErr) (eq errno $dirnfErr))                       (not (null dir)))   ;must have won at least once.            (signal-file-error errno (%cons-pathname dir name type))))        (setq %saved-directory-path% dir              %saved-ioVRefNum% ioVRefNum              %saved-ioDirID% ioDirID))))  (%cons-pathname dir name type))#|; only caller is %path-from-iopb(defun %std-name-from-ptr (ptr start len)  (with-macptrs ((pp (%inc-ptr ptr start)))    (%path-std-quotes (%str-from-ptr pp len) nil ".:;*")))(defun %std-name-and-type (str &optional (start 0))  (let ((lastpos start)        (len (length str))        dotpos)    (setq lastpos (%path-mem-last ":" str))    (setq lastpos (if lastpos (1+ lastpos) start))    (setq dotpos (%path-mem-last "." str lastpos))    (values (%path-std-quotes (if (or dotpos (neq lastpos 0))                                (%substr str lastpos (or dotpos len))                                str)                              nil ".:;*")            (if dotpos               (%path-std-quotes (%substr str (1+ dotpos) len) nil ".:;*")              :unspecific))))|#(defun %std-name-and-type (str &optional (start 0))  (let ((lastpos start)        (len (length str))        dotpos)    (setq lastpos (%path-mem-last ":" str))    (setq lastpos (if lastpos (1+ lastpos) start))    (setq dotpos (%path-mem-last "." str lastpos))    (values (%path-std-quotes (if (or dotpos (neq lastpos 0))                                (%substr str lastpos (or dotpos len))                                str)                              nil ".:;*")            (if dotpos               (%path-std-quotes (%substr str (1+ dotpos) len) nil ".:;*")              :unspecific))))(defun %dir-path-from-iopb (pb &optional use-cache-p &aux path)  (with-macptrs ((np (%get-ptr pb $ioFileName)))    (%put-ptr pb (%null-ptr) $ioFileName)    (setq path (%path-from-iopb pb use-cache-p))    (%put-ptr pb np $ioFileName)    path))(when (not (fboundp 'merge-pathnames))  (defun translate-logical-pathname (path) (pathname path)) ;redefined later  (defun merge-pathnames (path) path)   ; ditto   );Store pathname in $ioVRefNum, $ioDirID and $ioFileName fields of pb (and;other _GetCatInfo/_HGetVInfo info for the directory in other fields).;pb must be at least $ioPBSize bytes, $ioFileName at least 256.; This guys job now is to getcatinfo for the whole path obeying errchk; unless no-file-info (used by create-xxx).; dont-resolve can only apply to a file target - not intermediate dirs; and not to alias in final position of dir (used by delete-file)(defun %path-to-iopb (path pb &optional errchk dont-resolve no-file-info &aux (errno 0) len aliasp)  (let* ((path (translate-logical-pathname (merge-pathnames path)))         (dir (mac-directory-namestring-1 path))          nam          (dirp (directory-pathname-p path)))    (block nil            (setq nam (mac-file-namestring-1 path))      (setq len (length nam))      (multiple-value-setq (errno aliasp)         (%path-GetDirInfo dir pb errchk t))      (unless (%izerop errno) (return))      (when (or (%i> len 255)                (and (%izerop len)(not dirp)))        (setq errno $bdnamerr)        (return))      (with-macptrs ((np (%get-ptr pb $ioFileName)))        (%put-string np nam))      (when (and (not dirp) (not no-file-info))        (let ((dirid (%get-long pb $iodirid)))          (%put-word pb 0 $ioFDirIndex) ; already put the name          (setq errno (#_PBGetCatInfoSync pb))          (%put-long pb dirid $iodirid)          (unless (zerop errno) (return))          (when (pb-alias-p pb)            (setq aliasp t)            (unless dont-resolve               (setq errno (pb-resolve-alias pb)))))))    (when errchk (unless (%izerop errno)(signal-file-error errno path)))    (values errno aliasp)))(defun alias-path-p (path &optional dont-resolve)  (let ()    (%stack-iopb (pb np)      (when (nth-value 1 (%path-to-iopb path pb :errchk dont-resolve))        (or dont-resolve (%path-from-iopb pb))))))(defun pb-resolve-alias (pb &aux (errno 0)                             (dirid (%get-long pb $iodirid))                            aliasp)  (block nil        (when (and *alias-manager-present* ; paranoia perhaps               (< (the fixnum (%get-signed-word pb $fdFlags)) 0))  ; isAlias      (setq aliasp t)      (%put-long pb dirid $iodirid)      (rlet ((fss :fsspec)             (junk1 :integer)             (junk2 :integer))        (%put-ptr pb fss 28) ; $ioMisc = 28        (setq errno (#_PBMakeFsspecSync  pb))        (when (not (%izerop errno))          ; try nuking the final colon (if any) from the name.          ; seems to be unnecessary on local volumes but          ; necessary on remote volumes          (let* ((np (%get-ptr pb $iofilename))                 (n (%get-byte np 0)))            ; unless of course its the second half of a 2 byte character            (when (eql (%get-byte np n) (char-code #\:))              (%put-byte np (1- n) 0)              (setq errno (#_PBMakeFsspecSync pb))              (when (not (%izerop errno))(return)))))        (setq errno (#_ResolveAliasFile fss 1 junk1 junk2))        (unless (%izerop errno) (return))        (setq dirid (rref fss fsspec.parid :storage :pointer))        (%put-long pb dirid $iodirid)        (%put-word pb (rref fss fsspec.vrefnum :storage :pointer) $iovrefnum)        (with-macptrs ((np (%get-ptr pb $iofilename)))          (%put-string np  (%get-string fss 6))) ; fsspec.name                (%put-word pb 0 $iofdirindex)) ; heed name        (setq errno (#_PBGetCatInfoSync pb))                (when (not (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib)))          (%put-long pb dirid $iodirid)) ; << patch         ))  (values errno aliasp)); should this be a macro or just plug it in or what(defun pb-alias-p (pb)  (< (the fixnum (%get-signed-word pb $fdFlags)) 0))(defun findfolder (vrefnum ostype)  (%stack-iopb (pb name)    (let ((errno  (#_FindFolder vrefnum ostype nil                   (%inc-ptr pb $ioVRefNum)                   (%inc-ptr pb $ioDirId))))      (when (zerop errno)        (%path-from-iopb pb)))));Like _GetCatInfo, but also sets $iovrefnum (and $ioVSigWord).; pb must be at least $ioPBSize bytes, and $ioFileName at least 256.; dirflg means path is already mac-namestring'ed(defun %path-GetDirInfo (path pb &optional errchk dirflg dont-recurse                              &aux errno aliasp)  (flet ((maybe-alias-volume (dir pb errchk) ; is this right?           (let ((desktop (findfolder -1 "desk"))                 (result))             (when (%izerop (%path-getdirinfo                              (setq result (%str-cat (directory-namestring desktop) dir))                             pb errchk t t))               result))))    (prog ((dir (if dirflg path (mac-directory-namestring path)))            vol sig drv dref sid dirlen)      (when (%i> (setq dirlen (length dir)) 255)        (return (setq errno (%path-get-long-dir-info path pb))))      (when (%izerop dirlen) (setq dir ":"))      (%put-word pb -1 $ioVolIndex)      (%put-word pb 0 $ioVRefNum)      (with-macptrs ((np (%get-ptr pb $ioFileName)))        (%put-string np dir))      (setq errno (#_PBHGetVInfoSync pb))      (cond ((and (not dont-recurse) (eq errno $nsverr))             (when (maybe-alias-volume dir pb errchk)               (setq errno 0)               (setq aliasp t))             (return))            ((not (%izerop errno))(return)))      (setq vol (%get-word pb $ioVRefNum)            sig (%get-word pb $ioVSigWord)   ; these fields happen to be unused            drv (%get-word pb $ioVDrvInfo)   ; by _GetCatInfo for dirs, so            dref (%get-word pb $ioVDRefNum)  ; what the hell, might as well            sid (%get-word pb $ioVFSID))      ; keep them around...      (with-macptrs ((np (%get-ptr pb $ioFileName)))        (%put-string np dir))      (%put-word pb 0 $ioFDirIndex)      (%put-word pb 0 $ioVRefNum)      (%put-long pb 0 $ioDirID)      (setq errno (#_PBGetCatInfoSync pb))      ; if check dont recurse then "samson alias:alice:" fails      ; if dont chect then "non-existent:" loops forever       (cond ((and (or (not dont-recurse)(neq dont-recurse :mid)) ; << patch                  (or (eq errno $fnferr)(eq errno $dirnferr)))             ; possible alias in the middle                        (when (mid-path-aliases dir pb)(setq aliasp t) (setq errno 0)))            ; maybe alias at the end of dir path            (t (when (pb-alias-p pb)                   (setq aliasp t)                   (setq errno (pb-resolve-alias pb))                   (when (or (eq errno $fnferr)(eq errno $dirnferr))                     (when (unless (eql dont-recurse :mid)(mid-path-aliases dir pb)) (setq aliasp t) (setq errno 0))                   ))))      (unless (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))        (return (setq errno $dirnfErr)))      (when (and aliasp (neq (%get-word pb $iovrefnum) vol))(return))      (%put-word pb vol $ioVRefNum)      (%put-word pb sig $ioVSigWord)      (%put-word pb drv $ioVDrvInfo)      (%put-word pb dref $ioVDRefNum)      (%put-word pb sid $ioVFSID)      (%put-byte pb 0 $ioFileType))       ; just in case...    (when errchk (unless (%izerop errno) (signal-file-error errno path)))    (values errno aliasp)))(defun %path-get-long-dir-info (path pb)  (declare (ignore pb))  (error "Path ~s is longer than 255 character limit" path)); the fact that we have to do this is revolting. At least it could; tell us there is an alias someplace so we dont do it needlessly.(defun mid-path-aliases (dir pb)  ; assume the volume isn't an alias because there seems to be no way to do that  ; s.b.if system 7 p  (let ((pos (%path-mem ":" dir)) part errno whole aliasp)    (when pos      (setq whole (%substr dir 0 (1+ pos)))      (setq dir (%substr dir (1+ pos) (length dir)))      (setq pos (%path-mem ":" dir 0))      (when (not pos) (return-from mid-path-aliases nil)) ; shouldn't happen      (loop         (setq part (%substr dir 0 (1+ pos)))        (setq dir (%substr dir (1+ pos) (length dir)))        (setq whole (%str-cat whole part))        (multiple-value-setq (errno aliasp)(%path-getdirinfo whole pb nil t :mid))        (when (not (%izerop errno))(return-from mid-path-aliases nil))        (when aliasp          (setq whole ; efficiency be hanged                 (mac-directory-namestring-1 (%path-from-iopb pb))))        (when (not (setq pos (%path-mem ":" dir 0)))(return)))      whole)));Name for passing to ROM.(defun mac-namestring (path)    (let ((path (translate-logical-pathname (merge-pathnames path))))    (%str-cat (mac-directory-namestring-1 path) (mac-file-namestring-1 path))))(defun mac-file-namestring (path)  (%path-mac-namestring    (file-namestring (translate-logical-pathname (merge-pathnames path)))))(defun mac-file-namestring-1 (path)  (%path-mac-namestring (file-namestring path))); I think someone else should be calling translate-logical-pathname?(defun mac-directory-namestring (path)  (%path-mac-namestring      (%directory-list-namestring        (pathname-directory (translate-logical-pathname (merge-pathnames path))))))(defun mac-directory-namestring-1 (path)  (%path-mac-namestring      (%directory-list-namestring (pathname-directory path))));Prepare name for passing to ROM.  Verify that no wildcards or quoted colons,;then remove all quoting.(defun %path-mac-namestring (name)  (when (%path-mem-last-quoted ":" name)    (signal-file-error $xbadfilenamechar name #\:))  (when (%path-mem-last "*" name)    (signal-file-error $xillwild name))  (%path-std-quotes name "" ""));;;;;;;;;;;;;;;;;;;;;;;;;;;  Pathnames ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;In case you were wondering, the fundamental functions now are pathname-xxxx,;(not the pathname function itself, the way it used to be).#-ppc-clos  ; there is no l0-pred file for 3.1(defun pathnamep (thing)    (old-lap-inline ()    (move.l arg_z atemp0)    (move.l nilreg acc)    (if# (and (eq (ttagp ($ $t_vector) atemp0 da))              (eq (vsubtypep ($ $v_istruct) atemp0 da))              (or (eq (cmp.l 'pathname (atemp0 $v_data)))                  (eq (cmp.l 'logical-pathname (atemp0 $v_data)))))      (add.l ($ $t_val) acc))))(defun logical-pathname-p (thing) (istruct-typep thing 'logical-pathname))(defun pathname-host (thing)  ; redefined later in this file  (declare (ignore thing))  :unspecific)(defun pathname-version (thing)  ; redefined later in this file  (declare (ignore thing))  :unspecific)(defmethod print-object ((pathname pathname) stream)  (let ((flags (if (logical-pathname-p pathname) 4                   (%i+ (if (eq (%pathname-type pathname) ':unspecific) 1 0)                        (if (equal (%pathname-name pathname) "") 2 0))))        (name (namestring pathname)))        (if (and (not *print-readably*) (not *print-escape*))      (write-string name stream)      (progn        (format stream (if (eql flags 0) "#P" "#~DP") flags)        (write-escaped-string name stream #\")))))#|(%fhave '%expand-logical-directory  ;redefined later        (qlfun %expand-logical-directory (file &optional flag)          (declare (ignore flag))          file))|#; I thought I wanted to call this from elsewhere but perhaps not(defun absolute-directory-list (dirlist)  ; just make relative absolute and remove ups where possible  (when (eq (car dirlist) :relative)    (let ((default (mac-default-directory)) default-dir)      (when default        (setq default-dir (%pathname-directory default))        (when default-dir          (setq dirlist (append default-dir (cdr dirlist)))))))  (when (memq :up dirlist)    (setq dirlist (copy-list dirlist))    (remove-up dirlist))  dirlist); ? is (:absolute "a" :up "b") = (:absolute "b") - seems reasonable; destructively mungs dir(defun remove-up (dir)  (let ((n 0)(sub (cdr dir))(last nil))    (loop      (cond ((eq (car sub) :up)             (cond ((or (eq n 0)(and (stringp last)(string= last "**")))                    (return (when (memq :up (cdr sub))                              (remove-up sub))))                   (t (rplacd (nthcdr (1- n) dir) (cdr sub))                      (setq n (- n 2))))))      (setq last (car sub) n (1+ n) sub (cdr sub))      (if (null sub)(return nil)))    dir))             (defun namestring (path)  (let ((host (pathname-host path)))    (setq host (if (and host (neq host :unspecific))(%str-cat host ":") ""))    (%str-cat host (directory-namestring path) (file-namestring path))))(defun host-namestring (path)  (let ((host (pathname-host path)))    (if (and host (neq host :unspecific)) host  "")))(defun directory-namestring (path)  (let* ((dirlist (pathname-directory path))         (host (pathname-host path))         ; what if its a logical-pathname whose host is explicitly :unspecific?? - beats me - shouldn't happen?         (result (%directory-list-namestring dirlist (or  host (logical-pathname-p path))))) ; << 7/96    (cond ((and (not host)   ; put in a quote if it is not logical but might appear to be                (consp dirlist)                 (eq (car dirlist) :absolute)                (stringp (cadr dirlist))                (null (cddr dirlist))                (%str-assoc  (cadr dirlist) %logical-host-translations%))           (let ((pos (%path-mem ":" result)))             (%str-cat (%substr result 0  pos) "∂"                        (%substr result pos (length result)))))          (t result))))                   ;This assumes that :'s and ;'s in components are escaped (otherwise would have to;pre-scan for escapes, yuck).(defun %directory-list-namestring (list &optional host)  (when (eq host :unspecific) (setq host nil))  (if (null list)    ""          (let ((len (if (eq (car list) :relative) 1 0))          (type 'base-character)          result)      (declare (fixnum len)(optimize (speed 3)(safety 0)))      (dolist (s (%cdr list))        (when (consp s)(setq s (cadr s)))        (case s          (:wild (setq len (+ len 2)))          (:wild-inferiors (setq len (+ len 3)))          (:up (setq len (+ len 1)))          (t (setq len (+ len 1 (length s)))             (when (extended-string-p s)(setq type 'extended-character)))))      (setq result (make-string len :element-type type))      (let ((i 0)            (sep (if host (char-code #\;)(char-code #\:))))        (declare (fixnum i))        (when (eq (%car list) :relative)          (setf (%scharcode result 0) sep)          (setq i 1))        (dolist (s (%cdr list))          (let ((sep sep))            (when (consp s)              (setq s (cadr s))              (setq sep (char-code #\;)))            (case s              (:wild (setq s "*"))              (:wild-inferiors (setq s "**"))              (:up (setq s nil)))            (when s              (let ((len (length s)))                (declare (fixnum len))                (move-string-bytes s result 0 i len)                (setq i (+ i len))))            (setf (%scharcode result i) sep)            (setq i (1+ i)))))      result)))    (defun file-namestring (path)  (let* ((name (pathname-name path))         (type (pathname-type path))         (version (pathname-version path)))    (case version      (:newest (setq version ".newest"))      (:wild (setq version ".*"))      ((nil :unspecific) (setq version nil))      (t (setq version (if (fixnump version)                         (%str-cat "." (%integer-to-string version))                         (%str-cat "." version)))))    (if (and type (neq type :unspecific))      (if (null name)        (%str-cat "." type (or version ""))        (%str-cat name "." type (or version "")))      (if version ; version no type        (if (null name)          (%str-cat "." version)          (%str-cat name "." version))        (or name ""))))); not used -  is CL(defun enough-namestring (path &optional (defaults *default-pathname-defaults*))  (if (null defaults)(namestring path)      (let* ((path (pathname path))             (dir (pathname-directory path))             (nam (pathname-name path))             (typ (pathname-type path))             (host (pathname-host path))             (default-dir (pathname-directory defaults))             (real-host host))        (when (equalp host (pathname-host defaults))          (setq host nil))        (setq host (if (and host (neq host :unspecific))                     (%str-cat host ":")                     ""))        (cond ((equalp dir default-dir)               (setq dir nil))              ((and dir default-dir                    (eq (car dir) :absolute)(eq (car default-dir) :absolute))               (let (res) ; maybe make it relative to defaults                 (do ((p1 (cdr dir) (cdr p1))                      (p2 (cdr default-dir) (cdr p2)))                     nil                    (cond ((null p1) (return nil))                         ((null p2)                          (when res                            (setq dir (cons :relative p1)))                          (return))                         ((not (equalp (car p1)(car p2)))                          (return nil))                         (t (setq res t)))))))        (when (equalp typ (pathname-type defaults))          (setq typ nil))        (when (and (null typ) (equalp nam (pathname-name defaults)))          (setq nam nil))        (when (and typ (neq typ :unspecific))          (setq nam (if (null nam) (%str-cat "." typ) (%str-cat nam "." typ))))        (cond (dir               ; what if its a logical-pathname whose host is explicitly :unspecific?? ok               (setq dir (%directory-list-namestring dir (or real-host (logical-pathname-p path)))) ; 7/96               (if nam (%str-cat host dir nam)(%str-cat  host dir)))              ((neq (length host) 0)               (if nam (%str-cat host ";" nam)(%str-cat host ";")))              (t (or nam ""))))))(defun cons-pathname (dir name type &optional host version)  (if (and host (neq host :unspecific))    (%cons-logical-pathname dir name type host version)    (%cons-pathname dir name type))); Question of the day - what is (pathname ":foo;"); is it host "" directory (:absolute (:logical "foo"))  (get this on 06/19/90); or is it host :unspecific directory (:relative (:logical "foo")) (get this on 06/20/90); note that (make-pathname :directory '(:relative (:logical "foo"))) is #P":foo;"(defun pathname (path)  (when (streamp path) (setq path (%path-from-stream path)))  (if (pathnamep path)    path    (multiple-value-bind (sstr start end) (get-sstring path)      (let (directory name type host version pos semi-pos)        (multiple-value-setq (host pos semi-pos)(pathname-host-sstr sstr start end))        (when pos (setq start pos))        (multiple-value-setq (directory pos)(pathname-directory-sstr sstr start end host))        (when directory (setq start pos))        (multiple-value-setq (version pos)(pathname-version-sstr sstr start end))        ; version is :unspecific :newest or "*" or 0        (when pos (setq end pos))        (multiple-value-setq (type pos)(pathname-type-sstr sstr start end))        ; type-sstr should return beginning of type field        (when pos (setq end pos))        ; now everything else is the name        (unless (eq start end)          (setq name (%std-name-component (%substr sstr start end))))        (if semi-pos ; << 7/96          ; the fact that we make a logical pathname is the ONLY clue that dir contained ;'s          (%cons-logical-pathname directory name type host version)          (cons-pathname directory                       name                       type                       host                       version))))))(defun %path-from-stream (stream)  (or (stream-filename stream) (error "Can't determine pathname of ~S ." stream)))      ; ???;Like (pathname stream) except returns NIL rather than error when there's no;filename associated with the stream.(defun stream-pathname (stream &aux (path (stream-filename stream)))  (when path (pathname path))); this is currently only called by set-logical-pathname-translations; in fact things would be simpler parse-namestring really did the parsing; and pathname called it instead of vice versa (defun parse-namestring (thing &optional host (defaults *default-pathname-defaults*)                               &key (start 0) end junk-allowed)  (declare (ignore junk-allowed))  (if (or (pathnamep thing) (streamp thing))    (setq end start)    (progn      (cond ((null host)  (setq host (pathname-host defaults)))            (t (verify-logical-host-name host)))      (when (null end) (setq end (length thing)))      (when (> start end) (error "~S ~S is more than ~S ~S" :start start :end end))      (unless (and (eq start 0) (eq end (length thing)))        (multiple-value-bind (sstr start end) (get-sstring thing start end)          (setq thing (%substr sstr start end))))      (when (and host (neq host :unspecific))        (let ((thing-host (pathname-host thing)))          (cond ((and thing-host (neq thing-host :unspecific))                 (when (not (string-equal host thing-host))                   (signal-type-error thing-host host "Host ~S does not match default host ~S")))                ; here require no colons in thing - obey junk-allowed  ?                (t (when (not (%path-mem ":" thing))                     ; it is not clear that we are obligated or even permitted to glom on the host                     ; so below is questionable                     (setq thing (%str-cat host ":" thing)))                   ))))))  (values (pathname thing) end))(defun make-pathname (&key (host nil host-p)                            device                           (directory nil directory-p)                           (name nil name-p)                           (type nil type-p)                           (version nil version-p)                           (defaults nil defaults-p) case                           &aux path default-dir)  (declare (ignore device))  (when case (setq case (require-type case pathname-case-type)))  (when (null host-p)    (setq host (if defaults-p defaults *default-pathname-defaults*))    (when (or  (stringp host)(pathnamep host))(setq host (pathname-host host))))  (if directory-p     (setq directory (%std-directory-component directory host)))  (if defaults    (setq default-dir (pathname-directory defaults)))  (cond ((null directory)(setq directory default-dir))        ((and default-dir (eq (car directory) ':relative))         (setq directory (append default-dir (cdr directory)))         (when (memq :up directory)(remove-up directory))))    (setq name        (if name-p             (%std-name-component name)             (and defaults (pathname-name defaults))))  (setq type        (if type-p             (%std-type-component type)             (and defaults (pathname-type defaults))))  (setq version (if version-p                  (%logical-version-component version)                  (and defaults (pathname-version defaults))))    (setq path        (if (or (eq host :unspecific)  ; 7/96                (and (not host-p)                     (or (null defaults) (physical-pathname-p (pathname defaults)))))          (%cons-pathname directory name type)          (%cons-logical-pathname directory name type host version)))  (when (and case (neq case :local))    (setf (%pathname-directory path) (%reverse-component-case (%pathname-directory path) case)          (%pathname-name path) (%reverse-component-case (%pathname-name path) case)          (%pathname-type path) (%reverse-component-case (%pathname-type path) case)))  path);  In portable CL, if the :directory argument to make pathname is a string, it should;  be the name of a top-level directory and should not contain any punctuation characters;  such as ":" or ";".  In MCL a string :directory argument with colons or semicolons;  will be parsed as a directory in the obvious way.(defun %std-directory-component (directory &optional host)  (cond ((null directory) nil)        ((eq directory :wild) '(:absolute :wild-inferiors)) ; or :wild-inferiors? - yes        ((stringp directory) (%directory-string-list directory 0 (length directory) host))        ((listp directory)         ;Standardize the directory list, taking care not to cons if nothing         ;needs to be changed.         (let ((names (%cdr directory)) (new-names ()))                      (do ((nn names (%cdr nn)))               ((null nn) (setq new-names (if new-names (nreverse new-names) names)))             (let* ((name (car nn))                    (new-name (cond ((consp name)(error "Shouldnt"))                                    (t (%std-directory-part name)))))               (unless (eq name new-name)                 (unless new-names                   (do ((new-nn names (%cdr new-nn)))                       ((eq new-nn nn))                     (push (%car new-nn) new-names))))               (when (or new-names (neq name new-name))                 (push new-name new-names))))           (if (memq :up (or new-names names))             (setq new-names (remove-up (or new-names (copy-list names)))))           (ecase (%car directory)             (:relative                             (cond (new-names         ; Just (:relative) is the same as NIL. - no it isnt                         (if (eq new-names names)                           directory                           (cons ':relative new-names)))                        (t directory)))             (:absolute                  (cond ((null new-names) directory)  ; But just (:absolute) IS the same as NIL                        ((eq (%car new-names) ':up)                         (report-bad-arg (%car new-names)'(not (member :up))))                        ((eq new-names names) directory)                        (t (cons ':absolute new-names)))))))        (t (report-bad-arg directory '(or string list (member :wild))))))(defun %std-directory-part (name)  (case name    ((:wild :wild-inferiors :up) name)    (:back :up)    (t (cond ((string= name "*") :wild)             ((string= name "**") :wild-inferiors)             (t (%path-std-quotes name ":;*" ":;")))))); this will allow creation of garbage pathname "foo:bar;bas:" do we care?(defun merge-pathnames (path &optional (defaults *default-pathname-defaults*)                                       default-version)  ;(declare (ignore default-version))  (when (not (pathnamep path))(setq path (pathname path)))  (when (not (pathnamep defaults))(setq defaults (pathname defaults)))  (let* ((path-dir (pathname-directory path))         (path-host (pathname-host path))         (path-name (pathname-name path))         (default-dir (and defaults (pathname-directory defaults)))         (default-host (and defaults (pathname-host defaults)))         ; take host from defaults iff path-dir is logical or absent - huh?          ; we used to turn "foo;bar" into (:absolute (:logical foo)) no mo         (host (cond ((or (null path-host)  ; added 7/96                          (and (memq path-host '(nil :unspecific))                               (or (null path-dir)                                   (null (cdr path-dir))                                   (consp (cadr path-dir)) ; not relevant now                                   (and (eq :relative (car path-dir))                                        (not (memq default-host '(nil :unspecific)))))))                                                default-host)                     (t  path-host)))         (dir (cond ((null path-dir) default-dir)                    ((null default-dir) path-dir)                    ((eq (car path-dir) ':relative)                     (let ((the-dir (append default-dir (%cdr path-dir))))                       (when (memq ':up the-dir)(remove-up the-dir))                       the-dir))                    (t path-dir)))         (nam (or path-name                  (and defaults (pathname-name defaults))))         (typ (or (pathname-type path)                  (and defaults (pathname-type defaults))))         (version (cond ((not path-name)(pathname-version defaults))                        (t (pathname-version path)))))    (when (and default-version (or (null version)(eq version :unspecific)))      (setq version default-version))    (if (and (pathnamep path)             (eq dir (%pathname-directory path))             (eq nam path-name)             (eq typ (%pathname-type path))             (eq host path-host)             (eq version (pathname-version path)))      path       (cons-pathname dir nam typ host version))))(defun directory-pathname-p (path)  (let ((name (pathname-name path))(type (pathname-type path)))    (and  (or (null name) (%izerop (length name)))          (or (null type) (eq type :unspecific)))))(defun pathname-version (path)  (when (streamp path) (setq path (%path-from-stream path)))  (typecase path    (logical-pathname (%logical-pathname-version path))    (pathname :unspecific)    (string     (multiple-value-bind (sstr start end) (get-sstring path)       (pathname-version-sstr sstr start end )))    (t (report-bad-arg path pathname-arg-type))));; 7/96 this gives inconsistent results ;; (pathname-version (pathname "foo.0")) is :unspecific;; but (pathname-version "foo.0") is nil;; was always that way and no one complained so leave it for now.;; there is not much hope of making sense of versions anyway(defun pathname-version-sstr (sstr start end)  (declare (fixnum start end))  (let ((pos (%path-mem-last ":;" sstr start end)))    (when pos (setq start (%i+ 1 pos)))    (setq pos (%path-mem "." sstr start end))    (when pos      (setq pos (%path-mem-last "." sstr (%i+ pos 1) end))      (when pos        (setq start (%i+ pos 1))        (if (= start end)          (values :unspecific end) ;(%i- end 1))  ; lonely dot          (let ((v (%substr sstr start end)))            (setq start (%i- start 1))      ; back up to exclude dot            (cond ((string=  v "*")                   (values v start))                  ((string-equal v "newest")                   (values :newest start))                  ((string= v "0")                   (values 0 start))                  (t (values :unspecific end)))))))));In CCL, a pathname is logical if and only if pathname-host is not :unspecific.(defun pathname-host (thing &key case)  (when (streamp thing)(setq thing (%path-from-stream thing)))  (when case (setq case (require-type case pathname-case-type)))  (let ((name         (typecase thing               (logical-pathname (%logical-pathname-host thing))           (pathname :unspecific)           (string (multiple-value-bind (sstr start end) (get-sstring thing)                      (pathname-host-sstr sstr start end)))           (t (report-bad-arg thing pathname-arg-type)))))    (if (and case (neq case :local))      (%reverse-component-case name case)      name))); thing is logical-host if it starts with foo: which is a defined logical host; and it contains no other unquoted colons; So if one has a disk with the same name as a defined logical host; either rename the disk or access it via (make-pathname :directory "foo" ); this week if string contains colons (and not defined host) then return host :unspecific; else host is nil(defun pathname-host-sstr (sstr start end &optional no-check)  (when (not (%path-one-quoted-p ":" sstr start end))    (let* ((pos (%path-mem ":;" sstr start end))           (pos-char (and pos (%schar sstr pos)))           (host            (when (and pos                        (neq pos start)   ; leading : doesnt specify a host                       (eql pos-char #\:) ; a colon                       (not (%path-mem ":" sstr (%i+ 1 pos) end))) ; the only colon              (%substr sstr start pos)))           (semi-pos (if (eq pos-char #\;)                       pos                       (%path-mem ";" sstr (or pos start) end)))) ; << 7/96      (cond ((and host (or no-check (%str-assoc host %logical-host-translations%)))             (values host (%i+ pos 1) semi-pos))            (host              ; there was exactly one non-leading colon and its not a defined host             (if semi-pos               (error "~S is not a defined logical host" host)               (values :unspecific nil nil)))  ; gaak            ((and pos                  (or (and (eql pos-char #\:)                           semi-pos)                      (and (eql pos-char #\;)                           (%path-mem ":" sstr (%i+ pos 1) end))))             (error "~S is not a valid namestring" sstr))                          (t (if (and (eq pos-char #\:)(null semi-pos))                 (values :unspecific nil nil)                 (values nil nil semi-pos)))))))  ; huh??(defun pathname-device (thing &key case)  (declare (ignore case thing))  ;(pathname thing)  :unspecific)(defun pathname-directory-sstr (sstr start end &optional host)  (let (pos (other-str (%path-unquote-one-quoted ":" sstr start end)))    (when other-str (setq sstr other-str))    (setq pos (%path-mem-last ":;" sstr start end))    (when pos      (setq pos (%i+ pos 1))      (values        (%directory-string-list sstr start pos host)       (if other-str (1+ pos) pos)))));A directory is either NIL or a (possibly wildcarded) string ending in ":" or ";";Quoted :'s are allowed at this stage, though will get an error when go to the;filesystem.(defun pathname-directory (path &key case)  (when (streamp path) (setq path (%path-from-stream path)))  (when case (setq case (require-type case pathname-case-type)))  (let ((names (typecase path                 (pathname (%pathname-directory path))                 (string                  (multiple-value-bind (sstr start end) (get-sstring path)                    (multiple-value-bind (host pos2)(pathname-host-sstr sstr start end)                      (pathname-directory-sstr sstr (or pos2 start) end host))))                 (t (report-bad-arg path pathname-arg-type)))))    (if (and case (neq case :local))      (%reverse-component-case names case)      names)))(defun %directory-string-list (sstr start &optional (end (length sstr)) host)  ;This must cons up a fresh list, %expand-logical-directory rplacd's it.  (when (eq host :unspecific)(setq host nil))  (labels ((std-part (sstr start end)             (%std-directory-part (if (and (eq start 0) (eq end (length sstr)))                                    sstr (%substr sstr start end))))           (split (sstr start end)             (unless (eql start end)               (if (memq (%schar sstr start) '(#\: #\;))                 (cons :up (split sstr (%i+ start 1) end))                 (let* ((pos (or (%path-mem ":;" sstr start end) end))                        (part (std-part sstr start pos)))                   (cons part                         (unless (eq end pos)                           (split sstr (%i+ pos 1) end))))))))    (unless (eq start end)      (let* ((pos (%path-mem ":;" sstr start end)))        (when (and pos  (< pos (1- end))) ;; << gaak          (let ((char (schar sstr pos)))            ; this never did anything sensible but did not signal an error            (if (or (and (eq char #\:)(%path-mem ";" sstr (1+ pos) end))                    (and (eq char #\;)(%path-mem ":" sstr (1+ pos) end)))              (error "Ilegal directory string ~s" sstr))))                      (cond ((null pos)               (list :absolute (std-part sstr start end)))              ((eq start pos)               (let ((rest (split sstr (%i+ pos 1) end)))                 (cons ':relative rest)))                            (t  (list* :absolute (std-part sstr start pos) (split sstr (%i+ pos 1) end))))))));Namestring name/type parsing:;  "a.b" ->	name = "a", type = "b";  "a"   ->	name = "a", type = nil;  "a."  ->	name = "a", type = :unspecific;  ".b"  ->	name = nil, type = "b";  "."   ->	name = nil, type = :unspecific;  ""    ->	name = nil, type = nil;A name is either NIL or a (possibly wildcarded, possibly empty) string.;Quoted :'s are allowed at this stage, though will get an error if go to the;filesystem.(defun pathname-name (path &key case)  (when (streamp path) (setq path (%path-from-stream path)))  (when case (setq case (require-type case pathname-case-type)))  (let ((name (typecase path                (pathname (%pathname-name path))                (string                 (multiple-value-bind (sstr start end) (get-sstring path)                   (let ((pos  (%path-mem-last ":;" sstr start end)))                     (when pos (setq start (%i+ pos 1))))                   (let ((newend (nth-value 1 (pathname-version-sstr sstr start end))))                     (when newend (setq end newend))                     (setq end (or (nth-value 1 (pathname-type-sstr sstr start end)) end))                                          (unless (eq start end)                       (%std-name-component (%substr sstr start end))))))                (t (report-bad-arg path pathname-arg-type)))))    (if (and case (neq case :local))      (%reverse-component-case name case)      name)))(defun %std-name-component (name)  (cond ((null name) nil)        ((eq name :wild) "*")        (t (%path-std-quotes name ".:;*" ".:;"))));A type is either NIL or a (possibly wildcarded, possibly empty) string.;Quoted :'s are allowed at this stage, though will get an error if go to the;filesystem.(defun pathname-type (path &key case)  (when (streamp path) (setq path (%path-from-stream path)))  (when case (setq case (require-type case pathname-case-type)))  (let ((name (typecase path                (pathname (%pathname-type path))                (string                 (multiple-value-bind (sstr start end) (get-sstring path)                   (let ((vpos (nth-value 1 (pathname-version-sstr sstr start end))))                     (when vpos (setq end vpos)))                   (pathname-type-sstr sstr start end)))                (t (report-bad-arg path pathname-arg-type)))))    (if (and case (neq case :local))      (%reverse-component-case name case)      name))); assumes version if any has been stripped away (i.e. is past end)(defun pathname-type-sstr (sstr start end)  (let ((pos (%path-mem-last ":;" sstr start end)))    (if pos (setq start (%i+ 1 pos)))        (setq pos (%path-mem-last "." sstr start end))    (when pos      (cond ((= (%i+ 1 pos) end)  ; a lonely dot - or is it unspecific if no dot?             (values "" (%i- end 1)))            (t (setq start (%i+ 1 pos))               (values (%std-type-component (%substr sstr start end))                       (%i- start 1)))))))(defun %std-type-component (type)  (cond ((or (null type) (eq type :unspecific)) type)        ((eq type :wild) "*")        (t (%path-std-quotes type ".:;*" ".:;"))))#|(defun %expand-logical-directory (directory &optional no-error)    (let ((cadr (%cadr directory)))      (if (and (eq (%car directory) ':absolute) cadr (listp cadr))        (let* ((name (%cadr cadr))               (sub (assoc name *logical-directory-alist* :test #'string-equal)))          (unless sub            (if no-error              (return-from %expand-logical-directory nil)              (error "Undefined logical directory name ~S in ~S" name directory)))          (multiple-value-bind (sstr start end) (get-sstring (%cdr sub))            (let* ((sub-dir (%expand-logical-directory                             (%directory-string-list sstr start end) no-error))         ; guaranteed freshly consed                   (cddr (%cddr directory)))              (if sub-dir                (nconc sub-dir cddr)                (if cddr                  (cons ':relative cddr))))))        directory)))|#(defun %reverse-component-case (name case)  (cond ((not (stringp name))         (if (listp name)           (mapcar #'(lambda (name) (%reverse-component-case name case))  name)           name))        ((eq case :studly) (string-studlify name))        (t ; like %read-idiocy but non-destructive - need it be?         (let ((which nil)               (len (length name)))           (dotimes (i len)             (let ((c (%schar name i)))               (if (alpha-char-p c)                 (if (upper-case-p c)                   (progn                     (when (eq which :lower)(return-from %reverse-component-case name))                     (setq which :upper))                   (progn                     (when (eq which :upper)(return-from %reverse-component-case name))                     (setq which :lower))))))           (case which             (:lower (string-upcase name))             (:upper (string-downcase name))             (t name))))));;;;;;; String-with-quotes utilities(defun %path-mem-last-quoted (chars sstr &optional (start 0) (end (length sstr)))  (while (%i< start end)    (when (and (%%str-member (%schar sstr (setq end (%i- end 1))) chars)               (%path-quoted-p sstr end start))      (return-from %path-mem-last-quoted end))))(defun %path-mem-last (chars sstr &optional (start 0) (end (length sstr)))  (while (%i< start end)    (when (and (%%str-member (%schar sstr (setq end (%i- end 1))) chars)               (not (%path-quoted-p sstr end start)))      (return-from %path-mem-last end))))(defun %path-mem (chars sstr &optional (start 0) (end (length sstr)))  (let ((one-char (when (eq (length chars) 1) (%schar chars 0))))    (while (%i< start end)      (let ((char (%schar sstr start)))        (when (if one-char (eq char one-char)(%%str-member char chars))          (return-from %path-mem start))        (when (eq char *pathname-escape-character*)          (setq start (%i+ start 1)))        (setq start (%i+ start 1)))))); these for ∂:  meaning this aint a logical host. Only legal for top level dir (defun %path-unquote-one-quoted (chars sstr &optional (start 0)(end (length sstr)))  (let ((pos (%path-mem-last-quoted chars sstr start end)))    (when (and pos (neq pos 1))      (cond ((or (%path-mem chars sstr start (1- pos))                 (%path-mem-last-quoted chars sstr start (1- pos)))             nil)            (t (%str-cat (%substr sstr start (1- pos))(%substr sstr  pos end)))))))(defun %path-one-quoted-p (chars sstr &optional (start 0)(end (length sstr)))  (let ((pos (%path-mem-last-quoted chars sstr start end)))    (when (and pos (neq pos 1))      (not (or (%path-mem-last-quoted chars sstr start (1- pos))               (%path-mem chars sstr start (1- pos))))))) #+PPC-target(defun %path-quoted-p (sstr pos start &aux (esc *pathname-escape-character*) (q nil))  (while (and (%i> pos start) (eq (%schar sstr (setq pos (%i- pos 1))) esc))    (setq q (not q)))  q)#-PPC-target(defun %path-quoted-p (sstr pos start)  (old-lap-inline ()    (move.l arg_y da)    (sub.l acc da)    (getint arg_y)    (move.l arg_x atemp0)    (if# (eq (vsubtypep ($ $v_xstr) atemp0 db))      (add.l arg_y arg_y))    (lea (atemp0 arg_y.l $v_data) atemp0)    (move.l ($ 0) acc)    (getint da)        (if# (ge (sub.l ($ 1) da))      (move.l (special *pathname-escape-character*) dx)      (swap dx)      (prog#       (if# (eq (cmp.b ($ $v_xstr) db))         (cmp.w (-@ atemp0) dx)         else#         (cmp.b (-@ atemp0) dx))       (bne (exit#))       (eor.b ($ $t_val) acc)       (dbfl da (top#))))    (add.l nilreg acc)));Standardize pathname quoting, so can do EQUAL.(defun %path-std-quotes (arg keep-quoted make-quoted)  (when (symbolp arg)    (error "Invalid pathname component ~S" arg))  (let* ((str arg)         (esc *pathname-escape-character*)         (end (length str))         res-str char)    (multiple-value-bind (sstr start)(array-data-and-offset str)      (setq end (+ start end))      (let ((i start))        (until (eq i end)          (setq char (%schar sstr i))          (cond ((or (%%str-member char make-quoted)                     (and (null keep-quoted) (eq char esc)))                 (unless res-str                   (setq res-str (make-array (%i- end start)                                             :element-type (array-element-type sstr)                                             :adjustable t :fill-pointer 0))                   (do ((j start (%i+ j 1))) ((eq j i))                     (vector-push-extend (%schar sstr j) res-str)))                 (vector-push-extend esc res-str))                ((neq char esc) nil)                ((eq (setq i (%i+ i 1)) end)                 (error "Malformed pathname component string ~S" str))                ((or (eq (setq char (%schar sstr i)) esc)                     (%%str-member char keep-quoted))                 (when res-str (vector-push-extend esc res-str)))                (t                 (unless res-str                   (setq res-str (make-array (%i- end start)                                             :element-type (array-element-type sstr)                                             :adjustable t :fill-pointer 0))                   (do ((j start (%i+ j 1)) (end (%i- i 1))) ((eq j end))                     (vector-push-extend (%schar sstr j) res-str)))))          (when res-str (vector-push-extend char res-str))          (setq i (%i+ i 1)))        (ensure-simple-string (or res-str str))))));arg_y = char arg_z = string#-PPC-target(defun %%str-member (char string)  (lap-inline ()    (:variable char string)   (move.l arg_z atemp0)   (vsubtype atemp0 dx)   (getvect atemp0 acc)   (if# (eq (cmp.b ($ $v_xstr) dx))     (asr.l ($ 1) acc))   (if# (ne (move.l acc da))     (swap arg_y)     (sub.l ($ 1) da)  @1 (if# (eq (cmp.b ($ $v_xstr) dx))       (cmp.w (@+ atemp0) arg_y)       else#       (cmp.b (@+ atemp0) arg_y))     (dbeq da @1)     (if# eq       (add.l ($ 1) da)       (sub.l da acc)       (mkint acc)       (bra done))     (add.w ($ 1) da)     (sub.l ($ 1) da)     (bcc @1))   (move.l nilreg acc)   done))#+PPC-target(defun %%str-member (char string)  (locally (declare (optimize (speed 3)(safety 0)))    (dotimes (i (the fixnum (length string)))      (when (eq (%schar string i) char)        (return i))))); need to keep these until world is recompiled with different fcomp-standard-source(defvar *logical-directory-alist* nil)#|  `(("CCL" . ":")                       ; reset in l1-boot    ("HOME" . ":")                      ; ditto.))    ("L1" . "ccl;level-1:")    ("L1F" . "ccl;L1-fasls:")    ("LIB" . "ccl;lib:")    ("BIN" . "ccl;bin:"))    ("CODE" . "ccl;lib:")    ("FASLS"   . "ccl;bin:")    ("COMPILER" . "ccl;compiler:")    ("EXAMPLES" . "ccl;examples:")    ("LIBRARY" . "ccl;library:")    ("INTERFACES" . "library;interfaces:")    ))|# ; why do we crash if this is nil;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_; load, require, provide(defun find-load-file (file-name)  (let ((full-name (full-pathname file-name :no-error nil)))    (when full-name      (let ((file-type (pathname-type full-name)))        (if (and file-type (neq file-type :unspecific))          (values (probe-file full-name) file-name file-name)          (let* ((source (merge-pathnames file-name *.lisp-pathname*))                 (fasl   (merge-pathnames file-name *.fasl-pathname*))                 (true-source (probe-file source))                 (true-fasl   (probe-file fasl)))            (cond (true-source                   (if (and true-fasl                            (> (file-write-date true-fasl)                               (file-write-date true-source)))                     (values true-fasl fasl source)                     (values true-source source source)))                  (true-fasl                   (values true-fasl fasl fasl))                  ((setq full-name (probe-file full-name))                   (values full-name file-name file-name)))))))))(defun compile-load (file-name &rest options &key                               fasl-file force-compile ignore-compiler-warnings                               &allow-other-keys)  (declare (dynamic-extent options))  (remf options :fasl-file)  (remf options :force-compile)  (remf options :ignore-compiler-warnings)  (let* ((file (merge-pathnames file-name *.lisp-pathname*))         (fasl (merge-pathnames (if fasl-file (merge-pathnames fasl-file *.fasl-pathname*) *.fasl-pathname*)                                file)))    (when (probe-file file)      (when (or force-compile                (not (probe-file fasl))                (< (file-write-date fasl) (file-write-date file)))        (multiple-value-bind (compiled ignore bad-warnings)                             (apply #'compile-file file :output-file fasl options)          (declare (ignore ignore))          (unless compiled              ; skip compile to compiler error            (return-from compile-load nil))          (unless (or ignore-compiler-warnings (not bad-warnings))            (restart-case              (error "Compiling ~s produced warnings." file)              (retry-compile ()                     :report (lambda (s) (format s "Retry compiling ~s" file))                     (return-from compile-load (apply #'compile-load file-name options)))              (load-anyway ()                     :report (lambda (s) (format s "Load ~s despite compiler warnings" fasl)))              (skip-load ()                     :report (lambda (s) (format s "Skip loading ~s" fasl))                     (return-from compile-load nil)))))))    (if (probe-file fasl)      (restart-case        (apply #'load fasl options)        (retry-compile ()               :report (lambda (s) (format s "Retry compiling ~s" file))               (apply #'compile-load file-name options))        (skip-load ()               :report (lambda (s) (format s "Skip loading ~s" fasl))               nil))      (restart-case        (signal-file-error $err-no-file file)        (retry-compile ()               :report (lambda (s) (format s "Retry compiling ~s" file))               (apply #'compile-load file-name options))))))(defun load (file-name &key (verbose *load-verbose*)                       (print *load-print*)                       (if-does-not-exist :error)                       ;Franz foreign function keywords.                       foreign-files system-libraries unreferenced-lib-names)  "Extension: :PRINT :SOURCE means print source as well as value"  (loop    (restart-case      (return (%load file-name verbose print if-does-not-exist                      foreign-files system-libraries unreferenced-lib-names))      (retry-load ()                  :report (lambda (stream) (format stream "Retry loading ~s" file-name)))      (skip-load ()                 :report (lambda (stream) (format stream "Skip loading ~s" file-name))                 (return nil))      (load-other ()                  :report (lambda (stream) (format stream "Load other file instead of ~s" file-name))                  (return                   (load (choose-file-dialog)                         :verbose verbose                         :print print                         :if-does-not-exist if-does-not-exist                         :foreign-files foreign-files                         :system-libraries system-libraries                         :unreferenced-lib-names unreferenced-lib-names))))))(declaim (notinline ff-load))(defun ff-load (&rest args)  (require "FF")  (apply #'ff-load args))(defun %load (file-name verbose print if-does-not-exist                         foreign-files system-libraries                        unreferenced-lib-names                        &aux type)  (let ((*load-pathname* file-name)        (*load-truename* file-name)        (source-file file-name)        constructed-source-file)    (declare (special *load-pathname* *load-truename*))    (unless (streamp file-name)      (multiple-value-setq (*load-truename* *load-pathname* source-file)        (find-load-file (merge-pathnames file-name)))      (when (not *load-truename*)        (return-from %load (if if-does-not-exist                             (signal-file-error $err-no-file file-name))))      (setq file-name *load-truename*)      (setq type (mac-file-type file-name))      (when (and (or foreign-files                     system-libraries                     unreferenced-lib-names                     (eq type :|OBJ |))                 (fboundp 'ff-load))        (when (equal file-name "") (setq file-name nil))        (return-from %load          (ff-load (if (listp file-name)                     (append file-name foreign-files)                     (cons file-name foreign-files))                   :libraries system-libraries                   :library-entry-names unreferenced-lib-names))))    (when (setq foreign-files (if foreign-files :foreign-files                                  (if system-libraries :system-libraries                                      (if unreferenced-lib-names :unreferenced-lib-names))))      (error "Inappropriate options in ~S ." foreign-files))    (let* ((*package* *package*)           (*readtable* *readtable*)           (*loading-files* (cons file-name (specialv *loading-files*)))           (*loading-file-source-file* (namestring source-file))) ;reset by fasload to logical name stored in the file?      (declare (special *loading-files* *loading-file-source-file*))      (unwind-protect        (progn          (when verbose            (format t "~&;Loading ~S..." *load-pathname*)            (force-output))          (cond ((eq type #-ppc-target :FASL #+ppc-target :PFSL)                 (flet ((attempt-load (file-name)                          (multiple-value-bind (winp err) (%fasload (mac-namestring file-name))                            (if (not winp)                               (%err-disp err)))))                   (let ((*fasload-print* print))                     (declare (special *fasload-print*))                     (setq constructed-source-file (make-pathname :defaults file-name :type (pathname-type *.lisp-pathname*)))                     (when (equalp source-file *load-truename*)                       (when (probe-file constructed-source-file)                         (setq source-file constructed-source-file)))                     (if (and source-file                              (not (equalp source-file file-name))                              (probe-file source-file))                       ;;really need restart-case-if instead of duplicating code below                       (restart-case                         (attempt-load file-name)                         #+ignore                         (load-other () :report (lambda (x) (format s "load other file"))                                     (return-from                                       %load                                       (%load (choose-file-dialog) verbose print if-does-not-exist                                              foreign-files system-libraries unreferenced-lib-names)))                         (load-source                           ()                          :report (lambda (s)                                     (format s "Attempt to load ~s instead of ~s"                                             source-file *load-pathname*))                          (return-from                             %load                            (%load source-file verbose print if-does-not-exist                                    foreign-files system-libraries unreferenced-lib-names))))                       ;;duplicated code                       (attempt-load file-name)))))                ((eq type :TEXT)                 (with-open-file (stream file-name :element-type 'base-character)                   (load-from-stream stream print)))                ((null type)                 (load-from-stream file-name print))                (t (signal-file-error $xnotfaslortext file-name)))))))  file-name)(defun load-from-stream (stream print &aux (eof-val (list ())) val)  (with-compilation-unit (:override nil) ; try this for included files    (let ((env (new-lexical-environment (new-definition-environment 'eval))))      (%rplacd (defenv.type (lexenv.parent-env env)) *outstanding-deferred-warnings*)      (while (neq eof-val (setq val (read stream nil eof-val)))        (when (eq print :source) (format t "~&Source: ~S~%" val))        (setq val (cheap-eval-in-environment val env))        (when print          (format t "~&~A~S~%" (if (eq print :source) "Value: " "") val))))))(defun include (filename)  (load   (if (null *loading-files*)     filename     (merge-pathnames filename (directory-namestring (car *loading-files*))))))(%fhave '%include #'include)(defun provide (module &aux (str (string module)))  (when (null module) (report-bad-arg module '(not (member nil))))  (setq *modules* (adjoin str *modules* :test #'string-equal))  (let* ((cell (assoc str *module-file-alist* :test #'string-equal))         (path *loading-file-source-file*))    (if cell      (setf (cdr cell) path)      (push (cons str path) *module-file-alist*)))  str)(defparameter *loading-modules* () "Internal. Prevents circularity")(defun require (module &optional pathname &aux (str (string module)))  (when (null module) (report-bad-arg module '(not null)))  (when (and (not (member str *modules* :test #'string-equal))             (not (member str *loading-modules* :test #'string-equal))             (or pathname                 (setq pathname (find-module-pathnames str))                 (progn                   (cerror "If ~S still hasn't been provided,you will be asked to choose a file."                           "The module ~S was required while loading ~S.No file could be found for that module."                           str *loading-file-source-file*)                   (unless (member str *modules* :test #'string-equal)                     (catch-cancel                       (setq pathname (choose-file-dialog                                       :mac-file-type '(#-ppc-target :fasl                                                        #+ppc-target :pfsl                                                        :text)))))                   pathname)))    (let ((*loading-modules* (cons str *loading-modules*)))      (if (consp pathname)        (dolist (path pathname) (load path))        (load pathname)))    (setq *modules* (adjoin str *modules* :test #'string-equal)))  str)(defun find-module-pathnames (module)  "Returns the file or list of files making up the module"  (or (cdr (assoc module *module-file-alist* :test #'string-equal))      (let ((mod-path (make-pathname :name module :defaults nil)) path)        (dolist (path-cand *module-search-path* nil)          (when (setq path (find-load-file (merge-pathnames mod-path path-cand)))            (return path))))))#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)