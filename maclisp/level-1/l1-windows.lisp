; -*- Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  2 7/4/97   akh  see below;;  17 1/22/97 akh  front-window returns first found rather than groveling whole window lis;;  12 5/20/96 akh  windows - (find-class 'window) if arg is 'window;;  11 4/24/96 akh  bill's fix for view-mouse-position;;  8 3/9/96   akh  fixes for call-with-focused-view and call-with-port;;  5 12/1/95  akh  %i+;;  4 11/9/95  akh  add inverse-style-arg fix;;  2 10/17/95 akh  merge patches;;  11 6/6/95  akh  window-title and set-window-title deal with system script;;  9 5/1/95   akh  remove misleading extended-character-p from do keydown-event;;  8 4/28/95  akh  fix def-ccl-pointers fonts to be explicit about script;;                  add a comment re: do-key-down-event is broken;;  7 4/28/95  akh  probably no change;;  3 4/10/95  akh  content-color initarg;;  13 3/22/95 akh  fix stream-force-output for window;;  12 3/20/95 akh  fix brain dead stream-force-output for window;;  11 3/20/95 akh  dont remember;;  10 3/14/95 akh  dont remember;;  9 2/24/95  slh  window autopositioning!;;  8 2/17/95  akh  change *window-object-alist* to a hash table;;  7 2/9/95   akh  probably no change;;  6 1/30/95  akh  incorporate kalmans patch to call-with-focused-view;;  4 1/25/95  akh  windows get back-color initarg;;  3 1/17/95  akh  use without-event-processing;;  (do not edit before this line!!);; L1-windows.lisp; Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!;; Modification History;; 01/23/97 bill %new-window uses new add-points-16 instead of add-points to;               prevent overflowing the range representable by a 32-bit integer.; ------------- 4.0; 12/08/96 akh  front-window returns first found rather than groveling whole window list;  9/11/96 slh  window-save method (see comment); 08/27/96 bill funcall-with-foreign-window; ------------- 4.0b1; 07/30/96 gb   typo in (window-close (da-window).  Pass update events;               to #_SystemEvent, since something else didn't.; 05/17/96 bill (method view-activate-event-handler (window)) doesn't deactivate;               any (transitive) container of the current-key-handler.; ------------- MCL-PPC 3.9; 03/28/96 bill (require-trap #_LM...) in do-wptrs & menubar-height; 03/26/96  gb  lowmem accessors.; 01/09/96 bill  %new-window passes the window-type value, not :window-type, to report-bad-arg; 12/13/95 slh   pop-up-path-menu: use %local-to-global; 12/11/95 slh   find-window: CmpString -> IUMagIDPString; 11/08/95 bill  #_getenvirons -> #_GetScriptManagerVariable;  5/19/95 slh   windoid show-on-resume-p slot;  4/26/95 slh   call-with-focused-view, set-gworld, window-show: use ok-wptr;                try Bill's window-close patch (kill process earlier);  4/21/95 slh   window-bring-to-front: check (and w wptr) - can go nil unexpectedly;  4/20/95 slh   window-close: send whostate "Closed";  4/03/95 slh   moved windoid methods to windoid module; moved get-window-event-handler,;                window-under here;-------------- 3.0d18;  2/24/95 slh   window class :auto-position initarg & autoposition method; menubar-height macro;-------------- 3.0d17; 01/13/95 alice set-window-layer check wptr and be woi;  forget limiting menu-item title length in *windows-menu* -  cf  window-menu-item;  find-window somewhat closer to documentation - still unreliable xabc = abc, works for fat strings;  in/validate-control not used or exported;  limit menu-item title length in *windows-menu* since window-title no longer limited - nah;  window-draw-controls and window-invalidate-controls also dead code;  define color-or-gray-p (view), window-activate/deactivate-controls are dead code;  control-key in drag brings all windows of class of w near top;--------------;07/16/93 bill  do-keydown-event now handles 2-byte characters;-------------- 3.0d11;06/24/93 alice sys-font-spec does not cons when system font is constant.;		Should be used for menu & item titles and window titles from pathnames.;06/19/93 alice pop-up-path-menu uses sysfont not chicago 12;05/05/93 bill  in pop-up-path-menu - make-menu-item takes two args;04/29/93 bill  window-close-kills-process-p;04/23/93 bill  map-windows now works independently of how the user;               function rearranges the windows.;04/21/93 bill  no args to event-dispatch - new *idle* handling;04/15/93 bill  get rid of flashing caused by window-send-behind in;               System 7. This still needs to be tested in System 6.;04/06/93 bill  in window-send-behind: do nothing if the window is already where;               it belongs. This eliminates inappropriate erasure in the;               (new) front window when a modal dialog closes and there is a windoid;               on the screen.;-------------- 2.1d5;04/17/93 alice added a path "menu" when command-click in title of window having a window-filename;-------------- 2.1d4;03/21/93 alice view-activate-event-handler (window) deactivates non-current-key-handlers;02/21/93 alice new zoom size and position from Oliver (Thanks Oliver);02/15/93 alice window-select use (edit-menu) not *edit-menu*;02/06/93 alice style-arg can be a number too;02/04/93 alice instance-initialize for simple-view - set font before calling view-default-size;01/28/93 alice added view-font-line-height cause view-font conses;10/15/92 alice window-close-event-handler - CONTROL not COMMAND hides because;		this is now called by the menu-item and command-w;10/08/92 alice - let command key thru to view-key-event-handler;; 03/24/93 bill killing of window-process moved to (method window-close :around (window));               so that the window will be completely closed if the call happens;               in the window's process; 03/23/93 bill (method call-with-focused-view :around (t t)) calls;               window-process-enqueue-with-abort to ensure that the;               *event-processor* never gets stuck waiting for a lock.; 02/11/93 bill invalidate-grow-icon is now a generic function, and its;               third argument is no more. validate-grow-icon is no more; it;               had no callers.; 02/04/93 bill window-event passes keydwn & autokey events to;               *application* if the window is not active.; 02/03/93 bill window-close-internal doesn't kill the *event-processor*; 01/12/93 bill window-close-internal kills the window-process; 01/08/93 bill window-lock; 12/14/92 bill (method windoid-p (window)) -> (method windoid-p (t)); 12/08/92 bill (method window-menu-item (window)) enables the menu;               for the front window if it is not window-active-p; 11/23/92 bill call window-size-parts later in the initialization sequence;               (just before window-show); 11/12/92 bill add :movable-dialog to *window-type-procid-alist* and *window-type-foos*; 11/11/92 bill The :COLOR-P initarg for the WINDOW class defaults to T.; 09/14/92 bill windoid :window-type defaults to :windoid.; 09/10/92 bill window-close-internal comes out of line from;               (method window-close (window)).; 09/08/92 bill (method instance-initialize :after (window)) now calls;               window-show instead of window-select so that the :window-layer;               initarg will work.;               (method window-show-internal (window t)) is more likely to call;               window-select.;               (method set-window-layer (windoid t)) correctly handles a layer;               of 0 for an invisible windoid.;               New gf:  default-window-layer; 09/03/92 bill window-event no longer sends mouse up, key up, null, or;               key down events to inactive windows.; 09/02/92 bill reselect-windows no longer calls view-activate-event-handler;               on windows that are already active-p; 09/01/92 bill clicking in a deactivated front window now reactivates it.;               Before it simply called view-click-event-handler; 08/24/92 bill in window-close-event-handler: window-close -> window-close-nicely; 05/01/92 bill call-with-focused-view becomes a generic funtion for Engber.; 11/20/92 gb   Don't say "'WINDOID" (tree shaker.)  Do say "process, lock".;-------------- 2.0; 03/15/92 bill Move the default VIEW-SIZE of the WINDOID class from;               a default initarg of the class to a VIEW-DEFAULT-SIZE method.;               This makes user VIEW-DEFAULT-SIZE methods be called.;-------------- 2.0f3; 02/24/92 bill (style-arg '(:bold)) no longer returns (%ilogior nil 1); 01/07/92 gb   don't require RECORDS.; 12/27/91 bill (method set-view-font-codes (window)) now returns the;               font codes instead of NIL.; ------------- 2.0b4; 11/08/91 gb   revert TARGET, fix compiler.; 10/30/91 bill remove -iv on the end of slot names; 10/28/91 bill %new-window detects %null-ptr-p values from #_NewWindow; 10/24/91 bill In window-draw-event-handler, don't change the port before;               calling SET-VIEW-POSITION.; 10/21/91 bill stop TARGET from consing.; 10/15/91 bill eradicate window-font & set-window-font;               :erase-anonymous-invalidations initarg to the WINDOW class.;               Remove consing from (in)validate-control, window-draw-grow-icon,;               window-drag-event-handler; 10/29/91 alice def-load-pointers => def-ccl-pointers; 09/23/91 bill #'(setf view-nick-name) -> #'set-view-nick-name; 09/13/91 bill with-focused-font-view -> with-font-focused-view; 09/09/91 bill #_SelectWindow -> window-bring-to-front;               Add #_ActivatePalette to window-select; 09/21/91 bills fix to stream-write-string ((v simple-view);---------- 2.0b3; 09/03/91 bill Startup initialization of *setgworld-available?*.  Rest is in l1;sysutils.lisp;               fix (method initialize-instance (da-window)); 08/30/91 alice window-select does (menu-update *edit-menu*); 08/26/91 bill to support sheet-view: view-window becomes generic, set-gworld, get-gworld, call-with-port;               Unbogosify (method stream-force-output (window)); 08/24/91 gb   use new trap syntax.; 08/06/91 bill call-with-focused-view no longer defaults the font-view parameter; 07/26/91 bill call view-default-size & view-default-position for views;               other than windows and dialog-items.; 07/25/91 bill prevent memory leak in (method initialize-instance (da-window));               Add window-invalid-region to make back patterns function correctly; 07/21/91 gb   use DYNAMIC-EXTENT vice evil DOWNWARD-FUNCTION.; 07/05/91 bill *last-null-event-time* checking moves to do-event; 06/17/91 bill *current-font-view* handled by call-with-focused-view;               focus-view takes a new optional font-view parameter.;               call-with-focused-view's function takes one arg, the view.;               *grow-bm* is no longer used.;               set-view-size of a window sets the 'view-size slot too.; 06/07/91 bill simple-view takes a :help-spec initarg;-------------- 2.0b2; 05/13/91 bill sort *font-list*; 03/29/91 bill clear *last-mouse-click-window* in window-close; 03/25/91 bill option-click on a window's title bar now sends it to the back;               whether or not it was in the front.; 03/22/91 bill window-draw-grow-icon calls _DrawGrowIcon; 03/05/91 bill handle mac windows not in *window-object-alist* a bit better; 02/07/91 bill (method window-filename (window)) => (method window-filename (stream));03/05/91 alice report-bad-arg gets 2 (args that is);----------- 2.0b1; 01/29/91 bill fix window-make-parts & window-event to allow a window with;               a zoom box, but no grow box.  I inadvertently removed this;               possibility on 12/13.; 01/18/91 bill set-view-container-slot => (setf view-container-slot);               set-wptr => (setf wptr-slot);               Both due to reversal of args in :writer methods.; 01/16/91 bill (slot-value w 'window-grow-rect) -> (window-grow-rect w); 01/10/91 gb   window-null-event-handler - force-output iff *terminal-io* is a stream; 01/03/91 bill remove :parent keyword from map-windows, windows, front-window; 12/13/90 bill in window-make-parts: window-type & grow-icon-p need to interact; 12/12/90 bill (slot-value w 'grow-icon-p) -> (window-grow-icon-p w); 12/07/90 bill option-click in close box closes only windows of the same;               class as the one clicked on vice all windows that inherit from;               that class.; 11/05/90 bill gcable-wptr-p.  Do not allocate a clip-region or erase-region;               for DA-WINDOW's;               Process menu key events in DO-EVENT vice WINDOW-EVENT;               Only call window-null-event once a tick to speed up;               real-time stuff;               In window-update-event-handler: Erase visrgn if back-color not white.;               Fix window-zoom-event-handler; 11/01/90 bill view-default-font; 10/30/90 bill window-title uses slot-value-if-bound to avoid errors;               during window creation (before WPTR is bound); 10/25/90 bill color-green, color-blue, color-red for bootstrapping.; 10/23/90 bill set-view-container-slot, remove (defun wptr ...), replace with reader.;10/18/90 bill If a default-button closed a window before it was activated,;              The null wptr was sometimes referenced by the;              view-activate-event-handler code.;10/04/90 bill window-update-event-handler binds *processing-events* true.;10/03/90 bill %class-cpl -> %inited-class-cpl;09/21/90 bill add new-window-title to window-make-parts;09/20/90 bill da-window's default view-font is NIL: let the DA decide.;10/16/90 gb   no more %str-length.;08/29/90 joe  added *window-default-position*, *window-default-size*;              *window-default-zoom-position*, *window-default-zoom-size*;              and window-default-zoom-size, window-default-zoom-position methods.;              Removed the slots for above & changed def-load-pointers,;              view-default-position & size to reflect above.;              window-zoom-event-handler now uses window-zoom-size correctly;              window-drag-event-handler now uses drag-rect correctly;08/20/90 bill Add :class in windows, map-windows, front-window;08/13/90 bill (method stream-force-output (window));08/10/90 bill Hide windows when user <Command>-clicks close box.;              display-in-windows-menu to decide whether to display hidden windows.;08/09/90 bill store window font-codes in the alist.  If they are stored only;              in the wptr, then we sometimes see with-font-codes values.;08/03/90 bill new view-valid slot.;08/01/90 bill set-view-size-internal no longer invalidates controls.;07/24/90 bill in window-event: ignore command keys that have no menu item.;07/23/90 bill Eliminate duplicate fonts in *font-list*;07/06/90 bill Remove color-window-mixin from window-color-p;07/05/90 bill map-windows, windows, & front-window take keyword args now.;              nix wptr-if-bound & color-window-mixin.;06/25/90 bill add :procid keyword to window-make-parts;06/22/90 bill :window-font -> :view-font;              def-aux-init-functions for window class.;06/21/90 bill ed-select-file calls #'fred instead of make-instance directly.;06/19/90 bill (set-view-position window :centered) now works.;06/13/90 bill windoid built on lisp-wdef-mixin;06/07/90 gb   print-unreadable-object :identity vice :id.;06/05/90 bill call-with-focused-view;05/30/90 gb   use print-unreadable-object.;05/29/90 bill Move %temp-port% def & initialization from sysutils.;05/24/90 bill window-(de)activate-event-handler -> view-(de)activate-event-handler;              window-draw-contents -> view-draw-contents;              window-click-event-handler -> view-click-event-handler;              window-position -> view-position, window-size -> view-size;              Move *color-available* test to inside of %new-window;05/23/90 bill (with-focused-font-view v ...) -> (with-focused-font-view (v v) ...);05/05/90 bill new scrap handler.;05/04/90 bill window-draw-grow-icon: draw outline when window not highlighted.;05/03/90 bill window-activate-event-handler does nothing if Lisp is in background.;04/30/90 gb   Still in late April: use downward functions.  Set the wayback;              machine for the late 20th century.  %iasr.;04/24/90 bill view-window looks up the view hierarchy if it can't find the;              window in the *window-alist*;04/23/90 bill window-zoom-position & window-zoom-size now look in;              view-alist first.  set-xxx puts value there.;              Add invalidate-view to window-zoom-event-handler;04/19/90 bill grow-icon-corners, and erase-p arg to invalidate-grow-icon & use it.;04/18/90 bill grafport-write-string;04/17/90 bill wptr-font-codes, set-wptr-font-codes.;04/16/90 bill remove consing from stream-line-length.;04/13/90 bill stream-tyo, stream-write-string, view-terpri now specialize;              on simple-view instead on window.;04/10/90 bill set-window-font returns the font. steam-write-string for window;04/10/90  gz  view fonts.;04/07/90 bill view-put doesn't add a property for a vlaue of NIL;03/20/90 bill initialize-instance => instance-initialize;03/15/90  gz  Do more stuff in the interim focus-view, otherwise fred-window;              window-update breaks in various subtle ways in a level-1 lisp.;              Made WPTR and #'(SETF WPTR) be smarter.;03/13/90 bill in window-close: don't _DisposWindow %temp-port%,;              window-type, window-color-p;05/06/90 bill view-get & friends specialize on simple-view not window.;03/05/90 bill stream-tyo passed too many args to window-terpri.;              center-window bombed if position arg was malformed.;              window-key-event-handler => view-key-event-handler.;02/28/90 bill Add color-p initarg to window: call _NewCWindow in %new-window;02/26/90 bill without-interrupts is now implicit in with-port.;02/23/90 bill No without-interrupts around window-update-event-handler;02/21/90 bill Make window-show deactivate *selected-window* before showing;              a modal dialog.;02/20/90 bill window-hide before removing subviews in window-close;02/15/90 bill window-get & friends => view-get & friends.;01/26/90 bill Add window-alist, window-get, window-put, window-remprop;01/04/90 bill Add windoids.;12/26/89 bill map-windows added, used for windows, front-window, find-window.;12/23/89 bill Clicking inDrag with the command key down does NOT select the window,;              moves it in its layer.;11/13/89 bill Add optional first arg to edit-select-file.;10/4/89  gz NEW-install-window-object -> install-window-object.;09/27/89 gb simple-string -> ensure-simple-string.;09/16/89 bill Removed the last vestiges of object-lisp windows.;09/13/89 bill Make edit-select-file create a CLOS fred-window if it can;09/12/89 bill Make window-make-parts use set-window-title to set the title.;              Fred depends on this.;              Remove the title from %new-window & initialize-window;09/12/89 bill Add window-title initarg to window-make-parts;09/06/89 bill add print-object for window.;              window-title (window): prevent error if wptr slot unbound.;09/05/89 bill window-close-event-handler: update to work with option key again;09/05/89 bill Make initialize-instance for window a primary method instead;              of an :after method. Some user's of it needed this.;08/30/89 blll window-event: (_ask nil ...) as some dialog functions are now both;              obfuns and methods (kluge, kluge);08/25/89 bill window-menu-item: change to CLOS menus.;08/25/89 bill (defmethod clos-window-update-cursor ...) & (def_obfun window-update-cursor ...);          ==> (defmethod window-update-cursor ...) & (def_obfun window-object-update-cursor ...);07/18/89 bill window-title: add comments.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;To do: Change window-object to just search all objects if not found in alist.(defvar *font-list* ())(defvar *big-rgn* nil)(defvar *big-rect* nil);(defvar *grow-bm* nil)(defvar %temp-port%)(defvar %original-temp-port%)(defvar *grow-icon-rgn*)(defun simple-string< (a b)  (let ((la (length a))        (lb (length b)))    (dotimes (i (min la lb) (< la lb))      (let ((ca (%scharcode a i))            (cb (%scharcode b i)))      (if (< ca cb)(return t)          (if (/= ca cb) (return nil)))))))(defun simple-string= (a b)  (let ((la (length a)))    (when (= la (length b))      (dotimes (i la t)        (when (/= (%scharcode a i)(%scharcode b i))          (return nil))))))(def-ccl-pointers fonts ()    (rlet ((r :rect :topleft 0 :bottomright 0)         (tp (:string 2)))    (setq %temp-port%          (#_NewWindow            (%null-ptr)           r                            ; bounds           tp                           ; blank title           nil                          ; invisible           4                            ; procid: document           (%int-to-ptr -1)             ; behind           nil                          ; no goAwayFlag           4                            ; refCon           )))  (setq %original-temp-port% %temp-port%)  (let* ((script (#_GetScriptManagerVariable  #$smSysScript)))    (setq *grow-icon-rgn*  (#_NewRgn))    (setq     *font-list*     (%sort-list-no-key      (unwind-protect        (%stack-block ((ip 2) (tp 4) (np 256))          (#_SetResLoad nil)          (do* ((index (#_CountResources "FOND") (1- index))                (ret nil))               ((eq index 0) ret)            (#_GetResInfo (#_GetIndResource "FOND" index) ip tp np)            (let ((f (%get-word ip)))              (without-interrupts               (let* ((script (#_FontToScript f)))                 (when (not (memq script *script-list*))                   (let ((flag (#_getscriptmanagervariable #$smdefault)))                     (when (eq flag 0) (push script *script-list*))))))) ; flag false if installed                                  (let ((s (%get-string np 0 script)))              (unless (member s ret :test #'simple-string=)                (push s ret)))))        (#_SetResLoad t))      #'simple-string<))    (setq *big-rgn* (#_NewRgn))    (#_SetRectRgn *big-rgn* -32768 -32768 32767 32767)    (setq *big-rect* (#_NewPtr 8))    (#_SetRect *big-rect* -32768 -32768 32767 32767)    #|  (setq *grow-bm* (#_NewPtr :errchk 78))  (%put-ptr *grow-bm* (%inc-ptr *grow-bm* 14)) ;BaseAddr  (%put-word *grow-bm* 2 4) ;rowbytes  (%put-long *grow-bm* 0 6)  (%put-long *grow-bm* #x100010 10)  (with-pstrs ((s1 "FFFF800080009FE09020903E90229022902290229FE284028402840287FE8000"))    (#_StuffHex (%inc-ptr *grow-bm* 14) s1))|#    ))(eval-when (:execute :compile-toplevel)  (defconstant $noAutoCenter #x0000)  (defconstant $centerMainScreen #x280a)  (defconstant $alertPositionMainScreen #x300a)  (defconstant $staggerMainScreen #x380a)  (defconstant $centerParentWindow #xa80a)  (defconstant $alertPositionParentWindow #xb00a)  (defconstant $staggerParentWindow #xb80a)  (defconstant $centerParentWindowScreen #x680a)  (defconstant $alertPositionParentWindowScreen #x700a)  (defconstant $staggerParentWindowScreen #x780a))(eval-when (:execute :compile-toplevel)  ; :noAutoCenter must be first (see autoposition)  (defconstant autopos-constraints    `((:noAutoCenter . (nil nil #.$noAutoCenter))      (:centerMainScreen . (:center :main-screen #.$centerMainScreen))      (:alertPositionMainScreen . (:alert-pos :main-screen #.$alertPositionMainScreen))      (:staggerMainScreen . (:stagger :main-screen #.$staggerMainScreen))      (:centerParentWindow . (:center :parent-window #.$centerParentWindow))      (:alertPositionParentWindow . (:alert-pos :parent-window #.$alertPositionParentWindow))      (:staggerParentWindow . (:stagger :parent-window #.$staggerParentWindow))      (:centerParentWindowScreen . (:center :parent-window-screen #.$centerParentWindowScreen))      (:alertPositionParentWindowScreen . (:alert-pos :parent-window-screen #.$alertPositionParentWindowScreen))      (:staggerParentWindowScreen . (:stagger :parent-window-screen #.$staggerParentWindowScreen))))    (defmacro autopos-placement (key)    `(cadr (assoc ,key autopos-constraints)))    (defmacro autopos-bounds (key)    `(caddr (assoc ,key autopos-constraints)))    (defmacro autopos-id (key)    `(cadddr (assoc ,key autopos-constraints))))(defmacro do-wptrs (wptr &body body)  (let ((next-wptr (gensym)))    `(with-macptrs ((,wptr (require-trap #_LMGetWindowList))            ,next-wptr)       (do () ((%null-ptr-p ,wptr))         (%setf-macptr ,next-wptr (rref ,wptr windowrecord.nextwindow))         ,@body         (%setf-macptr ,wptr ,next-wptr)))))(defmacro do-all-windows (w &body body)  (let ((wptr (gensym)))    `(do-wptrs ,wptr      (let ((,w (window-object ,wptr)))        (when ,w          ,@body)))))(defmacro menubar-height ()  `(require-trap #_LMGetMBarHeight))(defun class-inherit-from-p (class parent-class)  (flet ((get-class (value)           (if (symbolp value) (find-class value nil) value)))    (let ((pclass (get-class parent-class)))      (memq pclass            (%inited-class-cpl (get-class class))))))(defun windows (&key class include-invisibles include-windoids)  (cond ((eq class 'window)         (setq class nil))        ((and class (symbolp class))         (setq class (find-class class))))  (when (and class (class-inherit-from-p class (find-class 'windoid)))    (setq include-windoids t))  (let ((windows nil))    (without-interrupts     (do-wptrs wptr       (let ((wob (window-object wptr)))         (when (and wob                    (or include-windoids                        (not (windoid-p wob)))                    (or (not class)(inherit-from-p wob class))                    (or include-invisibles (rref wptr windowrecord.visible)))           (setq windows (cheap-cons wob windows))))))    (nreverse windows)))(defun map-windows (function &key class include-invisibles include-windoids)  (let ((windows (windows :class class                          :include-invisibles include-invisibles                          :include-windoids include-windoids)))    (unwind-protect      (dolist (w windows)        (funcall function w))      (cheap-free-list windows))    nil))(defun front-window (&key class include-invisibles include-windoids)    (when class     (when (symbolp class)(setq class (find-class class)))     (when (class-inherit-from-p class (find-class 'windoid))      (setq include-windoids t)))  (do-wptrs wptr    (let ((wob (window-object wptr)))      (and wob           (or include-windoids               (not (windoid-p wob)))           (or (not class)(inherit-from-p wob class))           (or include-invisibles (rref wptr windowrecord.visible))           (return wob)))))(defun target ()  (let* ((first? nil)         (temp #'(lambda (w)                   (if first?                     (return-from target w)                     (setq first? t)))))    (declare (dynamic-extent temp))    (map-windows temp)))(defun find-window (title &optional class)  (with-pstrs ((tp title))    (let* ((len   (%get-byte tp 0))           (len+1 (%i+ len 1)))      (%stack-block ((np 256))        (with-macptrs ((tp1 (%inc-ptr tp 1))                       (np1 (%inc-ptr np 1))                       (np2 (%inc-ptr np 2)))          (let* ((mapper #'(lambda (w)                             (#_GetWTitle (wptr w) np)                             (let ((tlen (%get-byte np)))                               (when (or (and (eql tlen len)                                              (%izerop (#_IUMagIDPString np1 tp1 len len (%null-ptr))))                                         (and (eql tlen len+1)                                              (%izerop (#_IUMagIDPString np2 tp1 len len (%null-ptr)))))                                 (return-from find-window w))))))            (declare (dynamic-extent mapper))            (map-windows mapper                         :class class                         :include-windoids t)))))))(defun hilite-wptr (wptr hilite?)  (when wptr                            ; may have disappeared.    (unless (eq hilite? (rref wptr windowrecord.hilited))      (#_HiliteWindow wptr hilite?)      t))); Nobody actually calls this, but it shows how to maintain the; state of the window hiliting and activation correctly.(defun fix-windows ()  (if (da-or-modal-dialog-on-top-p)    (unselect-windows t)    (reselect-windows)))(defun da-or-modal-dialog-on-top-p ()  (or *modal-dialog-on-top* (typep *selected-window* 'da-window))); Unhilite & deactivate all the windows.; Leave the first one alone if skip-first? is true(defun unselect-windows (&optional skip-first?)  (with-macptrs ((wptr (#_LMGetWindowList)))    (when skip-first?      (unless (%null-ptr-p wptr)        (setq wptr (rref wptr windowrecord.nextwindow))))    (until (%null-ptr-p wptr)      (when (rref wptr windowrecord.visible)        (let ((wob (window-object wptr)))          (if (and wob (typep (wptr wob) 'macptr))            (view-deactivate-event-handler wob)            (hilite-wptr wptr nil))))      (%setf-macptr wptr (rref wptr windowrecord.nextwindow)))))(defvar *last-windoid* nil); Hilite & activate the windows.; Move windoids to the front.; If *selected-window* is a DA, pick a non-DA to select.; If *selected-window* is nil, leave it that way.; Update *last-windoid* and *windoid-count*(defun reselect-windows ()  (let ((selected *selected-window*)        last-windoid        found-non-windoid?        (da-before-selected? :maybe)        (windoid-count 0))    (if (typep selected 'da-window)      (setq selected nil))    (do-wptrs wptr      (when (rref wptr windowrecord.visible)        (let ((wob (window-object wptr)))          (cond ((or (null wob) (not (typep (wptr wob) 'macptr)))                 (hilite-wptr wptr nil))                ((windoid-p wob)                 (if found-non-windoid?                   (if last-windoid                     (window-send-behind wptr (wptr last-windoid) t)                     (window-bring-to-front wob wptr)))                 (setq last-windoid wob)                 (unless (window-active-p wob)                   (view-activate-event-handler wob))                 (setq windoid-count (%i+ windoid-count 1)))                (t                 (setq found-non-windoid? t)                 (if (typep wob 'da-window)                    (if (eq :maybe da-before-selected?)                     (setq da-before-selected? t))                   (if (and (eq wob (or selected (setq selected wob)))                            (eq :maybe da-before-selected?))                     (setq da-before-selected? nil))))))))    (setq *windoid-count* windoid-count          *last-windoid* last-windoid)    (when *selected-window*           ; maybe nobody is selected      (setq *selected-window* selected)      (when (eq t da-before-selected?)        (if last-windoid          (window-send-behind (wptr selected) (wptr last-windoid) t)          (window-bring-to-front selected)))      (unless (window-active-p selected)        (view-activate-event-handler selected)))))(defun fix-window-hiliting ()  (let* ((first-window? nil)         (temp #'(lambda (w)                   (let ((wptr (wptr w)))                     (if (typep w 'windoid)                       (hilite-wptr wptr t)                       (if first-window?                         (hilite-wptr wptr nil)                         (progn                           (hilite-wptr wptr t)                           (setq first-window? t))))))))    (declare (dynamic-extent temp))       (map-windows     temp     ;:class 'window     :include-invisibles nil     :include-windoids t)))(defun edit-select-file (&optional w &aux (name (choose-file-dialog                                                :mac-file-type "TEXT")))  (declare (ignore w))                  ; called from a comtab sometimes.  (when name    (fred name)))(defun style-arg (arg &aux val (ret 0))  (if (symbolp arg)    (if (setq ret (%cdr (assq arg *style-alist*)))      ret      (%err-disp $err-bad-input arg))    (dolist (sym arg ret)      (if (setq val (%cdr (assq sym *style-alist*)))        (setq ret (%ilogior2 ret val))        (%err-disp $err-bad-input sym)))))(defun inverse-style-arg (arg)    (if (eq 0 arg)    (dolist (e *style-alist* nil)      (if (eq 0 (cdr e))(return (car e))))    (let ((val))      (dotimes (i 7)        (when (logbitp i arg)          (let* ((n (ash 1 i))                 (it (dolist (e *style-alist* nil)                       (if (eq n (cdr e))(return (car e))))))            (when it (if (consp val)                       (push it val)                       (if val                         (setq val (list it val))                         (setq val it)))))))      (or val          (%err-disp $err-bad-input arg)))))      (defun make-style (num &aux ret) (dolist (elt *style-alist* ret)  (if (eq num (%cdr elt)) (return-from make-style (%car elt)))  (if (neq 0 (%ilogand2 num (%cdr elt))) (setq ret (cons (%car elt) ret)))))#|(defun get-window-control (wptr ctype &optional (hCtl (%null-ptr)))  (%setf-macptr hCtl (rref wptr windowrecord.ControlList))  (until (%null-ptr-p hCtl)    (if (eq ctype (rref hCtl controlrecord.contrlrfcon))      (return-from get-window-control hCtl)      (%setf-macptr hCtl (rref hCtl controlrecord.nextcontrol))))  nil)|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                              view                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Note: Most of the view code is in lib;views.lisp: not in level 1.; a simple-view is used for dialog-items.  It cannot have subviews.(defclass simple-view (output-stream)  ((view-container :initform nil                    :reader view-container)   (wptr :initarg :wptr :initform nil :reader wptr)   (view-position :initform #@(0 0) :initarg :view-position :reader view-position)   (view-size :initform #@(100 100) :initarg :view-size :reader view-size)   (view-nick-name :initform nil :initarg :view-nick-name :reader view-nick-name)   (view-alist :initform nil :accessor view-alist)   ))(defmethod view-default-size ((view simple-view)) #@(100 100))(defmethod view-default-position ((view simple-view)) #@(0 0))(defmethod set-view-container-slot ((view simple-view) value)  (setf (slot-value view 'view-container) value))(defmethod set-wptr ((view simple-view) value)  (setf (slot-value view 'wptr) value))(defmethod set-view-nick-name ((view simple-view) new-name)  (setf (slot-value view 'view-nick-name) new-name))(defclass view (simple-view)  ((view-valid :initform nil :accessor view-valid)   ; for lazy clip-region updating.   (view-scroll-position :initform #@(0 0) :initarg :view-scroll-position                         :accessor view-scroll-position)   (view-origin :initform #@(0 0) :accessor view-origin-slot)   (view-subviews :initform (make-array 1 :adjustable t :fill-pointer 0)                  :reader view-subviews)   (view-clip-region :initform nil :accessor view-clip-region-slot)))(defmethod (setf wptr) (wptr (v simple-view))  (setf (slot-value v 'wptr) (and wptr (require-type wptr 'macptr))))(defmethod initialize-instance ((view simple-view) &rest initargs &key                                (view-font (view-default-font view)))  (declare (dynamic-extent initargs))  (apply #'call-next-method         view         :view-font view-font         initargs))(defmethod instance-initialize :after ((view simple-view) &key                                       view-container view-font help-spec                                       (view-size nil vsp)                                       (view-position nil vpp))  (declare (ignore view-size view-position))  (when (and view-font (not (typep view 'window)))    (set-initial-view-font view view-font))  (when help-spec    (setf (view-get view :help-spec) help-spec))  (unless vsp (setf (slot-value view 'view-size) (view-default-size view)))  (unless vpp (setf (slot-value view 'view-position)(view-default-position view)))  (when view-container    (set-view-container view view-container)))(defmethod instance-initialize :after ((v view) &key view-subviews)  (dolist (subview view-subviews)    (set-view-container subview v)))(defmethod view-contains-p ((view view) contained-view)  (let ((container (view-container contained-view)))    (while container      (if (eq container view)        (return-from view-contains-p t))      (setq container (view-container container)))))(defmethod view-contains-p ((view null) contained-view)  (declare (ignore contained-view))  nil)(defmethod view-font ((view simple-view))  (multiple-value-bind (ff ms) (view-font-codes view)    (font-spec ff ms)))(defmethod view-font-line-height ((view simple-view))  (multiple-value-bind (a d w l) (view-font-codes-info view)    (declare (ignore w))    (%i+ a d l)))(defmethod view-font-codes-info ((view simple-view))  (multiple-value-call #'font-codes-info (view-font-codes view)))(defmethod set-view-font ((view simple-view) font-spec)  (multiple-value-bind (ff ms) (view-font-codes view)    (multiple-value-bind (ff ms) (font-codes font-spec ff ms)      (set-view-font-codes view ff ms)))  font-spec)(defmethod set-initial-view-font ((view simple-view) font-spec)  (set-view-font view font-spec))(defmethod view-font-codes ((view simple-view))  (let ((codes (view-get view 'view-font-codes)))    (if codes      (values (car codes) (%cdr codes))      (let ((container (view-container view)))        (and container (view-font-codes container))))))(defmethod set-view-font-codes ((view simple-view) ff ms &optional ff-mask ms-mask)  (let ((codes (view-get view 'view-font-codes)))    (if codes      (let ((old-ff (car codes))            (old-ms (%cdr codes)))        (if ff-mask          (setq ff (%ilogior (%ilogand ff ff-mask)                              (%ilogand old-ff (%ilognot ff-mask)))))        (if ms-mask          (setq ms (%ilogior (%ilogand ms ms-mask)                              (%ilogand old-ms (%ilognot ms-mask)))))        (%rplacd (rplaca codes ff) ms))      (view-put view 'view-font-codes (cons ff ms)))    (values ff ms)))(defvar *quieted-view* nil)(defmacro with-quieted-view-if (view predicate &body body)  (let ((view-var (gensym)))  `(let* ((,view-var ,view)             ; make sure we eval the view form          (*quieted-view* *quieted-view*))     (when (and ,predicate (not (view-contains-p *quieted-view* ,view-var)))       (setq *quieted-view* ,view-var))     ,@body)))(defmacro with-quieted-view (view &body body)  `(with-quieted-view-if ,view t ,@body))(defun view-quieted-p (view)  (let ((qv *quieted-view*))    (and qv (or (eq view qv) (view-contains-p qv view))))); Toggle blinkers is so that user windoid code can make fred-dialog-items blink; at the proper time.(defmethod toggle-blinkers ((item simple-view) on-p)  (declare (ignore on-p)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                             window                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass window (view)  ((window-cursor :allocation :class :reader window-cursor)   (window-grow-rect :allocation :class :reader window-grow-rect)   (window-drag-rect :allocation :class :reader window-drag-rect)   (color-list :initform nil :reader window-color-list)   (back-color :initform nil)   (object-name :initform nil)   (my-item :initform nil)   (grow-icon-p :initform nil :reader window-grow-icon-p)   (window-do-first-click :initform nil :accessor window-do-first-click                          :initarg :window-do-first-click)   (window-active-p :initform nil :accessor window-active-p)   (window-erase-region :initform (#_NewRgn) :accessor window-erase-region)   (window-invalid-region :initform nil :accessor window-invalid-region)   (process :initform nil :initarg :process :accessor window-process)   (queue :initform (make-process-queue "Window") :reader window-process-queue)   (auto-position :initarg :auto-position :initform :noAutoCenter)))(defmethod initialize-instance ((w window) &rest initargs &key auto-position)  (declare (dynamic-extent initargs))  (if (and auto-position           (null (assq auto-position autopos-constraints)))    (error "~S must be one of ~S" auto-position           (mapcar #'car (cdr autopos-constraints)))    (apply #'call-next-method w :auto-position auto-position initargs)))(defmethod windoid-p (w)  (declare (ignore w))  nil)(defmethod view-default-font ((window window))  *fred-default-font-spec*)(defmethod view-default-font ((view simple-view))  nil)(defmethod window-zoom-position ((w window))  (or (view-get w 'window-zoom-position)      (window-default-zoom-position w)))(defmethod set-window-zoom-position ((w window) h &optional v)  (if h    (setf (view-get w 'window-zoom-position) (make-point h v))    (view-remprop w 'window-zoom-position)))(defmethod window-zoom-size ((w window))  (or (view-get w 'window-zoom-size)      (window-default-zoom-size w)))(defmethod set-window-zoom-size ((w window) h &optional v)  (if h    (setf (view-get w 'window-zoom-size) (make-point h v))    (view-remprop w 'window-zoom-size)))#|(defmethod window-default-zoom-position ((w window))  *window-default-zoom-position*)(defmethod window-default-zoom-size ((w window))  *window-default-zoom-size*)|#(defconstant $window-zoom-border 2 "Leave this much border around the zoomed window.")(defmethod window-title-height ((window window))  20);; Find the screen that overlaps most of the window (or the main screen, if the;; window doesn't overlap any screens), and return the bounds of the part of that;; screen that is usable.  This is the entire screen bounds, unless the screen;; is the main screen, in which case the top portion is consumed by the menubar.(defun window-preferred-screen-bounds (window &aux (mbar-height (menubar-height)))  (if *color-available*    (rlet ((rect :rect :topLeft #@(0 0) :bottomRight (view-size window)))      (#_OffsetRect :pointer rect :longint (view-position window))      (let* ((main (#_GetMainDevice))             (best -1)             st sl sb sr)        (flet ((set-to-device-bounds (devicePtr main-device-p)                 (setf sl (pref devicePtr GDevice.gdRect.left)                       st (+ (pref devicePtr GDevice.gdRect.top)                             (if main-device-p mbar-height 0))                       sr (pref devicePtr GDevice.gdRect.right)                       sb (pref devicePtr GDevice.gdRect.bottom))))          (do ((device (#_GetDeviceList) (#_GetNextDevice device)))              ((%null-ptr-p device))            (with-dereferenced-handles ((devicePtr device))              (rlet ((intersection :rect))                (#_SectRect rect (pref devicePtr GDevice.gdRect) intersection)                (let ((area (* (- (pref intersection rect.bottom) (pref intersection rect.top))                               (- (pref intersection rect.right) (pref intersection rect.left)))))                  (when (> area best)                    (setf best area)                    (set-to-device-bounds devicePtr (eql device main)))))))          (unless sl            (with-dereferenced-handles ((devicePtr main))              (set-to-device-bounds devicePtr t))))        (values sl st sr sb)))    (values 0 mbar-height *screen-width* *screen-height*)));; The window's new position.  If its origin remains on the same screen, and its;; old position and new size allow it to fit entirely on that screen, leave it;; where it is, otherwise move it.(defmethod window-default-zoom-position ((window window))  (multiple-value-bind (sl st sr sb) (window-preferred-screen-bounds window)    (let* ((pos (view-position window))           (current-h (point-h pos))           (current-v (point-v pos))           (size (window-default-zoom-size window))           (new-width (point-h size))           (new-height (point-v size))           (moved-h (+ sl $window-zoom-border))           (moved-v (+ st $window-zoom-border (window-title-height window))))      ;; If origin of the window is still on the same screen...      (if (and (<= sl current-h (1- sr))               (<= st current-v (1- sb)))        ;; ...then keep the same coordinates where they allow the window to remain        ;; wholly on the screen, and use the new ones where the old ones don't...        (make-point (if (< (+ current-h new-width $window-zoom-border) sr) current-h moved-h)                    (if (< (+ current-v new-height $window-zoom-border) sb) current-v moved-v))        ;; otherwise go ahead and move the window.        (make-point moved-h moved-v)))));; The minimum of the window's preferred size and the usable window area;; of the window's preferred screen.(defmethod window-default-zoom-size ((window window))  (multiple-value-bind (sl st sr sb) (window-preferred-screen-bounds window)    (let* ((psize (view-preferred-size window))           (ph (min (point-h psize) (- sr sl                                       $window-zoom-border $window-zoom-border)))           (pv (min (point-v psize) (- sb st (window-title-height window)                                       $window-zoom-border $window-zoom-border))))      (make-point ph pv))))(defmethod view-preferred-size ((w window))  #@(3000 3000))  (defmethod view-valid-p ((view simple-view)) t)(defmethod view-valid-p ((view view))  (not (memq nil (view-valid view))))(defmethod make-view-valid ((view simple-view) &optional dont-inval-subviews)  (declare (ignore dont-inval-subviews))  view)(defmethod make-view-valid ((view view) &optional dont-inval-subviews)  (let ((valid (view-valid view)))    (unless (or (null valid) (car valid))      (setf (%car valid) t)      (unless dont-inval-subviews        (dovector (subview (view-subviews view))          (make-view-invalid subview)))))  view)(defmethod make-view-invalid ((view simple-view)) view)(defmethod make-view-invalid ((view view))  (let ((valid (view-valid view)))    (when (and valid (car valid))      (setf (%car valid) nil)))  view)(defmethod view-allocate-clip-region ((view view))  (let ((rgn (view-clip-region view)))    (or rgn        (setf (view-clip-region-slot view) (#_NewRgn)))))(defmethod view-clip-region ((view view))  (let ((rgn (view-clip-region-slot view)))    (unless (or (null rgn) (view-valid-p view))      (let ((container (view-container view)))        (compute-view-origin view container)        (make-view-valid view)        (compute-view-region view rgn container)))    rgn))(defmethod compute-view-region ((view window) rgn container)  (declare (ignore container))  (when rgn    (let* ((topleft (view-origin view))           (botright (add-points topleft (view-size view))))      (#_SetRectRgn rgn (point-h topleft) (point-v topleft) (point-h botright) (point-v botright))))  rgn)(defmethod compute-view-origin ((view view) container)  (setf (view-origin-slot view)        (if container          (add-points (subtract-points (view-scroll-position view)                                       (view-position view))                      (view-origin container))          (view-scroll-position view))))(defmethod view-origin ((view view))  (if (view-valid-p view)    (view-origin-slot view)    (let ((container (view-container view)))      (prog1        (compute-view-origin view container)        (make-view-valid view)        (compute-view-region view (view-clip-region-slot view) container)))))  (defmethod window-event-handler ((w window))  w); what if there are no windows(defmethod window-event-handler (( w t))())(defmethod toggle-blinkers ((w window) on-p)  (let ((key-handler (current-key-handler w)))    (when key-handler      (toggle-blinkers key-handler on-p))))(defclass da-window (window)  ())(defmethod view-default-font ((window da-window))  nil); This class is here to remove the lisp wdef from a window's wptr on window-close.; _DisposWindow calls the wdef from inside the GC, so it can't be in Lisp at that time.(defclass lisp-wdef-mixin () ())(defclass windoid (window lisp-wdef-mixin)   ((show-on-resume-p :initform nil))  (:default-initargs    :window-do-first-click t    :window-type :windoid))(defun get-window-event-handler ()  (window-event-handler (front-window :include-windoids t)))(defvar *windoid-count* 0)(def-ccl-pointers clos-window ()  (let ((window (find-class 'window)))    (set-class-slot-value window 'window-cursor *arrow-cursor*)    (let ((rect (#_NewPtr 8)))      (#_SetRect rect 32 32 32767 32767)      (set-class-slot-value window 'window-grow-rect rect))    (let ((rect (#_NewPtr 8)))      (#_BlockMove (rref (%getport) grafport.portbits.bounds) rect 8)      (#_InsetRect rect 4 4)      (set-class-slot-value window 'window-drag-rect rect)))  ; Initialized for real in sysutils  (setq *setgworld-available?* nil *screen-gdevice* nil))(defmethod print-object ((w window) stream)  (print-unreadable-object (w stream :identity t)    (format stream "~a ~s"            (class-name (class-of w))             (window-title w))))(defmethod view-get ((w simple-view) key &optional default)  (let ((cell (assq key (view-alist w))))    (if cell      (cdr cell)      default)))(defmethod view-put ((w simple-view) key value)  (let ((cell (assq key (view-alist w))))    (if cell      (setf (cdr cell) value)      (unless (null value)        (push (cons key value) (view-alist w))))    value))(defmethod (setf view-get) (value (w simple-view) key)  (view-put w key value))(defmethod view-remprop ((w simple-view) key)  (setf (view-alist w)        (delete key (view-alist w) :test #'(lambda (x y) (eq x (car y))))))(defmethod set-view-container ((w window) container)  (unless (null container)    (error "Container must always be ~s for windows." nil))); Note: this can't be an :after method because some of its user's change; its args and I'm avoiding :around methods.(defmethod instance-initialize ((window window) &rest initargs &key                                (erase-anonymous-invalidations t))  (declare (dynamic-extent initargs))  (setf (view-valid window) (list nil))  (view-allocate-clip-region window)  (when erase-anonymous-invalidations    (setf (window-invalid-region window) (#_newrgn)))  (call-next-method)  (without-interrupts   (let* ((wptr (wptr window)))     (unwind-protect       (progn         (apply #'window-make-parts window initargs)         (install-window-object window)         (apply #'initialize-window window initargs)         (setq wptr t))       (if (null wptr)         (window-close window)))))); This is an after method so that the subviews will get added before the window; is shown.(defmethod instance-initialize :after ((window window) &key (window-show t))  (window-size-parts window)  (when window-show    (window-show window)))(defvar *window-type-procid-alist* '((:document . 4)   (:movable-dialog . 5)   (:document-with-grow . 0)   (:document-with-zoom . 8)   (:tool . 16)   (:double-edge-box . 1)   (:single-edge-box . 2)   (:shadow-edge-box . 3)))(defvar *window-type-foos*   '(member :document :movable-dialog :document-with-grow :document-with-zoom    :tool :double-edge-box :single-edge-box :shadow-edge-box)); stash back-color in its slot(defmethod window-make-parts ((window window)                              &key (view-position (view-default-position window))                                   (view-size (view-default-size window))                                   (window-type :document-with-zoom)                                   back-color                                   content-color                                   procid                                   (window-title "Untitled")                                   (close-box-p t)                                   (color-p t)                                   (grow-icon-p nil gip?))  (unless (wptr window)    (if procid (setq gip? nil grow-icon-p nil))    (when gip?      (if grow-icon-p        (cond ((eq window-type :document) (setq window-type :document-with-grow))              ((not (or (eq window-type :document-with-grow)                        (eq window-type :document-with-zoom)))               (setq gip? nil grow-icon-p nil)))        (cond ((eq window-type :document-with-grow)               (setq window-type :document))              ((not (or (eq window-type :document)                        (eq window-type :document-with-zoom)))               (setq gip? nil grow-icon-p nil)))))    (let* ((wptr (%new-window (or procid window-type)                              view-position                              view-size                              close-box-p                              nil                              color-p))           (procid (rref wptr windowrecord.refCon)))   ; %new-window leaves it there      (setf (wptr window) wptr)      (set-window-title window window-title)      (setf (slot-value window 'grow-icon-p)            (if gip? grow-icon-p (or (eq procid 0) (eq procid 8))))      (when content-color        (set-part-color window :content content-color)        ;(set-part-color window :title-bar *white-color*) doesnt help        )      (when back-color        (setf (slot-value window 'back-color) back-color)  ; <<        (set-back-color window back-color)))))(defmethod view-default-position ((w window))  *window-default-position*)(defmethod view-default-size ((w window))  *window-default-size*); Same as add-points, but limits the resulting dimensions; to (signed-byte 16) range, similar to what the old add-points used to do.(defun add-points-16 (pt1 pt2)  (let ((h (+ (point-h pt1) (point-h pt2)))        (v (+ (point-v pt1) (point-v pt2))))    (make-point     (min (max h -32768) 32767)     (min (max v -32768) 32767))))(defun %new-window (type position size close-box-p visible-p color-p)  ;Leaves the procid in RefCon.  (unless (fixnump type)    (setq type (or (cdr (assoc type *window-type-procid-alist*))                   (report-bad-arg type *window-type-foos*))))  (setq position (center-window size position))  (rlet ((wrect :rect :topleft position :bottomright (add-points-16 position size))         (tp (:string 2)))    (%put-word tp #x0120)    (let ((res (if (and color-p *color-available*)                 (#_NewCWindow                   (%null-ptr)                  wrect                            ; bounds                  tp                               ; blank title                  visible-p                        ; visible                  type                             ; procid                  (%int-to-ptr -1)                 ; behind                  close-box-p                      ; goAwayFlag                  type                             ; refCon                  )                 (#_NewWindow                  (%null-ptr)                   wrect                            ; bounds                  tp                               ; blank title                  visible-p                        ; visible                  type                             ; procid                  (%int-to-ptr -1)                 ; behind                  close-box-p                      ; goAwayFlag                  type                             ; refCon                  ))))      (if (%null-ptr-p res)        (%err-disp #$MemFullErr)        res))))(defmethod default-window-layer ((w window))  *windoid-count*);This is invoked with window already created but still invisible.(defmethod initialize-window ((window window) &key view-font window-layer)  (when view-font    (set-initial-view-font window view-font))  (set-window-layer window (or window-layer (default-window-layer window)))  (window-size-parts window))(def-aux-init-functions window #'initialize-window #'window-make-parts); Get back the :window-type initarg; Doesn't work for windoids.(defmethod window-type ((window window))  (let ((procid (rref (wptr window) :windowrecord.refcon)))    (dolist (pair *window-type-procid-alist* procid)      (if (eq procid (cdr pair))        (return (car pair))))))(defmethod window-color-p ((window window))  (or (wptr-color-p (wptr window)))); seems to return t always?(defun wptr-color-p (wptr)  (let ((rowbytes (rref wptr :grafport.portbits.rowbytes)))    (and (%ilogbitp 15 rowbytes)    ; see IM V-49,50,52         (%ilogbitp 14 rowbytes))))(defun color-or-gray-p (view)  (when *color-available*    (let* ((w (view-window view))           (pos (view-position view))           (c (view-container view)))      (when c        (setq pos (add-points (view-position w) (convert-coordinates pos c w))))      (with-macptrs (ptr) (find-screen pos ptr)        (when (not (%null-ptr-p ptr))          (> (screen-bits ptr) 1))))))(defmethod window-menu-item ((w window) &aux (name (window-title w)))  (when (null (slot-value w 'my-item))    (setf (slot-value w 'my-item)           (make-instance 'windows-menu-menu-item :window w)))  (let* ((enable (and (window-shown-p w)                      (or (neq w (front-window))                          (not (window-active-p w))))))    (with-slot-values (my-item) w      (when (> (length name) 60) ; chosen at random sort of - doesnt send it left on powerbook        (setq name (%str-cat (%substr name 0 60) (string #\311))))      (set-menu-item-title my-item name)      (if enable (menu-item-enable my-item) (menu-item-disable my-item))      my-item)))(defmethod window-menu-item ((w da-window))  nil)(defun center-window (size position)  (if (numberp position)    position    (let* ((pos-h (%iasr 1 (%i- *screen-width*                                (point-h size))))           (pos-v (%iasr 1 (%i- *screen-height*                                (point-v size)))))      (cond ((eq position :centered)             (make-point pos-h pos-v))             (t (let* ((constraint (pop position))                      (amount (or (pop position) 0)))                 (case constraint                   (:top                    (make-point pos-h amount))                   (:bottom                    (make-point pos-h (- (- *screen-height*                                            amount)                                         (point-v size))))                   (:left                    (make-point amount pos-v))                   (:right                    (make-point (- (- *screen-width*                                      amount)                                   (point-h size))                                pos-v))                   (otherwise                    (report-bad-arg constraint '(member :top :bottom :left :right)))))))))); Method for general views is in lib;views.lisp(defmethod remove-view-from-window ((view simple-view))  (setf (wptr view) nil))(defvar *last-mouse-click-window* nil)(defmethod window-close ((w window))  (window-close-internal w))(defmethod window-close :around ((w window))  ; Killing the process may attempt to output on its window.  ; This prevents deadlock due to the *event-processor* holding  ; the window-process-queue during window-close.  (setf (slot-value w 'queue) nil)  (let ((p (window-process w)))    (cond ((or (null p)               (not (window-close-kills-process-p w p)))           (call-next-method))          (t (setf (window-process w) nil)             (cond ((eq p *current-process*)                    (process-interrupt *initial-process* #'finish-window-close w p)                    (suspend-current-process))                   (t (process-kill-and-wait p)                      (call-next-method)))))))(defun finish-window-close (w p)  (process-kill-and-wait p)  (window-close w))#| trying Bill's version above;(defmethod window-close :around ((w window))  (call-next-method)  ; Killing the process may attempt to output on its window.  ; This prevents deadlock due to the *event-processor* holding  ; the window-process-queue during window-close.  (setf (slot-value w 'queue) nil)  (let ((p (window-process w)))    (when p      (setf (window-process w) nil)      (cond ((not (window-close-kills-process-p w p)))            ((eq p *current-process*)             (process-interrupt *initial-process* #'process-kill-and-wait p)             (suspend-current-process "Closed"))            (t (process-kill-and-wait p))))))|#(defmethod window-close-kills-process-p :around ((window window) process)  (and process       (neq process *event-processor*)       (neq process *initial-process*)       (call-next-method)))(defmethod window-close-kills-process-p ((window window) process)  (declare (ignore process))  t)(defun window-close-internal (w &aux (wptr (wptr w)))  (when (eq w *last-mouse-click-window*)    (setq *last-mouse-click-window* nil))  (when wptr    (window-hide w)    (without-interrupts     (when (eq w *current-view*)       (focus-view nil))     (when (eq w *selected-window*)       (setq *selected-window* nil))     (remove-window-object wptr)     (remove-view-from-window w)     (let ((rgn (window-erase-region w)))       (when rgn         (setf (window-erase-region w) nil)         (#_DisposeRgn rgn)))     (let ((rgn (window-invalid-region w)))       (when rgn         (setf (window-invalid-region w) nil)         (#_DisposeRgn rgn)))     (unless (%ptr-eql wptr %temp-port%)       (with-port wptr         (#_ValidRect (rref wptr windowrecord.portrect))))     ; _DisposWindow is done by the GC.     (when (null *selected-window*)       (window-select (front-window)))     ))  nil)(defmethod view-size ((w window) &aux (wptr (wptr w)))  (subtract-points    (rref wptr windowrecord.portrect.bottomright)   (rref wptr windowrecord.portrect.topleft))); Overwritten by lib;views.lisp(defmethod window-size-parts ((w window)) ()); Real version in views.lisp(defmethod set-view-size ((w window) h &optional v)  (set-view-size-internal w h v))(defmethod set-view-size-internal ((w window) h &optional v &aux                                     (wptr (wptr w)))  (setq h (make-point h v))  (without-interrupts   (with-focused-view w     (invalidate-grow-icon w t)     (#_SizeWindow wptr (point-h h) (point-v h) t)     (setf (slot-value w 'view-size) h)     (window-size-parts w)     (invalidate-grow-icon w)))  h)(defmethod view-window ((view simple-view))  (or   (let ((wptr (wptr view)))     (and wptr (window-object wptr)))   ; During initialize-instance the window may not be on the *window-alist*   (let ((w view))     (loop       (if (or (null w) (typep w 'window))         (return w)         (setq w (view-container w)))))))(defmethod window-zoom-event-handler ((w window) msgw &aux                                      (wptr (wptr w)))  (without-interrupts   (with-macptrs ((wstate (pref wptr windowrecord.datahandle)))   ;  (%hput-long wstate (objvar window-zoom-position) 8)   ;  (%hput-long wstate (objvar window-zoom-size) 12))   (let* ((zoom-position (window-zoom-position w))          (br (add-points zoom-position (window-zoom-size w))))     (%hput-long wstate zoom-position 8)     (%hput-long wstate br 12))     (with-port wptr       (#_EraseRect (rref wptr :windowrecord.portRect))       (#_ZoomWindow wptr msgw nil))     (compute-view-region w (view-clip-region-slot w) nil)     (window-size-parts w)     nil)))#|(defmethod window-drag-event-handler ((w window) where)  (#_DragWindow (wptr w) where (window-drag-rect w))  (set-view-position w (view-position w)))|#(defmethod window-drag-event-handler ((w window) where &aux                                      rgn (wp (wptr w)) result)  (if (and (command-key-p) (pop-up-path-menu w where))    nil    (if (option-key-p)      (if (windoid-p w)        (set-window-layer w (1- *windoid-count*))        (set-window-layer w 9999))      (when (#_WaitMouseUp)        (with-macptrs ((wm (#_LMGetWMgrPort))                       (grayrgn (#_LMGetGrayRgn)))          (with-port wm            (#_SetClip grayrgn)            (#_ClipAbove wp)            (setq rgn *grow-icon-rgn*)            (#_CopyRgn (rref wp windowrecord.strucRgn) rgn)            (let ((drag-rect (window-drag-rect w)))              (setq result (#_DragGrayRgn rgn where drag-rect drag-rect 0 (%null-ptr)))))          (when (neq -32768 (point-h result))            (set-view-position             w             (add-points result (view-position w)))))        (when (control-key-p)          (let* ((windows (windows :class (class-of w)))                 (n 1))            (dolist (win windows)              (when (neq win w)(set-window-layer win n)(incf n)))))))))            (defparameter *sys-font-codes* nil)(defparameter *sys-font-spec* nil)(defun sys-font-spec ()  (let* ((ff (ash (#_LMGetSysFontFam) 16))         (ms (#_LMGetSysFontSize)))    (when (zerop ms)(setq ms 12))    (if (not *sys-font-codes*)      (setq *sys-font-codes* (cons ff ms) *sys-font-spec* (font-spec ff ms))      (if (and (eq (car *sys-font-codes*) ff)               (eq (cdr *sys-font-codes*) ms))        *sys-font-spec*        (progn          (rplacd (rplaca *sys-font-codes* ff) ms)          (setq *sys-font-spec* (font-spec ff ms)))))))  (defun pop-up-path-menu (w where)  (let ((file (window-filename w))        (x (point-h (%global-to-local (wptr w) where))))    (when file      (let* ((title (window-title w))             (twidth (+ 16 (string-width title (sys-font-spec))))             (wwidth (point-h (view-size w)))             (xtra (max 26 (floor (- wwidth twidth) 2)))             (title-max (min (- wwidth 26) (+ xtra twidth))))        (when (< xtra x title-max)          (let* ((file (pathname file))                 (dir (cons (file-namestring file)                            (reverse (cdr (pathname-directory file)))))                 (host (pathname-host file)))            (when (and host (neq host :unspecific))              (setq dir (nconc dir (list host))))            (let ((menu (make-instance 'pull-down-menu                         :menu-title ""                         :view-size #@(0 0)                         :view-container w                         :view-position (make-point (- xtra 5) -16)                         :menu-items (mapcar #'make-menu-item dir))))            (menu-select menu 0)            t)))))))      (defmethod window-grow-event-handler ((w window) where)  (let ((new-size (#_GrowWindow (wptr w) where (window-grow-rect w))))    (unless (%izerop new-size)      (set-view-size w new-size))))(defmethod window-close-event-handler ((w window))  (cond ((option-key-p)         (let ((class (class-of w)))           (dolist (w (nreverse (windows :class class :include-invisibles t)))             (if (eq (class-of w) class)               (window-close-nicely w)))))        ((control-key-p)         (view-put w :display-in-menu-when-hidden t)         (window-hide w))        (t (window-close w))))(defmethod display-in-windows-menu ((w window))  (or (window-shown-p w) (view-get w :display-in-menu-when-hidden)))(defvar *da-window-on-top* nil);;old function was susceptible to abort between setting wptr and getting ff and ms;;;would restore NIL instead of correct font codes;;Also don't have to refocus if view is same and font-view is nil -- Klmn(defmethod call-with-focused-view (view function &optional font-view)  (let* ((old-view *current-view*)         (old-font-view *current-font-view*)         wptr ff ms old-fonts)    (if (and (eq view old-view)             (or (null font-view)                 (eq font-view old-font-view)))      (funcall function view)      (unwind-protect        (progn          (when (and view (null old-font-view) font-view (setq wptr (wptr view)))            (multiple-value-setq (ff ms) (wptr-font-codes wptr))            (setq old-fonts t))          (focus-view view font-view)          (funcall function view))        (when (and (ok-wptr wptr) old-fonts)          (set-wptr-font-codes wptr ff ms))        (focus-view old-view old-font-view)))))(defmethod call-with-focused-view :around (view function &optional font-view)  (declare (ignore function font-view)           (dynamic-extent #'call-next-method))  (let* ((window (and view (view-window view)))         (queue (and window (window-process-queue window)))         (*current-view* *current-view*)         (*current-font-view* *current-font-view*))    (if (and queue (neq *current-process* (process-queue-locker queue)))      (if (eq *current-process* *event-processor*)        (unwind-protect          (progn             (unless (window-process-enqueue-with-abort *application* view queue)              (error "Couldn't process-enqueue"))            (call-next-method))          (process-dequeue queue nil nil))        (with-process-enqueued (queue nil nil nil)          (call-next-method)))      (call-next-method)))); We need some way to allow the *event-processor* to usurp a window lock.; Otherwise, if some process holds onto a window lock for too long,; the machine will lock up.; Every 15 ticks, we look for an abort event. If we find one,; we attempt to abort the offending process. If that doesn't work, we; usurp the lock.; I don't know that it will ever be useful for someone to specialize; these methods, though I can imagine that a debugged application; would want to just process-enqueue with no abort.(defmethod window-process-enqueue-with-abort (application view queue &optional                                                (timeout 15))  (let ((tried-abort-p nil))    (loop      (when (process-enqueue-with-timeout queue timeout)        (return t))      (let ((locker (process-queue-locker queue)))        (when locker          (when (eq tried-abort-p locker)            (return (window-process-enqueue-usurping application view queue)))          (when (abort-event-pending-p)            (#_FlushEvents #x003F 0)            (setq tried-abort-p locker)            (interactive-abort-in-process locker)))))))        (defmethod window-process-enqueue-usurping (application view queue)  (declare (ignore application view))  (process-enqueue-with-timeout queue :usurp)); These two methods are redefined in "ccl:lib;views.lisp"(defmethod focus-view ((view null) &optional font-view)  (declare (ignore font-view))  (set-gworld %temp-port%)  (setq *current-view* nil))(defmethod focus-view ((view simple-view) &optional font-view)  (declare (ignore font-view))  (without-interrupts   (let* ((wptr (wptr view)))     (if wptr       (progn         (set-gworld wptr)         (#_SetOrigin 0 0)         (#_ClipRect (rref wptr windowrecord.portrect))         (setq *current-view* view))       (focus-view nil))))); Initialized in ccl:lib;views.lisp(defvar *screen-gdevice* nil)(defvar *setgworld-available?* nil); Destructively modifies the two macptr args(defun get-gworld (port gdh)  (if *setgworld-available?*    (rlet ((portp :ptr)           (gdhp :ptr))      (#_GetGworld portp gdhp)      (%setf-macptr port (%get-ptr portp))      (%setf-macptr gdh (%get-ptr gdhp)))    (%setf-macptr port (%getport))))(defun set-gworld (port &optional (device *screen-gdevice*))  (when (ok-wptr port)    (if *setgworld-available?*      (#_SetGWorld port device)      (%setport port)))); WITH-PORT expands into a call to this function(defun call-with-port (port thunk)  (with-macptrs (saved-port saved-device)    (without-interrupts     (unwind-protect       (let ((%temp-port% port)             (*current-view* nil)             (*current-font-view* nil))         (get-gworld saved-port saved-device)         (set-gworld port)         (funcall thunk))       (set-gworld saved-port saved-device)))))(defmethod view-activate-event-handler ((v simple-view))); This is a :before method to make it unlikely to be user-shadowed.(defmethod view-activate-event-handler :before ((w window))  (view-remprop w :display-in-menu-when-hidden)  (when *foreground*    (hilite-wptr (wptr w) t)    (window-draw-grow-icon w)))(defmethod view-activate-event-handler ((w window))  (setq *da-window-on-top* nil)  (unless (or (not *foreground*) (window-active-p w))    (setf (window-active-p w) t)    (call-next-method)    (let ((key (current-key-handler w)))      (when key        (dolist (v (key-handler-list w))          (when (and (neq v key)                     (not (view-contains-p v key)))            (view-deactivate-event-handler v)))))))#|(defmethod window-activate-controls ((w window))  (with-macptrs ((hCtl (rref (wptr w) windowrecord.controllist)))    (until (%null-ptr-p hCtl)      (#_ShowControl hCtl)      (%setf-macptr hCtl (rref hCtl controlrecord.nextcontrol)))))|#(defmethod view-deactivate-event-handler ((v simple-view))); This is a :before method to make it unlikely to be user-shadowed.(defmethod view-deactivate-event-handler :before ((w window))  (let ((wptr (wptr w)))    (when wptr      (hilite-wptr wptr nil)      (window-draw-grow-icon w))))(defmethod view-deactivate-event-handler ((w window))  (let ((wptr (wptr w)))    (when wptr      (when (window-active-p w)        (setf (window-active-p w) nil)        (call-next-method)))))          ; deactivate subviews(defun funcall-with-foreign-window (thunk)  (without-event-processing    (let ((w *selected-window*))      (when w        (view-deactivate-event-handler w))      (unwind-protect        (funcall thunk)        (when (setq w *selected-window*)          (view-activate-event-handler w))))))#|(defmethod window-deactivate-controls ((w window))  (with-macptrs ((hCtl (rref (wptr w) windowrecord.controllist)))    (until (%null-ptr-p hCtl)      (#_HideControl hCtl)      (%setf-macptr hCtl (rref hCtl controlrecord.nextcontrol)))))|#(declaim (special *window-update-wptr*))(unless (fboundp 'get-back-color)  ; Overwritten by color.lisp  (defmethod get-back-color ((w window)) nil))(unless (fboundp 'set-back-color)  ; Overwritten by color.lisp  (defmethod set-back-color ((w window) c &optional d)(declare (ignore c d)) nil))(defmethod window-update-event-handler ((w window) &aux (wp (wptr w)))  (without-event-processing ;(let-globally ((*processing-events* *current-process*))       ; uninterruptable by events    (with-focused-view w      (let ((rgn (window-erase-region w))            (invalid-rgn (window-invalid-region w)))        (when rgn          (#_InvalRgn rgn))        (when *window-update-wptr*          (#_EndUpdate *window-update-wptr*)          (setq *window-update-wptr* nil))        (unwind-protect          (progn            (#_BeginUpdate wp)            (setq *window-update-wptr* wp)            (when invalid-rgn              (#_DiffRgn (rref wp :windowrecord.visRgn) invalid-rgn invalid-rgn)              (if rgn                (progn                  (#_UnionRgn rgn invalid-rgn rgn)                  (#_SetEmptyRgn invalid-rgn))                (setq rgn invalid-rgn)))            (when rgn               (#_EraseRgn rgn)              (#_SetEmptyRgn rgn))            (view-draw-contents w))          (when (setq wp *window-update-wptr*)            (setq *window-update-wptr* nil)            (#_EndUpdate wp)))))))#|(defun get-rect (h)  (with-dereferenced-handles ((p h))    (let ((r (pref p region.rgnbbox)))      (list (pref r rect.top)            (pref r rect.left)            (pref r rect.bottom)            (pref r rect.right)))))|#(defmethod view-draw-contents ((v simple-view)))(defmethod view-draw-contents :before ((w window))    (window-draw-grow-icon w))#|(defmethod window-draw-controls ((w window) &aux (wptr (wptr w)))  (when wptr    (with-focused-view w      (#_DrawControls wptr)      (with-macptrs ((hCtl (rref wptr windowrecord.controllist)))        (until (%null-ptr-p hCtl)          (validate-control hCtl)          (%setf-macptr hCtl (rref hCtl controlrecord.nextcontrol)))))))|#; Overwritten by color.lisp(defun color-green (color)  (declare (ignore color))  0)(defun color-blue (color)  (declare (ignore color))  0)(defun color-red (color)  (declare (ignore color))  0)#| ; Need to use _DrawGrowIcon so System 7's color grow icon will draw correctly.(defmethod window-draw-grow-icon ((w window) &aux (wptr (wptr w)))  (if (window-grow-icon-p w)    (rlet ((trect :rect))      (grow-icon-rect w trect)      ;(%put-long trect (%i+ #x-f000f bot-right))      ;(print-record trect :rect)      (if (rref wptr windowrecord.hilited)        (with-fore-color (getf (window-color-list w) :grow-icon *black-color*)          (#_CopyBits *grow-bm* (rref wptr windowrecord.portbits) (%inc-ptr *grow-bm* 6) trect 0 (%null-ptr)))        (with-port wptr          (incf (rref trect :rect.right))          (incf (rref trect :rect.bottom))          (#_FrameRect trect)          (#_InsetRect trect 1 1)          (#_EraseRect trect)))      (#_ValidRect trect)      )))|#; We don't draw anything but the little square in the lower-right-hand corner.(defmethod window-draw-grow-icon ((w window) &aux (wptr (wptr w)))  (when (and wptr (window-grow-icon-p w))    (without-interrupts     (let* ((cliprgn (rref wptr :windowrecord.cliprgn))            (save-rgn *grow-icon-rgn*))       (declare (dynamic-extent cliprgn)                (type macptr cliprgn))       (multiple-value-bind (tl br) (grow-icon-corners w)         (declare (dynamic-extent cliprgn))         (#_CopyRgn cliprgn save-rgn)         (unwind-protect           (progn             (#_SetRectRgn cliprgn (point-h tl) (point-v tl) (point-h br) (point-v br))             (#_DrawGrowIcon wptr))           (#_CopyRgn save-rgn cliprgn)))))))#|; Surround by with-port or with-focused-view or you will lose.(defmethod window-invalidate-controls ((w window) &aux (wptr (wptr w)))  ;;Invalidates any control rectangles in a window  (invalidate-grow-icon w t)  (with-macptrs ((hCtl (rref wptr windowrecord.controllist)))    (until (%null-ptr-p hCtl)      (invalidate-control hCtl t)      (%setf-macptr hCtl (rref hCtl controlrecord.nextcontrol)))))|#(defun control-rect (control &optional (rect (make-record :rect)))  (rset rect rect.topleft (rref control controlrecord.contrlrect.topleft))  (rset rect rect.bottomright (rref control controlrecord.contrlrect.bottomright))  rect)#|;; Must surround this with a with-port or you will lose badly.(defun invalidate-control (control &optional erase-p)  (let* ((port (%getport))        (w (window-object port)))    (declare (dynamic-extent port))    (if w      (invalidate-corners w                          (rref control :controlrecord.contrlrect.topleft)                          (rref control :controlrecord.contrlrect.bottomright)                          erase-p)      (rlet ((rect :rect))        (control-rect control rect)        (if erase-p (#_EraseRect rect))        (#_InvalRect rect))))); ditto(defun validate-control (control)  (let* ((port (%getport))        (w (window-object port)))    (declare (dynamic-extent port))    (if w      (validate-corners w                         (rref control :controlrecord.contrlrect.topleft)                        (rref control :controlrecord.contrlrect.bottomright))      (rlet ((rect :rect))        (control-rect control rect)        (#_ValidRect rect)))))|#; Overwritten by views.lisp(defmethod invalidate-corners ((view simple-view) topleft bottomright &optional                                erase-p)  (declare (ignore erase-p))  (rlet ((rect :rect :topleft topleft :bottomright bottomright))    (#_InValRect rect))); Also overwritten(defmethod validate-corners ((view simple-view) topleft bottomright)  (rlet ((rect :rect :topleft topleft :bottomright bottomright))    (#_ValidRect rect)))#|(defun grow-icon-rect (w &optional (rect (make-record :rect)))  (multiple-value-bind (top-left bot-right) (grow-icon-corners w)    (rset rect rect.bottomright bot-right)    (rset rect rect.topleft top-left)    rect))|#(defun grow-icon-corners (w)  (let ((wptr (wptr w)))    (let ((bot-right (rref wptr windowrecord.portrect.bottomright)))      (values (subtract-points bot-right #@(15 15))              bot-right))))(defmethod invalidate-grow-icon ((w window) &optional erase-p)  (when (window-grow-icon-p w)    (with-focused-view w      (multiple-value-bind (topleft botright) (grow-icon-corners w)        (invalidate-corners w topleft botright erase-p))))); overwritten by lib;dialogs.(defmethod view-key-event-handler ((w window) char)  (let ((w *top-listener*))    (when w      (view-key-event-handler *top-listener* char))))(defmethod view-click-event-handler ((view simple-view) where)  (declare (ignore where))  view)(defmethod stream-tyo ((v simple-view) char)  (if (eq char #\Return)    (view-terpri v)    (with-font-focused-view v      (#_DrawChar char))))(defun grafport-write-long-string (string start end)  (let* ((chunk (if (extended-string-p string) 127 255))         (n (ceiling (- end start) chunk)))    (dotimes (i n)      (with-pstr (pstr string start (min end (+ start chunk)))        (#_drawstring pstr))      (setq start (+ start chunk)))))(defmacro grafport-write-string (string start end)  (let ((pstr (gensym)))    `(if (> (byte-length ,string nil ,start ,end) 255)       (grafport-write-long-string ,string ,start ,end)       (with-pstr (,pstr ,string ,start ,end)         (require-trap #_DrawString ,pstr)))))(defmethod stream-write-string ((v simple-view) string start end)  (multiple-value-bind (string offset) (array-data-and-offset string)    (declare (fixnum offset))    (let ((start (+ offset (require-type start 'fixnum)))          (end (+ offset (require-type end 'fixnum)))          middle)      (declare (fixnum start end))      (with-font-focused-view v        (loop          (setq middle (%str-member #\newline string start end))          (grafport-write-string string start (or middle end))          (if middle            (progn              (view-terpri v)              (setq start (1+ middle)))            (return)))))))(defmethod view-terpri ((v simple-view))  "does the best it can at doing a generic carriage return"  (with-font-focused-view v    (let* ((wptr (wptr v))           (cur-pos (rref wptr windowrecord.pnloc)))      (multiple-value-bind (ascent descent widmax leading) (font-info)        (declare (ignore widmax))        (#_Moveto 5 (+ (point-v cur-pos)                       ascent descent leading))))))(defmethod stream-force-output ((w window))  (let ((key (current-key-handler w)))    (when key (stream-force-output key))))(defmethod view-mouse-position ((v simple-view))  (with-focused-view v    (%stack-block ((pt 4))      (#_GetMouse pt)      (%get-long pt))))(defmethod view-mouse-position ((v null))  (with-port %original-temp-port%    (%stack-block ((pt 4))      (#_GetMouse pt)      (%get-long pt)))); double-click-patch.lisp(defmethod window-select-event-handler ((w window))  (unless (window-do-first-click w)    (setq *last-mouse-down-time* 0))  (window-select w))(defmethod window-select ((w null))  ; Sometimes (front-window) is nil  (let ((w (front-window)))    (if w      (window-select w)      (progn        (setq w *selected-window*)        (when w          (view-deactivate-event-handler w)          (setq *selected-window* nil))))))(defmethod window-select ((w window))  (setq *last-mouse-click-window* w)  (if (eq w *selected-window*)    (unless (window-active-p w)      (view-activate-event-handler w))    (let ((wptr (wptr w)))      (when *selected-window*        (view-deactivate-event-handler *selected-window*))      (autoposition-show w wptr)      (setq *selected-window* nil)      (reselect-windows)      (if *last-windoid*        (window-send-behind wptr (wptr *last-windoid*) t)        (window-bring-to-front w))      (setq *selected-window* w)      (view-activate-event-handler w)      (when (getf *environs* :color-quickdraw)        (#_ActivatePalette wptr))       ; #_SelectWindow does this      (menu-update (edit-menu)))))(defmethod window-select ((w da-window))  (let ((selected *selected-window*)        (wptr (wptr w)))    (unless (eq w selected)      (autoposition-show w wptr)      (setq *selected-window* w)      (#_SelectWindow wptr)      (unselect-windows t)))  w)(defun window-bring-to-front (w &optional (wptr (wptr w)))  (when (and w wptr)    (if (typep (front-window :include-windoids t) 'da-window)      (#_SelectWindow wptr)      (#_BringToFront wptr))))        (defmethod window-layer ((w window) &optional include-invisibles)  (without-interrupts   (let* ((wp (wptr w)) (count 0))     (when wp       (do-wptrs w         (when (%ptr-eql w wp) (return))         (when (or include-invisibles (rref w windowrecord.visible))           (setq count (%i+ count 1))))       count))))(defmethod set-window-layer ((w window) new-layer &optional include-invisibles)  (without-interrupts   (let* ((wptr (wptr w)))         (when wptr      (let* ((visible? (rref wptr windowrecord.visible)))        (if (<= new-layer 0)          (with-macptrs ((fw (#_FrontWindow)))   ; this is the modal dialog case            (unless (%ptr-eql wptr fw)              (window-bring-to-front w wptr)              (when visible?                (unselect-windows t)                (setq *selected-window* w)                (view-activate-event-handler w))))          (let ((selected *selected-window*))            (if (set-window-layer-internal                  w (max *windoid-count* new-layer) include-invisibles)              (when (eq w selected)                (let ((new-selected (front-window)))                  (unless (eq w new-selected)                    (view-deactivate-event-handler w)                    (setq *selected-window* new-selected)                    (view-activate-event-handler new-selected))))              (unless (or (not visible?) (eq w selected))                (view-deactivate-event-handler selected)                (setq *selected-window* w)                (view-activate-event-handler w)))))))))); selects a da if it is briught in front of all non-windoids.; This (defmethod set-window-layer ((w da-window) new-layer &optional include-invisibles)  (if (and (<= new-layer *windoid-count*) (window-shown-p w))    (progn (window-select w) 0)    (progn      (if (eq w *selected-window*)        (reselect-windows))      (set-window-layer-internal w new-layer include-invisibles)      new-layer))); Will fail on trying to set the layer to 0.; Returns nil unless this window was sent behind the selected-window(defun set-window-layer-internal (w new-layer include-invisibles)  (let ((layer 0)        (wptr (wptr w))        (closerp t)        (selected-wptr (and *selected-window* (wptr *selected-window*)))        behind-selected?)    (with-macptrs ((wp (#_LMGetWindowList))                   last-wp)      (do () ((%null-ptr-p wp))        (if (and selected-wptr (%ptr-eql wp selected-wptr))          (setq behind-selected? t))        (if (%ptr-eql wptr wp)          (setq closerp nil)          (progn            (%setf-macptr last-wp wp)            (when (or include-invisibles (rref wp windowrecord.visible))              (when (>= (incf layer) new-layer)                (return)))))            ; return from do.        (%setf-macptr wp (rref wp windowrecord.nextwindow)))      (unless (or (%null-ptr-p last-wp)                  (%ptr-eql wptr (rref last-wp windowrecord.nextwindow)))        (window-send-behind wptr last-wp closerp)))    behind-selected?))(defun window-send-behind (wptr behind-wptr closerp &aux rgn)  (with-macptrs ((behind-behind-wptr (pref behind-wptr :windowRecord.NextWindow)))    (unless (eql wptr behind-behind-wptr)      (if (and (not *help-manager-present*)     ; system 7 does this for us.               closerp)        (with-focused-view nil            ; _PaintOne plays with the origin.          (setq rgn *grow-icon-rgn*)          (#_CopyRgn (rref wptr windowrecord.visrgn) rgn)          (let* ((topleft (rref (rref wptr windowrecord.contrgn) region.rgnbbox.topleft)))            (#_OffsetRgn :ptr rgn :long topleft))          (#_DiffRgn  (rref wptr windowrecord.strucrgn) rgn rgn)          (#_SendBehind wptr behind-wptr)          (#_CalcVisBehind wptr rgn)          (#_PaintOne wptr rgn))        (#_SendBehind wptr behind-wptr)))))(defun autoposition-show (w wptr)  (autoposition w)  (#_ShowHide wptr t))(defmethod autoposition ((w window))  (unless (window-shown-p w)    (let ((info (cdr (assq (slot-value w 'auto-position)                           (cdr autopos-constraints)))))      (when info        (let ((front-window (front-window)))          (multiple-value-bind (parent-size parent-pos screen-p)                               (case (second info)                                 (:main-screen (values *screen-size* #@(0 0) t))                                 (:parent-window (if front-window                                                   (values (view-size front-window)                                                           (view-position front-window))                                                   (values *screen-size* #@(0 0))))                                 (:parent-window-screen (if front-window                                                          (let ((screen (window-screen front-window)))                                                            (values (screen-size screen)                                                                    (screen-position screen)                                                                    t))                                                          (values *screen-size* #@(0 0) t))))            (let* ((our-size      (view-size w))                   (our-height    (point-v our-size))                   (parent-width  (point-h parent-size))                   (parent-height (point-v parent-size))                   (parent-h      (point-h parent-pos))                   (parent-v      (point-v parent-pos))                   (pos-h (max parent-h                               (%i+ parent-h (%iasr 1 (%i- parent-width                                                           (point-h our-size))))))                   (pos-v (%i+ parent-v (%iasr 1 (%i- parent-height                                                      our-height)))))              (set-view-position               w (case (first info)                   (:stagger                    (cond ((not screen-p)                           (add-points #@(10 10) parent-pos))                          ((and front-window                                (memq (slot-value front-window 'auto-position)                                      '(:staggerMainScreen                                        :staggerParentWindow                                        :staggerParentWindowScreen)))                           (add-points #@(10 10) (view-position front-window)))                          (t (add-points parent-pos                                         (make-point 2 (%i+ (menubar-height)                                                            (window-title-height w)))))))                                      (:center                    (make-point pos-h (max parent-v pos-v)))                   (:alert-pos                    (make-point pos-h                                (max parent-v                                     (%i+ parent-v                                          (round (%i- parent-height our-height)                                                 5))))))))))))))(defmethod window-screen ((w window))  (let ((position (view-position w)))    (rlet ((rect :rect :topleft position                 :bottomright (add-points position (view-size w))))      (#_GetMaxDevice rect))))(defmethod window-show ((w window))  (let ((wptr (wptr w)))    (when (and (ok-wptr wptr)               (not (rref wptr windowrecord.visible)))      (window-show-internal w wptr)))  w)(defmethod window-show-internal ((w window) wptr)  (let ((selected *selected-window*))    (cond ((or (null selected)               (wptr-behind-p (wptr selected) wptr))           (cond ((and (> *windoid-count* 0)                       (do-wptrs w                         (return (%ptr-eql w wptr))))                  (unselect-windows t)                  (autoposition-show w wptr)                  (setq *selected-window* w)                  (view-activate-event-handler w))                 (t (window-select w))))          (t (autoposition-show w wptr)))))(defmethod window-hide ((w window))  (#_ShowHide (wptr w) nil)  (when (eq w *selected-window*)    (window-select (front-window)))); True if wptr is behind behind(defun wptr-behind-p (wptr behind)  (with-macptrs ((w (rref behind windowrecord.nextwindow)))    (do () ((%null-ptr-p w) nil)      (if (%ptr-eql wptr w) (return t))      (%setf-macptr w (rref w windowrecord.nextwindow)))))(defmethod window-shown-p ((w window) &aux wptr)  (and (setq wptr (wptr w))       (rref wptr windowrecord.visible)))(defmethod view-position ((w window) &aux (wptr (wptr w)))  (%local-to-global wptr (rref wptr windowrecord.portrect.topleft)))(defmethod set-view-position ((w window) h &optional v)  (cond ((numberp h)         (setq h (make-point h v))         (#_MoveWindow (wptr w) (point-h h) (point-v h) nil)         h)        (t (set-view-position w (center-window (view-size w) h)))))#|(defmethod window-title ((w window) &aux wptr);Note - the stuff below compares the window's Pascal title string with;it's object-name slot.  If they are identical strings, it returns the ;object-name string.  This avoids consing and makes the result of window-title;eq to the object-name. Seems silly to me.   (or (and (setq wptr (slot-value-if-bound w 'wptr))           (or             (let ((title (slot-value w 'object-name)))              (and title                   ; what if its in some weird script - fred-window method deals with script                   (with-macptrs ((wtitle (pref wptr windowrecord.titlehandle)))                     (let ((len (length title)))                       (if (neq len (%hget-byte wtitle 0))                         nil                          (dotimes (i len title)                           (when (not (eql (%scharcode title i)(%hget-byte wtitle (+ 1 i))))                             (return nil))))))))            (rlet ((tp (:string 255)))                 (#_GetWTitle  wptr tp)                 (%get-string tp))))      "<No title>"))|#; nearly same as for fred-window(defmethod window-title ((w window) &aux wptr nm)  (or (slot-value w 'object-name)      (and (setq wptr (wptr w))           (let* ()             (%stack-block ((np 256))               (#_getWTitle wptr np)               (setq nm                     (%str-from-ptr-in-script  (%inc-ptr np 1) (%get-byte np 0)))               (setf (slot-value w 'object-name) nm))))      "<No title>" ))(defmethod set-window-title ((w window) new-title)  (let ((wptr (wptr w)))    (setq new-title (ensure-simple-string (string-arg new-title)))    (%stack-block ((np 256))      (let* ((script (#_GetScriptManagerVariable #$smSysScript))             (n (byte-length new-title script)))        (when (%i> n 255)          (error "Title ~S too long"  new-title))        (with-pointer (p np 1)          (%put-string-contents p new-title 255 script))        (%put-byte np n 0)        (#_SetWTitle wptr np)        (setf (slot-value w 'object-name) new-title)))    new-title))#|(defmethod set-window-title ((w window) new-title)  (with-pstrs ((np (setq new-title (ensure-simple-string new-title))))    (#_SetWTitle (wptr w) np)    (setf (slot-value w 'object-name) new-title)))|##|(defmethod view-font-codes ((w window))  (wptr-font-codes (wptr w)))|#(defmethod set-view-font-codes ((w window) ff ms &optional ff-mask ms-mask)  (declare (ignore ff ms ff-mask ms-mask))  (multiple-value-bind (new-ff new-ms) (call-next-method)    (let ((wptr (wptr w)))      (when wptr        (%put-long wptr new-ff 68)        (%put-long wptr new-ms 72)))    (values new-ff new-ms)))(defun wptr-font-codes (wptr)  (values (%get-long wptr 68) (%get-long wptr 72)))(defun grafport-font-codes ()  (let ((wptr (%getport)))    (declare (dynamic-extent wptr))    (values (%get-long wptr 68) (%get-long wptr 72))))(defun set-wptr-font-codes (wptr ff ms &optional ff-mask ms-mask)  (if ff-mask    (setq ff  (%ilogior2 (%ilogand2 ff ff-mask)                          (%ilogand2 (%get-long wptr 68) (%ilognot ff-mask)))))  (if ms-mask    (setq ms (%ilogior2 (%ilogand2 ms ms-mask)                         (%ilogand2 (%get-long wptr 72) (%ilognot ms-mask)))))  (%put-long wptr ff 68)  (%put-long wptr ms 72)  (values ff ms))(defun set-grafport-font-codes (ff ms &optional ff-mask ms-mask)  (let ((wptr (%getport)))    (declare (dynamic-extent wptr))    (set-wptr-font-codes wptr ff ms ff-mask ms-mask)))(defmethod stream-line-length ((v simple-view))  (multiple-value-bind (ascent descent widmax)                       (font-info (view-font v))    (declare (ignore ascent descent))    (floor (- (point-h (view-size v)) 20) ;always assumes that there is a                                         ;scroll bar. Not always correct                                        ;but little harm done if there isn't           widmax)))(defmethod window-filename ((w stream)) (stream-filename w));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                            DA-window                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod initialize-instance ((w da-window) &key)  (call-next-method)  (let ((rgn (window-erase-region w)))    (when rgn      (setf (window-erase-region w) nil)      (#_DisposeRgn rgn))    (when (setq rgn (window-invalid-region w))      (setf (window-invalid-region w) nil)      (#_DisposeRgn rgn))))(defmethod gcable-wptr-p ((w window))  t)(defmethod gcable-wptr-p ((w da-window))  nil)(defmethod view-clip-region ((w da-window))  *big-rgn*)(defmethod view-allocate-clip-region ((w da-window))  *big-rgn*)(defmethod Undo ((w da-window))  (#_SystemEdit 0))(defmethod Cut ((w da-window))  (#_SystemEdit 2))(defmethod Copy ((w da-window))  (#_SystemEdit 3))(defmethod Paste ((w da-window))  (put-external-scrap)  (#_SystemEdit 4))(defmethod Clear ((w da-window))  (#_SystemEdit 5)); since save-menu-item-update enables the item for any window with a; key handler, all windows should delegate the command(defmethod window-save ((w window))  (let ((handler (window-key-handler w)))    (when handler      (window-save handler))))(defmethod window-close ((w da-window) &aux refnum wptr)  (when (setq wptr (wptr w))    (setq refnum (rref wptr windowrecord.windowKind))    (flet ((do-it (wptr w)             (if (eq refnum (rref wptr windowrecord.windowKind))               (progn                 (remove-window-object wptr)                 (setf (wptr w) nil)                 (window-close w)))))                 (without-interrupts ; oh puke     (if  nil ;*window-object-hash*       (maphash #'do-it *window-object-hash*)              (dolist (elt *window-object-alist*)         (do-it (%car elt)(%cdr elt)))))     (#_CloseDeskAcc refnum))))(defmethod window-null-event-handler ((w da-window))  (unless *da-window-on-top*    (put-external-scrap)    (setq *da-window-on-top* t))  (let-globally ((*cursorhook* #'(lambda ())))    (call-next-method))  (#_systemtask));;;;;;;;;;;;;;;;(defmethod window-event ((w window))  ;Change part code to be an argument instead of stashing it away in the event record.  (let* ((event *current-event*)         (evtype (rref event eventrecord.what))         (where (rref event eventrecord.where))         (mods (rref event eventrecord.modifiers))         (part (%get-word event $evtPartCode))         (wptr (wptr w))         (active-p (window-active-p w)))    (when (typep wptr 'macptr)      (with-focused-view w        (with-font-codes nil nil          ; preserve the font codes.          (cond           ((eq evtype $MButDwnEvt)            (setq *last-mouse-click-window* w)            (when (or (and active-p                           (or (%ptr-eql wptr (#_FrontWindow))                               (eq w (front-window))))                      (and (eq part $inDrag)                           (or (%ilogbitp $cmdkey mods)                               (%ilogbitp $optionkey mods)))                      (progn (window-select-event-handler w)                             (window-do-first-click w)))              (cond ((or (eq part $inContent)                         (and (eq part $inGrow) (not (window-grow-icon-p w))))                     (view-click-event-handler w (%global-to-local wptr where)))                    ((eq part $inDrag)                     (window-drag-event-handler w where))                    ((eq part $inGrow)                     (window-grow-event-handler w where))                    ((eq part $inGoAway)                     (when (#_TrackGoAway wptr where)                       (window-close-event-handler w)))                    ((or (eq part $inZoomIn) (eq part $inZoomOut))                     (when (#_TrackBox wptr where part)                       (without-interrupts                        (window-zoom-event-handler w part)))))))           ((eq evtype $UpdatEvt) (unless (#_SystemEvent event) (window-update-event-handler w)))           (active-p            (cond ((eq evtype $nullEvt) (window-null-event-handler w))                  ((eq evtype $mButUpEvt) (window-mouse-up-event-handler w))                  ((eq evtype $keyUpEvt) (window-key-up-event-handler w))                  ((or (eq evtype $KeyDwnEvt) (eq evtype $AutoKeyEvt))                   (do-keydown-event w event mods))))           ((windoid-p w)            (let ((window-under (window-under w nil nil)))              (when window-under                (window-event window-under))))           ((or (eq evtype $keyDwnEvt) (eq evtype $AutoKeyEvt))            (do-keydown-event *application* event mods))))))))(defun window-under (w &optional include-invisibles (include-inactives t))  (with-macptrs ((wptr (%null-ptr)))    (%setf-macptr wptr (wptr w))    (loop      (%setf-macptr wptr (rref wptr :windowrecord.nextWindow))      (when (%null-ptr-p wptr) (return nil))      (when (or include-invisibles (rref wptr :windowRecord.visible))        (let ((res (window-object wptr)))          (when (and res (or include-inactives (window-active-p res)))            (return res)))))))(defvar *bufferred-char* nil)(defun do-keydown-event (w event &optional mods) ;(mods (pref event :eventRecord.modifiers)))  (declare (ignore mods))  (let ((char (%get-byte event $evtMessage-b))        (bc *bufferred-char*))    (if bc      (setq *bufferred-char* nil            char (+ (ash bc 8) char))      (progn ;unless (extended-character-p char)  ; this cant be right - itsa byte        (let ((table (get-char-byte-table (get-key-script))))          (when (and table (eql 1 (aref table char)))            (setq *bufferred-char* char)            (return-from do-keydown-event)))))    (view-key-event-handler w (%code-char char))))  (defmethod window-null-event-handler ((w window))  (update-cursor)  ;;;;  _WaitNextEvent does _SystemTask for us  ;(#_SystemTask)  )(defmethod window-mouse-up-event-handler ((w window)) ())(defmethod window-key-up-event-handler ((w window)) ())(defmethod view-cursor ((w window) point)  (declare (ignore point))  (window-cursor w)); Overwritten in views.(defmethod window-update-cursor ((w window) point)  (set-cursor (view-cursor w point)))(defmethod window-update-cursor ((w null) point)  (declare (ignore point))  (set-cursor *arrow-cursor*))#|	Change History (most recent last):	2	12/27/94	akh	merge with d13|# ;(do not edit past this line!!)