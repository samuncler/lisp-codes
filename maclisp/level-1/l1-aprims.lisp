;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  4 7/4/97   akh  see below;;  3 6/9/97   akh  see below;;  2 6/2/97   akh  see below;;  55 1/22/97 akh  optimizations for string and character comparisons;;  48 6/7/96  akh  lfun-keyvect for interpreted funs;;  46 5/20/96 akh  set-top-level - comment out require-type - dont rememeber why;;  44 3/27/96 akh  fix itlb resource thing;;  36 2/19/96 akh  fix element-type-subtype;;                  get subtype right in make-displaced-array;;  35 2/19/96 akh  %make-displaced-array - fix for rank 0;;  34 2/6/96  akh  fix char-sort-table for roman script;;  28 12/1/95 akh  simplify pstr/cstr segment-pointer;;  27 11/24/95 bill 3.0x43;;  25 11/20/95 slh ;;  24 11/19/95 gb  %make-displaced-array, %make-gcable-macptr fixes;;  22 11/15/95 gb  fix in make-displaced-array for PPC;;  21 11/14/95 gb  %list-to-uvector: don't pass null subtype to %alloc-misc;;  18 11/9/95 akh  delete ppc def of closure-function;;  16 10/31/95 akh add a blr;;                  put back 68k lap for move-string-bytes. The editor is slow enough already.;;  13 10/27/95 bill see below;;  12 10/27/95 akh %register trap and %stack trap aren't gonzo;;  11 10/27/95 akh damage control;;  10 10/26/95 gb  gcable-macptr changes;;  9 10/23/95 akh  lots of ppc stuff;;  8 10/17/95 akh  some delap, merge patches;;  7 10/11/95 akh  some lap substitutes for some lfun stuff;;  6 10/10/95 akh  move-string-bytes for PPC;;  3 10/9/95  akh  merge patches;;  (do not edit before this line!!);; L1-aprims.lisp; Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!; This file must be loaded in order to be compiled.;; Modification History;; 05/01/97 akh real-xstring-p checks extended-string-p before groveling down the string;----------- 4.1; 11/11/96 bill ppc-ff-call, ff-call-slep, & ff-call declare the;               foreign function call to be inline, just in case the;               user proclaims them notinline.; ------------- 4.0; 10/07/96 bill #-ppc-target version of defpascal-callback-p; 09/30/96 bill #-ppc-target version of ff-call doesn't use the compiler; ------------  4.0b2;  9/17/96 slh  supressed -> suppressed, but retain old names too; 07/02/96 slh  don't require lap for ppc; 06/22/96 bill %save-library has nicer stack overflow hysteresis.;               Remove warning about set-periodic-task-interval;;               it's neither documented nor referenced.; 06/14/96 bill %new-gcable-ptr; 06/20/96  gb  revive egc functions; *gc-event-status-bits* accessors.; akh lfun-keyvect for interpreted frobs; 06/04/96 bill fix apply; ------------- MCL-PPC 3.9; 04/08/96  gb  ensure %temp-cons and %apply-lexpr are fboundp.; 03/26/96  gb  lowmem accessors.; 03/20/96 bill quick and dirty applyv for Wood.; 03/17/96 gb   %save-library returns (values error lib-version).; 03/01/96 bill ff-call-slep; 02/20/96 gb   %save-library; 02/22/96 bill ff-call uses the compiler (invoking the ff-call compiler-macro).; 02/15/96 bill %make-displaced-array checks its fill arg for in bounds.;               Dummy versions of the EGC functions.; 01/16/96 bill %pascal-functions% has :INITIAL-ELEMENT of NIL; 01/03/96 gb   %make-displaced-array, element-subtype-type changes for PPC.; 01/03/95 bill first pass ppc-ff-call definition (calls COMPILE).; 12/21/95 bill PPC %lfun-vector now takes (and ignores) an optional second arg; 12/13/95 gb   GC and FULL-GCCOUNT for PPC.; 11/21/95 bill  make %set-toplevel do the right thing in a non-initial process.; 11/21/95 bill in %make-displaced-array, (fixnum 0 *) -> (and fixnum (integer 0 *)) in;               error case require-type (prevents an error in reporting the error).; 11/21/95 bill fix brain-damage in PPC %make-displaced-array; 11/16/95 bill dummy PPC versions of set-periodic-task-interval, periodic-task-interval,;               gc, egc-mmu-support-available-p to get rid of %currenta5 references; 11/17/95 slh   temp periodic-task stuff from Bill; 11/16/95 slh   Gary's bitset fixes to %make-displaced-array; 11/14/95 bill  Nuke the dummy PPC version of define-pascal-function.; 11/15/95 gb    PPC make-displaced-array: ensure "offset" fixnump.; 11/11/95 gb    gcable-macptr changes; allow use of %put-xx.; 11/10/95 bill  temporary PPC version of define-pascal-function for use until callbacks work.; 11/08/95 bill  #_getenvirons -> #_GetScriptManagerVariable; 11/01/95 bill  re-enable gestalt for the PPC; 10/26/95 slh   not-inline -> notinline; 10/25/95 bill  ppc-target versions of %stack-trap & %register-trap call compile.;                Need %stack-trap to compile "ccl:Library:new-file-dialogs.lisp"; 08/01/95 gb    call $flush_code_cache vice clrcache in %make-lfun.; 3/04/95 gb    %progvrestore didn't mean to say rplacd.;  5/25/95 slh   add %stack-block, %gen-trap to traps pkg;  5/22/95 slh   %str-to-handle: return handle from second clause;                import %ptr-to-int to traps pkg;  5/12/95 slh   added deftrap-inline to package frobs;  4/18/95 slh   %str-from-ptr-in-script: use *default-base-character*, not extended-character;                %cstr-segment-pointer: works for non-base strings (like pstr equivalent);  3/11/95 slh   gestalt takes optional bitnum arg;  3/05/95 slh   gb's fix to %progvrestore;  2/27/95 slh   string: better error for bad arg;     ?    alice today error if string too long for pascal string; 1/25/95 slh   comments indicate what to change for full defpascal longwords;-------------  3.0d16; 01/02/95 alice add char-word-break-p; 07/15/93 bill  make-char-byte-table now returns its result.;                char-byte-table entries are either 0 or 1, not #$smFirstByte; 07/14/93 bill  pointer-char-length returns 3rd value: stopped-in-middle-of-2-byte-char-p; -------------- 3.0d11; 07/10/93 alice str-char-length => pointer-char-length; 07/09/93 alice added pointer-to-string-in-script, some svref => aref; 07/02/93 alice messing about with scripts and string comparisons; 06/17/93 alice make-string heeds element type of initial element, string dtrt for chars; 06/16/93 alice %str-to-handle does fat strings; 06/14/93 alice added byte-length and str-char-length and %str-from-ptr-in-script;		 char-byte-table stuff comes here from l1-edbuf; 05/29/93 alice string-lessp return pos if true; 05/26/93 alice string-lessp do fat strings; char-upcase and downcase don't die if fat;----------------3.0d10; 05/06/93 bill GC tries until it succeeds: *pre-gc-hook* can cause a delay.;               full-gccount moves here from edit-callers.lisp; -------------- 3.0d8; 05/24/93 alice string, string= and string-equal and %pstr-pointer, %cstr-pointer, %pstr-segment-pointer; 05/23/93 alice move-string-bytes moved here for %str-cat; 05/22/93 alice %str-cat, %substr %str-member handle fat strings.; 05/22/93 alice moved extended-character-p and base-character-p here from chars; 05/08/93 alice added base-string-p and simple-base-string-p, and extended ditto; 05/03/93 alice make-string knows about extended-character, make him know more someday.;		 defaults to base-character which is not common lisp.;		 and character means base-character - also not CL; 		 stringp knows about extended-character strings; ------------- 2.1d6; 03/31/93 bill typo in equal-2 made it ignore lengths of bit-vectors.;               In the process, speed up EQUAL on bit-vectors by a factor of 80.; ------------ 2.1d5; ??	   alice char-upcase, downcase and string-equal are smaller; ------------ 2.1d4; 03/11/93 bill %register-trap now clears the cache.; 02/17/93 bill $sp-spreadX -> $sp-spreadX-vextend where appropriate.; 12/16/92 bill GB's fixes to nreverse & bit-vector-p; 12/02/92 bill %make-lfun no longer leaves an uninitialized byte at the beginning;               of the immediates map.; 11/25/92 bill gc-cursor-supressed-p & set-gc-cursor-supressed-p replace;               using-gc-cursor-p & use-gc-cursor-p; 10/09/92 bill set-fill-pointer calls tsignal_error with (fixnum $XNOFILLPTR);               instead of ($ $XNOFILLPTR); 07/06/92 bill GB's fix to EQUAL-2 makes EQUAL work for non-simple strings;               and bit-vectors.; 05/25/92 bill %stack-trap now handles up to 12 args. Used to do only 6.;               Will also error if it gets a bignum for the type bits arg.;------------- 2.0;Miscellaneous lap stuff moved out of the kernel.;01/03/92 gb   add EGC-CONFIGURATION.;01/02/92 gb   require non-zero e0size in configure-egc.;12/10/91 gb   fix %map-lfuns; add %non-empty-environment-p.  Change;              function-lambda-expression.;12/06/91 alice char-upcase, char-downcase, alpha-char-p deal with accented chars;----------- 2.0b4;11/20/91 bill debug ff-call & %gen-trap;11/04/91 gb   map-lfuns doesn't walk what gets consed after it starts.;10/14/91 bill (array-element-type (make-array 5 :element-type 'double-float));              is now DOUBLE-FLOAT, not FLOAT.;10/11/91 bill %make-initialized-uvector for use by %cons-nhash-vector;----------- 2.0b3;09/05/91 bill gestalt moves here from sysutils;08/30/91 gb   add configure-egc;08/24/91 gb   use new trap syntax.;08/07/91 bill bootstrapping #'(setf documentation);07/21/91 gb   flush page-type; add %gen-trap, ff-call, %temp-list, upgraded-complex-part-type.;              wtaerr fixes.  Fixup &lap arglists.  No more *save-link-maps*.;07/02/91 bill in %make-lfun - $lfatr-aplink-bit & $lfatr-aplink1-bit are no more;----------- 2.0b2;05/31/91 bill import some more stuff into the traps package;05/29/91 gb   update egc*.  New cons-area equates.;05/28/91 bill structurep moved here from sysutils.;05/22/91 alice %str-member gets optional start, end;05/20/91 gb   Allow 16-bit data register returns (:oserr) in %register-trap.;              USE-, USING-GC-CURSOR-P.  Eval-redef some more.;05/13/91 bill string-lessp comes here from lib;chars for bootstrapping l1-windows.;04/04/91 bill %cstr-segment-pointer, equal works for logical-pathname's;03/11/91 bill %%StringTwoArgs clobberred array arg for error message :end2 out of bounds.;03/05/91 alice report-bad-arg gets 2nd arg;03/04/91 bill add max-length arg to %str-to-handle;02/18/91 gb   schar, set-schar, uvsize, svref. svset now eval-redef'ed in level-2.;----------- 2.0b1;01/24/91 bill GB's patch to %make-lfun to detect >32K-word lfun vectors.;01/23/91 bill add optional new-value arg to lfun-attributes;01/09/90 bill change format of *def-accessor-types*;01/08/91 bill Move (defpackage traps ...) & *traps-package* here from lib;deftrap;12/31/90 gb   change %lfun-vector-lfun.;12/31/90 bill Add without-interrupts arg to define-pascal-function & defpascal-new-slot;12/19/90 gb   define-pascal-function sets $lfatr-resident-bit.;11/09/90 bill GB's fix to set-symbol-plist;10/25/90 gz   unsigned long vectors.;10/16/90 gb   call %%deref-sym-char-or-string here and there.;10/05/90 bill (signal_error ($ ...) ...) -> (signal_error (fixnum ...) ...);09/21/90 bill add-accessor-types;09/17/90 bill gc-event-check-enabled -> set-gc-event-check-enabled-p;09/06/90 bill nilreg-offset;08/27/90 gb  fix %map-lfuns again.;08/23/90 gb  bill's fix to set-symbol-plist.;08/10/90 gb   new package & plist accessors.  Fix symbol alignment assumptions;              in %nth-immediate, %make-lfun.  Eschew use of $symbol-header.;             %uvref/%uvset eval-redef'ed elsewhere.;07/18/90 alice do two arg LAST per Steele 2;07/04/90 bill new CLOS function type bits in lfun-keyvect;06/27/90 bill make lfun-keyvect use %nth-immediate for new method format.;06/22/90 bill %vector-member.;06/21/90 bill lfun-keyvect returns NIL if the $lfbits-gfn-bit is set;              (generic-function or combined-method).;06/10/90 gb  gc-event-check-enabled-p & gc-enable-event-check.;06/02/90 gb  %stack-trap handles :d0 selectors.;06/01/90 bill macptr-flags, set-macptr-flags;05/30/90 gb  Trap functions handle 32-bit values.;05/29/90 gb %vect-subtype & %vect-byte-size defined as functions here.;05/22/90 gb  No more symtagp.;05/14/90 gb  Move %%derefstring & %%deref-sym-or-string to l1-symhash.;04/14/90 gz  Made %substr take start/end args instead of start/length.;03/24/90 gz  Added upgraded-array-element-type.;04/30/90 gb  lap syntax; make-string accepts & ignores :element-type arg.;             make temp uvectors.  array subtype -> typespec accessor.;04/25/90 gb  they didn't end up as short branches in nreverse.;04/11/90 bill %pstr-segment-pointer for updated with-pstr;02/14/90 gz  Added %str-to-handle.;01/17/90 gz  Pass through attrib bits in %make-lfun. Added lfun-attributes.;             Check $lfatr-noname-bit in %lfun-vector-lfun-name-offset.;01/03/89 gz  uvectorp.  type-predicate for 'lfun-vector so typep/require-type works.;             %lfun-vector-lfun - note that this searches a5 space for swappable lfuns,;             so use with care.;01/05/89 bill defpascal-new-slot - Don't trust A5.;12/27/89 gz  setf package to support setf function specs.;12/21/89 gz  tweak in define-pascal-function for better dumping.;12/05/89 gb new lap for old.;12/04/89 gz  gvectorp.  Use %noforcestk in simple predicates.;11/16/89 gb applyv.;10/19/89 bill Added %lfun-vector-p;9/30/89  gz moved %lfun-vector to l1-utils.;9/28/89  gb unsigned short, byte vectors. ;09/27/89 gb simple-string -> ensure-simple-string.;09/21/89 bill in copy-uvector: (move.b (atemp1 $v_subtype) arg_y);              changed to:      (move.b (atemp0 $v_subtype) arg_y);9/14/89  gz $lfatr-slfunv-bit means there is an extra longword at end of lfun.;            %lfun-vector requires an lfun arg.;09/03/89 gz moved package accessors to l1-symhash.;            Don't assume %nilreg-{f,v}cell-symbols% covers entire nilreg space.;08/21/89 gz %cstr-pointer;08/06/89 gz %lfun-vector-lfun-name-offset.;05/31/89 gz added nilreg-cell-symbols;05/07/89 gb    allocvect,reservevect calls pass subtype in arg_y.;05/01/89 gb %stack-, %register- trap.;05/01/89 gz lfun link maps.;04/19/89 gz Added array-element-subtype, make-uvector,;            function-lambda-expression, coerce-to-compiled-function.;04/07/89 gb  $sp8 -> $sp.;3/25/89  gz %toplevel-function%. Number fns to l1-numbers.;            Added %immediate-offset. new defpascal stuff.;03/09/89 gz ash, byte, floor etc. logxxx etc. fns.  lfun-keyvect. %map-lfuns.;            Symbolic names for lfunish things.  %make-compiled-function takes;            displaced arrays, allows bignum bits (for some day).;03/03/89 gz min, max. %str-cat takes any number of args.;03/02/89 gb Added %set-toplevel. Use consZnil here and there, add GC.;02/23/89 gz Added %uvref, %uvset, %uvsize, array-dimension, array-dimensions,;            array-total-size, vector-pop, elt, set-elt, aref, aset, %make-uvector;            %make-compiled-function;02/12/89 gz real-arg -> $sp-real1chk.;01/03/89 gz %lfun-vector and %nth-immediate from compiler.;01/01/89 gb a5, heap, lfuns.;12/26/88 gz subtype in array headers. long and float arrays.;            Do typechecks inline in schar, svref.;12/7/88  gz pathnames are istructs now, in equal-2.;12/06/88 gz made EQUAL descend macptrs.;11/23/88 gb restore_regs mumbo-jumbo. lfun-bits -> l1-utils.;11/16/88 gb signal error for arg_z in %%derefstring.;11/12/88 gb removed ptr-accessors.;10/27/88 gb added equal, copy-tree, set-event-ticks, event-ticks, char-upcase,;            char-downcase.  Progv saves symbols, not locatives. $sp-xcxr ->$sp-ncxr.;            Some string functions moved here. $sp-seqarg -> $sp-seqarg-atemp0.;10/23/88 upload 8.9.;9/4/88   gb no cfp.; 8/27/88 gb %set-symbol-plist -> set-symbol-plist;9/2/88  gz added nreverse, reverse, nreconc, append, copy-uvector,;           %pstr-pointer, %str-from-ptr, %substr, %str-cat, make-string,;           array-element-type, array-rank, arrayp, vectorp, simple-vector-p,;           simple-string-p, stringp, bit-vector-p, displaced-array-p,;           adjustable-array-p,array-has-fill-pointer-p,fill-pointer,;           set-fill-pointer, %make-displaced-array, +,-,*,/,<,<=,>,>=,;           integerp, numberp, oddp, evenp, integer-length, logbitp.;           %SUBSTR now accepts non-simple strings.;8/25/88 gz added %str-length, %str-member, last, nconc, nthcdr, nth, cons,;	    page-type, %i*, svref, svset, schar, set-schar.;8/19/88 gz added =.;8/10/88 gz added %symbol-locative-symbol, package accessors, zerop, plusp, minusp; 8/13/88  gb  bindings stuff.(in-package :ccl)#-ppc-target(eval-when (compile eval)  (require 'lap)  (require 'lapmacros))(defun %badarg (arg type)  (%err-disp $XWRONGTYPE arg type))(defun atom (arg)  (not (consp arg)))(defun list (&rest args) args)#+ppc-target (%fhave '%temp-list #'list)(defun list* (arg &rest others)  "Returns a list of the arguments with last cons a dotted pair"  (cond ((null others) arg)	((null (cdr others)) (cons arg (car others)))	(t (do ((x others (cdr x)))	       ((null (cddr x)) (rplacd x (cadr x))))	   (cons arg others))))(defun funcall (fn &rest args)  (declare (dynamic-extent args))  (apply fn args))(defun apply (function arg &rest args)  "Applies FUNCTION to a list of arguments produced by evaluating ARGS in  the manner of LIST*.  That is, a list is made of the values of all but the  last argument, appended to the value of the last argument, which must be a  list."  (declare (dynamic-extent args))  (cond ((null args)	 (apply function arg))	((null (cdr args))	 (apply function arg (car args)))	(t (do* ((a1 args a2)		 (a2 (cdr args) (cdr a2)))		((atom (cdr a2))		 (rplacd a1 (car a2))		 (apply function arg args))))))#-ppc-target(defun applyv (&lap fn args)  (lap   (klexpr 2)   (move.l (vsp nargs.w 4) atemp0)   (vpop arg_z)   (jsr_subprim $sp-vspreadZ-vextend-save-atemp0)   (jmp_subprim $sp-tfuncallgen-vchunkpop))); This is not fast, but it gets the functionality that; Wood and possibly other code depend on.#+ppc-target(defun applyv (function arg &rest other-args)  (declare (dynamic-extent other-args))  (let* ((other-args (cons arg other-args))         (last-arg (car (last other-args)))         (last-arg-length (length last-arg))         (butlast-args (nbutlast other-args))         (rest-args (make-list last-arg-length))         (rest-args-tail rest-args))    (declare (dynamic-extent other-args rest-args))    (dotimes (i last-arg-length)      (setf (car rest-args-tail) (aref last-arg i))      (pop rest-args-tail))    (apply function (nconc butlast-args rest-args)))); This is slow, and since %apply-lexpr isn't documented either,; nothing in the world should depend on it.  This is just being; anal retentive.  VERY anal retentive.#+ppc-clos(defun %apply-lexpr (function arg &rest args)  (cond ((null args) (%apply-lexpr function arg))        (t (apply function arg (nconc (nbutlast args)                                      (collect-lexpr-args (car (last args)) 0))))))#+ppc-target(defun values-list (arg)  (apply #'values arg))#-ppc-target(defun values-list (arg)  (new-lap    (:variable arg)   (set_nargs 0)   (lea (a5 $sp-nvalret) atemp0)   (jsr_subprim $sp-spreadargZ)   (tst.w nargs)   (beq @jmp)   (cmp.w ($ 8) nargs)   (ble @oneortwo)   (movem.l #(arg_x arg_y arg_z) -@vsp)@jmp   (jmp @atemp0)@oneortwo   (bne @one)   (vpush arg_y)@one   (vpush arg_z)   (jmp @atemp0)))#+ppc-target(defun make-list (size &key initial-element)  (unless (and (typep size 'fixnum)               (>= (the fixnum size) 0))    (report-bad-arg size '(and fixnum unsigned-byte)))  (locally (declare (fixnum size))    (do* ((result '() (cons initial-element result)))        ((zerop size) result)      (decf size))))#-ppc-target(defun make-list (size &key initial-element)  (lap-inline (initial-element size nil)    (tst.l arg_y)    (bmi @badsize)    (beq @done)    (ttagp ($ $t_fixnum) arg_y da)    (bne @badsize)    (with-preserved-registers #(dsave0 dsave1)      (move.l arg_y dsave0)      (move.l arg_x dsave1)@loop      (move.l dsave1 arg_y)      (jsr_subprim $sp-consyz)      (sub.l (fixnum 1) dsave0)      (bne @loop))    (bra @done)@badsize   (wtaerr arg_y '(integer 0 *))@done    )); copy-list(defun copy-list (list)  (if list    (let ((result (cons (car list) '()) ))      (do ((x (cdr list) (cdr x))           (splice result                   (%cdr (%rplacd splice (cons (%car x) '() ))) ))          ((atom x) (unless (null x)                      (%rplacd splice x)) result))))); take two args this week#+ppc-target(defun last (list &optional (n 1))  (unless (and (typep n 'fixnum)               (>= (the fixnum n) 0))    (report-bad-arg n '(and fixnum unsigned-byte)))  (locally (declare (fixnum n))    (do* ((checked-list list (cdr checked-list))          (returned-list list)          (index 0 (1+ index)))         ((atom checked-list) returned-list)      (declare (type index index))      (if (>= index n)	  (pop returned-list)))))#-ppc-target(defun last (list &optional count)  ; list is in arg_y, count is in arg_z = acc  (lap-inline ()    (:variable list count)    (move.l arg_y atemp0)   ; last    (cmp.l nilreg arg_y)    (beq @ret0)    (vpush asave0)    (ttagp ($ $t_cons) arg_y da)    (bne @badlist)    (cmp.l nilreg acc)    (bne @suppl)    (move.l (fixnum 1) acc)@suppl   (ttagp ($ $t_fixnum) acc da)   (bne @badcnt)   (move.l acc db)   ; db gets count unless count is 0      (bmi @badcnt)   (bne @cntnz)   (move.l (fixnum 1) db) ; count at least 1@cntnz   (move.l arg_y atemp1)  ; list   (move.l arg_y asave0)  ; check@lpb    (cmp.l nilreg atemp1)    (beq @retAtemp0)    (ttagp ($ $t_cons) atemp1 da)    (bne @retAtemp0)    (cdr atemp1 atemp1)    (sub.l (fixnum 1) db)    (bgt @lpb)@lpa    (cmp.l nilreg atemp1)    (beq @retAtemp0)    (ttagp ($ $t_cons) atemp1 da)    (bne @retAtemp0)    (cdr atemp1 atemp1)    (cdr atemp0 atemp0)    (cmp.l nilreg atemp1)    (beq @retAtemp0)    (ttagp ($ $t_cons) atemp1 da)    (bne @retAtemp0)    (cdr atemp1 atemp1)    (cdr atemp0 atemp0)    (cmp.l atemp0 asave0)    (beq @badlist)    (cdr asave0 asave0)    (bra @lpa)@retAtemp0    (vpop asave0)    (cmp.l (fixnum 0)  acc)    (bne @ret0)    (cdr atemp0 atemp0)@ret0    (move.l atemp0 acc)    (bra @popj)@badcnt    (vpop asave0)    (wtaerr acc 'unsigned-byte)@badlist    (vpop asave0)    (wtaerr arg_y 'list)@popj ))#+ppc-target    (defun nthcdr (index list)  (unless (and (typep index 'fixnum)               (>= (the fixnum index) 0))    (report-bad-arg index '(and fixnum unsigned-byte)))  (locally (declare (fixnum index))    (do* ()         ((< (decf index) 0))      (when (null (setq list (cdr list))) (return)))    list))#-ppc-target(defun nthcdr (index list)  (lap-inline ()    (:variable index list)    (ttagp ($ $t_fixnum) arg_y da)    (bne @badidx)    (tst.l arg_y)    (bmi @badidx)    (prog#      (while# (pl (sub.l (fixnum 1) arg_y)))      (jsr_subprim $sp-cdr)      (until# (eq (cmp.l acc nilreg))))    (bra @done)@badidx    (wtaerr arg_y 'unsigned-byte)@done))(defun nth (index list) (car (nthcdr index list)))#+ppc-target(defun nconc (&rest lists)  (declare (dynamic-extent lists))  "Concatenates the lists given as arguments (by changing them)"  (do* ((top lists (cdr top)))       ((null top) nil)    (let* ((top-of-top (car top)))      (cond       ((consp top-of-top)        (let* ((result top-of-top)               (splice result))          (do* ((elements (cdr top) (cdr elements)))	         ((endp elements))            (let ((ele (car elements)))              (typecase ele                (cons (rplacd (last splice) ele)                      (setf splice ele))                (null (rplacd (last splice) nil))                (atom (if (cdr elements)                        (report-bad-arg ele 'list)                        (rplacd (last splice) ele)))                (t (report-bad-arg ele 'list)))))          (return result)))       ((null top-of-top) nil)       (t        (if (cdr top)          (report-bad-arg top-of-top 'list)          (return top-of-top)))))))#-ppc-target(defun nconc (&lap &rest lists)  (lap   (klexpr 0)   (vpush asave0)   (lea (vsp nargs.w 4) asave0)           ; asave0 = arg pointer   (vpush nilreg)                       ; (vsp) = the answer   (move.l nilreg acc)                  ; acc = last list   (spush nargs)                        ; (sp) = nargs   (if# ne     (prog#      (if# (eq (cmp.l nilreg acc))        (move.l (-@ asave0) acc)        (move.l acc (vsp))              ; First one, remember it       else#        (set_nargs 1)        (jsr #'last)        (jsr_subprim $sp-cdr)         ; atemp0<-acc, acc<-cdr(atemp0)        (cmp.l nilreg acc)        (if# ne (tsignal_error (fixnum $XIMPROPERLIST) atemp0))        (move.l atemp0 acc)        (move.l (-@ asave0) (cdr atemp0)))      (until# (eq (sub.l ($ 4) (sp))))))   (add.w ($ 4) sp)   (vpop acc)   (vpop asave0)   (lfret)))#-ppc-target(defvar %setf-function-names% nil)#-ppc-target(progn(defun setf-function-name (sym)  (%cdr (or (assq sym %setf-function-names%)            (%car (setq %setf-function-names% (cons (cons sym (construct-setf-function-name sym))                                                    %setf-function-names%))))))(queue-fixup (setq %setf-function-names% (alist-hash-table %setf-function-names% :weak t :test 'eq)) (defun setf-function-name (sym)   (or (gethash sym %setf-function-names%)       (setf (gethash sym %setf-function-names%) (construct-setf-function-name sym))))))#+ppc-target(defvar %setf-function-names% (make-hash-table :weak t :test 'eq))#+ppc-target(defun setf-function-name (sym)   (or (gethash sym %setf-function-names%)       (setf (gethash sym %setf-function-names%) (construct-setf-function-name sym))))(defun string (thing)  (if (stringp thing)    thing    (if (symbolp thing)      (symbol-name thing)      (if (characterp thing)        (make-string 1                      :element-type (if (typep thing 'base-character) 'base-character 'character)                     :initial-element thing)        (report-bad-arg thing '(or string symbol character))))))                     (defconstant *setf-package* (or (find-package "SETF") (make-package "SETF" :use nil :external-size 1)))(defun construct-setf-function-name (sym)  (let ((pkg (symbol-package sym)))    (setq sym (symbol-name sym))    (if (null pkg)      (gentemp sym *setf-package*)      (values       (intern        ;I wonder, if we didn't check, would anybody report it as a bug?        (if (not (%str-member #\: (setq pkg (package-name pkg))))          (%str-cat pkg "::" sym)          (%str-cat (prin1-to-string pkg) "::" (princ-to-string sym)))        *setf-package*)))))(defun valid-function-name-p (name)  (if (symbolp name)                    ; Nil is a valid function name.  I guess.    (values t name)    (if (and (consp name)             (consp (%cdr name))             (null (%cddr name))             (symbolp (%cadr name)))      (values t (setf-function-name (%cadr name)))      ; What other kinds of function names do we care to support ?      (values nil nil)))); Why isn't this somewhere else ?(defun ensure-valid-function-name (name)  (multiple-value-bind (valid-p nm) (valid-function-name-p name)    (if valid-p nm (error "Invalid function name ~s." name))))(defvar *string-compare-script* #$smSystemScript);these should not be saved with application! OK(defvar *script-char-byte-tables* nil)(defvar *script-char-sort-tables* nil)(defvar *script-char-equal-sort-tables* nil)(defvar *script-char-up-tables* nil)(defvar *script-char-down-tables* nil)(defvar *system-script* nil)(defun default-script (script)  (if (or (null script) (eql script #$smSystemscript))    (or *system-script* (setq *system-script* (#_GetScriptManagerVariable  #$smSysScript)))    script))(defun string-compare-script ()    (let* ((script *string-compare-script*))      (if (or (null script)(eq script #$smSystemScript))        (or *system-script* (default-script script))        script)))(defparameter *extended-STRING-font* nil)(defparameter *extended-STRING-font-codes* nil)(defvar *extended-STRING-script* nil)(defvar *script-list* nil)(defvar *input-file-script* nil)  ;  setting this to a 1 byte script - doesnt hurt, does nothing?; user call this(defun set-extended-string-font (spec)  (setq *extended-string-font* spec)  (setq *extended-string-font-codes* nil)  (multiple-value-bind (ff ms) (extended-string-font-codes)    (setq *extended-string-font-codes* (list ff ms))    (setq *extended-string-script* (ff-script ff)))); or user call this - else default is scriptappfond of system script(defun set-extended-string-script (script)  (setq *extended-string-script* script)  (setq *extended-string-font* nil)  (setq *extended-string-font-codes* nil)); if not set by user and systemscript not 2 byte, look in installed scripts(defun extended-string-script ()  (let ((script (or *extended-string-script* (default-script nil))))    (if (logbitp #$smsfSingByte (#_getscript script #$smscriptflags))      (unless (eq 0 (#_GetScriptManagerVariable #$SMDOUBLEBYTE)) ; false is 0, true is 255 or -1 depending        (dolist (script *script-list*)          (when (not (logbitp #$smsfSingByte (#_getscript script #$smscriptflags)))            (set-extended-string-script script)            (return script))))      (if (neq script *extended-string-script*)        (set-extended-string-script script)        script))))(defun extended-string-font ()  (or *extended-string-font*      (let ((script (or *extended-string-script* (default-script nil))))        (unless (%ilogbitp #$smsfSingByte (#_getscript script #$smscriptflags))          (let* ((font (get-script script #$smScriptAppFond))                 (ff (make-point 0 font))                 (syssize (#_LMGetSysFontSize))                 (ms (make-point (if (eq 0 syssize) 12 syssize)                                 #$srcor)))            (setq *extended-string-font-codes* (list ff ms))            (setq *extended-string-font* (font-spec ff ms)))))))(defun extended-string-font-codes ()  (let ((codes *extended-string-font-codes*))    (when (not codes)       (let ((font-spec (extended-string-font)))        (when font-spec          (multiple-value-bind (ff ms)(font-codes font-spec)            (setq *extended-string-font-codes* (list ff ms))))))        (apply #'values *extended-string-font-codes*))); is it an extended string that really needs to be extended?(defun real-xstring-p (str)  (multiple-value-bind (realstr strb)(array-data-and-offset str)    (declare (fixnum strb))    (if (extended-string-p realstr)      (dotimes (i (the fixnum (length str)) nil)        (when (> (%scharcode realstr (+ i strb)) #xff)(return t)))))); cant make-array yet; Of course, compiler-macros will eliminate the call to MAKE-ARRAY.(defun make-char-byte-table (script)  (let* ((font (#_getscript script #$smScriptAppFond))        (result (make-array 256 :element-type '(signed-byte 8))))    ; boy is this stupid - is it right    (with-font font      (rlet ((table (:array :character 256 :packed)))  ; was ((table :charbytetable)) - s.b. equiv?        (#_parsetable table)        (dotimes (i 256)          (setf (aref result i) (%get-signed-byte table i)))))    result))(defun get-char-byte-table (&optional script)  ; returns nil if 8 bit script  (setq script (default-script script))  (when (not (eql script #$smRoman))    (unless (%ilogbitp #$smsfSingByte (#_getscript script #$smscriptflags))      (when (null *script-char-byte-tables*)        (setq *script-char-byte-tables* (make-array 34 :element-type t :initial-element nil)))  ; ?? ad hoc 34      (or (%svref *script-char-byte-tables* script)          (let ((res (make-char-byte-table script)))            (setf (svref *script-char-byte-tables* script) res)            res)))))(defun get-char-sort-table (&optional (script (string-compare-script)))  ; returns nil for 2 byte scripts?    (when (or (eql script #$smRoman)(%ilogbitp #$smsfSingByte (#_getscript script #$smscriptflags)))    (when (null *script-char-sort-tables*)      (setq *script-char-sort-tables* (make-array 34 :element-type t :initial-element nil)))  ; ??    (or (%svref *script-char-sort-tables* script)        (let ((res (make-char-sort-table script)))          (setf (svref *script-char-sort-tables* script) res)          res))))(defun get-char-equal-sort-table (&optional script)  (when (or (eq script #$smRoman)(%ilogbitp #$smsfSingByte (#_getscript script #$smscriptflags)))        (when (null *script-char-equal-sort-tables*)      (setq *script-char-equal-sort-tables* (make-array 34 :element-type t :initial-element nil)))  ; ??    (or (%svref *script-char-equal-sort-tables* script)        (let ((res (make-char-equal-sort-table script)))          (setf (svref *script-char-equal-sort-tables* script) res)          res)))); how bout alpha-char-p?; and when not 8 bit use traps (yech); or should script default to *string-compare-script*? - I think not today(defun get-char-up-table (&optional script)  (setq script (default-script script))  (cond ((eq script #$smRoman) char-up-string-1)        (t (when (%ilogbitp #$smsfSingByte (#_getscript script #$smscriptflags))             (when (null *script-char-up-tables*)               (setq *script-char-up-tables* (make-array 34 :element-type t :initial-element nil)))  ; ??             (or (%svref *script-char-up-tables* script)                 (let ((res (make-char-up-table script)))                   (setf (svref *script-char-up-tables* script) res)                   res))))))(defun get-char-down-table (&optional script)  (setq script (default-script script))    (cond ((eq script #$smRoman) char-down-string-1)        (t (when (%ilogbitp #$smsfSingByte (#_getscript script #$smscriptflags))             (when (null *script-char-down-tables*)               (setq *script-char-down-tables* (make-array 34 :element-type t :initial-element nil)))  ; ??             (or (%svref *script-char-up-tables* script)                 (let ((res (make-char-down-table script)))                   (setf (svref *script-char-down-tables* script) res)                   res))))))(defparameter *roman-sort-table*  (make-array 256 :element-type '(unsigned-byte 8)))(dotimes (i 256)  (setf (aref *roman-sort-table* i)        (aref               #(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29                30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56                57 58 59 60 61 62 63 64 65  ;  7 upper #\A #\347 #\313 #\345 #\200 #\314 #\201                72 ; b                 73  ; 2 cs #\C #\202                75                 76 ; #\E #\203 #\351 #\346 #\350                81 82 83                 84  ; #\I #\352 #\355 #\353 #\354 #\365                 90 91 92 93                 94 ; #\N #\204                96 ; #\O #\356 #\361 #\357 #\205 #\315 #\257                 103 104 105 106 107                108 ; #\U #\362 #\364 #\363 #\206                113 114 115 116 117 ; #\Z ; end of upper case                118 119 120 121 122 123 124                125 ; #\a #\207 #\210 #\211 #\212 #\213 #\214 #\256 #\276                134                135  ;  #\c #\215                137                138  ; #\e #\216 #\217 #\220 #\221                143 144 145                146 ;#\i #\222 #\223 #\224 #\225                151 152 153 154                155 ; #\n #\226                157 ; #\o #\227 #\230 #\231 #\232 #\233 #\277 #\316 #\317                166 167 168 169 170                 171 ; #\u #\234 #\235 #\236 #\237                176 177 178                 179  ; \y #\330 #\331                182  ; #z                183 184 185 186                ; index 128                ; upper a #o200 #o201                69 71                ; upper c #o202                74                77  ; upper e #o203                95 ; upper n #o204                100 ; upper o #o205                112 ; upper u #o206                126 127 128 129 130 131 ; lower a #o207 - 214                136 ; lower c #o215                139 140 141 142 ; lower e #o216 - 221                147 148 149 150  ; lower i #o222 225                156 ; lower n #o226                158 159 160 161 162 ; lower o #o227-233                172 173 174 175 ; lower u #o234 237 - u's                ; index 161                187 188 189 190 191 192 193 194 195 196 197 198 199 200                132 ; lower a - o256                102 ; upper O o257                201 202 203 204 205 206 207 208 209 210 211 212 213 214                133 ; lower a index o276                163 ; lower o index o277 191                215 216 217 218 219 220 221 222 223 224 225                67 ; upper A o313                70 ; upper A o314                101 ; upper O o315                164 165  ; lower o o316 317                ; index o320                226 227 228 229 230 231 232  233                 180 181 ; lower y o330 0331                234 235 236 237 238 239                240 241 242 243 244                68 ; upper A o345                79 ; upper E o346                66 ; upper A o347                ; 350                80 78  ; upper E o350 o351                85 87 88 86 ; UPPer I o352-355                 97 99  ; upper O o356 357                ; 360                245                 98 ; upper O o361                109 111 110  ; upper U 362 363 364                89 ; upper I o365                246 247 248 249 250 251 252 253 254 255)              i))); case sensitive sort  - to heck with ligatures  (defun make-char-sort-table (script)  (if (eq script #$smRoman)    *roman-sort-table*    (let* ((result (make-array 256 :element-type '(unsigned-byte 8)))           (clist (make-list 256)))      (declare (dynamic-extent clist))      (with-macptrs ((bhdl (#_getresource :|itlb| script)))        (let ((id (cond ((eq script #$smRoman) 0)                        (t (cond ((%null-ptr-p bhdl)(error "Can't find :|itb| ~D resource." script ))                                 (t (#_loadresource bhdl)))                           (href bhdl itlbrecord.itlbsort)))))                    (with-macptrs ((ihdl (#_getresource :|itl2| id)))            (cond ((%null-ptr-p ihdl)(error "Can't find :|itl2| ~D resource." id ))                  (t (#_loadresource ihdl)))            (do* ((l clist (cdr l))                  (i 0 (1+ i)))                 ((= i 256))              (rplaca l i))            (%stack-block ((p1 1)(p2 1))              ; aargh - can't sort till much later              (setq clist (%sort-list-no-key                           clist #'(lambda (a b)                                     (%put-byte p1 a)                                     (%put-byte p2 b)                                     (let ((v (#_iumagpstring p1 p2 1 1 ihdl)))                                       ; -1 less, 0 equal, 1 greater                                       ;(print (list (code-char a)(code-char b) (if (= v 1) t nil)))                                       (if (= v 1) nil t)))))))))      (do* ((l clist (cdr l))            (i 0 (1+ i)))           ((= i 256))        (setf (aref result (car l)) i))      result))); case independent sort table (defun make-char-equal-sort-table (script)  (let* ((result (make-array 256 :element-type '(unsigned-byte 8))))    (let ((other (get-char-sort-table script))          (up-tbl (get-char-up-table script)))      (dotimes (i 256)        (let ((it (%scharcode up-tbl i)))          (setf (aref result i)(aref other it))))      result))); Returns index if char appears in string, else nil.#+ppc-target(defun %str-member (char string &optional start end)  (let* ((base-string-p (typep string 'simple-base-string)))    (unless base-string-p      (setq string (require-type string 'simple-string)))    (unless (characterp char)      (setq char (require-type char 'character)))    (if base-string-p      (do* ((i (or start 0) (1+ i))            (n (or end (uvsize string))))           ((= i n))        (declare (fixnum i n) (optimize (speed 3) (safety 0)))        (if (eq (schar (the simple-base-string string) i) char)          (return i)))      (do* ((i (or start 0) (1+ i))            (n (or end (uvsize string))))           ((= i n))        (declare (fixnum i n) (optimize (speed 3) (safety 0)))        (if (eq (schar (the simple-extended-string string) i) char)          (return i))))))#-ppc-target(defun %str-member (char string &optional start end)  (lap-inline ()    (:variable char string start end)    (move.l (varg char) arg_y)    (if# (eq (cmp.b ($ #x0f) arg_y))      (move.b ($ $t_imm_char) arg_y)      (move.l arg_y (varg char)))    (if# (ne (cmp.b ($ $t_imm_char) arg_y))      (move.l arg_y atemp0)      (jsr_subprim $sp-chararg-atemp0)      (move.l atemp0 arg_y))    (move.l arg_x atemp0)    (if# (or (ne (ttagp ($ $t_vector) arg_x da))             (not (or (eq (vsubtypep ($ $v_sstr) atemp0 da))                      (eq (cmp.b ($ $v_xstr) da)))))       (jsr_subprim $sp-check-string-atemp0))    (getvect atemp0 acc)    (if# (ne (cmp.l (varg end) nilreg))      (move.l (varg end) acc)      (getint acc))    (move.l ($ 0) db)    (if# (ne (cmp.l (varg start) nilreg))      (move.l (varg start) db)      (getint db)      (sub.l db acc)      (add.l db atemp0))            (if# (eq (cmp.b ($ $v_sstr) da))      (move.l acc da)      (beq @nilret)      (swap arg_y)      (sub.l ($ 1) da)      @1 (cmp.b (@+ atemp0) arg_y)      (dbeq da @1)      (beq @found)      (add.w ($ 1) da)      (sub.l ($ 1) da)      (bcc @1)      @nilret      (move.l nilreg acc)      (lfret)      else#      (add.l db atemp0)  ; fix for start not zero      (move.l acc da)      (beq @nilret)      (swap arg_y)      (sub.l ($ 1) da)      @2 (cmp.w (@+ atemp0) arg_y)      (dbeq da @2)      (beq @found)      (add.w ($ 1) da)      (sub.l ($ 1) da)      (bcc  @2)      (bra @nilret))    @found    (add.l ($ 1) da)    (sub.l da acc)    (add.l db acc)    (mkint acc)))      ; Returns index of elt in vector, or nil if it's not there.#+ppc-target(defun %vector-member (elt vector)  (unless (typep vector 'simple-vector)    (report-bad-arg vector 'simple-vector))  (dotimes (i (the fixnum (length vector)))    (when (eq elt (%svref vector i)) (return i))))#-ppc-target(defun %vector-member (elt vector)  (lap-inline ()    (:variable elt vector)    (move.l arg_z atemp0)    (if# (or (ne (ttagp ($ $t_vector) arg_z da))             (ne (vsubtypep ($ $v_genv) atemp0 da)))      (wtaerr arg_z 'simple-vector))    (getvect atemp0 da)    (asr 2 da)    (if# ne      (move.l da acc)      (bra @test)      (prog#       (cmp.l atemp0@+ arg_y)       @test       (dbeq da (top#))       (if# eq         (add.l ($ 1) da)         (sub.l da acc)         (mkint acc)         (lfret))       (add.w ($ 1) da)       (sub.l ($ 1) da)       (bcc (top#))))    (move.l nilreg acc)))#+ppc-target(progn; It's back ...(defun list-nreverse (list)  (nreconc list nil)); We probably want to make this smarter so that less boxing; (and bignum/double-float consing!) takes place.(defun vector-nreverse (v)  (let* ((len (length v))         (middle (ash (the fixnum len) -1)))    (declare (fixnum middle len))    (do* ((left 0 (1+ left))          (right (1- len) (1- right)))         ((= left middle) v)      (declare (fixnum left right))      (rotatef (aref v left) (aref v right)))))    (defun nreverse (seq)  (seq-dispatch seq   (list-nreverse seq)   (vector-nreverse seq))))#-ppc-target(defun nreverse (sequence)  (lap-inline ()    (:variable sequence)     (move.l arg_z atemp0)     (jsr_subprim $sp-seqarg-atemp0)     (if# eq       (move.l nilreg atemp1)           ; list       (bra @nextcons)       (prog#        (jsr_subprim $sp-cdr)		;Atemp0 <- a,  acc <- cdr(a)        (rplacd atemp0 atemp1)	   	;cdr(a) <- b        (move.l atemp0 atemp1)		;b <- a       @nextcons        (until# (eq (cmp.l nilreg arg_z))))       (move.l atemp1 acc)       (bra @done))     (bgt revcomplex); nreverse the simple vector in acc = atemp0. da.b = vector subtype.     (getvect atemp0 dy)     ;acc = return value, atemp0=start ptr, dy = length in bytes.     (move.l atemp0 atemp1)     (add.l dy atemp1)     (if# (ne (btst ($ $vnodebit) da))@long       (lsr.l ($ (+ 2 1)) dy)                 ; half the number of entries       (bra @ptrnext)      @ptrloop       (move.l (atemp0) da)       (move.l (-@ atemp1) (@+ atemp0))       (move.l da (atemp1))      @ptrnext       (dbfl dy @ptrloop)       (bra @done))     (ext.w da)     (jmp (pc da.w (- 2 $v_min_arr)))     ;These better end up as short branches!     (bra @word)                        ;%0110 - extended char     (bra @byte)                        ;%0111 - unsigned byte     (bra @word)			;%1000 - unsigned word     (bra @float)                       ;%1001 - float     (bra @long)                        ;%1010 - signed long     (bra @long)                        ;%1011 - unsigned long     (bra @bit)                         ;%1100 - bit     (bra @byte)			;%1101 - signed byte     (bra @word)			;%1110 - signed word    ;(bra @byte)			;%1111 - char@byte     (lsr.l ($ 1) dy)     (bra @bytenext)@byteloop     (move.b (atemp0) da)     (move.b (-@ atemp1) (@+ atemp0))     (move.b da (atemp1))@bytenext     (dbfl dy @byteloop)     (bra @done)@word     (lsr.l ($ 2) dy)     (bra @wordnext)@wordloop     (move.w (atemp0) da)     (move.w (-@ atemp1) (@+ atemp0))     (move.w da (atemp1))@wordnext     (dbfl dy @wordloop)     (bra @done)@float     (lsr.l ($ (+ 3 1)) dy)     (bra @floatnext)     @floatloop     (move.l (@+ atemp0) da)     (move.l (atemp0) db)     (move.l (-@ atemp1) (@+ atemp0))     (move.l db (atemp1))     (move.l (-@ atemp1) (atemp0 -8))     (move.l da (atemp1))     @floatnext     (dbfl dy @floatloop)     (bra @done)@bit (with-preserved-registers #(dsave0 acc)     (sub.l ($ 1) dy)     (beq @bitdone)     (sub.w ($ 1) atemp1)               ; point AT last byte     (sub.l ($ 1) dy)     (lsl.l 3 dy)     (move.l ($ 0) db)     (move.b (@+ atemp0) db)     (add.l db dy)     (lsr.l 1 dy)     (neg.b db)     (add.b ($ 8) db)     (move.l ($ 7) dsave0)              ; mask     (move.b dsave0 da)                 ; same as MSB bit#     (and.b dsave0 db)                  ; mask out LSB     (bra @bitnext)@bitloop     (if# (eq (bclr da (atemp0))) (bclr db (atemp1))      else# (bset db (atemp1)))     (if# ne (bset da (atemp0)))     (if# (mi (sub.b ($ 1) da))       (add.w ($ 1) atemp0)       (move.b dsave0 da))     (add.b ($ 1) db)     (if# (eq (and.b dsave0 db)) (sub.w ($ 1) atemp1))@bitnext     (dbfl dy @bitloop)@bitdone  )     (bra @done)revcomplex  (with-preserved-registers #(acc asave0 dsave0 dsave1 dsave2)    (move.l (svref atemp0 arh.fill) dsave1)   ; length of non-simple vector    (move.l dsave1 dsave2)    (lsr.l ($ (+ $fixnumshift 1)) dsave2)   ; half the length    (mkint dsave2)    (move.l atemp0 asave0)    (move.l (fixnum 0) dsave0)    (bra @nextgen)@genloop    (move.l asave0 atemp0)    (move.l dsave0 acc)    (jsr_subprim $sp-aref1)    (vpush acc)    (move.l asave0 atemp0)    (move.l dsave1 acc)    (jsr_subprim $sp-aref1)    (move.l asave0 arg_x)    (move.l dsave0 arg_y)    (jsr_subprim $sp-aset1)    (move.l asave0 arg_x)    (move.l dsave1 arg_y)    (vpop acc)    (jsr_subprim $sp-aset1)    (add.l (fixnum 1) dsave0)@nextgen    (sub.l (fixnum 1) dsave1)    (sub.l (fixnum 1) dsave2)    (bpl @genloop))@done))#+ppc-target(defun nreconc (x y)  "Returns (nconc (nreverse x) y)"  (do ((1st (cdr x) (if (atom 1st) 1st (cdr 1st)))       (2nd x 1st)		;2nd follows first down the list.       (3rd y 2nd))		;3rd follows 2nd down the list.      ((atom 2nd) 3rd)    (rplacd 2nd 3rd)))#-ppc-target(defun nreconc (a b)  (lap-inline ()    (:variable a b)    (move.l arg_z atemp1)    (move.l arg_y arg_z)    (bra @next)    (prog#     (jsr_subprim $sp-cdr)             ; atemp0 <- a, acc <- cdr(a)     (rplacd atemp0 atemp1)              ; cdr(a) <- b     (move.l atemp0 atemp1)     @next     (until# (eq (cmp.l nilreg arg_z))))    (move.l atemp1 acc)))#+ppc-target(defun append (&lexpr lists)  (let* ((n (%lexpr-count lists)))    (declare (fixnum n))    (if (> n 0)      (if (= n 1)        (%lexpr-ref lists n 0)        (do* ((res (%lexpr-ref lists n 0) (append-2 res (%lexpr-ref lists n j)))              (j 1 (1+ j)))             ((= j n) res)          (declare (fixnum j)))))))#-ppc-target(defun append (&lap &rest lists)  (lap   (if# (eq (cmp.w ($ 8) nargs)) (jmp_subprim $sp-append2))   (if# mi     (sub.w ($ 4) nargs)     (if# ne       (move.l nilreg acc))     (rts))   (vpush arg_x)   (jmp_subprim $sp-append)))#-ppc-target(defun reverse (sequence)  (new-lap    (:variable sequence)    (move.l acc atemp0)    (jsr_subprim $sp-seqarg-atemp0)    (if# eq      (if# (ne (cmp.l acc nilreg))        (with-preserved-registers #(asave0 asave1)           (move.l acc asave0)           (move.l nilreg asave1)           (prog#            (move.l asave0 arg_z)            (jsr_subprim $sp-car)            (move.l acc arg_y)            (move.l asave1 arg_z)            (jsr_subprim $sp-consyz)            (move.l acc asave1)            (cdr asave0 asave0)            (until# (eq (cmp.l asave0 nilreg))))           (move.l asave1 acc)))      (lfret))    (if# lt      (ccall copy-uvector acc)      (tail-ccall nreverse acc))    (preserve_regs #(asave0 asave1 dsave0 dsave1))    (move.l atemp0 asave0)    (move.l (svref asave0 arh.fill) dsave0)    (move.l (fixnum 0) dsave1)    (prog#     (add.l (svref asave0 arh.offs) dsave1)     (btst ($ $arh_disp_bit) (vref.l asave0 arh.fixnum $arh_bits))     (move.l (svref asave0 arh.vect) asave0)     (until# eq))    (vsubtype asave0 arg_z)    (ext.w arg_z)    (ext.l arg_z)    (mkint arg_z)    (ccall %make-uvector dsave0 arg_z)    (move.l acc asave1)    (bra @genloop)    (prog#     (move.l asave0 arg_y)     (move.l dsave1 arg_z)     (jsr_subprim $sp-uvref)     (move.l asave1 arg_x)     (move.l dsave0 arg_y)     (jsr_subprim $sp-uvset)     (add.l (fixnum 1) dsave1)     @genloop     (sub.l (fixnum 1) dsave0)     (until# cs))    (move.l asave1 acc)    (restore_regs)    (lfret)))#+ppc-target(progn(defun list-reverse (l)  (do* ((new ()))       ((null l) new)    (push (pop l) new))); Again, it's worth putting more work into this when the dust settles.(defun vector-reverse (v)  (let* ((len (length v))         (new (make-array (the fixnum len) :element-type (array-element-type v))))   ; a LOT more work ...    (declare (fixnum len))    (do* ((left 0 (1+ left))          (right (1- len) (1- right)))         ((= left len) new)      (declare (fixnum left right))      (setf (uvref new left)            (aref v right)))))(defun reverse (seq)  (seq-dispatch seq (list-reverse seq) (vector-reverse seq)))); The length in bytes of the packed equivalent of a fat string.; this guy does not count fat chars that make no sense in script. actually does now; And  %pstr-pointer will truncate fat chars that make no sense in script.(defun byte-length (string &optional script start end)  (declare (ignore script))  (when (or start end)(chkbounds string start end))  (if (not start) (setq start 0))  (if (not end)(setq end (length string)))  (let ((len (- end start)))    (cond      ((base-string-p string)      len)     (t         (let () ;(table (get-char-byte-table script))) ; just is script fat??          (cond            (nil (not table) len)           (t (multiple-value-bind (str offset)(array-data-and-offset string)                                (let* ((start (%i+ offset start))                       (end (%i+ offset end))                       (j 0))                  (until (eq start end)                    (let ((c (%scharcode str start)))                      (if (and (%i> c #xff)) #|(eq (aref table (%ilsr 8 c)) 1))|#                        (setq j (%i+ j 2))                        (setq j (%i+ j 1))))                    (setq start (%i+ start 1)))                  j))))))))); the length in characters of a packed pstr; second value is true if there are some fat chars in pointer(defun pstr-char-length (pointer &optional script)  (with-macptrs ((p pointer))    (pointer-char-length (%incf-ptr p)(%get-byte p -1) script)))  ; second value is true if actually contains fat chars(defun pointer-char-length (pointer len &optional script)  (let ((table (get-char-byte-table script)))    (cond ((not table) len)          (t (let ((i 0)                   (j 0))               (until (%i>= i len)                 (let ((c (%get-byte pointer i)))                   (if (eql 1 (aref table c))                     (setq i (%i+ i 2))                     (setq i (%i+ i 1)))                   (setq j (%i+ j 1))))               (values j (%i> i j) (%i> i len))))))); from string to pointer - used by with-pstrs ; only transmits fat chars as such if they make sense in script; ignores the possibility of a base-string containing bytes that are; start of 2 byte chars in script.#+ppc-target  (defun %pstr-pointer (string pointer &optional script)    (if (> (length string) 255) (error "String ~s too long for pascal string." string))  (if (base-string-p string)    (multiple-value-bind (s o n) (dereference-base-string string)      (declare (fixnum o n))      (let* ((limit (min n 255)))        (declare (fixnum limit))        (setf (%get-byte pointer 0) limit) ; set length byte        (do* ((o o (1+ o))              (i 0 (1+ i))              (j 1 (1+ j)))             ((= i limit))          (declare (fixnum o i j))          (setf (%get-byte pointer j) (%scharcode s o)))))    (%put-string pointer string 0 255 script))  nil)#-ppc-target(defun %pstr-pointer (string pointer &optional script)  (if (> (length string) 255) (error "String ~s too long for pascal string." string))  (if (base-string-p string)    (lap-inline ()      (:variable string pointer)      (move.l (varg pointer) atemp0)      (jsr_subprim $sp-macptrptr)         ; typecheck      (spush atemp0)      (move.l (varg string) acc)      (jsr (function %%derefstring))       ; atemp0=str, dtemp0=offset, dtemp1=len      (lea (atemp0 dtemp0.l $v_data) a0)      (movereg dtemp1 d1)      (move.l '0 d0)      (st d0)      (if# (lt (cmp.l d0 d1)) (move.l d1 d0))      (spop atemp1)      (move.b d0 (@+ a1))                  ; set length byte      (dc.w #_BlockMove))    (%put-string pointer string 0 255 script))  nil)(defun %pstr-segment-pointer (string pointer start end &optional script)  #|  (setq start (require-type start 'fixnum)        end   (require-type end 'fixnum))  (when (> (- end start) 255) (error "String  ~s too long for pascal string" string))  (if (base-string-p string)    (multiple-value-bind (src offset end-offset) (dereference-base-string string)      (declare (fixnum offset end-offset))      (let ((src-len (- end-offset offset)))        (declare (fixnum src-len limit))        (cond ((minusp start) (setq start 0))              ((< src-len start) (setq start src-len)))        (cond ((minusp end) (setq end 0))              ((< src-len end) (setq end src-len)))        (when (< end start) (setq end start))        (let ((len (min (- end start) 255)))          (declare (fixnum len))          (setf (%get-byte pointer 0) len) ; set length byte          (incf len)          (do* ((o (+ offset start) (1+ o))                (j 1 (1+ j)))               ((= j len))            (declare (fixnum o j))            (setf (%get-byte pointer j) (%scharcode src o))))))    |#    (with-pointers ((p pointer 1))      (setf (%get-byte p -1) (%put-string-segment-contents p string start end 255 script)))  nil)#+ppc-target   (defun %cstr-pointer (string pointer &optional script)  (if (base-string-p string)    (multiple-value-bind (s o n) (dereference-base-string string)      (declare (fixnum o n))      (do* ((o o (1+ o))            (i 0 (1+ i)))           ((= i n) (setf (%get-byte pointer i) 0))        (declare (fixnum o i))        (setf (%get-byte pointer i) (%scharcode s o))))    (%put-cstring pointer string 0 nil script))  nil)#-ppc-target(defun %cstr-pointer (string pointer &optional script)  (if (base-string-p string)    (lap-inline ()      (:variable string pointer)      (move.l (varg pointer) atemp0)      (jsr_subprim $sp-macptrptr)         ; typecheck      (spush atemp0)      (move.l (varg string) acc)      (jsr (function %%derefstring))       ; atemp0=str, dtemp0=offset, dtemp1=len      (lea (atemp0 dtemp0.l $v_data) a0)      (movereg dtemp1 d0)      (spop a1)      (sf.b (a1 d0.l))      (dc.w #_BlockMove))    (%put-cstring pointer string 0 nil script))  nil); used by with-cstr (used by help-manager.lisp)(defun %cstr-segment-pointer (string pointer start end)  #|  (setq start (require-type start 'fixnum)        end   (require-type end   'fixnum))  (require-type string 'string)   (if (base-string-p string)    (multiple-value-bind (src offset end-offset) (dereference-base-string string)      (declare (fixnum offset end-offset))      (let ((src-len (- end-offset offset)))        (declare (fixnum src-len))        (cond ((minusp start) (setq start 0))              ((< src-len start) (setq start src-len)))        (cond ((minusp end) (setq end 0))              ((< src-len end) (setq end src-len)))        (when (< end start) (setq end start))        (let ((len (- end start)))          (declare (fixnum len))          (do* ((o (+ offset start) (1+ o))                (i 0 (1+ i)))               ((= i len) (setf (%get-byte pointer i) 0))            (declare (fixnum o i))            (setf (%get-byte pointer i) (%scharcode src o))))))  |#  (setf (%get-byte pointer (%put-string-segment-contents pointer string start end)) 0)  nil)(defun %str-from-ptr-in-script (pointer len &optional script)  (setq script (default-script script))  (let ((table (get-char-byte-table script)))    (if (not table)      (%str-from-ptr pointer len)      (multiple-value-bind (chars fatp) (pointer-char-length pointer len script)        (cond         ((not fatp) (%str-from-ptr pointer len))         (t           (let ((new-string (make-string chars :element-type 'extended-character)))            (pointer-to-string-in-script pointer new-string len script)            new-string)))))))(defun pointer-to-string-in-script (pointer string len script &optional start)  (let* ((table (get-char-byte-table script))         (i 0)         (j (or start 0)))    (until (%i>= i len)      (let ((c (%get-byte pointer i)))        (cond ((and table (eql 1 (aref table c)))               (setq c (%ilogior (%ilsl 8 c)(%get-byte pointer (%i+ 1 i))))               (setq i (%i+ i 2)))              (t (setq i (%i+ i 1))))        (setf (%scharcode string j) c)        (setq j (%i+ j 1))))    string))(defun %str-from-ptr (pointer len)  (%copy-ptr-to-ivector pointer 0 (make-string len :element-type 'base-character) 0 len)); 3 callers - externalize scrap, 2 static text dialog item things (defun %str-to-handle (str &optional hdl (max-length 32000))   ; truncates to max-length chars.  (cond    (#-PPC-target (base-string-p str)    #+PPC-target nil    (lap-inline ()      (:variable str hdl max-length)      (preserve_regs #(asave0 asave1 dsave0))       (equate _vtop 12)      (defreg str asave0 hdl asave1 len dsave0)       (move.l (varg hdl _vtop) hdl)      (move.l (varg str _vtop) acc)      (jsr_subprim $sp-sstrarg)      (move.l acc str)      (vsize str d0)      (move.l (varg max-length _vtop) d1)      (if# (ne d1 nilreg)        (if# (ne (ttagp ($ $t_fixnum) d1 da))          (wtaerr d1 'fixnum))        (if# (gt (cmp.l d1 d0))          (move.l d1 d0)))                ; d0 <- size      (move.l d0 len)      (mkint len)      (if# (eq hdl nilreg)        (regtrapD0 #_NewHandle)        (jsr_subprim $sp-consmacptr)        (move.l acc hdl)        else#        (move.l hdl atemp0)        (jsr_subprim $sp-macptrptr)         ; a0 <- handle, preserves d0.        (regtrapd0 #_SetHandleSize))      (lea (str $v_data) a0)      (move.l (hdl $macptr.ptr) a1) (move.l (a1) a1)      (move.l len d0)      (getint d0)      (dc.w #_BlockMove)                   ; no funny business      (move.l hdl acc)      (restore_regs)))   (t (let ((hlen (byte-length str)))        (when (and max-length (> hlen max-length))(setq hlen max-length))        (cond (hdl (#_SetHandleSize hdl hlen))              (t (setq hdl (#_NewHandle :errchk hlen))))        (with-dereferenced-handle (pointer hdl)          (%put-string-contents pointer str hlen))        hdl))))(defun extended-string-p (thing)  (and (stringp thing)(not (base-string-p thing))))(defun simple-extended-string-p (thing)  (and (simple-string-p thing)(not (base-string-p thing))))(setf (type-predicate 'extended-string) 'extended-string-p)(setf (type-predicate 'simple-extended-string) 'simple-extended-string-p); allowable combos are source 8 dest 16, or matching#-PPC-target(defun move-string-bytes (source dest off1 off2 n)  (declare (optimize (speed 3)(safety 0)))      (lap-inline ()    (:variable source dest off1 off2 n)    (move.l (varg n) dx)    (if# (gt (getint dx))      (sub.l ($ 1) dx)      (move.l (varg source) atemp0)      (move.l (varg dest) atemp1)      (move.l (varg off1) da)      (move.l (varg off2) db)      (getint da)      (getint db)            (if# (eq (vsubtypep ($ $v_sstr) atemp0 dy)) ; source 8 bit        (if# (eq (vsubtypep ($ $v_sstr) atemp1 dy)) ; and dest 8 bit          (lea (atemp0 da.l $v_data) atemp0)          (lea (atemp1 db.l $v_data) atemp1)          (prog# (move.b (@+ atemp0)(@+ atemp1)) (dbf dx (top#)))          else#                    (add.l db db)          (lea (atemp0 da.l $v_data) atemp0)          (lea (atemp1 db.l $v_data) atemp1)          (moveq ($ 0) dy)          (prog#            (move.b (@+ atemp0) dy)           (move.w dy (@+ atemp1))           (dbf dx (top#))))        else#                (add.l da da)        (add.l db db)        (lea (atemp0 da.l $v_data) atemp0)        (lea (atemp1 db.l $v_data) atemp1)        (prog# (move.w (@+ atemp0)(@+ atemp1)) (dbf dx (top#))))))  nil)#+ppc-target(defun move-string-bytes (source dest off1 off2 n)  (declare (optimize (speed 3)(safety 0)))  (declare (fixnum off1 off2 n))  (let* ((base-source (typep source 'simple-base-string))         (base-dest (typep dest 'simple-base-string)))    (if (and base-dest base-source)      (%copy-ivector-to-ivector source off1 dest off2 n)      (if (or base-dest base-source)        (do* ((i 0 (1+ i))              (j off1 (1+ j))              (k off2 (1+ k)))             ((= i n))          (declare (fixnum i j k))          (setf (%scharcode dest k) (%scharcode source j)))        (%copy-ivector-to-ivector source                                   (the fixnum (+ off1 off1))                                  dest                                  (the fixnum (+ off2 off2))                                  (the fixnum (+ n n)))))))(defun %str-cat (s1 s2 &rest more)  (declare (dynamic-extent more))  (require-type s1 'simple-string)  (require-type s2 'simple-string)  (let* ((base-p 'base-character)         (len1 (length s1))         (len2 (length s2))         (len (%i+ len2 len1)))    (declare (optimize (speed 3)(safety 0)))    (if (simple-extended-string-p s1)      (setq base-p nil)      (if (simple-extended-string-p s2)        (setq base-p nil)))    (dolist (s more)      (require-type s 'simple-string)      (when base-p (if (simple-extended-string-p s)(setq base-p nil)))      (setq len (+ len (length s))))    (let ((new-string (make-string len :element-type (or base-p 'extended-character))))      (move-string-bytes s1 new-string 0 0 len1)      (move-string-bytes s2 new-string 0 len1 len2)      (dolist (s more)        (setq len2 (%i+ len1 len2))        (move-string-bytes s new-string 0 len2 (setq len1 (length s))))      new-string)))(defun %substr (str start end)  (require-type start 'fixnum)  (require-type end 'fixnum)  (require-type str 'string)  (let ((len (length str)))    (multiple-value-bind (str strb)(array-data-and-offset str)      (let ((newlen (%i- end start)))        (when (%i> end len)(error "End ~S exceeds length ~S." end len))        (when (%i< start 0)(error "Negative start"))        (let ((new (make-string newlen :element-type (array-element-type str))))          (move-string-bytes str new (%i+ start strb) 0 newlen)          new)))))#+ppc-target; dont really know what the subtype is here - assume type-code??; does simple-p mean simple-vector or simple-array? - assume simple-array; does subtype nil mean don't care or simple-vector?(defun coerce-to-uvector (object subtype simple-p)  ; simple-p ?    (let ((type-code (ppc-typecode object)))    (cond ((eq type-code ppc::tag-list)           (%list-to-uvector subtype object))          ((>= type-code ppc::min-cl-ivector-subtag)  ; 175           (if (or (null subtype)(= subtype type-code))             (return-from coerce-to-uvector object)))          ((>= type-code ppc::min-vector-subtag)     ; 170           (if (= type-code ppc::subtag-simple-vector)             (if (or (null subtype)                     (= type-code subtype))               (return-from coerce-to-uvector object))             (if (and (null simple-p)                      (or (null subtype)                          (= subtype (ppc-typecode (array-data-and-offset object)))))               (return-from coerce-to-uvector object))))          (t (error "Can't coerce ~s to Uvector" object))) ; or just let length error    (if (null subtype)(setq subtype ppc::subtag-simple-vector))    (let* ((size (length object))           (val (%alloc-misc size subtype)))      (declare (fixnum size))      (multiple-value-bind (vect offset) (array-data-and-offset object)        (declare (fixnum offset))        (dotimes (i size val)          (declare (fixnum i))           (uvset val i (uvref vect (%i+ offset i))))))))#-ppc-target;(coerce object '<vector-type>); this does goofy things if subtype is goofy - assume its either generated; by compiler or fished out of a valid object(defun coerce-to-uvector (object subtype simple-p)  (new-lap    (:variable object subtype simple-p)   (exg arg_x acc)  ; obj to arg_x simple-p to arg_x   (jsr_subprim $sp-seqargz)   (if# eq                              ; list     (lfunlk)     (cjmp %list-to-uvector arg_y acc))   (if# lt                              ; simple array (da = subtype)     (if# (or (eq arg_y nilreg)         ; subtype nil or subtype matches = done              (eq (progn (move.l arg_y db) (getint db) (cmp.b db da))))       (lfret))    else#                               ; vector header     (if# (and (eq arg_x nilreg)        ; simple-p nil               (or (eq arg_y nilreg)    ; and subtype nil                   (eq (progn (move.l arg_y db) ;  subtypes match                              (getint db)                              (cmp.b (svref atemp0 arh.fixnum $arh_type) db)))))       (lfret)))   (if# (eq arg_y nilreg) (move.l (fixnum $v_genv) arg_y))   (lfunlk)   (cjmp %vector-to-uvector arg_y acc))); only caller is above#-ppc-target(defun %vector-to-uvector (new-subtype vector)   ; subtype may be nil (meaning $v_genv)  (let* ((n (length vector))         (new (%make-uvector n new-subtype)))    (multiple-value-bind (vect offset) (array-data-and-offset vector)      (declare (fixnum offset))      (dotimes (i n) (declare (fixnum i)) (uvset new i (uvref vect (%i+ offset i)))))    new)); 3 callers(defun %list-to-uvector (subtype list)   ; subtype may be nil (meaning $v_genv) - better not be  (let* ((n (length list))         (new #-ppc-target (%make-uvector n subtype)              #+ppc-target (%alloc-misc n (or subtype ppc::subtag-simple-vector))))  ; yech    (dotimes (i n)      (declare (fixnum i))      (uvset new i (%car list))      (setq list (%cdr list)))    new)); appears to be unused(defun upgraded-array-element-type (type)  (element-subtype-type (element-type-subtype type)))(defun upgraded-complex-part-type (type)  (declare (ignore type))               ; Ok, ok.  So (upgraded-complex-part-type 'bogus) is 'REAL. So ?  'real); called by %copy-array in sequences#-PPC-target(defun element-subtype-type (subtype)  (lap-inline ()    (:variable subtype)    (if# (ne (cmp.l acc nilreg))      (vscale.w acc)      (move.l '#.array-element-subtypes atemp0)      (move.l (atemp0 acc.w (- $v_data (* 2 $v_min_arr))) acc))))#+PPC-target(progn  ; we are making assumptions - put in ppc-arch? - almost same as *ppc-immheader-array-types  (defparameter ppc-array-element-subtypes    #(single-float       (unsigned-byte 32)      (signed-byte 32)      (unsigned-byte 8)      (signed-byte 8)      base-character      extended-character      (unsigned-byte 16)      (signed-byte 16)      double-float      bit))    ; given uvector subtype - what is the corresponding element-type  (defun element-subtype-type (subtype)    (declare (fixnum subtype))    (if  (= subtype ppc::subtag-simple-vector) t        (svref ppc-array-element-subtypes                (ash (- subtype ppc::min-cl-ivector-subtag) (- ppc::ntagbits)))))  )#+ppc-target(defun %make-temp-uvector (len &optional subtype)  ; that will be wrong too   (%alloc-misc len (or subtype ppc::subtag-simple-vector)))#-ppc-target(defun %make-temp-uvector (len &optional subtype)  (lap-inline ()    (:variable len subtype)    (if# (eq arg_z nilreg)      (move.l ($ $v_genv) da)     else#      (bif (or (ne (ttagp ($ $t_fixnum) arg_z da))               (ne (btst ($ $fixnumshift) arg_z))) @badz)      (move.l arg_z da)      (getint da))    (bif (or (mi (move.l arg_y acc))             (ne (ttagp ($ $t_fixnum) acc db))) @badz)    (jsr_subprim $sp-uvd1Talloc)    (move.l nilreg dy)    (if# (eq (btst ($ $VNODEBIT) da))      (cmp.b ($ $v_floatv) da)      (bne @popj)      (move.l ($ 0) dy))    (getvect atemp0 da)    (asr.l ($ 2) da)    (dbfloop.l da (move.l dy (@+ atemp0)))    (bra @popj)    @badz    (wtaerr arg_z 'fixnum)@popj));Used by transforms.(defun make-uvector (length subtype &key (initial-element () initp))  (if initp    #-ppc-target (%make-uvector length subtype initial-element)    #+ppc-target (%alloc-misc length subtype initial-element)    #-ppc-target (%make-uvector length subtype)    #+ppc-target (%alloc-misc length subtype))); %make-displaced-array assumes the following#+ppc-target(eval-when (:compile-toplevel)  (assert (eql ppc::arrayH.flags-cell ppc::vectorH.flags-cell))  (assert (eql ppc::arrayH.displacement-cell ppc::vectorH.displacement-cell))  (assert (eql ppc::arrayH.data-vector-cell ppc::vectorH.data-vector-cell)))#+PPC-target(defun %make-displaced-array (dimensions displaced-to                                         &optional fill adjustable offset temp-p)  (declare (ignore temp-p))  (if offset     (unless (and (fixnump offset) (>= (the fixnum offset) 0))      (setq offset (require-type offset '(and fixnum (integer 0 *)))))    (setq offset 0))  (locally (declare (fixnum offset))    (let* ((disp-size (array-total-size displaced-to))           (rank (if (listp dimensions)(length dimensions) 1))           (new-size (if (fixnump dimensions)                       dimensions                       (if (listp dimensions)                         (if (eql rank 1)                           (car dimensions)                           (if (eql rank 0) 1 ; why not 0?                           (apply #'* dimensions))))))           (vect-subtype (%vect-subtype displaced-to))           (target displaced-to)           (real-offset offset)           (flags 0))      (declare (fixnum disp-size rank flags vect-subtype real-offset))      (if (not (fixnump new-size))(error "Bad array dimensions ~s." dimensions))       (locally (declare (fixnum new-size))        ; (when (> (+ offset new-size) disp-size) ...), but don't cons bignums        (when (or (> new-size disp-size)                  (let ((max-offset (- disp-size new-size)))                    (declare (fixnum max-offset))                    (> offset max-offset)))          (%err-disp $err-disp-size displaced-to))        (if adjustable  (setq flags (bitset $arh_adjp_bit flags)))        (when fill          (if (eq fill t)            (setq fill new-size)            (unless (and (eql rank 1)                         (fixnump fill)                         (locally (declare (fixnum fill))                           (and (>= fill 0) (<= fill new-size))))              (error "Bad fill pointer ~s" fill)))          (setq flags (bitset $arh_fill_bit flags))))      ; If displaced-to is an array or vector header and is either      ; adjustable or its target is a header, then we need to set the      ; $arh_disp_bit. If displaced-to is not adjustable, then our      ; target can be its target instead of itself.      (when (or (eql vect-subtype ppc::subtag-arrayH)                (eql vect-subtype ppc::subtag-vectorH))        (let ((dflags (%svref displaced-to ppc::arrayH.flags-cell)))          (declare (fixnum dflags))          (when (or (logbitp $arh_adjp_bit dflags)                    (progn                      (setq target (%svref displaced-to ppc::arrayH.data-vector-cell)                            real-offset (+ offset (%svref displaced-to ppc::arrayH.displacement-cell)))                      (logbitp $arh_disp_bit dflags)))            (setq flags (bitset $arh_disp_bit flags))))        (setq vect-subtype (%array-header-subtype displaced-to)))      ; assumes flags is low byte      (setq flags (dpb vect-subtype ppc::arrayH.flags-cell-subtag-byte flags))      (if (eq rank 1)        (%ppc-gvector ppc::subtag-vectorH                       (if (fixnump fill) fill new-size)                      new-size                      target                      real-offset                      flags)        (let ((val (%alloc-misc (+ ppc::arrayh.dim0-cell rank) ppc::subtag-arrayH)))          (setf (%svref val ppc::arrayH.rank-cell) rank)          (setf (%svref val ppc::arrayH.physsize-cell) new-size)          (setf (%svref val ppc::arrayH.data-vector-cell) target)          (setf (%svref val ppc::arrayH.displacement-cell) real-offset)          (setf (%svref val ppc::arrayH.flags-cell) flags)          (do* ((dims dimensions (cdr dims))                (i 0 (1+ i)))                             ((null dims))            (declare (fixnum i)(list dims))            (setf (%svref val (%i+ ppc::arrayH.dim0-cell i)) (car dims)))          val)))))#-PPC-target(defun %make-displaced-array (dimensions displaced-to                              &optional fill adjustable offset temp-p)  (lap-inline ()    (:variable temp-p adjustable offset displaced-to fill dimensions)    (with-preserved-registers #(dsave0 dsave1 asave0 asave1)      (defreg Rdims asave1 Rdispto asave0 Rfill dsave0 Rtemp dsave1)      (move.l (varg temp-p 16) Rtemp)      (vpush (fixnum $v_arrayh))            ; [0] New subtype      (vpush ($ (%ilsl 16 $arh_one_dim)))   ; [1] New rank4 & bits      (if# (ne (cmp.l (varg adjustable 24) nilreg))        (bset ($ $arh_adjp_bit) (vsp $arh_bits)))      (move.l (varg offset 24) acc)      (if# (eq (cmp.l acc nilreg)) (move.l (fixnum 0) acc)           elseif# (or (ne (ttagp ($ $t_fixnum) acc da)) (mi (tst.l acc))) (wtaerr acc 'unsigned-byte))      (vpush acc)                            ; [2] ARH.OFFS New offset (boxed)      (move.l (varg displaced-to 28) Rdispto)      (ccall array-total-size Rdispto)      (sub.l (vsp) acc)                      ;acc <- available size (boxed)      (bmi @dispsz)      (move.l Rdispto arg_x)                 ; [3] ARH.VECT new data      (vsubtype Rdispto da)      (if# (eq (cmp.b ($ $v_arrayh) da)) ; is dispto array        (if# (or (ne (btst ($ $arh_adjp_bit) (vref.l Rdispto arh.fixnum $arh_bits)))                 ; is target adjustable                 (ne (progn                       (move.l (svref Rdispto arh.offs) da)                       ;This can't overflow since (VSP)<=arrsiz<=Lo3bytes                        ; and OFFS<=Lo3bytes.                       (add.l da (vsp))                       (move.l (svref Rdispto arh.vect) arg_x)                       ; or is target displaced                       (btst ($ $arh_disp_bit) (vref.l Rdispto arh.fixnum $arh_bits)))))          ; then result is displaced - huh - isn't it always          (bset ($ $arh_disp_bit) (vsp (+ 4 $arh_bits))))        ; get arh_type to da        (move.b (svref Rdispto arh.fixnum $arh_type) da))      (move.b da (vsp (+ 4 $arh_type)))      ;Finally check out the dimensions. acc has the available size (boxed)      (move.l (varg fill 28) Rfill)      (move.l (varg dimensions 28) Rdims)      (bif (eq (cmp.l Rdims nilreg)) @arr)      (move.l Rdims arg_y)                   ; [4] ARH.VLEN new vlen      (if# (eq (ttagp ($ $t_cons) arg_y da))        (bif (ne (cmp.l (cdr Rdims) nilreg)) @arr)        (car Rdims arg_y))      (bif (ne (ttagp ($ $t_fixnum) arg_y da)) @badims)      (bif (gt (cmp.l acc arg_y)) @dispsz)      (move.l arg_y arg_z)                   ; [5] ARH.FILL new fill      (if# (ne (cmp.l nilreg Rfill))        (bset ($ $arh_fill_bit) (vsp (+ 4 $arh_bits))))      (set_nargs 6)      (bra @make)      @badims	(wtaerr Rdims 'fixnum)      @dispsz	(signal_error (fixnum $err-disp-size) Rdispto)      @arr ; here is rdims is NIL or rdims is consp len > 1      (vpush arg_x)      (vpush acc)                            ; save allowable size      (move.l Rdims arg_z)      (set_nargs 0)                          ; (apply #'* dimensions)      (jsr_subprim $sp-spreadargz-vextend)      (spush nargs)                          ; Save the new rank while we've got it      (add.l ($ 1) (sp))			  :make it safe      (jsr #'*)      (jsr_subprim $sp-vchunkpop)      (spop nargs)      (sub.w ($ 1) nargs)      (move.w nargs (vsp (+ 12 $arh_rank4)))   ; store rank4      ;If ACC is not a fixnum, it's either because there were some non-integers      ;in the dimensions list, or because we overflowed to bignum.  The latter      ;case should be a DISPSZ error but...      (bif (or (ne (ttagp ($ $t_fixnum) acc da)) (mi (tst.l acc))) @badims)      (bif (gt (cmp.l (@+ vsp) acc)) @dispsz)      (move.l Rdims arg_z)                   ; All typechecked, go for it.      (set_nargs 4)      (jsr_subprim $sp-spreadargz-vextend)      (move.l nilreg Rdims)@make      (if# (ne nilreg Rtemp)        (jsr_subprim $sp-Tgvector)        else#        (jsr_subprim $sp-gvector))      (if# (eq nilreg Rdims)        (jsr_subprim $sp-vchunkpop))      (if# (ne (cmp.l nilreg Rfill))         ; Fill pointer?        (vpush acc)        (ccall set-fill-pointer acc Rfill)   ; Set it.        (vpop acc)))))#+ppc-target(defun vector-pop (vector)  (let* ((fill (fill-pointer vector)))    (declare (fixnum fill))    (if (zerop fill)      (error "Fill pointer of ~S is 0 ." vector)      (progn        (decf fill)        (%set-fill-pointer vector fill)        (aref vector fill)))))#-ppc-target(defun vector-pop (vector)  (lap-inline ()    (:variable vector)   (move.l arg_z atemp0)   (if# (or (ne (jsr_subprim $sp-arrayarg))            (eq (btst ($ $arh_fill_bit) (svref atemp0 arh.fixnum $arh_bits))))     (tsignal_error (fixnum $XNOFILLPTR) arg_z))   (if# (mi (progn (move.l (svref atemp0 arh.fill) db)                   (sub.l '1 db)))     (ccall error '"Fill pointer of ~S is 0 ." arg_z))   (vpush atemp0)   (prog#    (add.l (svref atemp0 arh.offs) db)    (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))    (move.l (svref atemp0 arh.vect) atemp0)    (until# eq))   (vsubtype atemp0 da)   (jsr_subprim $sp-uvd1ref)   (vpop atemp0)   (sub.l '1 (svref atemp0 arh.fill))))#+ppc-target(defun elt (sequence idx)  (seq-dispatch   sequence   (let* ((cell (nthcdr idx sequence)))     (declare (list cell))     (if cell (car cell) (%err-disp $XACCESSNTH idx sequence)))   (progn     (unless (and (typep idx 'fixnum) (>= (the fixnum idx) 0))       (report-bad-arg idx 'unsigned-byte))     (locally        (declare (fixnum idx))       (if (and (array-has-fill-pointer-p sequence)                (>= idx (the fixnum  (fill-pointer sequence))))         (%err-disp $XACCESSNTH idx sequence)         (aref sequence idx))))))#-ppc-target(defun elt (sequence idx)  (lap-inline ()    (:variable sequence idx)   (exg arg_y arg_z)   (jsr_subprim $sp-seqargz)           ; preserves arg_y, arg_z   (if# ne     (if# lt       (if# (or (ne (ttagp ($ $t_fixnum) arg_y db))                (mi (move.l arg_y db)))         (wtaerr arg_y 'unsigned-byte))       else#       (if# (ne (ttagp ($ $t_fixnum) arg_y db))         (wtaerr arg_y 'fixnum))       (if# (geu (cmp.l (svref atemp0 arh.fill) arg_y))         (tsignal_error (fixnum $XARROOB) arg_y atemp0))       (move.l arg_y db)       (prog#        (add.l (svref atemp0 arh.offs) db)        (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))        (move.l (svref atemp0 arh.vect) atemp0)        (until# eq))       (vsubtype atemp0 da))     (jsr_subprim $sp-uvd1ref)     else#     (ccall nthcdr arg_y arg_z)     (if# (eq nilreg acc)       (signal_error (fixnum $XACCESSNTH) (varg idx) (varg sequence)))     (jsr_subprim $sp-car))))#+ppc-target                         (defun set-elt (sequence idx value)  (seq-dispatch   sequence   (let* ((cell (nthcdr idx sequence)))     (if cell        (locally          (declare (cons cell))         (setf (car cell) value))       (%err-disp $XACCESSNTH idx sequence)))   (progn     (unless (and (typep idx 'fixnum) (>= (the fixnum idx) 0))       (report-bad-arg idx 'unsigned-byte))     (locally        (declare (fixnum idx))       (if (and (array-has-fill-pointer-p sequence)                (>= idx (the fixnum (fill-pointer sequence))))         (%err-disp $XACCESSNTH idx sequence)         (setf (aref sequence idx) value))))))#-ppc-target(defun set-elt (sequence index value)  (lap-inline ()    (:variable sequence index value)    (move.l arg_x atemp0)    (jsr_subprim $sp-seqarg-atemp0)		;Preserves arg_y, arg_z    (if# ne      (if# lt        (if# (or (ne (ttagp ($ $t_fixnum) arg_y db))                 (mi (move.l arg_y db)))          (wtaerr arg_y 'unsigned-byte))       else#       (if# (ne (ttagp ($ $t_fixnum) arg_y db))         (wtaerr arg_y 'fixnum))       (if# (geu (cmp.l (svref atemp0 arh.fill) arg_y))         (tsignal_error (fixnum $XARROOB) arg_y atemp0))       (move.l arg_y db)       (prog#        (add.l (svref atemp0 arh.offs) db)        (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))        (move.l (svref atemp0 arh.vect) atemp0)        (until# eq))       (vsubtype atemp0 da))      (jsr_subprim $sp-uvd1set)      else#      (ccall nthcdr arg_y atemp0)      (if# (eq nilreg acc)        (signal_error (fixnum $XACCESSNTH) (varg index) (varg sequence)))      (jsr_subprim $sp-car)      (move.l (varg value) acc)      (rplaca atemp0 acc))))(%fhave 'equalp #'equal)                ; bootstrapping(defun copy-tree (tree)  (if (atom tree)    tree    (locally (declare (type cons tree))      (do* ((tail (cdr tree) (cdr tail))            (result (cons (copy-tree (car tree)) nil))            (ptr result (cdr ptr)))           ((atom tail)            (setf (cdr ptr) tail)            result)        (declare (type cons ptr result))        (locally           (declare (type cons tail))          (setf (cdr ptr) (cons (copy-tree (car tail)) nil)))))))#|(defun set-periodic-task-interval (n)  (lap-inline ()    (:variable n)    (if# (not          (and           (ne (dtagp arg_z $t_fixnum))           (pl (progn                 (move.l arg_z da)                 (getint da)                 (move.w da db)))           (eq (progn                 (ext.l db)                 (mkint db)                 (cmp.l db arg_z)))))      (wtaerr arg_z '(integer 0 32767)))    (move.w da (a5 $vblwait1))))|##-ppc-target(defun set-periodic-task-interval (n)  (when (or (not (fixnump n)) (%i< n 0)(%i> n 32767))    (report-bad-arg n '(integer 0 32767)))  (setf (%get-word (%currenta5) $vblwait1) n))#-ppc-target(defun periodic-task-interval ()  (%get-word (%currenta5) $vblwait1))#+ppc-target(defun set-periodic-task-interval (n)  n)#+ppc-target(defun periodic-task-interval ()  1)(defun make-char-up-table (script)  (let* ((font (#_getscript script #$smScriptAppFond)))    (%stack-block ((p1 256))      (dotimes (i 256) (%put-byte p1 i i))      (with-font font        (#_uppertext p1 256)        (%str-from-ptr-in-script p1 256 script)))))(defun make-char-down-table (script)  (let* ((font (#_getscript script #$smScriptAppFond)))    (%stack-block ((p1 256))      (dotimes (i 256) (%put-byte p1 i i))      (with-font font        (#_lowertext p1 256)        (%str-from-ptr-in-script p1 256 script)))))   (defparameter char-up-string-1  " 	
 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~I") (defparameter char-down-string-1  " 	
 !\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~") ; for chars between #\200 and #\237#|(defparameter char-up-string  ""); monaco 9 is missing many of these but monaco 14 has them;(defparameter char-up-string  ""); between #\200 and #\206(defparameter char-down-string  ""); between #\313 and #\315  (defparameter char-down-string-313 ""); between #\345 and #\364 - the blotch is the apple(defparameter char-down-string-345  "")|# (defun char-downcase (c)    (let* ((code (char-code c))           (script (string-compare-script)))      (declare (optimize (speed 3)(safety 0)))      (if  (and (%i< code 128)                (or (eq script #$smRoman)                    (eq script #$smJapanese)))        (if (and (%i>= code (char-code #\A))(%i<= code (char-code #\Z)))          (%code-char (%i+ code #.(- (char-code #\a)(char-code #\A))))          c)        (let ((tbl (get-char-down-table script)))          (if  tbl             (if (%i< code #x100) (%schar tbl code) c)            (xchar-up-down c t)))))); not used(defun %char-upcase (c)  (declare (optimize (speed 3)(safety 0))) ; no #args checked  ;(dbg)  (let ((code (%char-code c))        (tbl (get-char-up-table *string-compare-script*)))    (if  tbl       (if (%i< code #x100) (%schar tbl code) c)      (xchar-up-down c))))  (defun digit-char-p (char &optional radix)  (let* ((code (char-code char))         (r (if radix (if (and (typep radix 'fixnum)                               (%i>= radix 2)                               (%i<= radix 36))                        radix                        (%validate-radix radix)) 10))         (weight (if (and (<= code (char-code #\9))                          (>= code (char-code #\0)))                   (the fixnum (- code (char-code #\0)))                   (if (and (<= code (char-code #\Z))                            (>= code (char-code #\A)))                     (the fixnum (+ 10 (the fixnum (- code (char-code #\A)))))                   (if (and (<= code (char-code #\z))                            (>= code (char-code #\a)))                     (the fixnum (+ 10 (the fixnum (- code (char-code #\a))))))))))    (declare (fixnum code r))    (and weight (< (the fixnum weight) r) weight)))(defun char-upcase (c)    (let* ((code (char-code c))           (script (string-compare-script)))      (declare (optimize (speed 3)(safety 0)))      (if  (and (%i< code 128)                (or (eq script #$smRoman)                    (eq script #$smJapanese)))        (if (and (%i>= code (char-code #\a))(%i<= code (char-code #\z)))          (%code-char (%i- code #.(- (char-code #\a)(char-code #\A))))          c)        (let ((tbl (get-char-up-table script)))          (if  tbl             (if (%i< code #x100) (%schar tbl code) c)            (xchar-up-down c))))))(defun chkbounds (arr start end)  (flet ((are (a i)(error "Array index ~S out of bounds for ~S." a i)))    (let ((len (length arr)))      (if (and end (> end len))(are arr end))      (if (and start (or (< start 0)(> start len)))(are arr start))      (if (%i< (%i- (or end len)(or start 0)) 0)        (error "Start ~S exceeds end ~S." start end)))))(defun string-start-end (string start end)  (setq string (string string))  (let ((len (length (the string string))))    (flet ((are (a i)(error "Array index ~S out of bounds for ~S." i a)))          (if (and end (> end len))(are string end))      (if (and start (or (< start 0)(> start len)))(are string start))      (setq start (or start 0) end (or end len))      (if (%i> start end)        (error "Start ~S exceeds end ~S." start end))      (multiple-value-bind (str off)(array-data-and-offset string)        (values str (%i+ off start)(%i+ off end))))))(defun string= (string1 string2 &key start1 end1 start2 end2)    (locally (declare (optimize (speed 3)(safety 0)))      (if (and (simple-string-p string1)(null start1)(null end1))        (setq start1 0 end1 (length string1))        (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1)))      (if (and (simple-string-p string2)(null start2)(null end2))        (setq start2 0 end2 (length string2))        (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2)))          (%simple-string= string1 string2 start1 start2 end1 end2))); redefined in chars (defun string-equal (string1 string2 &key start1 end1 start2 end2)  (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1))  (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2))  (when (eq (%i- end2 start2) (%i- end1 start1))    (let ((upstring char-up-string-1))      (declare (type (simple-array (unsigned-byte 8) (*)) upstring)               (optimize (speed 3)(safety 0)))          ; believe the lie.      (do* ((i start1 (%i+ 1 i))            (j start2 (%i+ 1 j)))           ((%i>= j end2))        (let* ((c1 (aref upstring (%scharcode string1 i)))               (c2 (aref upstring (%scharcode string2 j))))          (when (neq c1 c2)(return-from string-equal nil))))      t)))        ; ditto(defun string-lessp (string1 string2 &key start1 end1 start2 end2)  (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1))  (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2))    (let ((upstring char-up-string-1))      (declare (type (simple-array (unsigned-byte 8) (*)) upstring)               (optimize (speed 3)(safety 0)))          ; stop this nonsense, please!.      (do* ((i start1 (%i+ 1 i))            (j start2 (%i+ 1 j)))           ((or (eq j end2)(eq i end1))(if (< j end2) (- i start1) nil))        (let* ((c1 (aref upstring (%scharcode string1 i)))               (c2 (aref upstring (%scharcode string2 j))))          (when (neq c1 c2)            (if (> c1 c2)              (return-from string-lessp nil)              (return-from string-lessp (- i start1))))))))  #-PPC-target; used by define-pascal-function  (needed), generate-setup-code (eval), make-stack-group; and 68k compiler(defun %make-lfun (imms icode linkmap bits attrib)  (let* (immstart         (numcodewords (length icode)) codestart         (numrefwords (length linkmap)) linkmapstart)    (multiple-value-setq (imms immstart) (array-data-and-offset imms))    (unless (= (the fixnum (%vect-subtype imms)) $v_genv)      (setq imms (require-type imms '(vector t))))    (multiple-value-setq (icode codestart) (array-data-and-offset icode))    (unless (= (the fixnum (%vect-subtype icode)) $v_swordv)      (setq icode (require-type icode '(vector (signed-byte 16)))))    (multiple-value-setq (linkmap linkmapstart) (array-data-and-offset linkmap))    (unless (= (the fixnum (%vect-subtype linkmap)) $v_swordv)      (setq linkmap (require-type linkmap '(vector (signed-byte 16)))))        (lap-inline ()     (:variable linkmap imms numrefwords numcodewords linkmapstart attrib bits icode codestart immstart)      (preserve_regs #(asave0 asave1 dsave0)) (equate _vtop 12)      (defreg LINKMAP asave0 IMMS asave1 NREFS dsave0)      (move.l (varg linkmap _vtop) LINKMAP)      (move.l (varg imms _vtop) IMMS)      (move.l (varg numrefwords _vtop) NREFS)      ; we need (codewords + 1 [attributes] + 2 [lfbits] imm-mapwords + link-map words)  words total      (move.l (varg numcodewords _vtop) acc)      (vscale.w acc)      (add.l ($ 8) acc)                ; 6 bytes [attributes/lfbits] + 1 immmap null + rounding      (move.l NREFS da)      (vscale.w da)      (asr.l 2 da)                      ; da = numrefs      (move.l (varg linkmapstart _vtop) dx)      (vscale.w dx)      (lea (LINKMAP dx.l $v_data) atemp0)      (moveq 0 dx)      (moveq 0 db)      (dbfloop da        (move.l (@+ atemp0) dy)        (if# (and (ne (btst ($ $lm_bit_longimm) dy))                  #|(eq (btst ($ $lm_bit_indirect) dy))|#)          (add.l ($ 1) db)          (clr.w dy)          (swap dy)          (sub.l dx dy)          (add.l dy dx)          (if# (pl (cmp.l ($ 128) dy)) (add.l ($ 1) db))))      (add.l db acc)      (bclr 0 acc)      (if# (eq (tst.l db)) (sub.l ($ 2) acc))      (moveq $v_nlfunv arg_y)      (move.w acc atemp0)      (if# (ne acc atemp0) (ccall 'compiler-function-overflow))      (jsr_subprim $sp-allocvect)      (move.l (varg attrib _vtop) acc)      (if# (eq nilreg acc) (moveq '0 acc))      (getint acc)      (and.w ($ (lognot (logior (%ilsl $lfatr-immmap-bit 1)                                (%ilsl $lfatr-linkmap-bit 1)                                (%ilsl $lfatr-slfunv-bit 1)))) acc)      (bset ($ $lfatr-new-lfbits-bit) acc)      (move.w acc (atemp0 ($lfv_attrib)))      (move.l atemp0 atemp1)      (getvect atemp1 dy)      (add.l atemp1 dy)                    ; dy = end of lfun vector      (add.w ($ ($lfv_lfun)) atemp0)      (move.l atemp0 acc)                  ; acc = lfun      (move.l (varg icode _vtop) atemp1)   ; Copy code      (add.w ($ $v_data) atemp1)      (move.l (varg codestart _vtop) da)      (vscale.w da)      (add.l da atemp1)      (move.l (varg numcodewords _vtop) da)      (getint da)      (dbfloop da (move.w (@+ atemp1) (@+ atemp0)))      (move.l acc atemp1)            ; preserved by getlong      (move.l (varg bits _vtop) acc)      (jsr_subprim $sp-getlong)      (move.l atemp1 atemp0)      (move.l dy atemp1)                   ; atemp1 = dy = lfun end      (move.l acc -@atemp1)      (move.l atemp1 dy)      (move.l atemp0 acc)               ; acc = atemp0 = lfun      (move.l (varg linkmapstart _vtop) da)      (vscale.w da)      (lea (LINKMAP da.l $v_data) LINKMAP)      (asr.l ($ (1+ $fixnumshift)) NREFS)      (move.l (varg immstart _vtop) da)      (vscale.l da)      (lea (IMMS da.l $v_data) IMMS)      (move.l ($ 0) da)      (dbfloop NREFS        (move.l (@+ LINKMAP) db)        (if# (and (ne (btst ($ $lm_bit_longimm) db))                  #|(eq (btst ($ $lm_bit_indirect) db))|#)          (btst ($ $lm_bit_indirect) db)          (sne dtemp0)          (clr.w db)          (swap db)          (sub.l da db)          (add.l db da)          (if# (pl (cmp.l ($ 128) db))            (lsr.b 1 db)            (bset 7 db)            (move.b db (-@ atemp1))            (lsr.w ($ 8) db)            (move.b db (-@ atemp1))           else#            (lsr.b 1 db)            (move.b db (-@ atemp1)))          (move.l ($ 0) dx)          (move.w (atemp0 da.l 2) dx)    ; immno          (lsl.l ($ 2) dx)          (move.l (IMMS dx.l) dx)          (moveq 0 db)          (move.w (atemp0 da.l) db)       ; symloc offset if any          (add.l db dx)          (exg atemp1 dx)          (if# (ne (tst.b dtemp0))            (if# (eq (sub.w ($ $sym.gvalue) db))              (move.l @atemp1 atemp1)              else#              (move.l (atemp1 (- $sym.entrypt $sym.fapply)) atemp1)))          (move.l atemp1 (atemp0 da.l))          (move.l dx atemp1)))      (if# (ne atemp1 dy)        (bset.w ($ $lfatr-immmap-bit) (atemp0 ($lf_attrib)))        (sf (-@ atemp1))        (move.l atemp1 dx)        (if# (ne (btst ($ 0) dx))           (sf -@atemp1)))               ; don't leave an uninitialized byte      (move.l atemp0 acc)      (jsr_subprim $flush_code_cache)       (restore_regs))))#+ppc-target(defun lfun-attributes (lfun &optional new-value)  (declare (ignore lfun new-value))  0)#-PPC-target(defun lfun-attributes (lfun &optional new-value)  (lap-inline (new-value (%lfun-vector lfun t))    (move.l acc atemp0)    (if# (eq (cmp.l arg_y nilreg))      (move.w (atemp0 ($lfv_attrib)) acc)      (ext.l acc)      (mkint acc)     else#      (move.l arg_y acc)      (getint arg_y)      (move.w arg_y (atemp0 ($lfv_attrib))))))#+PPC-target(progn  ; only returns 1 value  (defun %nth-immediate (lfv i &optional (n (%count-immrefs lfv)))    (declare (fixnum i n))    (unless (and (>= i 0) (< i n))      (report-bad-arg i `(integer 0 ,n)))    (%svref lfv (the fixnum (1+ i))))    (defun %count-immrefs (lfv)    (- (uvsize lfv) 2))); No big deal about NILREG-[FV]CELL-SYMBOLS anymore, so last value always false.#-PPC-target(defun %nth-immediate (lfv i &optional (n (%count-immrefs lfv)))  (declare (fixnum i n))  (unless (and (>= i 0) (< i n))    (report-bad-arg i `(integer 0 ,n)))  (new-lap   (:variable lfv i)    (move.l (varg lfv) atemp0)    (getvect atemp0 da)    (move.w (atemp0 (- ($lfv_attrib) $v_data)) db)    (if# (ne (btst ($ $lfatr-slfunv-bit) db))      (sub.l ($ 4) da))    (lea (atemp0 da.l -4) atemp1)    (add.w ($ (- ($lfv_lfun) ($lfv_attrib))) atemp0)    (move.l (varg i) arg_y)@loop    (move.l ($ 0) da)    (move.b -@atemp1 da)    (if# (cs (add.b da da))      (rol.w ($ 8) da)      (move.b -@atemp1 da)      (rol.w ($ 8) da))    (add.l da atemp0)    (bif (pl (sub.l '1 arg_y)) @loop)    (move.l @atemp0 acc)    (if# (eq (ttagp ($ $t_symbol) acc da)) ; sets da.l to 0      (move.l acc atemp0)      (if# (ne (tst.w (atemp0 (- $t_symbol))))        (moveq $sym.gvalue da)        (if# (ne (tst.w (atemp0 (- (+ $t_symbol $sym.gvalue)))))          (moveq $sym.fapply da)))      (sub.l da acc)      (ext.w da)      (ext.l da)      (mkint da)      else#      (moveq 0 da))    (vpush acc)    (vpush da)    (vpush nilreg)                      ; why bother ?    (set_nargs 3)    (jmp_subprim $sp-nvalret)))#-PPC-target(progn;Offset from start of lfun.(defun %immediate-offset (lfv i &optional (n (%count-immrefs lfv)))  (declare (fixnum i n))  (unless (and  (<= 0 i) (< i n))    (report-bad-arg i `(integer 0 ,(1- n))))  (lap-inline (i lfv)    (move.l arg_z atemp0)    (getvect atemp0 da)    (move.w (atemp0 (- ($lfv_attrib) $v_data)) db)    (if# (ne (btst ($ $lfatr-slfunv-bit) db))      (sub.l ($ 4) da))    (if# (ne (btst ($ $lfatr-new-lfbits-bit) db))      (sub.l ($ 4) da))    (add.l da atemp0)    (moveq 0 acc)    (prog#     (move.l ($ 0) da)     (move.b -@atemp0 da)     (if# (cs (add.b da da))       (move.w da (-@ sp))       (move.b -@atemp0 (sp))       (move.w sp@+ da))     (add.l da acc)     (until# (mi (sub.l '1 arg_y))))    (mkint acc)))(defun %count-immrefs (lfunv)  (lap-inline (lfunv)   (move.l arg_z atemp0)   (if# (or (ne (ttagp ($ $t_vector) arg_z da))            (ne (vsubtypep ($ $v_nlfunv) atemp0 da)))     (wtaerr arg_z 'lfun-vector))   (move.l '0 acc)   (if# (ne (btst.w ($ $lfatr-immmap-bit) (atemp0 ($lfv_attrib))))     (getvect atemp0 da)     (move.w (atemp0 (- ($lfv_attrib) $v_data)) db)     (if# (ne (btst ($ $lfatr-slfunv-bit) db))       (sub.l ($ 4) da))     (if# (ne (btst ($ $lfatr-new-lfbits-bit) db))       (sub.l ($ 4) da))     (add.l da atemp0)     (while# (ne (tst.b -@atemp0))       (if# mi (sub.l ($ 1) atemp0))       (add.l '1 acc)))))) ; end #-ppc#-PPC-target(defun %lfun-vector-p (vector)  (declare (%noforcestk))  (lap-inline (vector)    (move.l arg_z atemp0)    (move.l nilreg acc)    (if# (and (eq (ttagp ($ $t_vector) atemp0 da))             (eq (vsubtypep ($ $v_nlfunv) atemp0 da)))      (add.l ($ $t_val) acc))))(setf (type-predicate 'lfun-vector) '%lfun-vector-p)#+GONZO  ; isn't used(defun %lfun-vector-lfun-name-offset (lfunv)  ;This takes an lfun vector, but returns offset from start of lfun.  #-bccl (setf lfunv (require-type lfunv 'lfun-vector))  (lap-inline ()    (:variable lfunv)    (move.l (varg lfunv) atemp1)    (move.l nilreg acc)    (if# (and (ne (btst.w ($ $lfatr-immmap-bit) (atemp1 ($lfv_attrib))))              (eq (btst.w ($ $lfatr-noname-bit) (atemp1 ($lfv_attrib)))))      (getvect atemp1 da)      (move.w (atemp1 (- ($lfv_attrib) $v_data)) db)      (if# (ne (btst ($ $lfatr-slfunv-bit) db))       (sub.l ($ 4) da))      (if# (ne (btst ($ $lfatr-new-lfbits-bit) db))       (sub.l ($ 4) da))      (add.l da atemp1)      (moveq 0 acc)      (while# (ne (progn (moveq 0 da) (move.b (-@ atemp1) da)))        (if# (cs (add.b da da))          (move.b (-@ atemp1) db) (lsl.w 8 db) (add.w db da))        (add.l da acc))      (mkint acc))))(defun lfun-keyvect (lfun)  ;Don't bother with kernel fns, they're going away.  (let ((lfv (%lfun-vector lfun)))    (when lfv      (let ((bits (lfun-bits lfun)))        (declare (fixnum bits))        (and (logbitp $lfbits-keys-bit bits)             (or (logbitp $lfbits-method-bit bits)                 (and (not (logbitp $lfbits-gfn-bit bits))                      (not (logbitp $lfbits-cm-bit bits))))             (if #+ppc-target (typep lfv 'interpreted-function) ; patch needs interpreted-method-function too                 #-ppc-target nil               (nth 4 (evalenv-fnentry (%nth-immediate lfv 0))) ; gag puke               (%nth-immediate lfv 0)))))))#+PPC-target(progn  ; ???(defun %lfun-vector-lfun (lfv) lfv)(defun %lfun-vector (lfn &optional load-p)      ; this is in level-0;68k-def  (declare (ignore load-p))  lfn))#-PPC-target(defun %lfun-vector-lfun (lfv)  #-bccl (setq lfv (require-type lfv 'lfun-vector))  (lap-inline ()    (:variable lfv)    (moveq ($lfv_lfun) acc)    (add.l (varg lfv) acc)    (move.l acc atemp0)    (if# (ne (btst.w ($ $lfatr-slfunv-bit) (atemp0 ($lf_attrib))))      (move.l (a5 $slfuns_start) atemp1)      (sub ($ 2) atemp1)      (move.l (a5 $slfuns_end) db)      (prog#        (add ($ 2) atemp1)        (while# (ne (cmp.l db atemp1)))        (add.w ($ 2) atemp1)        (until# (and (eq (cmp.l (@+ atemp1) acc))                     (eq (cmp.w ($ $jmp_absl) (atemp1 -6)))))        (move.l atemp1 acc)        (sub.l ($ 6) acc)))))(defun function-lambda-expression (fn)  ;(declare (values def env-p name))  (let* ((bits (lfun-bits (setq fn (require-type fn 'function)))))    (declare (fixnum bits))    (if (logbitp $lfbits-trampoline-bit bits)      (function-lambda-expression (%nth-immediate (%lfun-vector fn) 0))      (values (uncompile-function fn)              (logbitp $lfbits-nonnullenv-bit bits)              (function-name fn))))); env must be a lexical-environment or NIL.; If env contains function or variable bindings or SPECIAL declarations, return t.; Else return nil(defun %non-empty-environment-p (env)  (loop    (when (or (null env) (istruct-typep env 'definition-environment))      (return nil))    (when (or (consp (lexenv.variables env))              (consp (lexenv.functions env))              (dolist (vdecl (lexenv.vdecls env))                (when (eq (cadr vdecl) 'special)                  (return t))))      (return t))    (setq env (lexenv.parent-env env))));(coerce object 'compiled-function)(defun coerce-to-compiled-function (object)  (setq object (coerce-to-function object))  (unless (typep object 'compiled-function)    (multiple-value-bind (def envp) (function-lambda-expression object)      (when (or envp (null def))        (%err-disp $xcoerce object 'compiled-function))      (setq object (compile-user-function def nil))))  object);Map function over all heap lfuns - only caller is callers! - we can punt; but remember need to do it#-PPC-target(defun %map-lfuns (function)  (setq function (coerce-to-function function))  (lap-inline ()    (:variable function)    (with-preserved-registers #(dsave0 asave0)      (move.l (varg function 8) asave0)      (move.l nilreg arg_z)      (jsr_subprim $sp-consZnil)      (move.l acc dsave0)      (move.l (a5 $Pdynamic_cons_area) atemp1)      (move.l (atemp1 $cons-area.gspace-start) atemp0)      (prog#       (move.l @atemp0 da)       (if# (ne (progn (header-p da db)))         (add ($ 8) atemp0)         elseif# (eq (cmp.w ($ $symbol-header) da))         (lea (atemp0 $sym_size) atemp0)         else#         (header-subtype da db)         (if# (eq (cmp.b ($ $v_nlfunv) db))           (add.w ($ $t_vector) atemp0)           (vpush atemp0)           (move.l ($ ($lfv_lfun)) arg_z)           (add.l atemp0 arg_z)           (set_nargs 1)           (jsr @asave0)           (move.l (a5 $Pdynamic_cons_area) atemp1)           (vpop atemp0)           (sub.w ($ $t_vector) atemp0))         (header-length @atemp0 da)         (add2.l ($ 11) da)         (and.b ($ (lognot 7)) da)         (add.l da atemp0))       (until# (geu dsave0 atemp0)))))  nil)#-PPC-target(progn; The first nrs-offset is $t_val.(defvar *last-nrs-offset* (lap-inline ()                             (move.l (a5 $nrs_end) acc)                            (sub.l nilreg acc)                            (mkint acc)))(defun nilreg-cell-symbol (offset)  "Given nilreg offset, return corresponding symbol and locative offset"  (if (not (typep offset 'fixnum))    (values nil nil)    (locally      (declare (fixnum offset))      (let* ((tdiff (- offset $t_val)))        (declare (fixnum tdiff))        (if (and (>= tdiff 0)                 (< offset (the fixnum *last-nrs-offset*))                 (= 0 (the fixnum (logand tdiff $typemask))))          (let* ((locative (mod tdiff $sym_size))                 (base-symbol (- tdiff locative)))            (declare (fixnum tdiff base-symbol))            (values (%symptr->symbol (lap-inline (base-symbol)                                       (getint acc)                                       (add.l (a5 $t) acc)))                    locative))          (values nil nil)))))))            ; Given nilreg relative symbol, return offset; Return NIL for non-symbol or non-nilreg relative symbol#+GONZO(defun nilreg-offset (sym)  (when (symbolp sym)    (lap-inline (sym)      (move.l arg_z atemp0)      (move.l nilreg acc)      (if# (ne (btst ($ $sym_bit_indirect) (atemp0 $sym.vbits)))        (move.l (atemp0 $sym.gvalue) acc)        (sub.l nilreg acc)        (mkint acc)))))#-ppc-target(defvar %toplevel-function% nil)(unless (fboundp 'call-toplevel-function)(defun call-toplevel-function (fun)  (funcall fun))) ; end unless(defun %set-toplevel (&optional (fun nil fun-p))  ;(setq fun (require-type fun '(or symbol function)))  (if (eq *current-process* *initial-process*)    (prog1      %toplevel-function%      (when fun-p        (setq %toplevel-function% fun)))    (let* ((p *current-process*)           (function.args (process.initial-form p)))      (prog1        (if (eq (car function.args) #'call-toplevel-function)          (cadr function.args)          (if (cdr function.args)            (let ((function.args (copy-list function.args)))              #'(lambda () (apply (car function.args) (cdr function.args))))            (car function.args)))        (when fun-p          (without-interrupts           (setf (car function.args) #'call-toplevel-function                 (cdr function.args) (list fun)))))))); Look! GC in Lisp !#-ppc-target(defun full-gccount ()  (%get-unsigned-word   (%get-ptr (%get-ptr (%currentA5) $Pdynamic_cons_area)             $cons-area.pgc-count)))#-ppc-target(defun gc ()  (let ((hook *pre-gc-hook*))    (when (functionp hook)      (without-interrupts       (funcall hook))))  (let* ((*pre-gc-hook* nil)         (count (full-gccount)))    (loop      (%primitive $sp-gcoll :acc)      (unless (eql count (full-gccount))        (return)))))#+ppc-target(defppclapfunction full-gccount ()  (ref-global arg_z tenured-area)  (cmpwi cr0 arg_z 0)  (if :eq    (ref-global arg_z gc-count)    (lwz arg_z ppc::area.gc-count arg_z))  (blr))#+ppc-target(defun gccounts ()  (let* ((total (%get-gc-count))         (full (full-gccount))         (g2-count 0)         (g1-count 0)         (g0-count 0))    (when (egc-enabled-p)      (let* ((a (%normalize-areas)))        (setq g0-count (%fixnum-ref a ppc::area.gc-count) a (%fixnum-ref a ppc::area.older))        (setq g1-count (%fixnum-ref a ppc::area.gc-count) a (%fixnum-ref a ppc::area.older))        (setq g2-count (%fixnum-ref a ppc::area.gc-count))))    (values total full g2-count g1-count g0-count)))      #+ppc-target(defppclapfunction gc ()  (uuo_xalloc rzero rzero rzero)  (mr arg_z rnil)  (blr))#+ppc-target(defppclapfunction purify ()  (uuo_xalloc rzero rnil rzero)  (mr arg_z rnil)  (blr))#+ppc-target(defppclapfunction %save-library ((refnum 0) (libname arg_x) (firstobj arg_y) (lastobj arg_z))  (vpop temp0)  (unbox-fixnum imm0 temp0)  (uuo_xalloc rzero vsp imm0)  (box-fixnum arg_z imm0)  (box-unsigned-byte-32 arg_y imm1 imm2)  (vpush arg_z)  (vpush arg_y)  (la temp0 8 vsp)  (set-nargs 2)  (ba .SPvalues));;;Procedure for creating pascal callable functions(defparameter %pascal-functions%  (make-array 4 :initial-element nil)); If name is already bound to a pascal-callable function, reuse the slot it occupies; so that pointers buried in Mac data structures remain valid.#-PPC-target(defun define-pascal-function (fn code lfun-offset &optional without-interrupts &aux name slot slot-index)  (setq fn (require-type fn 'function))  (unless (and (symbolp (setq name (function-name fn)))               ;Might as well err out now before do any _Newptr's...               (not (constantp name)))    (report-bad-arg name '(and symbol (not (satisfies constantp)))))  (setq code (%make-lfun              (vector fn name)              code              (coerce (list (%ilsl 1 lfun-offset) $lm_longimm                            (%ilsl 1 (%i- (length code) 2)) $lm_longimm)                      '(vector (signed-byte 16)))              (%ilsl $lfbits-lap-bit 1)              (%ilsl $lfatr-resident-bit 1)))  (let ((len (length %pascal-functions%)))    (unless (and (boundp name)                 (macptrp (setq slot (symbol-value name)))                 (dotimes (i len)                   (declare (fixnum i))                   (let ((cons (%svref %pascal-functions% i)))                     (when (eq (%car cons) slot)                       (%rplacd cons code)                       (%put-word slot (if without-interrupts 1 0) 6)   ; set without-interrupts flag                       (return slot)))))      (dotimes (i len (let ((new (make-array (%i+ len 2))))                        (dotimes (i len) (declare (fixnum i)) (%svset new i (%svref %pascal-functions% i)))                        (setq %pascal-functions% new)                        (setq slot-index len)))        (declare (fixnum i))        (when (null (%svref %pascal-functions% i))          (return (setq slot-index i))))      (%svset %pascal-functions% slot-index (cons (%null-ptr) code))      (setq slot (defpascal-new-slot slot-index without-interrupts))))  (%proclaim-special name)  (set name slot)  (record-source-file name 'variable)  (when *fasload-print* (format t "~&~S~%" name))  name)#-ppc-target(defun defpascal-callback-p (macptr)  (let ((v %pascal-functions%))    (dotimes (i (length v))      (let ((cons (%svref v i)))        (when (and (consp cons) (eql (%car cons) macptr))          (return cons))))))#-PPC-target(defun defpascal-new-slot (slot-index &optional without-interrupts)  (let* ((cons (svref %pascal-functions% slot-index)))    (when (%null-ptr-p (car cons)) (%setf-macptr (%car cons) (#_NewPtr :errchk 20)))    (lap-inline ()      (:variable cons slot-index without-interrupts)      (move.l (varg cons) atemp0)      (car atemp0 atemp0)      (jsr_subprim $sp-macptrptr)      (move.w ($ #o47271) (@+ atemp0))   ; jsr ($sp-callback(a5)).L                  ; 0      (lea (a5 $sp-callback) atemp1)      (move.l atemp1 (@+ atemp0))                                                    ; 2      (move.l ($ 0) dtemp0)      (if# (ne (cmp.l (varg without-interrupts) nilreg))        (move.l ($ 1) dtemp0))      (move.w dtemp0 (@+ atemp0))                                                    ; 6      (move.w ($ #o20154) (@+ atemp0))    ; move.l vc.pascal-functions(nilreg),a0    ; 8      (lea (special %pascal-functions%) atemp1)   ; (better be nilreg-relative!!)      (sub.l nilreg atemp1)      (move.w atemp1 (@+ atemp0))                                                    ; 10      (move.w ($ #o20150) (@+ atemp0))    ; move.l v_data+slot-index*4(a0),a0        ; 12      (move.l (varg slot-index) acc)      (vscale.l acc)      (add.w ($ $v_data) acc)      (move.w acc (@+ atemp0))                                                       ; 14      (move.w ($ #o20140) (@+ atemp0))    ; cdr a0,a0                                ; 16      (move.w ($ #o47320) (@+ atemp0)))   ; jmp (a0)                                 ; 18    (%car cons))); Called by kill-lisp-pointers(defun defpascal-trampoline-without-interrupts-p (code)  (and (macptrp code) (not (%null-ptr-p code)) (neq 0 (%get-word code 6)))); The least significant n bits of the bitmap contain register specifiers for; each of n/4 arguments.; Bit n+5 is set if error checking on the low half of D0 is requested.; Bit n+4 is set if a value is to be returned: bits n thru n+3 specify the register to return.; If this register is a data register, bit n+6 is set if its low halfword is to be extended, and; bit n+7 is set when sign- (vice zero-) extension is required.#+ppc-target(defun %register-trap (trapword bitmap &rest args)  (funcall (compile nil `(lambda () (%register-trap ,trapword ,bitmap ,@args))))); This writes (words) into itself.  May be a bad idea ...; Might instead try consing a "temporary" lfun & recycling it ...#-ppc-target(defun %register-trap (&lap trapword bitmap &rest args)  ;(puke)  (lap   (klexpr 2)   (move.l (vsp nargs.w 4) da)   (getint da)   (and.w ($ #x0fff) da)   (or.w ($ #xa000) da)   (lea (^ @trap) atemp0)   (move.w da @atemp0)   (lea (^ @trapD0) atemp0)   (move.w da @atemp0)   (jsr_subprim $sp-clrcache)   (move.l (vsp nargs.w 0) dx)   (getint dx)   (exitlisp)   ; refuse to clobber any lisp-important registers   (begin_csarea)   (movem.l #(a7 a6 a5 a4 a3 a2 a1 a0 d7 d6 d5 d4 d3 d2 d2 d1 d0) -@sp)   (begin_csarea)   (pea (@w 1))   (bra @test)   (prog#    (move.l ($ #xf) dy)    (and.w dx dy)    (lsr.l ($ 4) dx)    (move.l (vsp nargs.w 0) arg_z)    (btst ($ 3) dy)    (if# eq      (jsr_subprim $sp-getXlong)      else#      (move.l arg_z atemp0)      (jsr_subprim $sp-macptrptr) ; preserves arg_y      (move.l atemp0 acc))    (lsl.w ($ 2) dy)    (move.l acc (sp dy.w 8))@test    (bif (pl (sub.w ($ 4) nargs)) (top#))); This is not truly general - it won't clobber a4-a7 or any lisp-; preserved registers or anything.   (move.b dx @sp)   (vpush sp@+)   (add ($ 4) sp) ; spop_csarea   (movem.l sp@+ #(d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3))   (lea (sp 16) sp)   (spop_csarea)   (vpop -@sp)   (enterlisp)   (if# (ne (btst ($ 5) @sp))     (jsr_subprim $sp-rtrapD0)@trap (dc.w #x4afc)     else#     (jsr_subprim $sp-rtrap)@trapD0 (dc.w #x4afc))   (if# (eq (btst ($ 4) @sp))     (add.w ($ 4) sp)     (move.l nilreg acc)     (lfret))   (begin_csarea)   (movem.l #(a7 a6 a5 a4 a3 a2 a1 a0 d7 d6 d5 d4 d3 d2 d1 d0) -@sp)   (begin_csarea)   (move.l ($ #xf) dx)   (move.b (sp 72) dy)   (and.b dy dx)   (lsl.w ($ 2) dx)   (move.l (sp dx.w 4) acc)   (add ($ 4) sp) ; spop_csarea   (lea (sp 64) sp)   (spop_csarea)   (add ($ 4) sp) ; discard arg word   (if# (eq (btst ($ (+ 3 2)) dx))      ; A data reg ...     (if# (eq (btst ($ 6) dy))       (jsr_subprim $sp-mklong)       elseif# (eq (btst ($ 7) dy))       (swap acc)       (clr.w acc)       (swap acc)       (mkint acc)       else#       (ext.l acc)       (mkint acc))     else#     (move.l acc atemp0)     (jsr_subprim $sp-consmacptr))   (lfret)))#+ppc-target(defun %stack-trap (&rest args)  (funcall (compile nil `(lambda () (%stack-trap ,@args))))); This writes (words) into itself.  May be a bad idea ...; Might instead try consing a "temporary" lfun & recycling it ...#-ppc-target(defun %stack-trap (&lap 0)  ;(puke)  (lap   (klexpr 2)   (move.l (vsp nargs.w 4) da)   (getint da)   (and.w ($ #x0fff) da)   (or.w ($ #xa000) da)   (lea (^ @trap) atemp0)   (move.w da @atemp0)   (jsr_subprim $sp-clrcache); First, count stack area size:   (move.l (vsp nargs.w 0) dx)   (if# (eq (dtagp dx $t_fixnum))     (wtaerr dx 'fixnum))   (getint dx)   (move.w nargs dy)   (move.l ($ 8) arg_z) ; Return address, result longwords.   (prog#    (if# (pl (sub.w ($ 4) dy))      (move.l ($ 3) da)      (and.w dx da)      (lsr.l ($ 2) dx)      (add.w ($ 2) arg_z)      (if# (le (sub.w ($ 1) da))        (add.w ($ 2) arg_z)        elseif# (eq (sub.w ($ 1) da))        (sub.w ($ 2) arg_z))      (bra (top#))))   (move.l arg_z dy)   (pea (@w 1))   (move.b dx @sp)   (jsr_subprim $sp-mknlisparea)   (lea (sp dy.l -4) atemp1)   (move.l (vsp nargs.w 0) dx)   (clr.l (-@ vsp))   (clr.l (-@ vsp))   (getint dx)   (bra @test2)   (prog#    (move.l (vsp nargs.w 8) arg_z)    (move.l ($ 3) da)    (and.w dx da)    (if# eq      ; macptr      (move.l arg_z atemp0)      (jsr_subprim $sp-macptrptr)      (move.l atemp0 -@atemp1)      elseif# (eq (sub.b ($ 1) da))      (jsr_subprim $sp-getXlong)      (move.l arg_z -@atemp1)      elseif# (eq (sub.b ($ 1) da)) ; selector thing      (jsr_subprim $sp-getXlong)      (move.w arg_z @vsp)      (swap arg_z)      (move.w arg_z (vsp 4))      else#      (getint arg_z)      (move.w arg_z -@atemp1))    (lsr.l ($ 2) dx)@test2    (bif (pl (sub.w ($ 4) nargs)) (top#)))   (moveq 0 arg_z)   (move.w @vsp arg_z)   (add ($ 4) vsp)   (or.l vsp@+ arg_z)   (jsr_subprim $sp-strap)@trap (dc.w #x4afc)   (move.b @sp dx)   (add.w ($ 4) sp)   (if# (eq (btst ($ 2) dx))     (move.l nilreg acc)     elseif# (eq (cmp.b ($ #b100) dx))     (move.l acc atemp0)     (jsr_subprim $sp-consmacptr)     else#     (if# (ne (btst ($ 1) dx))       (swap acc)       (ext.l acc)       (mkint acc)       else#       (jsr_subprim $sp-mklong)))   (lfret)))(defun ppc-ff-call (addr &rest args)  (declare (dynamic-extent args))  (funcall (compile nil `(lambda ()                            (declare (inline ppc-ff-call))                           (ppc-ff-call ,addr ,@args)))))(defun ff-call-slep (slep &rest args)  (declare (dynamic-extent args))  (funcall (compile nil `(lambda ()                            (declare (inline ff-call-slep))                           (ff-call-slep ,slep ,@args)))))#+ppc-target(defun ff-call (addr &rest args)  (declare (dynamic-extent args))  (funcall (compile nil `(lambda ()                           (declare (inline ff-call))                           (ff-call ,addr ,@args)))))#-ppc-target(defun ff-call (addr &rest args)  (declare (dynamic-extent args))  (apply #'ff-call-gen-trap nil addr args))#-ppc-target(defun %gen-trap (trapnum &rest args)  (declare (dynamic-extent args))  (apply #'ff-call-gen-trap t trapnum args))#-ppc-target(defun ff-call-gen-trap (trap-p addr &rest original-args)  (declare (dynamic-extent original-args))  (with-managed-allocation    (let* ((retspec nil)           (retform nil)           (argtypes nil)           (paramwords 0)           (argvals nil)           (retblk nil)           (stackwords 0))      (declare (fixnum stackwords))      (do* ((args original-args (cddr args)))           ((null (cdr args)) (setq retform (car args)))        (let* ((spec (car args))               (argtype (cdr (assq spec '((:a5 . 13) ;a6/a7 not allowed                                          (:d0 . 0) (:d1 . 1) (:d2 . 2) (:d3 . 3)                                          (:d4 . 4) (:d5 . 5) (:d6 . 6) (:d7 . 7)                                          (:a0 . 8) (:a1 . 9) (:a2 . 10) (:a3 . 11)                                          (:a4 . 12)                                          (:word . #x13)                                          (:long . #x12) (:longword . #x12)                                          (:ptr . #x14) (:pointer . #x14))))))          (if argtype            (locally             (declare (fixnum argtype))             (setq argtypes (%temp-cons argtype argtypes))             (setq argvals (%temp-cons (cadr args) argvals))             (if (eql argtype #x13)                (setq stackwords (1+ stackwords))                (if (> argtype #x10)                  (setq stackwords (+ stackwords 2)))))            (if (eq spec :return-block)              (if (null retblk)                 (progn                  (setq retblk (cadr args)                        argtypes (%temp-cons #x17 argtypes)                        argvals (%temp-cons retblk argvals)))                (error "Duplicate ~S specifier in ~S." spec original-args))              (error "Unknown argument specifier ~S in ~S."  spec original-args)))))      (setq paramwords stackwords)      (if retblk        (do* ((retlist (if (listp retform) retform (list retform)) (%cdr retlist)))             ((atom retlist) (setq retspec (if (null retlist) (nreverse retspec))))          (let* ((argtype (cdr (assq (car retlist)                                     '((:d0 . 0) (:d1 . 1) (:d2 . 2) (:d3 . 3)                                       (:d4 . 4) (:d5 . 5) (:d6 . 6) (:d7 . 7)                                       (:a0 . 8) (:a1 . 9) (:a2 . 10) (:a3 . 11)                                       (:a4 . 12) ;a5/a6/a7 not allowed                                       (:word . #x13)                                       (:long . #x12) (:longword . #x12)                                       (:ptr . #x14) (:pointer . #x14))))))            (unless argtype (return (setq retspec nil)))            (locally              (declare (fixnum argtype))              (if (eql argtype #x13)                (setq stackwords (1+ stackwords))                (if (> argtype #x10)                  (setq stackwords (+ stackwords 2))))              (setq retspec (%temp-cons argtype retspec)))))        (if          (setq retspec (cdr (assq retform                                   '((:novalue . #x10) (:none . #x10) (nil . #x10)                                     (:d0 . 0) (:d1 . 1) (:d2 . 2) (:d3 . 3)                                     (:d4 . 4) (:d5 . 5) (:d6 . 6) (:d7 . 7)                                     (:a0 . 8) (:a1 . 9) (:a2 . 10) (:a3 . 11)                                     (:a4 . 12) ;a5/a6/a7 not allowed                                     (:word . #x13)                                     (:long . #x12) (:longword . #x12)                                     (:ptr . #x14) (:pointer . #x14)))))          (if (eql retspec #x13)            (setq stackwords (1+ stackwords))            (if (> retspec #x10)              (setq stackwords (+ stackwords 2))))))      (unless retspec (error "Invalid returned value specification: ~S" retform))      (%ff-call trap-p addr retspec (%ilsl 1 (- stackwords paramwords))                 (if retblk (+ stackwords 2) stackwords) (nreverse argvals) (nreverse argtypes)))))#-PPC-target(defun %ff-call (trap-p addr retspec retbytes stackwords argvals argtypes)  (lap-inline ()    (:variable trap-p addr retbytes retspec stackwords argvals argtypes)    (with-preserved-registers #(dsave0 dsave1 dsave2 asave0 asave1)      (move.l (varg argvals 20) asave0)      (defreg argvals asave0)      (move.l (varg argtypes 20) asave1)      (defreg argtypes asave1)      (move.l (varg retspec 20) dsave1)      (defreg retspec dsave1)      (move.l (varg stackwords 20) arg_z)      (move.l arg_z dsave0)      (add.l dsave0 dsave0)      (sub.l (varg retbytes 20) dsave0)      (defreg stackbytes dsave0)      (if# (eq (dtagp retspec $t_fixnum))        (move.l '#x40 dsave2)        (add.l stackbytes dsave2)        (sub.l '4 stackbytes)        else#        (moveq 0 dsave2))      (defreg retblk dsave2)      (getint arg_z)      (if# (eq (varg trap-p 20) nilreg)        (move.l (varg addr 20) atemp0)        (jsr_subprim $sp-macptrptr)        (jsr_subprim $sp-ffsetup)        else#        (lea (^ @trap) atemp0)        (move.l (varg addr 20) dtemp1)        (getint dtemp1)        (move.w dtemp1 @atemp0)        (jsr_subprim $sp-trap-setup)        @trap (illegal))      ; Evaluate each argument; we can err out at any point here.      (until# (eq (null argvals))       (car argvals arg_z)       (move.l arg_z atemp0)       (cdr argvals argvals)       (car argtypes arg_y)       (cdr argtypes argtypes)       (if# (eq '#x17 arg_y)            ; :return-block, a macptr.         (jsr_subprim $sp-macptrptr)         (move.l retblk da)         (getint da)         (move.l atemp0 (sp da.l))         elseif# (eq '#x13 arg_y)        ; spush 16 bits         (getint arg_z)         (getint stackbytes)         (sub.l ($ 2) stackbytes)         (move.w arg_z (sp stackbytes.l #x44))         (mkint stackbytes)         elseif# (eq '#x12 arg_y)       ; spush 32 bits as "long"         (jsr_subprim $sp-getXlong)         (getint stackbytes)         (sub.l ($ 4) stackbytes)         (move.l arg_z (sp stackbytes.l #x44))         (mkint stackbytes)         elseif# (eq '#x14 arg_y)       ; spush 32 bits as macptr         (jsr_subprim $sp-macptrptr)         (getint stackbytes)         (sub.l ($ 4) stackbytes)         (move.l atemp0 (sp stackbytes.l #x44))         (mkint stackbytes)         else#                          ; set register         (vpush arg_y)         (if# (eq (btst ($ (+ 3 $fixnumshift)) arg_y))          ; a dreg           (jsr_subprim $sp-getXlong)           else#           (jsr_subprim $sp-macptrptr)           (move.l atemp0 arg_z))         (vpop arg_y)         (vscale.l arg_y)         (move.l arg_z (sp arg_y.l 4))))      (if# (eq (null (varg trap-p 20)))        (jsr_subprim $sp-ffcall)        else#        (jsr_subprim $sp-gen-trap))      (if# (ne (tst.l retblk))        (move.l retblk da)        (getint da)        (move.l (sp da.l) atemp0)        (move.l atemp0 acc)        (move.l retspec asave0)        (move.l (sp #x40) atemp1)        (until# (eq (null asave0))          (car asave0 arg_y)          (cdr asave0 asave0)          (if# (gt '#x10 arg_y)            (if# (eq '#x13 arg_y)              (move.w atemp1@+ atemp0@+)              else#              (move.l atemp1@+ atemp0@+))            else#            (vscale.l arg_y)            (move.l (sp arg_y.l 4) atemp0@+)))        (move.l arg_z atemp0)        (jsr_subprim $sp-consMacptr)        elseif# (eq '#x10 retspec)      ; :novalue        (move.l nilreg acc)        elseif# gt                      ; from stack, somewhere        (move.l (sp #x40) atemp0)        (if# (eq '#x13 retspec)          (move.w @atemp0 acc)          (ext.l acc)          (mkint acc)          elseif# (eq '#x14 retspec)          (move.l @atemp0 atemp0)          (jsr_subprim $sp-consMacPtr)          else#          (move.l @atemp0 acc)          (jsr_subprim $sp-mklong))        ; from register cache:        else#        (move.l retspec da)        (vscale.l da)        (if# (ge '#o10 retspec)      ; address reg          (move.l (sp da.l 4) atemp0)          (jsr_subprim $sp-consMacPtr)          else#          (move.l (sp da.l 4) acc)          (jsr_subprim $sp-mklong)))      (jsr_subprim $sp-popnlisparea)))); Screw: should be a passive way of inquiring about enabled status.#-PPC-target(progn(defun egc (arg)  (declare (%noforcestk))  (lap-inline (arg)    (cmp.l arg_z nilreg)    (jsr_subprim $sp-enable-egc)    (setpred ne)))(defun egc-active-p ()  (lap-inline ()    (move.l (a5 $Pe0Cons_area) atemp0)    (cmp.l (a5 $Pdefault_cons_area) atemp0)    (setpred eq))); this IS effectively a passive way of inquiring about enabled status.(defun egc-enabled-p ()  (lap-inline ()    (tst.l (a5 $pe0Cons_area))    (setpred ne)))(defun egc-configuration ()  (lap    (moveq (- 10 $fixnumshift) da)    (move.l (a5 (+ $e0cons_area $cons-area.total)) acc)    (lsr.l da acc)    (vpush acc)    (move.l (a5 (+ $e1cons_area $cons-area.total)) acc)    (lsr.l da acc)    (vpush acc)    (move.l (a5 (+ $e2cons_area $cons-area.total)) acc)    (lsr.l da acc)    (vpush acc)    (set_nargs 3)    (jmp_subprim $sp-nvalret)))(defun configure-egc (e0size e1size e2size)  (lap-inline ((ash (require-type e2size '(unsigned-byte 18)) 10)               (ash (require-type e1size '(unsigned-byte 18)) 10)               (ash (require-type e0size '(integer 1 #.(ash 1 18))) 10))    (movereg arg_x d2)    (movereg arg_y d1)    (movereg arg_z d0)    (move.l ($ (1- 4096)) da)    (move.l da db)    (not.l db)    (getint d2)    (add.l da d2)    (and.l db d2)    (getint d1)    (add.l da d1)    (and.l db d1)    (getint d0)    (add.l da d0)    (and.l db d0)    (jsr_subprim $sp-configure-egc)))) ; end #-ppc-target#+ppc-target(progn(defun egc (arg)  (not (eql 0 (the fixnum (ppc-ff-call (%kernel-import ppc::kernel-import-egc-control)                                        :unsigned-halfword (if arg 1 0)                                       :unsigned-halfword)))))(defun egc-active-p ()  (and (egc-enabled-p)       (not (eql 0 (%get-kernel-global 'oldest-ephemeral))))); this IS effectively a passive way of inquiring about enabled status.(defun egc-enabled-p ()  (not (eql 0 (%fixnum-ref (%normalize-areas) ppc::area.older))))(defun egc-configuration ()  (let* ((g0 (%normalize-areas))         (g1 (%fixnum-ref g0 ppc::area.older))         (g2 (%fixnum-ref g1 ppc::area.older)))    (values (ash (the fixnum (%fixnum-ref g0 ppc::area.threshold)) -8)            (ash (the fixnum (%fixnum-ref g1 ppc::area.threshold)) -8)            (ash (the fixnum (%fixnum-ref g2 ppc::area.threshold)) -8))))(defun configure-egc (e0size e1size e2size)  (unless (egc-active-p)    (setq e2size (logand (lognot #x7fff) (+ #x7fff (ash (require-type e2size '(unsigned-byte 18)) 10)))          e1size (logand (lognot #x7fff) (+ #x7fff (ash (require-type e1size '(unsigned-byte 18)) 10)))          e0size (logand (lognot #x7fff) (+ #x7fff (ash (require-type e0size '(integer 1 #.(ash 1 18))) 10))))    (let* ((g0 (%normalize-areas))           (g1 (%fixnum-ref g0 ppc::area.older))           (g2 (%fixnum-ref g1 ppc::area.older)))      (%fixnum-set g0 ppc::area.threshold (ash e0size (- ppc::fixnumshift)))      (%fixnum-set g1 ppc::area.threshold (ash e1size (- ppc::fixnumshift)))      (%fixnum-set g2 ppc::area.threshold (ash e2size (- ppc::fixnumshift)))      t))))  ; end of #+ppc-target#-ppc-target(defun egc-mmu-support-available-p ()  (not (zerop (%get-signed-word (%currentA5) #x-31e))))#+ppc-target; The question doesn't make sense for the PPC garbage collector,; but EGC is a good idea there, so return true(defun egc-mmu-support-available-p ()  t)(defun macptr-flags (macptr)  (if (eql (uvsize (setq macptr (require-type macptr 'macptr))) 1)    0    #-PPC-target    (lap-inline ()      (:variable macptr)      (move.l (varg macptr) atemp0)      (move.l (atemp0 $macptr.flags) acc)      (mkint acc))    #+PPC-target    (uvref macptr PPC::XMACPTR.FLAGS-CELL)))#-PPC-target(defun make-gcable-macptr (flags)  (lap-inline (flags)    (getint arg_z)    (sub.l atemp0 atemp0) ; why not in subprim ?    (jsr_subprim $sp-cons-gcable-macptr)    (move.l atemp0 acc)))#|(ppc::define-fixedsized-object xmacptr  address  flags  link  ; where we get this from?)|##+PPC-target(progn(defppclapfunction set-%gcable-macptrs% ((ptr ppc::arg_z))  (ref-global arg_y gcable-pointers)  (stw arg_y ppc::xmacptr.link ptr)  (set-global ptr gcable-pointers)  (blr))(defun make-gcable-macptr (flags)  (let ((v (%alloc-misc ppc::xmacptr.element-count ppc::subtag-macptr)))    (setf (uvref v PPC::XMACPTR.ADDRESS-CELL) 0)  ; ?? yup.    (setf (uvref v PPC::XMACPTR.FLAGS-CELL) flags)    (without-interrupts     (set-%gcable-macptrs% v))    v))(defun %new-gcable-ptr (size &optional clear-p)  (let ((p (make-gcable-macptr $flags_DisposPtr)))    (if clear-p      (%setf-macptr p (#_NewPtrClear :errchk size))      (%setf-macptr p (#_NewPtr :errchk size)))    p))); This doesn't really make the macptr be gcable (now has to be; on linked list), but we might have other reasons for setting; other flag bits.(defun set-macptr-flags (macptr value)   (unless (eql (uvsize (setq macptr (require-type macptr 'macptr))) 1)    #-PPC-target    (lap-inline ()      (:variable macptr value)      (move.l (varg macptr) atemp0)      (move.l (varg value) acc)      (getint acc)      (move.l acc (atemp0 $macptr.flags)))    #+PPC-target ; assuming its stored as a fixnum    (setf (%svref macptr PPC::XMACPTR.FLAGS-CELL) value)    value))(defun gc-event-check-enabled-p ()  (declare (special *gc-event-status-bits*))  (%i>= *gc-event-status-bits* 0))#|(defun set-gc-event-check-enabled-p (flag)  (declare (special *gc-event-status-bits*))  (setq *gc-event-status-bits*        (lap-inline (flag *gc-event-status-bits*)          (if# (eq nilreg arg_y)            (bset ($ 31) acc)            else#            (bclr ($ 31) acc))))  flag)|#(defun set-gc-event-check-enabled-p (flag)  (declare (special *gc-event-status-bits*)           (fixnum  *gc-event-status-bits*))  ; Polling is disabled when $gc-polling-enabled-bit is set.  (setq *gc-event-status-bits*        (if flag           (logand (lognot (ash -1 $gc-polling-enabled-bit)) *gc-event-status-bits*)          (logior (ash -1 $gc-polling-enabled-bit) *gc-event-status-bits*)))  flag)(defun gc-cursor-suppressed-p ()  (declare (special *gc-event-status-bits*)           (fixnum *gc-event-status-bits*))  (locally (declare (optimize (speed 3) (safety 0)))    (logbitp $GC-USE-GC-CURSOR-BIT *gc-event-status-bits*)))(defun set-gc-cursor-suppressed-p (flag)  (declare (special *gc-event-status-bits*)           (fixnum *gc-event-status-bits*))  (setq *gc-event-status-bits*        (locally (declare (optimize (speed 3) (safety 0)))      ; no $sp-specref          (if flag            (bitset $GC-USE-GC-CURSOR-BIT *gc-event-status-bits*)            (bitclr $GC-USE-GC-CURSOR-BIT *gc-event-status-bits*))))  flag); backwards compat.(setf (symbol-function 'gc-cursor-supressed-p)     #'gc-cursor-suppressed-p      (symbol-function 'set-gc-cursor-supressed-p) #'set-gc-cursor-suppressed-p);True for a-z - redefined in chars.lisp(defun lower-case-p (c)  (let ((code (char-code c)))    (and (>= code (char-code #\a))         (<= code (char-code #\z)))));True for a-z A-Z(defun alpha-char-p (c)    (let ((script (string-compare-script)))      (cond       ((or (eq script #$smRoman)(and (eq script #$smJapanese)(< (char-code c) 128)))        #-ppc-target        (lap-inline (c)          (jsr_subprim $sp-char_argZ)          (if#             (or             (and (geu (cmp.b ($ #\a) arg_z))                  (leu (cmp.b ($ #\z) arg_z)))             (and (geu (cmp.b ($ #\A) arg_z))                  (leu (cmp.b ($ #\Z) arg_z)))             (and (geu (cmp.b ($ #\345) arg_z))                  (leu (cmp.b ($ #\364) arg_z))                  (ne (cmp.b ($ #\360) arg_z)))             (and (geu (cmp.b ($ #\313) arg_z))                  (leu (cmp.b ($ #\315) arg_z)))             (and (geu (cmp.b ($ #\200) arg_z))                  (leu (cmp.b ($ #\237) arg_z))))            (move_t acc)            else#            (move.l nilreg acc)))        #+PPC-target        (let ((code (char-code c)))          (declare (fixnum code))          (or (and (>= code (char-code #\a))                   (<= code (char-code #\z)))              (and (>= code (char-code #\A))                   (<= code (char-code #\Z)))              (and (>= code #o200)                   (or (<= code #o237)                       (and (>= code #o313)                            (or (<= code #o315)                                (and (>= code #o345)                                     (<= code #o364)                                     (neq code #o360))))))))        )       (t (xalpha-char-p c script))))); def-accessors type-tracking stuff.  Used by inspector(defvar *def-accessor-types* nil)(defun add-accessor-types (types names)  (dolist (type types)    (let ((cell (or (assq type *def-accessor-types*)                    (car (push (cons type nil) *def-accessor-types*)))))      (setf (cdr cell) (if (vectorp names) names (%list-to-uvector nil names)))))); Real definition in lib;misc.lisp(defun (setf documentation) (string thing &optional doc-type)  (declare (ignore thing doc-type))  string); Make sure the imported symbols below actually exist(mapcar #'intern        '("DEFTRAP" "DEFCTBTRAP" "DEFRECORD" "REQUIRE-INTERFACE"          #+interfaces-2 "DEFTRAP-INLINE"          "PROVIDE-INTERFACE" "RECORD-LENGTH" "DEF-MACTYPE" "FIND-MACTYPE"          "%DEFINE-RECORD" "FIND-RECORD-DESCRIPTOR"          "%INT-TO-PTR" "%INC-PTR" "%PTR-TO-INT"          "%GET-BYTE" "%GET-WORD" "%GET-LONG" "%GET-PTR"          "%HGET-BYTE" "%HGET-WORD" "%HGET-LONG" "%HGET-PTR"          "%GET-SIGNED-BYTE" "%GET-SIGNED-WORD" "%GET-SIGNED-LONG"          "%GET-UNSIGNED-BYTE" "%GET-UNSIGNED-WORD" "%GET-UNSIGNED-LONG"          "%HGET-SIGNED-BYTE" "%HGET-SIGNED-WORD" "%HGET-SIGNED-LONG"          "%PUT-BYTE" "%PUT-WORD" "%PUT-LONG" "%PUT-PTR"          "%HPUT-BYTE" "%HPUT-WORD" "%HPUT-LONG" "%HPUT-PTR"          "%STACK-BLOCK" "%GEN-TRAP"))(defpackage :traps  (:use common-lisp)            ; don't use CCL  (:import-from :ccl                deftrap defctbtrap defrecord require-interface                 #+interfaces-2 deftrap-inline                provide-interface record-length def-mactype find-mactype                 %define-record find-record-descriptor                %int-to-ptr %inc-ptr %ptr-to-int                %get-byte %get-word %get-long %get-ptr                %hget-byte %hget-word %hget-long %hget-ptr                %get-signed-byte %get-signed-word %get-signed-long                %get-unsigned-byte %get-unsigned-word %get-unsigned-long                %hget-signed-byte %hget-signed-word %hget-signed-long                %put-byte %put-word %put-long %put-ptr                %hput-byte %hput-word %hput-long %hput-ptr                %stack-block %gen-trap)  (:export $true $false))(defvar *traps-package* (find-package :traps))(defun gestalt (selector &optional bitnum)  (rlet ((res :longint))    (if (eql 0 (#_Gestalt selector res))      (let ((attr (%get-long res)))        (if bitnum          (logbitp bitnum attr)          attr)))))(defun chartype (char &optional (script (string-compare-script)))    (let* ((font (#_getscript script #$smScriptAppFond))           (code (char-code char)))      ; typemask #xf 0 means punct or number, anything else means alpha?      ; classmask #xf00 100 is number, 0 is "normal" 300 is whitespace      (%stack-block ((p 2))        (if (%i< code #x100)(%put-byte p code)(%put-word p code))        (with-FONT font          (#_chartype p 0)))))(defun xalpha-char-p (char &optional (script (string-compare-script)))  (neq #$smcharpunct (logand #$smctypemask (chartype char script)))); or maybe we mean not xalphanumericp(defun char-word-break-p (char &optional (script (string-compare-script)))  (if (eq script #$smRoman)    (not (%str-member char *fred-word-constituents*))    (not (xalphanumericp char script))))#|  (let ((type (chartype char script)))    (and (eq #$smcharpunct (logand #$smctypemask type))         (eq #$smPunctBlank (logand #$smcClassmask type)))))|#(defun xalphanumericp (char &optional (script (string-compare-script)))  (let ((type (chartype char script)))    (or (neq #$smcharpunct (logand #$smctypemask type))    (and ;(eq smcharpunct (logand #$smctypemask type))         (eq #$smpunctnumber (logand #$smcClassmask type))))));; callers did japanese < 128;; do the hairy one otherwise for "ascii" 2 byte chars  (defun xchar-up-down (char &optional down-p (script (string-compare-script)))        (if (and (neq script #$smRoman)  ; shouldn't be here if it is             (neq script #$smJapanese)             (let ((flags (get-script script #$smscriptflags)))               (and ;(not (logbitp #$smsfsingbyte flags)) ; who cares if 2 or 1 byte                (not (logbitp #$smsfNatCase flags)))))      char      (let* ((code (char-code char))             (font (#_getscript script #$smScriptAppFond))             (len (if (%i> code #xff) 2 1)))        (with-font font          (%stack-block ((p 2))            (if (eq len 2) (%put-word p code)(%put-byte p code))            (if down-p              (#_lowertext p len)              (#_uppertext p len))            (code-char (if (eq len 1)(%get-byte p)(%get-word p))))))))      #|	Change History (most recent last):	2	12/29/94	akh	merge with d13	3	1/5/95	akh	added char-word-break-p|# ;(do not edit past this line!!)