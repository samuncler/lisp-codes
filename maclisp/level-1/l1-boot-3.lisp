;;;-*- Mode: Lisp; Package: CCL -*-;; l1-boot-3.lisp;; Third part of l1-boot;;;;;;;;;;;;;;;;;;;;;;;;;;; Modification History;;;; 04/16/97 bill  New file. Broken out of l1-boot.lisp;;(catch :toplevel    (setq *scrap-count* -1)    (or (find-package "COMMON-LISP-USER")        (make-package "COMMON-LISP-USER" :use '("COMMON-LISP" "CCL") :NICKNAMES '("CL-USER"))))(set-periodic-task-interval 1)(defun event-processing-loop ()  (let* ((global-top-listener *top-listener*))    (flet ((valid-window (w)             (and w                  (typep w 'window)                  (wptr w)                  w)))      (setq *top-listener* nil)      (unwind-protect        (let ((*top-listener* (valid-window global-top-listener))              (tag (list nil)))          (unwind-protect            (let-globally ((*event-processing-loop-tag* tag))              (loop                (catch tag                  (with-standard-abort-handling "Continue event processing"                    (let ((handler #'(lambda (condition)                                       (declare (ignore condition))                                       (maybe-create-standin-event-processor)                                       nil)))                      (declare (dynamic-extent handler))                      (handler-bind ((warning #'muffle-warning)                                     (serious-condition handler))                        (loop                          (if (eq *current-process* *event-processor*)                            (progn                              (process-wait "Event-poll"                                             (if *new-processes*                                               #'(lambda ()                                                   (and (event-available-p)                                                        (process.priority *event-processor*)))                                              #'event-available-p))                              (%event-dispatch))                            (without-interrupts                             (process-wait "Standin process" #'(lambda () (not *processing-events*)))                             (let ((p *event-processor*)                                   (me *current-process*))                               (unless (eq p me)                                 (setq *event-processor* me)                                 (setf (process.priority me) (if *new-processes* 10 1)) ; s.b *max-priority*                                 (process-kill-and-wait p))))))))))))            ; unwind-protect cleanup            (setq global-top-listener *top-listener*)))          ; unwind-protect cleanup        (setq *top-listener* (valid-window global-top-listener))))))(defvar *event-error-dialog* nil); called from above and from %break-message(defun maybe-create-standin-event-processor ()  (when (and (not *single-process-p*)             (eq *event-processor* *initial-process*)             (eq *current-process* *initial-process*))    (setq *processing-events* nil)    (setq *modal-dialog-on-top* nil) ; do this help?    ;(setq *eventhook* nil) ; this do help    (if (room-for-new-listener-p)      (let ((p (make-process "Event processing standin"                             :priority (if *new-processes* 10 1) ; s.b. *max-priority*                             :background-p t)))        (process-preset p #'after-error-event-processing-loop)        (setq *event-processor* p)        (release-locked-windows)        (process-enable p)        (setf (process.priority *current-process*) 0))      ; ugh now what - kill the original? kill other listeners?      (progn        ; this is not doing what I mean - i.e. errors still happen        (ed-beep)        (ignore-errors (release-locked-windows)); ??        (if *event-error-dialog* (window-select *event-error-dialog*))        (process-interrupt *initial-process* #'after-error-event-processing-loop)        ;(ed-beep)(ed-beep)        ;(process-enable *initial-process*)        ;(ed-beep)(ed-beep)(ed-beep)        ))))(defun after-error-event-processing-loop ()  (loop    (catch :toplevel      (catch :cancel        (handler-case          (loop            ; used to be just #'event-available-p            (process-wait "Event-poll"                          #'(lambda (process)                              (and (event-available-p)                                   (eq process *event-processor*)))                          *current-process*)            (let ((*break-on-signals* nil))              (%event-dispatch)))          (t () nil))))))(%set-toplevel #'(lambda ()     (%set-toplevel      #'(lambda ()          (lds (progn                 (let ((p (if *single-process-p*                            *current-process*                            (make-mcl-listener-process))))                   (process-interrupt                    p                    #'(lambda ()                        (startup-ccl (if (or (probe-file "home:boot-init.lisp")                                             (probe-file #-ppc-target "home:boot-init.fasl"                                                         #+ppc-target "home:boot-init.pfsl"))                                       "home:boot-init"                                       "home:init")))))                 (%set-toplevel (if *single-process-p*                                  #'toplevel-loop                                  #'event-processing-loop)))               (%set-toplevel (symbol-function 'app-loader-toplevel)))          (toplevel)))))(setq *interrupt-level* 0)(setq *warn-if-redefine* t)(setq *level-1-loaded* t);(setq *loading-file-source-file* "ccl:l1;level-1.lisp") ;reset from last %fasload...;End of Level-1.lisp