;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  3 6/2/97   akh  see below;;  (do not edit before this line!!)(in-package :ccl);; new file - shared parts of sysutils, gestalt stuff, font stuff, some array stuff;; 05/20/97 akh fix result of gestalt for processor type - heuristicate cause :|cput| and:|proc| are different for 68K's, :|cput| may be nil (7.1 or so);; 03/01/97 gb  init-uvector-contents-without-calling-ELT-all-the-time.(queue-fixup (defun fmakunbound (name)   (when (consp name)     (unless (eq (%car name) 'setf)       (return-from fmakunbound (funcall (function-spec-handler name) name nil)))     (setq name (setf-function-name (cadr name))))   (remhash name %structure-refs%)   (%unfhave name)   name))(defun frozen-definition-p (name)  (if (symbolp name)    (%ilogbitp $sym_fbit_frozen (%symbol-bits name))))(defun redefine-kernel-function (name)  (when (and *warn-if-redefine-kernel*             (frozen-definition-p name)             (or (lfunp (fboundp name))                 (and (not (consp name)) (macro-function name)))             (or (and (consp name) (neq (car name) 'setf))                 (let ((pkg (symbol-package (if (consp name) (cadr name) name))))                   (or (eq *common-lisp-package* pkg) (eq *ccl-package* pkg)))))    (cerror "Replace the definition of ~S."            "The function ~S is already defined in the MCL kernel." name)    (unless (consp name)      (proclaim-inline nil name))))(defun fset (name function)  (setq function (require-type function 'function))  (when (symbolp name)    (when (special-form-p name)      (error "Can not redefine a special-form: ~S ." name))    (when (macro-function name)      (cerror "Redefine the macro ~S as a function"              "The macro ~S is being redefined as a function." name))); This lets us redefine %FHAVE.  Big fun.  (let ((fhave #'%fhave))    (redefine-kernel-function name)    (fmakunbound name)    (funcall fhave name function)    function))(defsetf symbol-function fset)(defsetf fdefinition fset)(defun set-macro-function (name macro-fun)  (if (special-form-p name)    (error "Can not redefine a special-form: ~S ." name))  (when (and (fboundp name) (not (macro-function name)))    (cerror "Redefine function ~S as a macro."            "The function ~S is being redefined as a macro." name))  (redefine-kernel-function name)  (fmakunbound name)  (%macro-have name macro-fun)  macro-fun)(defsetf macro-function set-macro-function)(defun trap-implemented-p (trap)  (not (%ptr-eql (#_GetToolTrapAddress #xA89F)                 (if (%ilogbitp 11 trap)                   (#_GetToolTrapAddress trap)                   (#_GetOSTrapAddress   trap)))))(defvar *multifinder* nil)(defparameter *environs* nil)(defparameter *known-gestalt-machine-types*  '((3 . "512KE") (4 . "Plus") (5 . "SE") (6 . "II") (7 . "IIx") (8 . "IIcx") (9 . "SE/30") (10 . "Portable") (11 . "IIci") (13 . "IIfx") (17 . "Classic") (18 . "IIsi") (19 . "LC") (20 . "Quadra 900") (21 . "PowerBook 170") (22 . "Quadra 700") (23 . "Classic II") (24 . "PowerBook 100") (25 . "PowerBook 140") (26 . "Quadra 950") (27 . "LCIII") (29 . "PowerBook Duo 210") (30 . "Centris 650") (32 . "PowerBook Duo 230") (33 . "PowerBook 180") (34 . "PowerBook 160") (35 . "Quadra 800") (36 . "Quadra 650") (37 . "LCII") (38 . "PowerBook Duo 250") (39 . "AWS 9150/80") (40 . "Power Macintosh 8100/110") (44 . "IIVi") (45 . "Performa 600") (48 . "IIVx") (49 . "Color Classic") (50 . "PowerBook 165c") (52 . "Centris 610") (53 . "Quadra 610") (54 . "PowerBook 145") (56 . "LC520") (57 . "AWS 9150/120") (60 . "Quadra 660AV") (62 . "Performa 46x") (71 . "PowerBook 180c") (72 . "PowerBook 540c") (77 . "PowerBook Duo 270c") (78 . "Quadra 840AV") (80 . "Performa 550") (84 . "PowerBook 165") (89 . "LC475") (94 . "Quadra 605") (98 . "Quadra 630") (102 . "PowerBook Duo 280") (103 . "PowerBook Duo 280c") (666 . "Macintosh of Doom") (47 . "Power Macintosh 7100/80") (55 . "Power Macintosh 8100/100") (65 . "Power Macintosh 8100/80") (67 . "Power Macintosh 9500") (68 . "Power Macintosh 7500") (69 . "Power Macintosh 8500") (75 . "Power Macintosh 6100/60") (85 . "PowerBook 190") (88 . "Macintosh TV") (92 . "LC 575") (99 . "LC 580") (100 . "Power Macintosh 6100/66") (104 . "Mac LC 475 & PPC Processor Upgrade Card") (105 . "Mac LC 575 & PPC Processor Upgrade Card") (106 . "Quadra 630 & PPC Processor Upgrade Card") (108 . "Power Macintosh 7200") (112 . "Power Macintosh 7100/66") (115 . "PowerBook 150") (116 . "Quadra 700 & Power PC Upgrade Card") (117 . "Quadra 900 & Power PC Upgrade Card") (118 . "Quadra 950 & Power PC Upgrade Card") (119 . "Centris 610 & Power PC Upgrade Card") (120 . "Centris 650 & Power PC Upgrade Card") (121 . "Quadra 610 & Power PC Upgrade Card") (122 . "Quadra 650 & Power PC Upgrade Card") (123 . "Quadra 800 & Power PC Upgrade Card") (124 . "PowerBook Duo 2300") (126 . "PowerBook 5xx PPC Upgrade Card") (128 . "PowerBook 5300")))(defparameter *known-gestalt-keyboard-types*  '((1 . "Macintosh keyboard")    (2 . "Macintosh keyboard with numeric keypad")    (3 . "Macintosh plus keyboard")    (4 . "Apple extended keyboard")    (5 . "Apple standard keyboard")    (6 . "Portable Keyboard")    (7 . "Portable Keyboard (ISO)")    (8 . "Apple Standard Keyboard (ISO)")    (9 . "Apple Extended Keyboard (ISO)")    (10 . "Elmer Keyboard (owns a mansion & a yacht)")    (11 . "Elmer ISO Keyboard (owns an ISO mansion & a yacht")    (12 . "PowerBook Keyboard")    (13 . "PowerBook KeyBoard (ISO)")    (14 . "Apple Adjustable Keypad")    (15 . "Apple Adjustable Keyboard")    (16 . "Apple Adjustable Keyboard (ISO)")    (17 . "Apple Adjustable Keyboard (Japanese)")    (20 . "PowerBook Extended Keyboard with function keys (ISO)")    (21 . "PowerBook Extended Keyboard with function keys (Japanese)")    (24 . "PowerBook Extended Keyboard with function keys")    )); These are the return values for (gestalt #$gestaltNativeCPUtype),; not (gestalt #$gestaltProcessorType) as before.(defparameter *known-gestalt-processor-types*  '((1 . 68000)    (2 . 68010)    (3 . 68020)    (4 . 68030)    (5 . 68040)    (#x101 . 601)    (#x103 . 603)    (#x104 . 604)    (#x106 . "603e")))(defparameter *known-gestalt-fpu-types*  '((0 . nil)    (1 . 68881)    (2 . 68882)    (3 . 68040)))(eval-when (compile eval)(defconstant $gestalt8BitQD #x100)(defconstant $gestalt32BitQD #x200))(def-ccl-pointers sysenvirons ()  (let* ((sysversion (gestalt :|sysv|))         (minorversion (neq 0 (logand sysversion #xf))))    (setq *multifinder* (trap-implemented-p #xA88f))    ; #xa88f = #_OSDispatch.    (setq *environs*          (list           :machine-type                      (let* ((machine-number (gestalt :|mach|)))             (or (cdr (ASSQ machine-number *known-gestalt-machine-types*))                 (getindstring #$kMachineNameStrID machine-number)                 (format nil "Macintosh #~d" machine-number)))           :system-version           (let ((str (make-string (if minorversion 5 3) :element-type 'base-character)))             (when minorversion               (setf (schar str 3) #\.                     (schar str 4) (%code-char (+ 48 (logand sysversion #xf)))))             (setq sysversion (ash sysversion -4))             (set-schar str 0 (%code-char (+ 48 (ash sysversion -4))))             (set-schar str 1 #\.)             (set-schar str 2 (%code-char (+ 48 (logand sysversion #xf))))             str)           :appleevents           (gestalt #$gestaltAppleEventsAttr #$gestaltAppleEventsPresent)           :processor           (let ((processor-number (gestalt #$gestaltNativeCPUtype))                 (old-processor-number (gestalt :|proc|)))             (cond ((null processor-number)(setq processor-number old-processor-number))                   ((and processor-number old-processor-number                         (neq processor-number old-processor-number)                         (<= processor-number #$gestaltCPU68040))                    (setq processor-number old-processor-number)))                                 (or (cdr (assq processor-number *known-gestalt-processor-types*))                 ;(format nil "#~d" processor-number)                 "Unknown CPU"                 ))           :fpu           (let* ((fpu-number (gestalt :|fpu |)))             (if (eql #$gestaltNoFPU fpu-number)               nil               (or (cdr (assq fpu-number *known-gestalt-fpu-types*))                   ;(format nil "#~d" fpu-number)                   "Unknown FPU"                   )))           :color-quickdraw           (let ((res (gestalt :|qd  |)))             (cond ((not (eql 0 (logand #$gestalt32BitQD res)))                    (setq *setgworld-available?* t                          *screen-gdevice* (#_getmaindevice))                    32)                   ((not (eql 0 (logand #$gestalt8BitQD res))) 8)))           :keyboard           (let ((keyboard-number (gestalt :|kbd |)))             (or (cdr (assq keyboard-number *known-gestalt-keyboard-types*))                 ;(format nil "#~d" keyboard-number)                 "Peculiar new keyboard"))           :appletalk-version           (gestalt :|atlk|))))  );; font stuff.; Returns two longs calculated from a font-spec that specify a font's; font-number/style, and text-mode/size; And two more longs that are the masks for changed parts of the first two longs.; (values ff-code ms-code ff-mask ms-mask)(defun font-codes (font-spec &optional old-ff old-ms                             &aux                              (items font-spec) temp item font face mode size color                             reset-style-p                              (font-mask 0) (face-mask 0) (color-mask 0)                             (mode-mask 0) (size-mask 0))  (if (null old-ff) (setq old-ff 0))  (if (null old-ms) (setq old-ms (make-point 0 (position :srcor *pen-modes*))))  (if (null font-spec)    (return-from font-codes (values old-ff old-ms 0 0)))  (setq item (if (consp items) (pop items) items))  (tagbody    LOOP    (cond     ((fixnump item)      (if size         (error "Font Spec: ~s contains two sizes" font-spec)        (setq size item              size-mask -1)))     ((stringp item)      (if font (error "Font Spec: ~s contains two strings" font-spec))      (setq font-mask -1)      (if (equalp item "chicago")        (setq font 0)        (rlet ((fnum :integer))          (with-pstrs ((np item))            (#_GetFNum np fnum))          (setq font (%get-word fnum)))))     ((consp item)      (ecase (car item)        (:color-index         (when color           (error "Font Spec: ~s contains two color specs" font-spec))         (setq color (second item))         (unless (and (fixnump color)                      (<= 0 color 255))           (error "~s is not a valid font color" color))         (setq color-mask 255))        (:color         (when color           (error "Font Spec: ~s contains two color specs" font-spec))         (setq color (fred-palette-closest-entry (second item))               color-mask 255))))     ((setq temp (position item (the list *pen-modes*) :test 'eq))      (if mode         (error "Font Spec: ~s contains two text-modes" font-spec)        (setq mode temp              mode-mask -1)))     ((setq temp (assq item *style-alist*))      (when (eq (%car temp) :plain)        (setq reset-style-p t              face-mask -1))      (setq temp (%cdr temp))      (setq face (if face (%ilogior2 face temp) temp)            face-mask (%ilogior2 face-mask temp)))     (t (error "Unrecognized option ~a in font-spec: ~a" item font-spec)))    (if (consp items) (progn (setq item (pop items)) (go LOOP))))  (unless font (setq font (point-v old-ff)))  (unless face (setq face (%ilsr 8 (point-h old-ff))))  (unless color (setq color (%ilogand 255 (point-h old-ff))))  (unless reset-style-p    (setq face (%ilogior2 face (%ilsr 8 (point-h old-ff)))))  (unless mode (setq mode (point-v old-ms)))  (unless size (setq size (point-h old-ms)))  (values (make-point (+ color (%ilsl 8 face)) font)          (make-point size mode)          (make-point (logior color-mask (%ilsl 8 face-mask)) font-mask)          (make-point size-mask mode-mask)))(defun merge-font-codes (old-ff-code old-ms-code ff-code ms-code &optional ff-mask ms-mask)  #| (unless (and (integerp old-ff-code) (integerp old-ms-code) ; NO               (integerp ff-code) (integerp ms-code)               (or (null ff-mask) (integerp ff-mask))               (or (null ms-mask) (integerp ms-mask)))    (error "All args must be fixnums."))|#  (values   (if ff-mask     (logior (logand ff-code ff-mask) (logand old-ff-code (lognot ff-mask)))     ff-code)   (if ms-mask     (logior (logand ms-code ms-mask) (logand old-ms-code (lognot ms-mask)))     ms-code)))(defun font-values (ff-code ms-code &aux temp font size mode face color)  (if (not ff-code) (setq ff-code 0))  (if (not ms-code) (setq ms-code 0))  (rlet ((np (:string 256)))    (#_GetFontName (point-v ff-code) np)    (setq font (%get-string np)))  (setq mode (elt *pen-modes* (point-v ms-code)))  (setq size (point-h ms-code))  (setq color (logand 255 ff-code))  (setq ff-code (%ilsr 8 (point-h ff-code)))  (if (eq ff-code 0)      (setq face :plain)      (dotimes (i 7)        (declare (fixnum i))         (if (%ilogbitp i ff-code)             (progn (setq temp (car (rassoc (%ilsl i 1) *style-alist*)))                    (if face                        (if (consp face)                            (push temp face)                            (setq face (list temp face)))                        (setq face temp))))))  (values font size mode face color))(defun font-spec (ff-code ms-code)  (multiple-value-bind (name size mode style color) (font-values ff-code ms-code)    (if (atom style) (setq style (cons style nil)))    (nconc (list* name size mode style)           `((:color-index ,color)))))(defun font-size-list (font)  (without-interrupts   (with-macptrs (famrec)     (with-pstrs ((np font))       (%setf-macptr famrec (#_GetNamedResource "FONT" np)))     (do* ((count (%hget-word famrec 52) (1- count))           (offset (+ 54 (* 6 count)) (- offset 6))           ret)          ((< count 0) ret)       (if (eq 0 (%hget-word famrec (+ offset 2)))         (push (%hget-word famrec offset) ret))))));;; Arrays and vectors, including make-array.(defun make-array (dims &key (element-type t element-type-p)                        displaced-to                        displaced-index-offset                        adjustable                        fill-pointer                        (initial-element nil initial-element-p)                        (initial-contents nil initial-contents-p))  (when (and initial-element-p initial-contents-p)        (error "Cannot specify both ~S and ~S" :initial-element-p :initial-contents-p))  (make-array-1 dims element-type element-type-p                displaced-to                displaced-index-offset                adjustable                fill-pointer                initial-element initial-element-p                initial-contents initial-contents-p                nil))(defun make-array-1 (dims element-type element-type-p                          displaced-to                          displaced-index-offset                          adjustable                          fill-pointer                          initial-element initial-element-p                          initial-contents initial-contents-p                          size)  (let ((subtype (element-type-subtype element-type)))    (when (and element-type (null subtype))      (error "Unknown element-type ~S" element-type))    (when (null size)      (cond ((listp dims)             (setq size 1)             (dolist (dim dims)               (when (< dim 0)                 (report-bad-arg dim '(integer 0 *)))               (setq size (* size dim))))            (t (setq size dims)))) ; no need to check vs. array-dimension-limit    (cond     (displaced-to      (when (or initial-element-p initial-contents-p)        (error "Cannot specify initial values for displaced arrays"))      (when (and element-type-p                 (neq (array-element-subtype displaced-to) subtype))        (error "The ~S array ~S is not of ~S ~S"               :displaced-to displaced-to :element-type element-type))      (%make-displaced-array dims displaced-to                             fill-pointer adjustable displaced-index-offset))     (t      (when displaced-index-offset        (error "Cannot specify ~S for non-displaced-array" :displaced-index-offset))      (when (null subtype)        (error "Cannot make an array of empty type ~S" element-type))      (make-uarray-1 subtype dims adjustable fill-pointer                      initial-element initial-element-p                     initial-contents initial-contents-p                     nil size)))))(defun make-uarray-1 (subtype dims adjustable fill-pointer                              initial-element initial-element-p                              initial-contents initial-contents-p                              temporary                               size)  (when (null size)(setq size (if (listp dims)(apply #'* dims) dims)))  (let ((vector (if temporary                  (%make-temp-uvector size subtype)                  #-ppc-target (%make-uvector size subtype)                  #+ppc-target (%alloc-misc size subtype))))  ; may not get here in that case    (if initial-element-p      (dotimes (i (uvsize vector)) (declare (fixnum i))(uvset vector i initial-element))      (if initial-contents-p        (if (null dims) (uvset vector 0 initial-contents)            (init-uvector-contents vector 0 dims initial-contents))))    (if (and (null fill-pointer)             (not adjustable)             dims             (or (atom dims) (null (%cdr dims))))      vector      (let ((array (%make-displaced-array dims vector                                           fill-pointer adjustable nil)))        (when (and (null fill-pointer) (not adjustable))          #-ppc-target          (lap-inline ()            (:variable array)            (move.l (varg array) atemp0)            (bset ($ $arh_simple_bit) (svref atemp0 arh.fixnum $arh_bits)))          #+ppc-target          (%set-simple-array-p array))        array))))(defun init-uvector-contents (vect offset dims contents                              &aux (len (length contents)))  "Returns final offset. Assumes dims not ()."  (unless (eq len (if (atom dims) dims (%car dims)))    (error "~S doesn't match array dimensions of ~S ."  contents vect))  (cond ((or (atom dims) (null (%cdr dims)))         (if (listp contents)           (let ((contents-tail contents))             (dotimes (i len)               (declare (fixnum i))               (uvset vect offset (pop contents-tail))               (setq offset (%i+ offset 1))))           (dotimes (i len)             (declare (fixnum i))             (uvset vect offset (elt contents i))             (setq offset (%i+ offset 1)))))        (t (setq dims (%cdr dims))           (if (listp contents)             (let ((contents-tail contents))               (dotimes (i len)                 (declare (fixnum i))                 (setq offset                       (init-uvector-contents vect offset dims (pop contents-tail)))))             (dotimes (i len)               (declare (fixnum i))               (setq offset                     (init-uvector-contents vect offset dims (elt contents i)))))))  offset)(defun char (string index) (if (stringp string)  (aref string index)  (report-bad-arg string 'string)))(defun set-char (string index new-el)  (if (stringp string)    (aset string index new-el)    (report-bad-arg string 'string)))(defun equalp (x y)  "Just like EQUAL, but more liberal in several respects.  Numbers may be of different types, as long as the values are identical  after coercion.  Characters may differ in alphabetic case.  Vectors and  arrays must have identical dimensions and EQUALP elements, but may differ  in their type restriction.  If one of x or y is a pathname and one is a string with the name of the  pathname then this will return T."  (cond ((eql x y) t)        ((characterp x) (and (characterp y) (eq (char-upcase x) (char-upcase y))))        ((numberp x) (and (numberp y) (= x y)))        ((consp x)         (and (consp y)              (equalp (car x) (car y))              (equalp (cdr x) (cdr y))))                ((pathnamep x) (equal x y))        ((vectorp x)         (and (vectorp y)              (let ((length (length x)))                (when (eq length (length y))                  (dotimes (i length t)                    (declare (fixnum i))                    (let ((x-el (aref x i))                          (y-el (aref y i)))                      (unless (or (eq x-el y-el) (equalp x-el y-el))                        (return nil))))))))        ((arrayp x)         (and (arrayp y)              (let ((rank (array-rank x)) x-el y-el)                (and (eq (array-rank y) rank)                     (if (%izerop rank) (equalp (aref x) (aref y))                         (and                          (dotimes (i rank t)                            (declare (fixnum i))                            (unless (eq (array-dimension x i)                                        (array-dimension y i))                              (return nil)))                          (multiple-value-bind (x0 i) (array-data-and-offset x)                            (multiple-value-bind (y0 j) (array-data-and-offset y)                              (dotimes (count (array-total-size x) t)                                (declare (fixnum count))                                (setq x-el (uvref x0 i) y-el (uvref y0 j))                                (unless (or (eq x-el y-el) (equalp x-el y-el))                                  (return nil))                                (setq i (%i+ i 1) j (%i+ j 1)))))))))))        ((and (structurep x) (structurep y))	 (let ((size (uvsize x)))	   (and (eq size (uvsize y))	        (dotimes (i size t)                  (declare (fixnum i))		  (unless (equalp (uvref x i) (uvref y i))                    (return nil))))))        ((and (hash-table-p x) (hash-table-p y))         (%hash-table-equalp x y))        (t nil)))(defun font-info (&optional font-spec &aux ff ms)  (if font-spec    (multiple-value-setq (ff ms) (font-codes font-spec))    (with-macptrs ((port (%getport)))       (setq ff (%get-long port 68)            ms (%get-long port 72))))  (font-codes-info ff ms))(defun font-codes-info (ff-code ms-code)  (with-port %temp-port%    (with-font-codes ff-code ms-code      (rlet ((fi :fontinfo))        (#_GetFontInfo fi)        (values (rref fi fontinfo.ascent)                (rref fi fontinfo.descent)                (rref fi fontinfo.widmax)                (rref fi fontinfo.leading))))))(defun font-line-height (&optional font-spec)  (multiple-value-bind (a d w l) (font-info font-spec)    (declare (ignore w))    (%i+ a d l)))(defun font-codes-line-height (ff ms)  (multiple-value-bind (a d w l)(font-codes-info ff ms)    (declare (ignore w))    (%i+ a d l)))(defun real-font (&optional font-spec &aux family ff ms)  (unless font-spec    (with-macptrs ((port (%getport)))      (setq ff (%get-long port 68)            ms (%get-long port 72))))  (with-macptrs ((port %temp-port%))    (with-port port      (when font-spec        (setq family (if (consp font-spec)                       (dolist (x font-spec) (when (stringp x) (return x)))                       (when (stringp font-spec) font-spec)))        (when (and family                   (eq 0 (rlet ((fnum :integer))                           (with-pstrs ((np family))                             (#_GetFNum np fnum))                           (%get-word fnum)))                   (not (equalp family "chicago")))          (return-from real-font nil))        (multiple-value-setq (ff ms) (font-codes font-spec)))      (with-font-codes ff ms        (#_RealFont          (rref port grafport.txfont)         (rref port grafport.txsize))))))(defun string-width (string &optional font-spec &aux ff ms)  (if font-spec    (multiple-value-setq (ff ms) (font-codes font-spec))    (with-macptrs ((port (%getport)))      (setq ff (%get-long port 68)            ms (%get-long port 72))))  (font-codes-string-width string ff ms))(defun font-codes-string-width (string ff ms &optional                                       (start 0)                                       (end (length string)))  (unless (fixnump start)    (setq start (require-type start 'fixnum)))  (unless (fixnump end)    (setq end (require-type end 'fixnum)))  (locally (declare (fixnum start end))    (let ((size (- end start)))      (declare (fixnum size))      (if (> size 255)        (let ((res 0)              (sub-start start))          (declare (fixnum sub-start res))          (dotimes (i (floor size 255))            (incf res (font-codes-string-width                       string ff ms sub-start (the fixnum (+ start 255))))            (incf sub-start 255))          (unless (eql sub-start end)            (incf res (font-codes-string-width string ff ms sub-start end))))        (with-pstrs ((sp string start end))          (with-port %temp-port%            (with-font-codes ff ms              (#_StringWidth sp))))))));The following functions are redefined correctly in time.lisp(defun mac-to-universal-time (time-hi &optional time-lo)  (+ $mac-time-offset     (if time-lo       (+ (ash time-hi 16) time-lo)       time-hi)))(defun universal-to-mac-time (time)  (- time $mac-time-offset)); The compiler (or some transforms) might want to do something more interesting; with these, but they have to exist as functions anyhow.(defun constantly (value)  #'(lambda (&rest ignore)      (declare (ignore ignore))      value))(defun complement (function)  (let ((f (coerce-to-function function))) ; keep poor compiler from consing value cell  #'(lambda (&rest args)      (declare (dynamic-extent args)) ; not tail-recursive anyway      (not (apply f args))))); Special variables are evil, but I can't think of a better way to do this.(defparameter *outstanding-deferred-warnings* nil)(def-accessors (deferred-warnings) %svref  nil  deferred-warnings.parent  deferred-warnings.warnings  deferred-warnings.defs  deferred-warnings.flags ; might use to distinguish interactive case/compile-file)(defun %defer-warnings (override &optional flags)  (%istruct 'deferred-warnings (unless override *outstanding-deferred-warnings*) nil nil flags))(defun report-deferred-warnings ()  (let* ((current *outstanding-deferred-warnings*)         (parent (deferred-warnings.parent current))         (defs (deferred-warnings.defs current))         (warnings (deferred-warnings.warnings current))         (any nil)         (harsh nil))    (if parent      (setf (deferred-warnings.warnings parent) (append warnings (deferred-warnings.warnings parent))            (deferred-warnings.defs parent) (append defs (deferred-warnings.defs parent))            parent t)      (let* ((file nil)             (init t))        (dolist (w warnings)          (let ((wfname (car (compiler-warning-args w))))            (when (if (typep w 'undefined-function-reference)                    (not (or (fboundp wfname)                             (assq wfname defs))))              (multiple-value-setq (harsh any file) (signal-compiler-warning w init file harsh any))              (setq init nil))))))    (values (values any harsh parent))))(defun print-nested-name (name-list stream)  (if (null name-list)    (princ "a toplevel form" stream)    (progn      (if (car name-list)        (prin1 (%car name-list) stream)        (princ "an anonymous lambda form" stream))      (when (%cdr name-list)        (princ " inside " stream)        (print-nested-name (%cdr name-list) stream)))))(defparameter *suppress-compiler-warnings* nil)(defun signal-compiler-warning (w init-p last-w-file harsh-p any-p &optional eval-p)  (let ((muffled *suppress-compiler-warnings*)        (w-file (compiler-warning-file-name w))        (s *error-output*))    (unless muffled       (restart-case (signal w)        (muffle-warning () (setq muffled t))))    (unless muffled      (setq any-p t)      (unless (typep w 'style-warning) (setq harsh-p t))      (when (or init-p (not (equalp w-file last-w-file)))        (format s "~&;~A warnings " (if (null eval-p) "Compiler" "Interpreter"))        (if w-file (format s "for ~S :" w-file) (princ ":" s)))      (format s "~&;   ~A" w))    (values harsh-p any-p w-file)));;;; Assorted mumble-P type predicates. ;;;; No functions have been in the kernel for the last year or so.;;;; (Just thought you'd like to know.)(defun sequencep (form)  "Not CL. SLISP Returns T if form is a sequence, NIL otherwise."   (or (listp form) (vectorp form)));;; The following are not defined at user level, but are necessary for;;; internal use by TYPEP.(defun bitp (form)  "Not CL. SLISP"  (or (eq form 0) (eq form 1)))(defun unsigned-byte-p (form)  (and (integerp form) (not (< form 0))));This is false for internal structures.;;; ---- look at defenv.structures, not defenv.structrefs;This is false for internal structures.(defun structure-class-p (form &optional env)  (and (symbolp form)       (let ((sd (or (and env                          (let ((defenv (definition-environment env)))                            (and defenv                                 (%cdr (assq form (defenv.structures defenv))))))                     (gethash form %defstructs%))))         (and sd              (null (sd-type sd))              sd))))