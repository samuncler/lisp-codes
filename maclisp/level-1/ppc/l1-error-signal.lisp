;;	Change History (most recent first):;;  1 11/13/95 gb   split off from l1-readloop.lisp;;;;  (do not edit before this line!!);;; Functions that actually try to signal or handle errors.;; 03/26/97 gb    (defpascal %err-disp) : recognize errors during FRSP as "can't coerce".;; -------------  4.1b1;; 03/13/97 bill  From Gary: (defpascal %err-disp ...) handles ppc::error-fpu-exception-single;; 03/12/97 bill  handle-stack-overflow properly updates sg.maxsize;; 03/04/97 bill  handle-stack-overflow supports *minimum-stack-overflow-size*;; 12/30/97 bill  handle-udf-call no longer calls bug.;; 12/30/96 bill  handle-udf-call temporarily calls bug to display the symbol name;; 10/29/96 bill  (defpascal %err-disp ...) handles ppc::error-too-many-values;; -------------  4.0;; 10/11/96 bill  handle-stack-overflow increases stack size while signalling error;;                so that recursive overflows are less likely.;; -------------  4.0f1;; 06/26/96 bill  handle-stack-overflow comes out-of-line from (defpascal %err-disp ...).;;                It determines if the stack size has gotten too large and signals;;                a continuable error if it has.;; 06/25/96 bill  handle-udf-call comes out of line from %err-disp. It makes restarting work.;; -------------- MCL-PPC 3.9;; 04/10/96 gb    handle ppc::error-memory-full error.;; 04/08/96 gb    handle ppc::error-excised-function-call uuo.;; 03/25/96 bill  (defpascal %err-disp ...) handles ppc::error-throw-tag-missing instead;;                of the non-existent (to the kernel) ppc::error-divide-by-zero.;; 03/01/96 gb    %err-disp callback handles (some) FPU exceptions;; 02/22/96 bill  %kernel-restart-internal passes the frame-ptr as the first arg to;;                the restart functions.;; 01/31/96 gb    no need for nilreg-cell-symbol since 3.0.;; 01/22/96 gb   %err-disp callback recognizes stack-overflow & alloc-failed.;; 01/17/96 bill  Get frame-ptr from with-xp-stack-frames and call new %err-disp-internal;;                or %kernel-restart-internal instead of %err-disp & %kernel-restart.;; 12/08/95 bill  xp-gpr-lisp & friends move from here to ppc-trap-support;; 11/30/95 bill  Remove the #_DebugStr from error.;;                (defpascal %err-disp ...) now handles the UUO error codes correctly.;; 11/29/95 bill  with-error-reentry-detection moves from here to l1-events;; 11/21/95 bill (defpascal %err-disp ...) to handle callback from handle-error;;               in lisp-exceptions.c. Wrap with-error-reentry-detection around;;               the body of %err-disp to prevent infinite %err-disp loops.;; callback here from C exception handler#+ppc-target(defpascal %err-disp (:ptr xp :long fn-reg :long pc-or-index :long errnum :long rb :long continuable)  (let ((fn (unless (eql fn-reg 0) (xp-gpr-lisp xp fn-reg)))        (err-fn (if (eql continuable 0) '%err-disp-internal '%kernel-restart-internal)))    (if (eql errnum ppc::error-stack-overflow)      (handle-stack-overflow xp fn rb)      (with-xp-stack-frames (xp fn frame-ptr)   ; execute body with dummy stack frame(s)        (with-error-reentry-detection          (let* ((rb-value (xp-gpr-lisp xp rb))                 (res                  (cond ((< errnum 0)                         (%err-disp-internal errnum nil frame-ptr))                        ((logtest errnum ppc::error-type-error)                         (funcall err-fn                                   #.(car (rassoc 'type-error *kernel-simple-error-classes*))                                  (list rb-value (logand errnum 63))                                  frame-ptr))                        ((eql errnum ppc::error-udf)                         (funcall err-fn $xfunbnd (list rb-value) frame-ptr))                        ((eql errnum ppc::error-throw-tag-missing)                         (%err-disp-internal $xnoctag (list rb-value) frame-ptr))                        ((eql errnum ppc::error-cant-call)                         (funcall err-fn $xnotfun (list rb-value) frame-ptr))                        ((eql errnum ppc::error-udf-call)                         (return-from %err-disp                           (handle-udf-call xp frame-ptr)))                        ((eql errnum ppc::error-alloc-failed)                         (%error (make-condition                                   'simple-storage-condition                                  :format-string (%rsc-string $xmemfull))                                 nil frame-ptr))                        ((eql errnum ppc::error-memory-full)                         (%error (make-condition                                   'simple-storage-condition                                  :format-string (%rsc-string $xnomem))                                 nil frame-ptr))                        ((or (eql errnum ppc::error-fpu-exception-double)                              (eql errnum ppc::error-fpu-exception-single))                         (let* ((code-vector (and fn fn (uvref fn 0)))                                (instr (if code-vector                                          (uvref code-vector pc-or-index)                                         (%get-long (%int-to-ptr pc-or-index)))))                           (let* ((minor (ldb (byte 5 1) instr))                                  (fra (ldb (byte 5 16) instr))                                  (frb (ldb (byte 5 11) instr))                                  (frc (ldb (byte 5 6) instr)))                             (declare (fixnum minor fra frb frc))                             (if (= minor 12)   ; FRSP                               (%err-disp-internal $xcoerce (list (xp-double-float xp frc) 'short-float) frame-ptr)                               (flet ((coerce-to-op-type (double-arg)                                        (if (eql errnum ppc::error-fpu-exception-double)                                          double-arg                                          (handler-case (coerce double-arg 'short-float)                                            (error (c) (declare (ignore c)) double-arg)))))                                 (multiple-value-bind (status control) (xp-fpscr-info xp)                                   (%error (make-condition (fp-condition-from-fpscr status control)                                                           :operation (fp-minor-opcode-operation minor)                                                           :operands (list (coerce-to-op-type                                                                             (xp-double-float xp fra))                                                                           (if (= minor 25)                                                                             (coerce-to-op-type                                                                               (xp-double-float xp frc))                                                                             (coerce-to-op-type                                                                               (xp-double-float xp frb)))))                                           nil                                           frame-ptr)))))))                        ((eql errnum ppc::error-excised-function-call)                         (%error "~s: code has been excised." (list (xp-gpr-lisp xp ppc::nfn)) frame-ptr))                        ((eql errnum ppc::error-too-many-values)                         (%err-disp-internal $xtoomanyvalues (list rb-value) frame-ptr))                        (t (%error "Unknown error #~d with arg: ~d" (list errnum rb-value) frame-ptr)))))            (setf (xp-gpr-lisp xp rb) res)        ; munge register for continuation            ))))))(defun handle-udf-call (xp frame-ptr)  ;(bug (symbol-name (xp-gpr-lisp xp ppc::fname)))  (let* ((args (xp-argument-list xp))         (values (multiple-value-list                  (%kernel-restart-internal                   $xudfcall                   (list (xp-gpr-lisp xp ppc::fname) args)                   frame-ptr)))         (stack-argcnt (max 0 (- (length args) 3)))         (vsp (%i+ (xp-gpr-lisp xp ppc::vsp) stack-argcnt))         (f #'(lambda (values) (apply #'values values))))    (setf (xp-gpr-lisp xp ppc::vsp) vsp          (xp-gpr-lisp xp ppc::nargs) 1          (xp-gpr-lisp xp ppc::arg_z) values          (xp-gpr-lisp xp ppc::nfn) f)    (with-macptrs ((machine-state (pref xp :ExceptionInformationPowerPC.machineState)))      (let ((pc-offset (get-field-offset :MachineInformationPowerPC.PC.lo)))        (without-interrupts         (%set-object machine-state                      pc-offset                      (%i- (%misc-address-fixnum (uvref f 0))                           1)))))))     ; handle_uuo will bump pc by 1(defppclapfunction %misc-address-fixnum ((misc-object arg_z))  (check-nargs 1)  (la arg_z ppc::misc-data-offset misc-object)  (blr))(defun %stack-group-useable-size (&optional (sg *current-stack-group*))  (multiple-value-bind (cf cu vf vu tf tu) (%stack-group-stack-space sg)    (- (+ cf cu vf vu tf tu) (* 2 4096) *cs-hard-overflow-size* *cs-soft-overflow-size*)))(defvar *allow-stack-overflows* t); This probably needs some tuning(defvar *minimum-stack-overflow-size* (* 100 1024)); rb is the register number of the stack that overflowed.; xp & fn are passed so that we can establish error context.(defun handle-stack-overflow (xp fn rb)  (flet ((stack-overflow-error ()           (with-xp-stack-frames (xp fn frame-ptr)      ; execute body with dummy stack frame(s)             (%error              (make-condition               'stack-overflow-condition                :format-string "Stack overflow on ~a stack.~@                               To globally increase stack space,~@                               increase ~s"               :format-arguments (list                                  (if (eql rb ppc::sp)                                    "control"                                    (if (eql rb ppc::vsp)                                      "value"                                      (if (eql rb ppc::tsp)                                        "temp"                                        "unknown")))                                  '*minimum-stack-overflow-size*))              nil frame-ptr))))    (declare (dynamic-extent #'stack-overflow-error))    (if (not (or (eql rb ppc::vsp)                 (eql rb ppc::tsp)                 (and (eql rb ppc::sp)                      (let ((cs-area (%get-kernel-global 'current-cs)))                        (> (%current-frame-ptr)                           (%fixnum-ref cs-area ppc::area.softlimit))))))      (stack-overflow-error)      (unless *allow-stack-overflows*       ; startup        (let* ((sg *current-stack-group*)               (total-used (%stack-group-useable-size sg))               (maxsize (sg.maxsize sg))               (total-allowed (max maxsize *minimum-stack-overflow-size*))               (delta (- total-used total-allowed))               (diff (max (* 16 1024) (* 2 delta)))               (continued? nil))          (when (> delta 0)            (unwind-protect              (progn                (setf (sg.maxsize sg) (+ total-allowed diff))                (restart-case (stack-overflow-error)                  (continue ()                            :report (lambda (stream)                                       (format stream "Continue with a larger stack"))                            (setq continued? t)                            nil)))              (unless continued?                (setf (sg.maxsize sg) maxsize)))))))))(queue-fixup (setq *allow-stack-overflows* nil))(defun %kernel-restart (error-type &rest args)  (%kernel-restart-internal error-type args (%get-frame-ptr)))(defun %kernel-restart-internal (error-type args frame-ptr)  ;(declare (dynamic-extent args))  (dolist (f *kernel-restarts* (%err-disp-internal error-type args frame-ptr))    (when (eq (car f) error-type)      (return (apply (cdr f) frame-ptr args))))); this is the def of %err-disp.; Yup.  That was my first guess.(defun %err-disp (err-num &rest errargs)  (%err-disp-internal err-num errargs (%get-frame-ptr)))(defun %err-disp-internal (err-num errargs frame-ptr)  (declare (fixnum err-num))  ; The compiler (finally !) won't tail-apply error.  But we kind of  ; expect it to ...  (let* ((err-typ (max (ash err-num -16) 0))         (err-num (%word-to-int err-num))         (format-string (%rsc-string err-num))         (condition-name (or (uvref *simple-error-types* err-typ)                             (%cdr (assq err-num *kernel-simple-error-classes*)))))    ;(dbg format-string)    (if condition-name            (funcall '%error               (case condition-name                 (type-error (make-condition condition-name                                             :format-string format-string                                             :datum (car errargs)                                             :expected-type (%type-error-type (cadr errargs))))                 (file-error (make-condition condition-name                                             :pathname (car errargs)                                             :error-type format-string                                             :format-arguments (cdr errargs)))                 (undefined-function (make-condition condition-name                                                     :name (car errargs)))                 (t (make-condition condition-name                                     :format-string format-string                                    :format-arguments errargs)))               nil               frame-ptr)      (funcall '%error format-string errargs frame-ptr))))(defun error (condition &rest args)  #|  #+ppc-target  (with-pstrs ((pstr (if (stringp condition) condition "Error")))    (#_DebugStr pstr))  |#  (%error condition args (%get-frame-ptr)))(defun cerror (cont-string condition &rest args)  (let* ((fp (%get-frame-ptr))         (eval-queue *eval-queue*))    (restart-case (%error condition (if (condition-p condition) nil args) fp)      (continue ()                :report (lambda (stream)                             (apply #'format stream cont-string args))                (setq *eval-queue* eval-queue)                nil))))(defun %error (condition args error-pointer)  (setq condition (condition-arg condition args 'simple-error))  ;(with-pstrs ((str (format nil "error: ~a" condition))) (#_DebugStr str))    (signal condition)  ;(with-pstrs ((str (format nil "error: ~a" condition))) (#_DebugStr str))  (application-error *application* condition error-pointer)  (application-error   *application*   (condition-arg "~s returned. It shouldn't.~%If it returns again, I'll throw to toplevel."                  '(application-error) 'simple-error)   error-pointer)  (toplevel))