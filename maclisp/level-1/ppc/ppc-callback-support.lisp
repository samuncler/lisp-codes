;;;-*- Mode: Lisp; Package: CCL -*-;;	Change History (most recent first):;;  1 11/16/95 bill New file;;  (do not edit before this line!!);;; ppc-callback-support.lisp;;;;;; Support for PPC callbacks;;; Modification History;;;;;; 03/10/97 bill  A version of the backward-compatible define-ppc-pascal-function;;;                that actually works.;;; 03/09/97 gb    define-ppc-pascal-function -> define-ppc-pascal-function-2, backward compat.;;; 02/23/97 bill  %pascal-functions% now passes the stack-ptr-fixnum to the;;;                lisp function. This prevents VSP use for lisp functions;;;                that have no args (cs-overflow-callback makes use of this fact).;;; -------------  4.0;;; 10/07/96 bill  #+ppc-target version of defpascal-callback-p;;;  9/06/96 slh   define-ppc-pascal-function: record 'defpascal (from AlanR);;; 07/31/96 bill  new upp-transition-vector function;;; -------------  MCL-PPC 3.9;;; 04/03/96 bill  %cons-pfe takes a new, without-interrupts arg.;;;                define-ppc-pascal-function takes a new, optional without-interrupts;;;                arg, which it puts into the generated pfe.;;;                %pascal-functions% is optimized (speed 3) (safety 0) so that;;;                it won't do event check on entry. It conditionally executes;;;                it's body without-interrupts according to the pfe.without-interrupts;;;                value.;;; 03/25/96 bill  define-ppc-pascal-function takes an optional doc-string arg;;; 02/22/96 bill *call-universal-proc-slep*, *call-universal-proc-address*;;; 01/23/96 bill  %fixnum-from-macptr (opposite of %setf-macptr-to-object).;;; 01/16/96 bill  define-ppc-pascal-function correctly initializes new entries in;;;                %pascal-functions to NIL. It also doesn't attempt to %svref;;;                entries that are not vectors.;;; 11/21/95 bill  New %get-object function. Add one instruction memory access time in %set-object.;;; 11/10/95 bill  New file;;;;;; Universal Procedure Pointer -> Transition Vector = (address, TOC, ...);;; The transition vector for our callbacks looks like:;;;;;; .SPcallback      ; Subprim that trampolines back to the Lisp;;; nil-ptr          ; pointer to the nil below;;; nil              ; for initializing nilreg;;; index            ; Index in %pascal-functions% of lisp code. Boxed.;;;;;; sp-callback uses the nil-ptr value it finds in the TOC register (nilreg);;; to load nilreg and get the %pascal-functions% index. Then it;;; funcalls #'%pascal-functions% with two args, the %pascal-functions% index;;; and a pointer to the stack frame containing the arguments (tagged as a fixnum).;;; %pascal-functions% puts the return value in param0.(eval-when (:compile-toplevel :execute);; Callback-Transition-Vector(defconstant $ctv.spcallback 0)(defconstant $ctv.toc 4)(defconstant $ctv.nil 8)(defconstant $ctv.index 12)(defconstant ctv.size 16)(unless (fboundp 'pfe.routine-descriptor)       ; defined in level-2.lisp; %Pascal-Functions% Entry(def-accessor-macros %svref  pfe.routine-descriptor  pfe.proc-info  pfe.lisp-function))  ; end unless)  ; end eval-when; Make sure we get the real #_NewRoutineDescriptor macro on the 68K#-ppc-target(eval-when (:compile-toplevel :execute)(deftrap "_NewRoutineDescriptor" ((theProc :pointer) (theProcInfo :signed-long) (theISA :signed-byte))   (:stack :pointer)   (:stack-trap #xAA59 :d0 0 theProc theProcInfo theISA))); This is referenced by the expansion of call-universal-proc(defparameter *call-universal-proc-slep* (get-slep "CallUniversalProc"))(defparameter *call-universal-proc-address*  (%resolve-slep-address *call-universal-proc-slep*))(defun cons-routine-descriptor (transition-vector proc-info &optional (isa #$kPowerPCISA))  (#_NewRoutineDescriptor transition-vector proc-info isa)); Return as a fixnum the address of the subprim at the given offset#+ppc-target(defppclapfunction %get-subprim ((subprim-offset arg_z))  (ref-global imm0 subprims-base)  (unbox-fixnum arg_z arg_z)  (add arg_z imm0 arg_z)  (blr));; Dummy, non-functioning, 68K version#-ppc-target(defun %get-subprim (subprim-offset)  (declare (ignore subprim-offset))  0)#+ppc-target(defppclapfunction %get-object ((macptr arg_y) (offset arg_z))  (twnei nargs (* 2 4))  (trap-unless-typecode= arg_y ppc::subtag-macptr)  (macptr-ptr imm0 arg_y)  (trap-unless-lisptag= arg_z ppc::tag-fixnum imm1)  (unbox-fixnum arg_z arg_z)  (lwzx arg_z arg_z imm0)  (blr));; It would be awfully nice if (setf (%get-long macptr offset);;                                   (ash (the fixnum value) ppc::fixnumshift));; would do this inline.#+ppc-target(defppclapfunction %set-object ((macptr arg_x) (offset arg_y) (value arg_z))  (twnei nargs (* 3 4))  (trap-unless-typecode= arg_x ppc::subtag-macptr)  (macptr-ptr imm0 arg_x)  (trap-unless-lisptag= arg_y ppc::tag-fixnum imm1)  (unbox-fixnum arg_y arg_y)  (stwx arg_z arg_y imm0)  (blr));; It would be nice if (%setf-macptr macptr (ash (the fixnum value) ppc::fixnumshift));; would do this inline.#+ppc-target(defppclapfunction %setf-macptr-to-object ((macptr arg_y) (object arg_z))  (twnei nargs (* 2 4))  (trap-unless-typecode= arg_y ppc::subtag-macptr)  (stw arg_z ppc::macptr.address arg_y)  (blr))(defppclapfunction %fixnum-from-macptr ((macptr arg_z))  (check-nargs 1)  (trap-unless-typecode= arg_z ppc::subtag-macptr)  (lwz imm0 ppc::macptr.address arg_z)  (trap-unless-lisptag= imm0 ppc::tag-fixnum imm1)  (mr arg_z imm0)  (blr));; Dummy, non-functioning, 68K versions#-ppc-target(defun %get-object (macptr offset)  (lap-inline ((require-type macptr 'macptr) (require-type offset 'fixnum))    (move.l arg_y atemp0)    (move.l (svref atemp0 macptr.ptr) atemp0)    (getint arg_z)    (move.l (atemp0 arg_z.l) acc)))#-ppc-target(defun %set-object (macptr offset value)  (setf (%get-long macptr offset) (%address-of value))  value)#-ppc-target(defun %setf-macptr-to-object (macptr object)  (lap-inline ((require-type macptr 'macptr) object)    (move.l arg_y atemp0)    (move.l arg_z (svref atemp0 macptr.ptr))))(defun %cons-pfe (routine-descriptor proc-info lisp-function sym without-interrupts)  (vector routine-descriptor proc-info lisp-function sym without-interrupts))(defun make-routine-descriptor (index proc-info &optional (isa #$kPowerPCISA))  (let ((ctv (#_NewPtr ctv.size)))      ; should allocate a bunch at a time    (%set-object ctv 0 (%get-subprim .spcallback))    (setf (%get-ptr ctv $ctv.toc) (%inc-ptr ctv $ctv.nil))    (%set-object ctv $ctv.nil nil)    (%set-object ctv $ctv.index index)    (cons-routine-descriptor ctv proc-info isa)))(defun ppc-pascal-function-template (args-fixnum)  (with-area-macptr (args-macptr args-fixnum)    (funcall 'foo args-macptr))); Backward-compatilbility so that pfsls compiled with the; old expansions of the DEFPASCAL macro will continue to work.(let ((foo-index (dotimes (i (uvsize #'ppc-pascal-function-template))                   (when (eq 'foo (uvref #'ppc-pascal-function-template i))                     (return i))))      (name-index (dotimes (i (uvsize #'ppc-pascal-function-template))                    (when (eq 'ppc-pascal-function-template (uvref #'ppc-pascal-function-template i))                      (return i)))))(defun define-ppc-pascal-function (lisp-function proc-info &optional                                                  doc-string (without-interrupts t))  (let ((f (copy-uvector #'ppc-pascal-function-template)))    (setf (uvref f name-index) (function-name lisp-function)          (uvref f foo-index) lisp-function)    (define-ppc-pascal-function-2 f proc-info doc-string without-interrupts))))  ; end of LET; (defpascal ...) on the PPC expands into a call to this function.(defun define-ppc-pascal-function-2 (lisp-function proc-info &optional doc-string (without-interrupts t)                                                   &aux name routine-descriptor)  (unless (functionp lisp-function)    (setq lisp-function (require-type lisp-function 'function)))  (unless (and (symbolp (setq name (function-name lisp-function)))               ;Might as well err out now before do any _Newptr's...               (not (constant-symbol-p name)))    (report-bad-arg name '(and symbol (not (satisfies constantp)))))  (let ((len (length %pascal-functions%)))    (declare (fixnum len))    (when (boundp name)      (let ((descriptor (symbol-value name)))        (dotimes (i len)          (let ((pfe (%svref %pascal-functions% i)))            (when (and (vectorp pfe)                       (eql descriptor (pfe.routine-descriptor pfe)))              (unless (eql proc-info (pfe.proc-info pfe))                (setf (pref (pref descriptor :RoutineDescriptor.routineRecords)                            :RoutineRecord.procInfo)                      proc-info                      (pfe.proc-info pfe) proc-info))              (setf (pfe.without-interrupts pfe) without-interrupts)              (setf (pfe.lisp-function pfe) lisp-function)              (setq routine-descriptor descriptor))))))    (unless routine-descriptor      (let ((index (dotimes (i (length %pascal-functions%)                               (let* ((new-len (+ len 5))                                      (new-pf (make-array (the fixnum new-len))))                                 (declare (fixnum new-len))                                 (dotimes (i len)                                   (setf (%svref new-pf i) (%svref %pascal-functions% i)))                                 (do ((i len (1+ i)))                                     ((>= i new-len))                                   (declare (fixnum i))                                   (setf (%svref new-pf i) nil))                                 (setq %pascal-functions% new-pf)                                 len))                     (unless (%svref %pascal-functions% i)                       (return i)))))        (setq routine-descriptor (make-routine-descriptor index proc-info))        (setf (%svref %pascal-functions% index)              (%cons-pfe routine-descriptor proc-info lisp-function name without-interrupts)))))  ;(%proclaim-special name)          ; already done by defpascal expansion  (set name routine-descriptor)  (record-source-file name 'defpascal)  (when (and doc-string *save-doc-strings*)    (set-documentation name 'variable doc-string))  (when *fasload-print* (format t "~&~S~%" name))  name)#+ppc-target(defun defpascal-callback-p (macptr)  (let ((v %pascal-functions%))    (dotimes (i (length v))      (let ((pfe (%svref v i)))        (when (and (vectorp pfe)                   (eql macptr (pfe.routine-descriptor pfe)))          (return pfe))))))(defun upp-transition-vector (upp)  (with-macptrs ((routine-record (pref upp :RoutineDescriptor.RoutineRecords)))    (pref routine-record :RoutineRecord.procDescriptor))); This is called by .SPcallback#+ppc-target(defun %pascal-functions% (index args-ptr-fixnum)  (declare (optimize (speed 3) (safety 0)))  (let* ((pfe (svref %pascal-functions% index))         (without-interrupts (pfe.without-interrupts pfe))         (lisp-function (pfe.lisp-function pfe)))    (if without-interrupts      (without-interrupts (funcall lisp-function args-ptr-fixnum))      (funcall lisp-function args-ptr-fixnum)))); moved to "lib;dumplisp" as restore-pascal-functions#+ignore#+ppc-target(def-ccl-pointers ppc-pascal-functions ()  (setq *call-universal-proc-address*        (%resolve-slep-address *call-universal-proc-slep*))  (dotimes (i (length %pascal-functions%))    (let ((pfe (%svref %pascal-functions% i)))      (when (vectorp pfe)        (let ((routine-descriptor (make-routine-descriptor i (pfe.proc-info pfe)))              (name (pfe.sym pfe)))          (setf (pfe.routine-descriptor pfe) routine-descriptor)          (when name            (set name routine-descriptor)))))))