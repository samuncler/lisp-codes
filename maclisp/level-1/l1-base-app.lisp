;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  5 10/3/96  slh  declare ftype keep-trying;;  (do not edit before this line!!); l1-base-app.lisp; Copyright 1995 Digitool, Inc. The 'tool rules!; (compile-file "ccl:level-1;l1-base-app.lisp" :output-file "ccl:l1-fasls;l1-base-app.fasl"); Modification History;; 06/12/97 slh   app-loader-toplevel: (load-patches) -> (load-patch-fir-fasls); 04/17/97 slh   changes for MCL 3.2:;                 appgen-misc.lisp at compile-time only (too early for defstruct);  7/31/96 slh   appgen-defs now checked in; 06/26/96 gb    #+have-secret-files;  5/03/96 slh   updated from 3.0, PPC; application-do-save: use app-info-init-file;  2/26/96 slh   app-require-modules: allow pathnames;  7/13/95 slh   application-do-save method;  7/07/95 slh   remove base-application class (leave app-laoder-class);                error handler just uses :dialog mode; updated print/open methods;                app-loader-toplevel: bind *loading-file-source-file*;  6/29/95 slh   reverse app-info-sizes for save-application; call load-patches;  6/28/95 slh   ignore null menubar; move menubar methods to app-misc.lisp;  6/27/95 slh   reorder app-loader-toplevel for menubar stuff; add menubar methods;  6/20/95 slh   changes for AppGen application;  4/26/95 slh   more save-application params;  4/07/95 slh   folded *app-keys* into *app-modules*;  4/05/95 slh   added backtrace to *base-app-modules*;  4/04/95 slh   added app-loader-class(in-package :ccl)(eval-when (:execute :compile-toplevel)  (require "APPGEN-DEFS")  (require "APPGEN-MISC" "ccl:lib;appgen-misc.lisp"))(defvar *application-info* nil)(defun base-app-nono (fn &optional msg &rest args)  (message-dialog (if msg                    (format nil "Illegal function ~A called in base application. ~?"                            fn msg args)                    (format nil "Illegal function ~A called in base application." fn))                  :ok-text "Toplevel")  (toplevel))(defun app-loader-toplevel ()  (setq *features* (delete :gen-appgen *features*))  (pushnew :mcl-appgen *features*)  (unless (or *application-info*              (load *appgen-fasl-path* :if-does-not-exist nil))    (message-dialog (format nil "The file \"~A\" was not found; see the Redistribution Kit documentation for instructions on how to build it."                            *appgen-fasl-path*)                    :ok-text "Exit"                    :title "MCL AppGen Error"                    :size #@(380 100))    (quit))  (unless *application-info*    (error "The application-info structure was not supplied by AppGen.fasl or another file."))  (unless (application-info-p *application-info*)    (error "~S is not an application-info structure." *application-info*))  (let* ((app-info *application-info*)         (app-name (app-info-name app-info))         (*loading-file-source-file* (app-info-name app-info)))    (setq *app-modules*        (app-info-optional-modules app-info)          *module-search-path* (app-info-search-path      app-info))        (flet ((app-require-modules (modules)             (let ((*package* *ccl-package*))               (dolist (module modules)                 (cond ((or (null module) (keywordp module)))                       ((or (stringp module)         ; custom module path                            (pathnamep module))                        (load module))                       (t (require module)))))))      (declare (dynamic-extent #'app-require-modules))      (let ((*load-verbose*     nil)            (*warn-if-redefine* nil)            (*warn-if-redefine-kernel* nil))        (app-require-modules *app-modules*)        (load-patch-fir-fasls)        (app-require-modules (app-info-custom-modules app-info))))    (let* ((class-name  (app-info-class-name   app-info))           (application (make-instance class-name))           (menubar     (application-menubar application)))      ; Now that all modules are loaded, can set *application*.      ; Also set error handler mode for application-error method.      (setq *app-error-handler-mode* (app-info-error-mode app-info))      ; Only set menubar if non-null      (when menubar        (set-menubar menubar))            ; see l1-initmenus.lisp      (let ((first-menu (car (menubar))))        (when (typep first-menu 'apple-menu)          (let ((first-item (car (menu-items first-menu))))            (when first-item              (set-menu-item-title first-item                                   (%str-cat "About " app-name "É"))))))      (lds-key :unbind-macros               (let ((unintern (memq :unintern-macros *app-modules*)))                 (do-all-symbols (sym)                   (when (macro-function sym)                     (fmakunbound sym)                     (when unintern                       (unintern sym (symbol-package sym)))))))      (lds-key :unbind-constants               (let ((unintern (memq :unintern-constants *app-modules*)))                 (do-all-symbols (sym)                   (when (constant-symbol-p sym)                     (makunbound sym)                     (when (and unintern                                (not (fboundp sym)))                       (unintern sym (symbol-package sym)))))))            #+no      (lds-key :clear-vars               (setq *arglist-on-space*   nil      ; won't load help map                     *record-source-file* nil      ; l1-utils.lisp sets t                     %source-files% (make-hash-table :size 0)                     *ccl-system*         nil                     ))      (setq *application* application)      (application-do-save application app-info))))(defun load-patch-fir-fasls ()  (dolist (file (directory (merge-pathnames (%str-cat ":"                                                      patch-directory-prefix                                                       (lisp-implementation-version-less-patch)                                                      ":")                                            #.(make-pathname :name :wild                                                             :defaults *.fasl-pathname*))))    (let ((*load-verbose* t)          (*record-source-file* nil)          (*warn-if-redefine* nil)           (*warn-if-redefine-kernel* nil))      (load file))))(defmethod application-do-save ((app application) app-info)  (let ((creator (app-info-file-creator app-info)))    (save-application (app-info-pathname app-info)                      :application-class (find-class (app-info-class-name app-info))                      :error-handler (app-info-error-mode app-info)                      :toplevel-function (let ((function (app-info-toplevel app-info)))                                           (if (neq function 'toplevel-function)                                             function))       ; see do-save-application                      :init-file (app-info-init-file app-info)                      :size (reverse (app-info-sizes app-info))                      :resources (get-app-resources (app-info-resource-file app-info)                                                    creator)                      :clear-clos-caches t                      :excise-compiler t                      :creator creator                      ))); Redefined from l1-readloop.lisp(defmethod application-name ((app application))  (app-info-name *application-info*)); *application* gets this while loading the application, before; the custom modules are loaded. May want to add 'cold load'; methods, maybe just leave the base class methods...(defclass app-loader-class (application)   ())(defmethod application-error ((a app-loader-class) condition error-pointer)  (declare (ignore error-pointer)           (ftype (function (&rest t) t) keep-trying))  (keep-trying condition t)  (quit))(defun break (&optional string &rest args)  (declare (ignore string args))  (base-app-nono 'break))(defun cbreak-loop (msg cont-string condition error-pointer)  (declare (ignore msg cont-string condition error-pointer))  (base-app-nono 'cbreak-loop))(defun warn (format-string &rest args)  (let ((c (require-type (condition-arg format-string args 'simple-warning) 'warning)))    (restart-case (signal c)      (muffle-warning () :report "Skip the warning" (return-from warn nil))))); Should MCL-AppGen print doc(defmethod print-application-document ((a app-loader-class)                                       path &optional startup)  (declare (ignore path startup))  (error "~A cannot be used to print files." *app-name*))(defmethod open-application-document ((a app-loader-class)                                      path &optional startup)  ;(declare (ignore startup))  (let ((type (mac-file-type path)))    (case type      (:text (error "~A cannot be used to edit files." *app-name*))      (#-ppc-target :fasl #+ppc-target :pfsl       (error "~S recognized! startup = ~S" path startup))      (t nil))));; Functions to redefine from l1-streams.lisp:(defmethod stream-current-listener ((stream t))  nil)(defmethod stream-current-listener ((stream front-listener-terminal-io))  (or *top-listener*      (call-next-method)))(defmethod stream-tyi ((stream terminal-io-rubout-handler))  (base-app-nono '(stream-tyi terminal-io-rubout-handler)))(defmethod stream-tyo :before ((stream pop-up-terminal-io) char)  (declare (ignore char))  (base-app-nono '(stream-tyo pop-up-terminal-io)))(defmethod stream-write-string :before ((stream pop-up-terminal-io) string start end)  (declare (ignore string start end))  (base-app-nono '(stream-write-string pop-up-terminal-io))); End of l1-base-app.lisp