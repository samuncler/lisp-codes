;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  6 10/5/97  akh  see below;;  5 8/25/97  akh  optimizations for long menus;;  4 7/4/97   akh  see below;;  3 6/2/97   akh  see below;;  7 9/4/96   akh  conditionalize use of hash table for 3.1 vs 4.0;;  5 5/20/96  akh  remove some goofy underlining;;  2 11/9/95  akh  attach-menu - assure that menus intended to be disabled are in fact disabled;;  7 3/2/95   akh  changed menu-update to enable if any items enabled????;;  6 2/9/95   akh  install-menu-item sets style also;;  5 2/7/95   akh  probably no change;;  4 1/30/95  akh  dont remember;;  (do not edit before this line!!);; L1-menus.lisp - Object oriented menu stuff; Copyright 1986-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc.;; Modification History;; 07/28/97 akh   set-menu-item-check-mark - do nothing if same cause menu-item-number is slow for lots of items; 04/17/97 bill  fix-menu-color-bug does something only if *fix-menu-color-bug* is true.;                The default is NIL.;                This speeds up set-menubar.; 04/15/97 bill  (method menu-install (menu)) calls initialize-menubar-color; -------------  4.1b2; 06/03/96 bill  (method menu-update :around (t)) prevents reentry for a single menu.;                This stops Edit menu problems from repeating.; -------------  MCL-PPC 3.9; 03/26/96  gb  lowmem accessors.; 11/29/95 bill  New trap names to avoid emulator.;  4/20/95 slh   update-menus-for-modal folded into update-menus; menu-update different; 01/30/95 alice add-menu-items checks if installed-p - from patch;12/26/94 alice make fix-menu-color-bug and set-menubar work when building from scratch; update-menus-for-modal was brain dead tho it happened to work in the usual case; menu-enable/disable and set-menu-title pass the menu to draw-menubar-if; draw-menubar-if takes optional menu arg - draws only when in menubar (pop-up-menus dont have owners either);10/12/93 alice menu-item-action ((item windows-menu-menu-item)) - control brings class front wards;------------;;start of added text;06/29/94 bill  set-menubar works around a system 7.1.1 bug in menu colors.;-------------- 3.0d13;05/04/93 alice 'character -> 'base-character, make-menu-item second arg is optional;05/04/93 bill  *menu-id-object-table* replaces *menu-id-object-alist*;               Faster algorithm for allocate-menu-id;04/30/93 bill  in window-menu-item methods: front-window -> get-window-event-handler;               bootstrapping version on get-window-event-handler;-------------- 2.1d4;02/03/93 alice instance-initialize for menu is primary instead of :after so item-list is set ; 		before view-default-size is called by the after method on simple-view  (pop-ups care);12/10/92 bill menu-item-icon-num slot for menu-item's.;              initarg is :icon-num, read by menu-item-icon-num, set by set-menu-item-icon-num;              Thanx to Steve Mitchell for the initial version of the icon code.;07/30/92 alice change update-menu-items so menu state is truly fn of state of items;------------ 2.0;10/30/91 bill remove "-iv" on the end of slot names;10/16/91 bill  Selecting a hierarchical menu instead of one of its items;               no longer causes an error.;10/15/91 bill  menu-items no longer conses if it doesn't need to.;09/25/91 alice more menu-update fiddling;---------- 2.0b3;09/05/91 alice another menu-update tweak;09/04/91 alice menu-update and menu-item-update tweaks;08/27/91 alice menu-update - enable item then call menu-item-update;08/23/91 alice menu-update - let updater decide;08/24/91 gb   use new trap syntax.;07/11/91 bill leading "-" in menu-item title becomes n-dash so the damn;              ROM won't interpret it as a seperator line.;08/12/91 alice menu-disable - (when enabled ...), menu-enable too - looks better, goes faster;08/12/91 alice dim-if-undefined look at handler if any;06/10/91 bill install-menu-item no longer causes all menu-items below a;              menu-item with a title of "" to display as "xxx".;06/07/91 bill help-spec for menu-elements.;------------- 2.0b2;01/28/91 bill add set-menu-item-action-function;01/18/91 bill set-menu-item-update-function no longer a :writer (wrong arg order);01/04/91 bill instance-initialize for menu-item take menu-item-title as well;              as menu-title.;12/11/90 bill (setf menu-item-update-function) -> set-menu-item-update-function;10/03/90 bill %class-cpl -> %inited-class-cpl;08/27/90 bill install-menu-item: wrong sense on test of (slot-value item 'checkedp);07/23/90 bill proper return value for set-menu-item-check-mark;07/05/90 bill menu-item-update-function & menu-update-function;06/18/90 bill call window-ensure-on-screen if windows-menu-menu-item is;              selected with the shift key down.;05/30/90 gb   Use print-unreadable-object.;05/04/90 bill _DelMCEntries only if *color-available*;03/26/90 bill Use "_InsMenuItem instead of _AppendMenu so that adds to the;              apple-menu will work.  No longer need add-menu-items specialization;              for apple-menu.;03/20/90 bill initialize-instance => instance-initialize.;03/17/90 bill add readers to menu-element and menu-item classes.;03/13/90 bill menu-owner => menu-item-owner;02/27/90 bill Add menu-owner method.;12/27/89 gz apple-menu-class -> apple-menu.  Remove obsolete #-bccl conditionals.;12/15/89 bill set-command-key: fix error on setting to NIL.;10/11/89 as MENU-ITEMS defaults class to MENU-ELEMENT;10/03/89 gz with-menu-detached returns;09/27/89 gb simple-string -> ensure-simple-string.;09/16/89 bill Removed the last vestiges of object-lisp windows.; 9/31/89 bill menu-item-action & dim-if-undefined: make work for CLOS windows.; 8/25/89 bill dim-if-undefined: Alwas dim unless the window is an object.;              This needs to be modified to work with CLOS windows.; 7/28/89   gz Use :default-initargs for apple-menu-class.; 7/20/89   gz closified.; 18-mar-89 as from 1.3: uninstalled menus are gc-able;                        flushed dispose-menu, menus;                        color support; 3/17/89  gz CLOS window-select syntax.; 2-mar-89 as removed window-selection-menu-item;             added windows-menu-menu-item; 11/19/88 gb dispatch on functionp or symbolp.; 10/27/88 gb char-int -> %char-code.; 9/19/88 as  (unless *menubar-frozen* (_drawmenubar)) -->> (draw-menubar-if); 8/21/88 gz  declarations; 8/6/88  gb  make (menu-install *apple-menu-class*) check macptrp-ness.;             stack-cons.; 6/28/88 jaj re-init menup to nil in add-menu-items; 6/6/88  jaj added *window-selection-menu-item* fns; 5/19/88 as  brought over from Beany; 4/21/88 jaj more changes for apple menu (cannot be deinstalled except;             by system code), double install is okay.; 4/20/88 jaj set-menubar doesn't remove apple-menu (for multifinder);             added menu-deinstall for apple-menu; 4/10/88 jaj did solo defobfuns; 4/6/88  as  added definitions for *apple-menu-class*;             heirarchical menus dump properly; 3/31/88 as  moved with-menu-detached to l1-macros;             removed add-item, remove-item; 3/30/88 as  replaced call to with-menubar-frozen with let;             changed with-detached-menu to not use detach-menu;             punted detach-menu, domenu; 3/30/88 gz  New macptr scheme. Flushed pre-1.0 edit history.; 3/2/88  gz  Eliminate compiler warnings(defvar %menubar ())(defclass menu-element (instance-initialize-mixin)  ((owner :initform nil :reader menu-item-owner :reader menu-owner)   (title :initform "" :reader menu-item-title :reader menu-title)   (enabledp :initarg :enabledp :initform t :reader menu-item-enabled-p :reader menu-enabled-p)   (style :initform nil :reader menu-item-style :reader menu-style)   (color-list :initform nil)                         ; part-color-list will read this   (update-function :initform nil :initarg :update-function                    :accessor menu-update-function                     :accessor menu-item-update-function)   (help-spec :initarg :help-spec :initform nil :accessor help-spec)))(defmethod set-menu-item-update-function ((e menu-element) value)  (setf (menu-item-update-function e) value))(defclass menu-item (menu-element)      ; really "simple-menu-element"  ((checkedp)   (command-key)   (menu-item-action :accessor menu-item-action-function)   (menu-item-icon-num :reader menu-item-icon-num                       :writer (setf menu-item-icon-num-slot)                       :initform nil                       :initarg :icon-num)))#|(defclass better-menu-item (menu-item)())(defmethod menu-item-action ((menu-item better-menu-item))  (let ((action (slot-value menu-item 'menu-item-action)))    (when action (funcall action menu-item))))|#(defmethod set-menu-item-action-function ((menu-item menu-item) value)  (setf (menu-item-action-function menu-item) value));menu-handle and menu-id are nil if not installed(defclass menu (menu-element)  ((item-list :initform nil)   (menu-id :initform nil :reader menu-id)   (menu-handle :initform nil :reader menu-handle)   ))(defmethod print-object ((thing menu-element) stream)  (print-unreadable-object (thing stream)    (format stream "~S ~S"            (class-name (class-of thing))            (slot-value thing 'title))))(defmacro with-menu-detached (menu &rest body)  (let* ((rest-mbar (gensym)) (item (gensym)))    `(let ((,rest-mbar (reverse (memq ,menu %menubar)))           (*menubar-frozen* t))       (dolist (,item ,rest-mbar) (menu-deinstall ,item))       ,@body       (dolist (,item (nreverse ,rest-mbar)) (menu-install ,item)))))#-ppc-clos ; we mean cclx or something(progn(defvar *menu-id-object-table* nil)(defun allocate-menu-id (object)  (without-interrupts   (let ((start-id (+ 2 (length *menu-id-object-table*))))     (flet ((search (start end)              (do ((id start (1+ id)))                  ((>= id end) nil)                (unless (menu-object id)                  (return id)))))       ; There is evidence that ids >= 256 don't work correctly,       ; so attempt to allocate one less than that.       ; Start at start-id so we likely succeed sooner.       (let ((id (or (search start-id 256)                     (search 2 start-id)                     (search (max 256 start-id) 32767)                     (error "Can't allocate menu id"))))         (push (cons id object) *menu-id-object-table*)         id)))))(defun deallocate-menu-id (id)  (without-interrupts   (setq *menu-id-object-table* (remove-from-alist id *menu-id-object-table*))   nil))(defun menu-object (menuID)  "Given a menu id returns the associated menu object"  (%cdr (assq menuid *menu-id-object-table*)))(queue-fixup(defun allocate-menu-id (object)  (without-interrupts   (let ((start-id (+ 2 (hash-table-count *menu-id-object-table*))))     (flet ((search (start end)              (do ((id start (1+ id)))                  ((>= id end) nil)                (unless (menu-object id)                  (return id)))))       ; There is evidence that ids >= 256 don't work correctly,       ; so attempt to allocate one less than that.       ; Start at start-id so we likely succeed sooner.       (let ((id (or (search start-id 256)                     (search 2 start-id)                     (search (max 256 start-id) 32767)                     (error "Can't allocate menu id"))))         (setf (gethash id *menu-id-object-table*) object)         id)))))(defun deallocate-menu-id (id)  (without-interrupts   (remhash id *menu-id-object-table*)   nil))(defun menu-object (id)  (gethash id *menu-id-object-table*))(setq *menu-id-object-table*      (alist-hash-table *menu-id-object-table* :size 0)))  ; end of queue-fixup)#+ppc-clos(progn(defvar *menu-id-object-table* (make-hash-table :size 0))(defun allocate-menu-id (object)  (without-interrupts   (let ((start-id (+ 2 (hash-table-count *menu-id-object-table*))))     (flet ((search (start end)              (do ((id start (1+ id)))                  ((>= id end) nil)                (unless (menu-object id)                  (return id)))))       ; There is evidence that ids >= 256 don't work correctly,       ; so attempt to allocate one less than that.       ; Start at start-id so we likely succeed sooner.       (let ((id (or (search start-id 256)                     (search 2 start-id)                     (search (max 256 start-id) 32767)                     (error "Can't allocate menu id"))))         (setf (gethash id *menu-id-object-table*) object)         id)))))(defun deallocate-menu-id (id)  (without-interrupts   (remhash id *menu-id-object-table*)   nil))(defun menu-object (id)  (gethash id *menu-id-object-table*)))(defmethod init-menu-id ((menu menu))  (unless (slot-value menu 'menu-id)    (setf (slot-value menu 'menu-id)          (allocate-menu-id menu))))(defun menubar () (copy-list %menubar))(defun draw-menubar-if (&optional menu)  (unless (or *menubar-frozen*              (and menu (not (memq menu %menubar))))    (#_DrawMenuBar)))(defun set-menubar (menu-list)  (let ((*menubar-frozen* t))    (dolist (menu %menubar)      ; menu-deinstall of apple-menu is a nop      (if (neq menu *apple-menu*) (menu-deinstall menu)))    (when (boundp '*menubar*)(fix-menu-color-bug *menubar*))  ; UH what is *menubar* this week??    (dolist (menu menu-list)      (menu-install menu)      (fix-menu-color-bug menu)      ))  (draw-menubar-if)  menu-list)(defvar *fix-menu-color-bug* nil); work around a system 7.1.1 menu color bug(defun fix-menu-color-bug (menu-or-menubar)  (when (and *fix-menu-color-bug*             (fboundp 'part-color)             (method-exists-p (fboundp 'part-color) menu-or-menubar)) ; dont die when called from l1-initmenus.    (let ((color (or (part-color menu-or-menubar :default-item-title))))      (if color        (progn          (set-part-color menu-or-menubar :default-item-title nil)          (set-part-color menu-or-menubar :default-item-title color))        (progn          (set-part-color menu-or-menubar :default-item-title *black-color*)          (set-part-color menu-or-menubar :default-item-title nil))))))(defun find-menu (name)  (setq name (ensure-simple-string name))  (dolist (menu %menubar)    (if (string-equal name (slot-value menu 'title)) (return menu))));;Menu Object Primitives;These get replaced later.(defmethod set-part-color-loop (part colors) (declare (ignore part colors)))(when (not (fboundp 'typep))  (defun typep (object type)    (memq (find-class type nil)          (%inited-class-cpl (class-of object)))))(defmethod instance-initialize  ((menu menu) &key                                 menu-title                                 view-font                                 menu-item-title                                 (menu-items ())                                 menu-colors)    (setf (slot-value menu 'title)        (ensure-simple-string (or menu-title menu-item-title "Untitled")))  (setf (slot-value menu 'color-list) menu-colors)  (when view-font (set-initial-view-font menu view-font))  (when menu-items (apply #'add-menu-items menu menu-items))  (call-next-method)  ;; << make mark tapia happy - mixing menu and window??  )(defmethod add-menu-items ((menu menu) &rest args &aux item mh)  (declare (dynamic-extent args))  (do* ((number (%i+ 1 (list-length (slot-value menu 'item-list))) (%i+ number 1)))       ((null args) nil)    (setq item (require-type (pop args) 'menu-element))    (when (typep item 'menu)      (when (slot-value item 'menu-handle)        (error "Menu ~s is already installed" item)))    (setf (slot-value menu 'item-list)          (nconc (slot-value menu 'item-list) (list item)))    (setf (slot-value item 'owner) menu)    (when (string= (slot-value item 'title) "-")      (setf (slot-value item 'enabledp) nil))    (when (setq mh (menu-handle menu))      (when (typep item 'menu)        (when (menu-installed-p menu)          (menu-install item)))      (install-menu-item mh item number))        (set-part-color-loop item (slot-value item 'color-list))))(defmethod remove-menu-items ((menu menu) &rest args &aux item-num)  (declare (dynamic-extent args))  (without-interrupts   (dolist (item args)     (when (memq item (slot-value menu 'item-list))       (setq item-num (menu-item-number item))       (when (slot-value menu 'menu-id)         (when *color-available*           (#_DeleteMCEntries  (slot-value menu 'menu-id) item-num))         (#_DeleteMenuItem (slot-value menu 'menu-handle) item-num))       (setf (slot-value item 'owner) nil)       (when (typep item 'menu)         (let ((*menubar-frozen* t))           (menu-deinstall item)))       (setf (slot-value menu 'item-list)             (nremove item (slot-value menu 'item-list)))))   (dolist (item (slot-value menu 'item-list))     (update-color-defaults item))))(defun make-menu-item (title &optional action &rest stuff)  (declare (dynamic-extent stuff))  (apply #'make-instance 'menu-item :menu-item-title title :menu-item-action action stuff))(defun add-new-item (menu title &optional action &rest rest &key                          (class 'menu-item) &allow-other-keys)  (declare (dynamic-extent rest))  (remf rest :class)  (let ((item (apply #'make-instance                     class                     :menu-item-title title                     :menu-item-action action                     rest)))    (add-menu-items menu item)    item))(defmethod menu-items ((menu menu) &optional (menu-item-class 'menu-element)                       &aux ret)  (let ((items (slot-value menu 'item-list)))    (if (neq menu-item-class 'menu-element)      (dolist (item items (nreverse ret))        (when (typep item menu-item-class) (push item ret)))      items)))(defmethod find-menu-item ((menu menu) title)  "Returns menu item with given title or nil if none."  (dolist (item (slot-value menu 'item-list))    (when (string-equal title (menu-item-title item))      (return item))))(defmethod menu-title ((menu menu)) (slot-value menu 'title))(defmethod set-menu-title ((menu menu) new-title)  (if (slot-value menu 'owner)    (set-menu-item-title menu new-title)    (progn      (with-menu-detached menu        (setf (slot-value menu 'title) new-title))      (draw-menubar-if menu)))  (slot-value menu 'title)); Bootstrapping(unless (fboundp 'initialize-menubar-color)  (%fhave 'initialize-menubar-color          #'(lambda ())))(defmethod menu-install ((menu menu) &aux (n 0))  (unless (slot-value menu 'menu-handle)    (init-menu-id menu)    (if (slot-value menu 'owner)      (progn        (with-pstrs ((tp (slot-value menu 'title)))          (#_InsertMenu            (setf (slot-value menu 'menu-handle)                 (#_NewMenu (slot-value menu 'menu-id) tp))           -1))        (dolist (subitem (slot-value menu 'item-list))          (setq n (%i+ n 1))          (when (typep subitem 'menu)            (menu-install subitem))          (install-menu-item (slot-value menu 'menu-handle) subitem n))        (initialize-menubar-color)        (set-part-color-loop menu (slot-value menu 'color-list)))      (progn        (setf (slot-value menu 'menu-handle) (%null-ptr))        (attach-menu menu)        (dolist (item (slot-value menu 'item-list))          (when (typep item 'menu) (menu-install item)))        (setq %menubar (nconc %menubar (list menu)))        (initialize-menubar-color)        (set-part-color-loop menu (slot-value menu 'color-list))        (draw-menubar-if))))  t); << another patch(defun attach-menu (menu &aux (n 0) mh) ;No DrawMenuBar  (with-pstrs ((tp (slot-value menu 'title)))    (when (%izerop (%get-byte tp)) (%put-word tp #x0120))    (setq mh (%setf-macptr (slot-value menu 'menu-handle)                           (#_NewMenu  (slot-value menu 'menu-id) tp))))  (dolist (item (slot-value menu 'item-list))    (setq n (%i+ n 1))    (install-menu-item mh item n))  (#_InsertMenu mh 0)  (when (not (menu-enabled-p menu))    (setf (slot-value menu 'enabledp) t) ; lie to assure it gets disabled << put back    (menu-disable menu)))(defun install-menu-item (mh item n)  (with-pstrs ((tp (or (slot-value item 'title) ""))               (xp "xxx"));    (#_appendMenu mh  xp)    (#_InsertMenuItem mh xp (%i- n 1))    (if (%izerop (%get-byte tp))      (%put-word tp #x0120)      (if (and (not (eql 1 (%get-byte tp)))               (eq (char-code #\-) (%get-byte tp 1)))        (%put-byte tp (char-code #\Ð) 1)))    (#_SetMenuItemText mh n tp))  ;Looks like a job for a generic function...  (cond ((typep item 'menu)         (init-menu-id item)         (#_SetItemCmd mh n #\escape)         (#_SetItemMark mh n (%code-char (slot-value item 'menu-id))))        ((typep item 'menu-item)         (if (slot-value item 'command-key)           (set-command-key item (slot-value item 'command-key)))         (if (slot-value item 'checkedp)           (set-menu-item-check-mark item (slot-value item 'checkedp)))         (let ((style (menu-item-style item)))           (when (not (or (null style)(eq style :plain)))             (set-menu-item-style item style)))         (let ((icon-num (menu-item-icon-num item)))           (when (and icon-num (not (eql 0 icon-num)))             (set-menu-item-icon-num item icon-num)))))  (unless (menu-item-enabled-p item)    (menu-item-disable item)))(defmethod menu-deinstall ((menu menu) &aux mh md)  (dolist (item (slot-value menu 'item-list))    (when (typep item 'menu)      (menu-deinstall item)))  (when (setq md (slot-value menu 'menu-id))    (deallocate-menu-id md)    (setf (slot-value menu 'menu-id) nil))  (when (setq mh (slot-value menu 'menu-handle))    (#_DeleteMenu md)    (#_DisposeMenu mh)    (setf (slot-value menu 'menu-handle) nil)    (setq %menubar (nremove menu %menubar))    (draw-menubar-if))  nil)(defmethod menu-installed-p ((menu menu))  (if (slot-value menu 'menu-handle) t))(defmethod menu-enable ((menu menu) &aux mh (owner (slot-value menu 'owner)))  (when (not (menu-enabled-p menu))    (setf (slot-value menu 'enabledp) t)    (if owner      (when (setq mh (slot-value owner 'menu-handle))        (let ((num (menu-item-number menu)))          (#_EnableItem mh num)))      (when (setq mh (slot-value menu 'menu-handle))        (#_EnableItem mh 0)        (draw-menubar-if menu)))))(defmethod menu-disable ((menu menu) &aux mh (owner (slot-value menu 'owner)))  (when (menu-enabled-p menu)    (setf (slot-value menu 'enabledp) nil)    (if owner      (when (setq mh (slot-value owner 'menu-handle))        (let ((num (menu-item-number menu)))          (#_DisableItem mh num)))      (when (setq mh (slot-value menu 'menu-handle))        (#_DisableItem mh 0)        (draw-menubar-if menu))))); >> patch(defmethod menu-update ((menu menu))  (let ((updater (menu-update-function menu)))    (if updater       (funcall updater menu)      (update-menu-items menu))))(defvar *updating-menus* nil)(defmethod menu-update :around (menu)  (unless (memq menu *updating-menus*)    (let ((*updating-menus* (cons menu *updating-menus*)))      (declare (dynamic-extent *updating-menus*))      (call-next-method))))#|; b2 version(defmethod menu-update ((menu menu))  (let ((updater (menu-update-function menu)))    (when updater (funcall updater menu)))  (dolist (item (slot-value menu 'item-list))    (menu-item-update item))); b3 kill it(defmethod menu-update ((menu menu))  (let ((updater (menu-update-function menu)))    (cond (updater (funcall updater menu))          (*modal-dialog-on-top* (menu-disable menu))          (t  (menu-enable menu)))    (when (not updater)      (update-menu-items menu)))); nother possibility(defmethod menu-update ((menu menu))  (let ((updater (menu-update-function menu)))    (if updater       (funcall updater menu)      (dolist (item (slot-value menu 'item-list))        (menu-item-update item)))))(defun update-menu-items (menu)  (let ((enb (menu-enabled-p menu))        on)    (dolist (item (slot-value menu 'item-list))      (if enb        (progn           ;(menu-item-enable item) ; ??          (menu-item-update item)          (when (menu-item-enabled-p item)(setq on t)))        (menu-item-disable item)))    (when (and enb (not on))(menu-disable menu))))|#; I like this better - edit menu is the only caller; leave alone if no menu items(defun update-menu-items (menu)  (let (;(enb (menu-enabled-p menu))        on)    (let ((items (slot-value menu 'item-list)))      (when items        (dolist (item (slot-value menu 'item-list))          (menu-item-update item)          (when (menu-item-enabled-p item)(setq on t)))        (if (not on)          (menu-disable menu)          (menu-enable menu))))))#| folded into update-menus now; >> patch - merge with update-menus?(defun update-menus-for-modal (&optional what state                                          &aux mob offset changed oldstate)  (let ((*menubar-frozen* t))    (with-macptrs ((mh (#_LMGetMenuList)))      (setq offset (%hget-word mh))      (while (%i> offset 0)        (when (setq mob (menu-object (%hget-word (%hget-ptr mh offset))))          (let ((before (menu-enabled-p mob)))            (when (eq what :disable) (push before oldstate))                        (menu-update-for-modal mob (if state                                         (if (car state) :enable :disable)                                         what))            (when (neq before (menu-enabled-p mob))(setq changed t)))          (setq state (cdr state)))        (setq offset (%i- offset 6)))))  (when changed (draw-menubar-if))  (if oldstate (nreverse oldstate)))|#; >>Patch(defmethod menu-update-for-modal ((menu menu) &optional what)  (let ((updater (menu-update-function menu)))    (cond (updater (funcall updater menu))          (t (case what               (:disable (menu-disable menu))               (:enable (menu-enable menu)))))))    (defmethod menu-select ((menu menu) num)  ;Use ELT because errs out if list too short...  (menu-item-action (elt (slot-value menu 'item-list) (%i- num 1))));;;Menu-item objects(defmethod instance-initialize :after ((menu-item menu-item)                                       &key menu-item-colors                                       owner                                       (menu-item-title "Untitled")                                       disabled                                       command-key                                       menu-item-checked                                       style                                       menu-item-action)  (setf (slot-value menu-item 'color-list) menu-item-colors)  (setf (slot-value menu-item 'owner) (when owner (require-type owner 'menu)))  (setf (slot-value menu-item 'title) (ensure-simple-string menu-item-title))  (setf (slot-value menu-item 'enabledp) (not disabled))  (setf (slot-value menu-item 'command-key)        (when command-key (require-type command-key 'base-character)))  (setf (slot-value menu-item 'checkedp) menu-item-checked)  (setf (slot-value menu-item 'style) style)  (setf (slot-value menu-item 'menu-item-action)        (require-type menu-item-action '(or function symbol))))(defmethod menu-install ((item menu-element)) )#|(defmethod menu-item-number ((item menu-element) &aux owner)  (when (setq owner (slot-value item 'owner))    (1+ (position item (the list (slot-value owner 'item-list))                  :test 'eq))))|#(defmethod menu-item-number ((item menu-element) &aux owner)  (when (setq owner (slot-value item 'owner))    (let ((n 0))      (declare (fixnum n))      (dolist (x (the list (slot-value owner 'item-list)))        (setq n (1+ n))        (when (eq x item)(return n))))))(defmethod menu-item-action ((menu-item menu-item))  (let ((action (slot-value menu-item 'menu-item-action)))    (when action (funcall action))))(defmethod menu-item-action ((menu menu))  nil)(defmethod menu-item-title ((item menu-element))  (slot-value item 'title))(defmethod set-menu-item-title ((item menu-element) new-title &aux owner)  (setf (slot-value item 'title)        (setq new-title (ensure-simple-string new-title)))  (when (setq owner (slot-value item 'owner))    (if (equalp new-title "-")      (progn         (if (slot-value owner 'menu-handle) (with-menu-detached owner))        (menu-item-disable item))      (let ((num (menu-item-number item)))        (if (slot-value owner 'menu-handle)          (with-pstrs ((tp new-title))            (if (%izerop (%get-byte tp)) (%put-word tp #x0120))            (#_SetMenuItemText (slot-value owner 'menu-handle) num tp))))))  new-title)(defmethod command-key ((item menu-element))  nil)(defmethod set-command-key ((item menu-element) new-key)  (declare (ignore new-key))  )(defmethod command-key ((item menu-item))  (slot-value item 'command-key))(defmethod set-command-key ((item menu-item) new-key &aux mh owner)  (setf (slot-value item 'command-key)        (setq new-key (and new-key (require-type new-key 'character))))  (when (and (setq owner (slot-value item 'owner))             (setq mh (slot-value owner 'menu-handle)))    (#_SetItemCmd mh (menu-item-number item) (or new-key #\Null))))(defmethod menu-item-enable ((item menu-item) &aux mh owner)  (when (not (string= "-" (slot-value item 'title)))    (when (not (menu-item-enabled-p item))      (setf (slot-value item 'enabledp) t)      (if (and (setq owner (slot-value item 'owner))               (setq mh (slot-value owner 'menu-handle)))        (#_EnableItem mh (menu-item-number item))))))(defmethod menu-item-enable ((menu menu)) (menu-enable menu)); enabledp is nil but the darn thing is enabled!(defmethod menu-item-disable ((item menu-element) &aux mh owner)  (when t ;(menu-item-enabled-p item) ; WHY?     (setf (slot-value item 'enabledp) nil)    (if (and (setq owner (slot-value item 'owner))             (setq mh (slot-value owner 'menu-handle)))      (progn (#_DisableItem mh (menu-item-number item))))))(defmethod menu-item-disable ((menu menu)) (menu-disable menu))#|(defmethod menu-item-enabled-p ((item menu-element))  (slot-value item 'enabledp))|#(defmethod menu-item-enabled-p ((menu menu)) (menu-enabled-p menu))(defmethod set-menu-item-enabled-p ((item menu-element) value)  (if value    (menu-item-enable item)    (menu-item-disable item))  value);Extended to allow arbitrary mark characters... Rename to item-mark ?(defmethod set-menu-item-check-mark ((item menu-item) mark &aux mh owner)  (setq mark        (cond ((characterp mark) mark)              ((fixnump mark) (code-char mark))              ((eq t mark) #\CheckMark)              ((not mark) nil)              (t (report-bad-arg mark '(or character (member t nil))))))  (when (or (not (null mark))(not (eql mark (menu-item-check-mark item))))    (setf (slot-value item 'checkedp) mark)    (when (and (setq owner (slot-value item 'owner))               (setq mh (slot-value owner 'menu-handle)))      (#_SetItemMark  mh (menu-item-number item) (or mark #\Null)))    mark))(defmethod menu-item-check-mark ((item menu-item))  (slot-value item 'checkedp))(defmethod menu-item-check-mark ((item menu-element))  )(defmethod set-menu-item-check-mark ((item menu-element) mark)  (declare (ignore mark)))(defmethod set-menu-item-style ((item menu-element) newstyle &aux mh owner)  (when (and (setq owner (slot-value item 'owner))             (setq mh (slot-value owner 'menu-handle)))    (#_SetItemStyle mh (menu-item-number item) (style-arg newstyle)))  (setf (slot-value item 'style) newstyle))(defmethod menu-item-update ((item menu-element))  (let ((updater (menu-item-update-function item)))    (when updater      (funcall updater item)      t)))(defmethod menu-item-update ((menu menu)) (menu-update menu))(defmethod set-menu-item-icon-num ((item menu-item) icon-num)  (unless (or (null icon-num) (<= 1 icon-num 255))    (setq icon-num (require-type icon-num '(integer 1 255))))  (setf (menu-item-icon-num-slot item) icon-num)  (let* ((owner (menu-item-owner item))         (mh (and owner (menu-handle owner))))    (when mh      (#_SetItemIcon mh (menu-item-number item) (or icon-num 0))))  icon-num);;;;; window menu-items(defclass window-menu-item (menu-item) ()); Bootstrapping version. Real one in "ccl:lib;windoids".(unless (fboundp 'get-window-event-handler)  (%fhave 'get-window-event-handler #'(lambda () (front-window))))(defmethod menu-item-action ((item window-menu-item))  (let ((action (slot-value item 'menu-item-action))        (w (get-window-event-handler)))    (when action      (funcall action w))))(defmethod menu-item-update ((item window-menu-item))  (unless (call-next-method) ; i.e. does menu-element method deal with it    (let ((action (slot-value item 'menu-item-action)))      (when (or (non-nil-symbol-p action)                (typep action 'generic-function))        (dim-if-undefined item action)))))(defmethod dim-if-undefined ((item window-menu-item) sym &aux wob)  (if (and (setq wob (get-window-event-handler))           (or (method-exists-p sym wob)               (let ((handler (current-key-handler wob)))                 (and handler (method-exists-p sym handler)))))    (menu-item-enable item)    (menu-item-disable item)))(defclass windows-menu-menu-item (menu-item)  ((my-window :initarg :window)))(defmethod menu-item-action ((item windows-menu-menu-item))  (let ((window (slot-value item 'my-window)))    (window-select window)    (when (shift-key-p)      (window-ensure-on-screen window))    (when (control-key-p)      (let* ((windows (windows :class (class-of window)))             (n 1))        (dolist (win windows)          (when (neq win window)(set-window-layer win n)(incf n)))))));;apple-menu;; used for creating menus with da's appended(defclass apple-menu (menu)  ()  (:default-initargs :menu-title #.(string #\applemark))  )#| Not needed(defmethod add-menu-items ((menu apple-menu) &rest menu-items)  (declare (ignore menu-items))  (let ((*menubar-frozen* t))    (with-menu-detached menu      (call-next-method)))  (draw-menubar-if))|#(defmethod menu-install ((menu apple-menu))  (unless (and (slot-value menu 'menu-id)               (macptrp (slot-value menu 'menu-handle)))    (setf (slot-value menu 'menu-handle) nil)    (setq %menubar nil))  (unless (slot-value menu 'menu-handle)    (let ((*menubar-frozen* t)          (mbar (menubar)))      (call-next-method)      (#_AppendResMenu (slot-value menu 'menu-handle) "DRVR")      (dolist (x mbar)        (menu-install x)))    (draw-menubar-if)))(defmethod menu-deinstall ((menu apple-menu))  ;;The apple menu cannot be removed by the user (it causes multifinder  ;;to overwrite random memory).  ;;*menubar-frozen* is true only for system code, it is used when adding  ;;menu-items to the apple menu (seems not to confuse multifinder).  nil)(defmethod menu-select ((menu apple-menu) item)  (if (<= item (length (slot-value menu 'item-list)))    (call-next-method)    (rlet ((str (:string 255)))      (#_GetMenuItemText (slot-value menu 'menu-handle) item str)      (#_OpenDeskAcc str)      (let ((front (front-window)))        (when (typep front 'da-window)          (unselect-windows t)          (setq *selected-window* front))))))    ; end of L1-menus.lisp#|	Change History (most recent last):	2	12/23/94	akh	fix update-menus-for-modal again	3	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)