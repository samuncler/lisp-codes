;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  6 10/22/97 akh  see below;;  5 8/25/97  akh  sleep wakeup stuff;;  4 6/2/97   akh  see below;;  3 4/1/97   akh  see below;;  37 10/3/96 akh  declaim ftype map-windoids;;  33 9/3/96  akh  dont make bignum of *gc-event-status-bits* on 68K;;  28 7/18/96 akh  added get-dead-keys-state, preserve state when suspend/resume etc;;  25 5/20/96 akh  window-object back to alist, now with cache;;  23 3/27/96 akh  check *startup-aevents* before error in %event-dispatch;;  20 3/9/96  akh  run-masked-periodic-tasks - dont bind *current-x-view*;;  12 11/22/95 akh *hide-windoids-on-suspend* nil till windoids exist;;  8 11/9/95  akh  fix update-menus to cdr down state list;;  5 10/26/95 Alice Hartley %istruct;;  3 10/17/95 akh  merge patch to menukey-modifiers-p;;  2 10/13/95 bill ccl3.0x25;;  14 5/22/95 akh  make command-option-, work in do-event;;  11 5/19/95 akh  fix do-event (do get-byte vs event-keystroke when menukey) for *control-key-mapping* and command-shift-. etc;;  8 5/4/95   akh  fix *control-key-mapping* (lost a fix). revert update-menus;;  6 3/22/95  akh  in event-poll dont force-output when woi;;  4 2/17/95  akh  *window-object-alist* => *window-object-hash*;;  3 1/17/95  akh  new macros for with and without event processing - use them - set *processing-events* to the process vs t;;  (do not edit before this line!!);; L1-events.lisp - Object oriented events; Copyright 1986-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!; Modification History;10/22/97  akh *can-powermanager-dispatch* set along with other gestalt things for sleep-q; 03/24/97 akh  all the guys who check boundp *current-event* also check for nil;               process-abort-event and seek-abort-event bind *current-event* before calling interactive-abort; 03/23/97 akh  do-event recognizes option-command-. (no longer necessary since bill fixed cmain); 02/26/97 bill %event-dispatch takes a new event-mask arg which it passes to get-next-event.;               It also exits its loop if *startup-aevents* was true at function entry and;               there is *deferred-appleevents* is non-null or *startup-aevents* is null.; 02/25/97 bill cmain clears the $gc-allow-stack-overflows-bit bit in *gc-event-status-bits*; 01/21/97 bill do-event does (#_BeginUpdate)(#_EndUpdate) for update;               events on unknown windows (from a Dylan patch).; ------------- 4.0; 10/07/96 bill remove-window-object calls (new) remove-lisp-wdef; 09/25/96 bill set-cursor no longer initializes *current-cursor*.;               This is now done by (def-ccl-pointers qd ...) in "ccl:l1;l1-init.lisp".; 09/23/96 bill stop set-cursor from consing; ------------- 4.0b2; 09/11/96 bill *dead-keys-state* initialized to T.;               (method application-suspend-event-handler (application));                 enables dead keys if they are disabled.;               (method application-resume-event-handler (application));                 disables dead keys if necessary.;  9/04/96 slh  set-cursor sets *current-cursor*; 08/23/96 bill If process-event is running in other than the *initial-process*;               (i.e. the standin event processor), it executes *eventhook*;               functions ignoring errors. This prevents the Lisp from being;               wedged if an *eventhook* function signals an error.; 08/20/96 bill If *startup-aevents* is true, %event-dispatch does its thing independent of;               *current-process*.; ------------- 4.0b1; 08/05/96 bill %event-dispatch no longer signals a "Wrong process" bug.;               Instead it does nothing if the *current-process* is not the *event-processor*.; 07/27/96 gb   dbg -> bug.; 07/26/96 bill %event-dispatch proceses the $gc-redraw-window-frames-bit of *gc-event-status-bits*;               process-gc-event-status-bits comes out-of-line from %event-dispatch; 06/26/96 bill The initial value for *inside-update-menus* is 0.; 05/13/96 bill update-menus protects itself against recursive errors.;               This allows you to debug a buggy menu or menu-item udpate function.; 04/25/96 bill "...help-manager.fasl" => (merge-pathnames *.fasl-pathname* "ccl:library;help-manager"); ------------- MCL-PPC 3.9; 04/03/96 bill %run-masked-periodic-tasks uses new with-periodic-task-mask instead;               of let binding *periodic-task-mask* & *gc-event-status-bits*.;               cmain takes new, optional, no-event-dispatch arg. If true,;               doesn't switch processes or do event dispatch.;               %event-dispatch calls cmain with the new no-event-dispatch arg true;               to ensure that we don't miss interrupts.; 03/26/96  gb  lowmem accessors.; 03/19/96 bill  with-cursor restores the cursor on its way out.; 01/31/96 bill  event-poll does force output when woi, otherwise it never does.; 01/04/96 bill  event-poll always does force-output if *single-process-p* is true.; 12/27/95 gb    get-next-event maintains *cme-microseconds* on PPC; 12/08/95 bill  (defpascal cmain ...) & friends move to ppc-trap-support; 12/05/95 bill  (defpascal cmain ...) prints xp & pc if it doesn't recognize the trap; 11/29/95 bill  with-error-reentry-detection moves here from l1-error-signal; 11/22/95 bill  (defpascal %err-disp ...) called by "lisp-exceptions.c".;                New: match-instr, RA-field, D-field, RS-field, codevec-header-p,;                     *trap-lookup-tries*, scan-for-instr;                (#_HMGetBalloons :boolean) -> (#_HMGetBalloons); 11/20/95 alice *hide-windoids-on-suspend* nil till windoids exist; 11/14/95 bill draghook returns; 11/10/95 bill remove installation of draghook for PPC until callbacks exist.; 11/09/95 bill  #_getenvirons -> #_GetScriptManagerVariable; 10/11/95 bill  event-poll calls event-dispatch if the current process is the event processor.;  6/06/95 slh   Bill's fix to event-poll;  5/19/95 slh   use window-hide-for-suspend, window-show-for-resume;  5/12/95 slh   application-suspend/resume-event-handler; hide & show windoids;  5/04/95 slh   update-menus: unwind *menubar-frozen* before draw-menubar-if;  4/25/95 slh   maybe-get-ext-scrap on resume event (checking more often;                overwrites fred scrap after file dialogs, etc);  4/20/95 slh   update-menus has update-menus-for-modal folded in;  3/30/95 slh   merge in base-app changes;--------------  3.0d18; 3/11/95 slh   use gestalt bitnum arg;-------------- 3.0d17; bill's fix ? to set-cursor; do-event unhilites menus before action rather than after - like finder etal; event-available-p not true when *processing-events*, event-poll uses abort-event-pending-p vs event-available-p; Fixes a bug exposed by modal-dialog - if an event occurred during cleanup forms the; cleanup forms never finished because the event process was alway ready to run; (cause an event was available) but did nothing because *processing-events* was true.; *processing-events* stayed true forever because setting it back to nil is;  a cleanup form that never executed.;---------------;10/04/93 bill  *event-mask*;-------------- 3.0d13;06/22/93 bill  set-cursor no longer dispatches on handlep; its arg must be a handle or fixnum or *arrow-cursor*;               This makes ROM-resident cursors work correctly on the new AV macs and on the PDM.;-------------- 3.0d11;06/06/93 alice shift-key-p more explicit - fixes frec-click;05/20/93 bill  do-event swaps the keyboard script on suspend/resume events.;-------------  3.0d8;05/19/93 alice event-poll does event-dispatch if current-process is event-processor so we can;		get out of event-processing run amok;05/08/93 alice process-abort-event returns true if event was abort, nil otherwise;		%event-dispatch uses this to avoid calling interactive-abort twice;		when command-. is typed.;--------------- 2.1d7;04/29/93 bill  all-processes & friends -> *all-processes* & friends;04/28/93 bill  (#_TickCount) -> (get-tick-count);04/22/93 bill  Call #_IdleUpdate on machines that support it when;               we are not *idle*.;-------------- 2.1d4;03/22/93 alice command-key-p etal account for *control-key-mapping*;10/22/92 alice menu-selected allows event-processing, moved *interrupt-level* 0; 		from do-event to menu-selected - who cares if its 0 or 2 anyway? ;10/08/92 alice do-event and menukey-modifiers-p for *emacs-mode* => *control-key-mapping*;               now non-menu command keys get thru to fred but ;		shift-modified menu commands are treated same as unmodified - maybe O.K.;07/02/92 alice nuke binding standard-output, evalhook and applyhook in do-event ; 03/24/93 bill  key-states-p, abort-event-pending-p, %abort-event-p; 03/15/93 bill  in with-cursor: let -> let-globally; 02/23/93 bill  in cmain: run periodic tasks with scheduling disabled. I think this;                gets rid of a deadlock caused by the gc-thermometer; 02/19/93 bill  %run-masked-periodic-tasks does not allow the scheduler to run.;                This stops keystrokes from escaping from the choose-file-dialog;                to MCL's front window.; 02/17/93 bill  (method view-key-event-handler (application)); 01/21/93 bill  cmain runs *event-dispatch-task* with interrupts enabled.; 01/14/93 bill  wait-key-event now works with multiple processes; 12/24/92 bill  cmain binds *in-scheduler* to prevent infinite loop;                on PowerBooks in idle mode.; 12/17/92 bill  event-dispatch can now be called by other than the *event-processor*; 12/09/92 bill  kill *wait-next-event-calls*; 08/24/92 bill  wrap *event-abort-restart* around do-deferred-appleevents; 04/30/92 bill  in update-cursor. Don't ignore-errors while requiring the help-manager.;                Instead, don't require it if no file exists.; -------------- 2.0; 01/07/92 gb    don't require RECORDS.; 11/19/91 bill  Nuke %event-dispatch to save a symbol: Ralph hackers beware.;                break process-event out from inside the loop in event-dispatch so that;                appleevent-idle can call it.; 11/13/91 bill  change *background-sleep-ticks* to 5 so that it agress with the manual.;                Whether that number makes any more sense than nil or 10 is a matter of opinion.; 11/08/91 gb    not sure if *background-event-ticks* should be 10, don't think it should be nil.; 11/07/91 alice nuke reference to *terminal-io* in %event-dispatch?? (maybe in do-event too); 10/18/91 bill  -1 -> #$everyEvent as default value for the mask arg to get-next-event; 10/17/91 bill  *periodic-task-mask*, draghook, %run-masked-periodic-tasks; 10/22/91 alice add *alias-manager-present*; 09/26/91 alice nuke menus-state;------------------ 2.0b3; 08/30/91 alice add menus-state, update-menus draws iff changed; 08/21/91 bill redraw-window-frame; 08/12/91 alice update-menus freezes menubar till done - much prettier; 07/21/91 gb   add a few ms when dequeing time task.  #_DiBadMound;               puts up a dialog; that's enough.; 08/15/91 bill In set-cursor, don't call HELP-ON? unless *HELP-MANAGER-PRESENT*; 08/09/91 bill Jeremy's code for *multi-click-count*; 08/09/91 bill set-cursor deals properly with fixnum cursors and does LoadResource; 07/09/91 bill autoloading of help-manager is inside update-cursor; 07/05/91 bill check for *last-null-event-time* moves to do-event.;               Call (window-null-event-handler nil) when no windows open.; 07/01/91 bill Joe added do-defererred-appleevents to end of event-dispatch.;               Don't do this unless *deferred-appleevents* is non-NIL.; 06/20/91 bill get-next-event assures that MCL runs for (event-ticks).;               Before, (event-ticks) was the time all applications got;               to run between our calls to _WaitNextEvent; 06/13/91 bill in get-next-event - $run_time is a double word; 06/11/91 bill *allow-without-interrupts-abort* is history.;               Don't be so eager to look for <Command>-. in event-dispatch.; 06/08/91 bill make flags & privatedata optional in %install-periodic-task; 06/07/91 bill funcall 'event-dispatch, not #'event-dispatch, so it can;               be changed.;------------ 2.0b2; 05/20/91 gb   new periodic-tasks scheme.  Dequeue timer when calling _WaitNextEvent.; 05/17/91 bill in cursorhook: with-port -> with-focused-view; 03/29/91 bill system clicks set *last-mouse-click-window*.;               do-event calls window-event on the front windoid for key & null events; 03/23/90 joe  add do-event-queue macro (used again in appleevents) & change seek-abort-event; 03/05/91 bill Firm up event handling of Mac windows not in *window-object-alist* and;               Lisp windows with non-macptr WPTR's.; 01/14/91 gb   Make get-next-event suspend/resume $run_time_task.  Always _WaitNextEvent,;               so flush *use-wait-next-event*.;------------ 2.0b1; 12/31/90 gb   Nail some of this down.; 12/13/90 bill 23 -> $kHighLevelEvent; 12/13/90 joe  process $kHighLevelEvent in do-event; 11/28/90 bill nuke menukey-event-p & %menu-key-p.; 11/21/90 gb   bind *interrupt-level* when processing menu events.; 11/05/90 bill GCABLE-WPTR-P decides if INSTALL-WINDOW-OBJECT will make a gcable-macptr;               (used for DA-WINDOW instances);               Process menu key events in DO-EVENT vice WINDOW-EVENT so that they will;               work if no windows are open.; 10/23/90 bill process-abort-event calls interactive-abort vice abort; 10/10/90 bill *event-abort-restart* is now named 'event-abort, not 'abort.;               break-loop knows about it.;               <Command><Option><Period> (C-M-.) does abort-break.; 08/24/90 bill make *event-abort-restart* catch abort, not event-abort; 08/21/90 bill (change-mouse-view nil) when we become background (just in case things;               are real slow and we miss the leave it takes to get to the menubar).; 08/02/90 gb   new gcable-macptr scheme in install-window-object.; 07/30/90 bill update-cursor functions only if lisp is in the *foreground*; 07/24/90 bill menukey-modifiers-p comes out of line from menukey-event-p; 07/23/90 bill enable abort during event processing.; 07/05/90 bill nix wptr-if-bound; 05/31/90 bill install-window-object marks the MACPTR for _DisposWindow by GC.; 05/15/90 gb   *event-abort-restart* : change restart name to "abort-events."; 05/05/90 bill update for new scrap handler.; 04/30/90 gb   One more slot in %make-restart call; never wait NIL ticks (most;               unpleasant !); handle gc-deferred events.; 03/16/90 bill abort events were missed sometimes.;               New global *allow-without-interrupts-aborts*; 03/05/90 bill xxxxground-event-ticks functions become *foreground-event-ticks*;               and *background-event-ticks* variables.; 02/23/90 bill check for wptr-if-bound before calling window-event;               bind *processing-events* right after testing it.; 02/15/90 bill any-modifier-keys-p; 02/07/90 bill seek-abort-event; 01/17/90  gz  Add a restart around do-event.; 01/13/90  gz  Optional idle arg to event-dispatch.; 01/10/90 bill Remove ignore-errors around do-event.; 01/08/90 bill Ignore activate events (part of adding windoids); 12/28/89  gz  no more catch-error.; 10/4/89   gz  install-window-object (back from l1-windows).;               Allow for suspend/resume events with no windows present.; 09/27/89  gb  more object-lisp removal.; 09/16/89 bill Removed last vestiges of object-lisp; 09/09/89 bill change window-object-(de)activate-event-handler to ;               window-(de)activate-event-handler in do-event; 09/03/89 as added foreground and background event ticks; 7/20/89   gz clos menus.; 5/19/89   gz Call event handlers for drag/grow/close events.;              Update-cursor uses front window rather than current object.;              default def for *cursorhook*.; 18-mar-89 as menu-object moved to l1-menus; 3/31/89   gz *inest-ptr* -> *interrupt-level*; 3/18/89   gz window-foo -> window-object-foo.; 3/17/89   gz didn't remove wait-key-event (just because WE don't use it...); 15-mar-89 as removed wait-key-event;              *eventhook* is a list of hooks; 9-mar-89  as suspend/resume events cause window deactivate/activate; 12/16/88  gz Unbreak loop in remove-window-object.;              window-object doesn't copy wptr, exist does.;  11/19/88 gb dispatch on functionp or symbolp.;  10/23/88 gb window-object copies wptr arg when creating a *da-window*.; 10/19/88 jaj reorganized events.  non-window events handled by do-event,;              evtMessage always contains wptr for window events, added ;              evtPartCode to event record. got rid of window-disk-insert-eh;              window-suspend-eh window-resume-eh.  Alien windows handled by;              (window-event nil).  added *processing-events*, events are;              always processed at interrupt level 0. removed *action-xx;              and *event-object*;  9/30/88 jaj window-event no longer calls window-control-click-event-handler;  9/22/88 jaj do-event takes level as an arg, event-dispatch passes it;  9/14/88 as  click in close-box closes all windows of class if option-key-p;  8/26/88 jaj in event-dispatch: don't look at *multifinder*, the delay;              for _WaitNextEvent is zero, use ilogbitp instead of zerop;              to check for boolean return from _WaitNextEvent;  10/18/88 gz moved zoom event handler to l1-windows.  Added wait-key-event.;  9/1/88  gz  %signal-error -> %err-disp. added %menu-key-p.;  8/02/88 gz  Bind *compiling-file* around event processing.;  6/29/88 jaj added a catch-error around call to do-event;  6/21/88 jaj catch :cancel -> catch-cancel. remove closed DAs from ;              *window-object-alist*;  5/29/88 as  click in title-bar calls set-window-position;              <redundant, but needed for mini-buffer hook.  perhaps punt>;  5/27/88 jaj window-select-event-handler calls window-select;  5/23/88 jaj check for *multifinder* and *use-wait-next-event* before;              calling _WaitNextEvent;  5/19/88 as  punted *abort-character*;  5/13/88 jaj click in title bar of non-front window calls window-select-e-h;  5/11/88 jaj call _WaitNextEvent if *idle*;  4/11/88 jaj removed call to window-size-parts in window-zoom-event-handler;  4/07/88 as  with-cursor calls update-cursor, first thing;  3/30/88 jaj kerwordified rlets; 3/31/88   gz New macptr scheme. Flushed pre-1.0 edit history.; 3/2/88    gz Eliminate compiler warnings; 10/25/87 jaj one more fix to double-click-p; 10/23/87 jaj _DIBadMound -> _DIBadMount; 10/22/87 jaj check for *foreground* in abort processing, set it in;              suspend/resume processing; 10/21/87 jaj *grow-rect*, *drag-rect* -> window-grow-rect, window-drag-rect; 10/19/87 jaj call abort instead of signal-error; 10/15/87 jaj default window-select-event-handler zeros *last-mouse-down-time*; 10/15/87 as window-event calls window-zoom-event-handler, instead of;             trapping in-line.;-----------------------------------release 1.0-----------------------------(declaim (special *current-event*));(defvar *emacs-mode* nil)(defvar *control-key-mapping* nil) ; can also be :command-shift or :command(defvar *inhibit-abort* nil)(defglobal *processing-events* nil)(defparameter *event-abort-restart*  (%make-restart 'event-abort nil "Abort event processing" () ()))(eval-when (eval compile load)  (defmacro do-event-queue (event &body body)    ; event should be a variable    (let ((evqp (gensym)))      `(block nil         (with-macptrs ((,evqp (%get-ptr (%int-to-ptr $EventQueue) 2))                        ,event)           (until (or (%null-ptr-p ,evqp) (%izerop (rref ,evqp EvQEl.evtQWhat)))             (%setf-macptr ,event (%inc-ptr ,evqp (get-field-offset EvQEl.evtQWhat)))             ,@body             (%setf-macptr ,evqp (%get-ptr ,evqp)))))))  ; instead of let-globally - maybe  ; trying to avoid the following scenario  ; 1) *processing-events* is NIL  ; 2) process A remembers nil, sets to t (and he becomes interruptable at some point)  ; 3) process B remembers t, sets to NIL  ; 4) process A resets to nil  ; 5) process B resets to T. and then we are wedged  ; OR make *processing-events* true also imply without-interrupts  ; OR *processing-events* if true should be a process and he is the only one allowed  ;   to run (like this better)  (defmacro without-event-processing (&body body)    (let ((esym (gensym)))          `(let (,esym)         (unwind-protect           (progn              (setq ,esym *processing-events* *processing-events* *current-process*)             ,@body)           ; restore it unless some other dude has set it to nil.           (when *processing-events* ; ??             (setq *processing-events* ,esym))))))    (defmacro with-event-processing-enabled (&body body)    `(let ((*interrupt-level* 0))       (setq *processing-events* nil)       ,@body))    ); if *processing-events* and abort-event - do it(defun seek-abort-event ()  (declare (resident))  (when (and *processing-events* (abort-event-pending-p))    (#_FlushEvents #x003f 0)    (let ((*current-event* nil)) ; hide outer binding if any - for option-key-p      (interactive-abort)))); if current-event is abort do it(defun process-abort-event (event)  (declare (resident))  (when (%abort-event-p event)    (#_FlushEvents #x003F 0) ;Flush typeahead    (let ((*current-event* event)) ;  - for option-key-p      (interactive-abort)      t)))(defun %abort-event-p (event)  (and (eq $KeyDwnEvt (rref event :eventrecord.what))       (eq (%ilogand #x1300 (rref event eventrecord.modifiers)) #x100)       (let ((code (%get-byte event 5)))         (or (eq code (char-code #\.))             (eq code 179)))))          ; <option>-.(defun %break-event-p (event)  (and (eq $KeyDwnEvt (rref event :eventrecord.what))       (eq (%ilogand #x1300 (rref event eventrecord.modifiers)) #x100)       (let ((code (%get-byte event 5)))         (or (eq code (char-code #\,))             (eq code 178)))))(defun abort-event-pending-p ()  (or   (do-event-queue event     (when (%abort-event-p event)       (return t)))   ; This is here for AU/X, which doesn't have an event queue   #| Makes abort happen too often   (key-states-p '(47                   ; period (".")                   55                   ; command                   (59)                 ; not control                   (56)))               ; not shift   |#   ))(defun break-event-pending-p ()  (or   (do-event-queue event     (when (%break-event-p event)       (return t)))))(defvar *event-mask* #$everyEvent)#-ppc-target(defun get-next-event (event &optional (idle *idle*) (mask *event-mask*)                             (sleep-ticks (wait-next-event-sleep-ticks idle)))  (declare (resident))  (lap-inline ()    (move.l (a5 $run_time_task) a0)    (dc.w #_RmvTime)    (move.l ($ 1000000) d0)    (add.l (a0 10) d0)    (add.l (a5 $timeqMS) d0)    (add.l d0 (a5 (+ $run_time 4)))    (if# cs      (add.l ($ 1) (a5 $run_time))))  (unless    (#_WaitNextEvent mask event sleep-ticks (%null-ptr))    (rset event eventrecord.what #$nullEvent))  (lap-inline ()    (move.l (a5 $run_time_task) a0)    (dc.w #_instime)    (move.l ($ 1000) d0)    (dc.w #_PrimeTime)    (move.l (special *event-dispatch-task*) atemp0)    (if# (ne (cmp.l nilreg atemp0))      (move.l (svref atemp0 ptask.state) atemp0)      (jsr_subprim $sp-macptrptr)      (move.l (@ #$ticks) acc)      (add.l (atemp0 (get-field-offset :ptaskState.interval)) acc)      (move.l acc (atemp0 (get-field-offset :ptaskState.nextTick)))))  event)#+ppc-target(progn(defloadvar *cme-microseconds* (make-record (:unsignedwide :clear t)))(defun get-next-event (event &optional (idle *idle*) (mask *event-mask*)                             (sleep-ticks (wait-next-event-sleep-ticks idle)))  (rlet ((before :unsignedwide)         (after :unsignedwide))    (#_MicroSeconds before)    (unless (#_WaitNextEvent mask event sleep-ticks (%null-ptr))      (rset event eventrecord.what #$nullEvent))    (#_MicroSeconds after)    (#_WideAdd *cme-microseconds* (#_WideSubtract after before))    (let* ((task *event-dispatch-task*))      (when task        (let* ((state (ptask.state task)))          (setf (pref state :ptaskState.nextTick)                (+ (#_TickCount) (pref state :ptaskState.interval))))))    event)))(defloadvar *event-wakeup* nil)(defun event-available-p (&optional (mask #$everyevent))  (or (prog1 *event-wakeup* (setq *event-wakeup* nil))      (and        (rlet ((junk eventrecord))         ; OSEventAvail does not do a Multi-Finder context switch. EventAvail does.         ; The trap also returns D0.L = -1 when no events are available, D0.W = 0         ; otherwise.  That's not how I read the documentation...  Look at         ; event.what just to be sure ...         (#_OSEventAvail mask junk)         (not (eql (pref junk :eventrecord.what) #$NullEvent)))       (or (not *processing-events*)(abort-event-pending-p))))); maybe this works - dont switch if event-processor or the guy who set processing events(defun event-poll ()  (setq *event-wakeup* t)    (when *single-process-p*    (unless *in-scheduler*      (let* ((tio *terminal-io*)) ; gag puke        (when (streamp tio)           (stream-force-output tio)))))  (if (and (neq *event-processor* *current-process*)  ; if not event processor           (or (not *processing-events*)              ; and not the guy who set *processing-events*               (neq *current-process* *processing-events*)))    (unless *in-scheduler*      (unless *single-process-p*        (when t  ; (%i>= *interrupt-level* 0)          (let* ((tio *terminal-io*)) ; gag puke            (when (streamp tio) (stream-force-output tio)))))      (suspend-current-process))    ; rearranged the and's and or's a little bit - used to do (or (and ..)(abort-event-pending-p))     (when (and (eq *event-processor* *current-process*)               (or (not *processing-events*)                   (abort-event-pending-p)                   ;; ??? - let us break in event-processor too                   (break-event-pending-p)))          ; is event processor or is the guy who set processing-events      (setq *processing-events* nil) ; maybe belongs elsewhere?      (event-dispatch))))#|(defun maybe-abort ()  (let ((abort-enabled-p           (and *foreground* (not *inhibit-abort*) (%i>= *interrupt-level* 0))))    (when (and abort-enabled-p)      (when (abort-event-pending-p)        (#_FlushEvents #x003f 0)        (interactive-abort)))))|##| ; old one(defun event-poll ()  (setq *event-wakeup* t)    (if (neq *event-processor* *current-process*)    (unless *processing-events*      (progn        (let* ((tio *terminal-io*)) ; gag puke          (when (streamp tio) (stream-force-output tio)))        (suspend-current-process)))    (when (let ((*event-wakeup* nil))(event-available-p))(event-dispatch))))|#(defparameter *idle-sleep-ticks* 5)(defparameter *foreground-sleep-ticks* 0)(defparameter *background-sleep-ticks* 5)(defun wait-next-event-sleep-ticks (&optional (idle *idle*))  (declare (resident))  (or   (if (or *foreground* (null *background-sleep-ticks*))     (if idle *idle-sleep-ticks* *foreground-sleep-ticks*)     *background-sleep-ticks*)   5))(defun event-dispatch (&optional (idle *idle*) (level *interrupt-level*))  (if (eq *current-process* *event-processor*)    (%event-dispatch idle level)    (event-poll)))(defvar *sleep-wakeup-functions* nil)(defun process-gc-event-status-bits ()  (let ((gc-bits *gc-event-status-bits*))    (declare (fixnum gc-bits))    (setq *gc-event-status-bits* (logand gc-bits $gc-fixed-bits-mask))    (if (logbitp $gc-update-bit gc-bits)      (do-all-windows w        (redraw-window-frame w)        ; windoids need this        (invalidate-view w t))      ;  - don't know if this bit exists in 3.0? - it doesn't - windoid wdef sets it in 3.9      (when (logbitp $gc-redraw-window-frames-bit gc-bits)        (do-all-windows w          (redraw-window-frame w))))    (when (logbitp $gc-sleep-wakeup-bit gc-bits)      (dolist (fn *sleep-wakeup-functions*)        (funcall fn)))    (when (logbitp $gc-suspend-or-resume-bit gc-bits)      (if *foreground*        (reselect-windows)        (unselect-windows)))))(defun %event-dispatch (&optional (idle *idle*) (level *interrupt-level*) (event-mask *event-mask*))  (declare (special *gc-event-status-bits*)           (fixnum *gc-event-status-bits*)           (resident))  (when (and (eql 0 (logand (+ $ptask_event-dispatch-flag $ptask_draw-flag)                            (the fixnum *periodic-task-mask*)))             (or (eq *current-process* *event-processor*)                 *startup-aevents*))    (without-interrupts     (unless idle       (when *cpu-idle-p*         (#_IdleUpdate))       (setq *idle* t))     (process-gc-event-status-bits)     (let* ((*interrupt-level* *interrupt-level*)            (*compiling-file* nil)            (abort-enabled-p              (and *foreground* (not *inhibit-abort*) (%i>= level 0)))            (startup-aevents *startup-aevents*))       (declare (special *compiling-file*))       ;; If we are merrily looping in the *event-processor* and type command-.,       ;; then LEVEL (the value of *interrupt-level* on entry) appears to be -1 (WHY?)       ;; which means that the guys who look for abort events won't do it,       ;; and the command-. ends up being handled by the menu item. Weird.       ;; This oddness is PPC specific.       (if *processing-events*         (when abort-enabled-p           (seek-abort-event))         (without-event-processing           (%stack-block ((event 18)) ;leave room for event record (16) plus part code (2)             (loop               (cmain t)               (get-next-event event idle event-mask)               (process-gc-event-status-bits)               (when abort-enabled-p                 (when (process-abort-event event)(return))                 (seek-abort-event))                              (when (eq (process-event event) $nullEvt)                 (return))               ; Once we get an appleevent while starting up, get out of here               ; so that we don't end up quitting before getting a chance to print.               (when (and startup-aevents                          (or *deferred-appleevents*                              (not *startup-aevents*)))                 (return))))))))    (when *deferred-appleevents*      (with-restart *event-abort-restart*        (let ((*interrupt-level* 0))        ; make sure we can be interrupted          (without-interrupts)              ; process any pending interrupts          (do-deferred-appleevents))))))(defvar *eventhooks-in-progress* nil)(defun process-event (event)  (let ((e-code (rref event eventrecord.what)))    (when (eq e-code $MButDwnEvt) (process-multi-clicks event))    (let* ((*current-event* event))      (declare (special *current-event* *processing-events*))      (block foo        (with-restart *event-abort-restart*          (let ((eventhook *eventhook*))            (unless (and eventhook                         (flet ((process-eventhook (hook)                                  (unless (memq hook *eventhooks-in-progress*)                                    (let ((*eventhooks-in-progress*                                           (cons hook *eventhooks-in-progress*)))                                      (declare (dynamic-extent *eventhooks-in-progress*))                                      (funcall hook)))))                           (declare (inline process-eventhook))                           (if (listp eventhook)                             (dolist (item eventhook)                               (when (process-eventhook item) (return t)))                             (process-eventhook eventhook))))            (return-from foo (catch-cancel (do-event)))))))      e-code)))(defun redraw-window-frame (window)  (let* ((wptr (wptr window))         (hilited (pref wptr :windowrecord.hilited)))    (setf (pref wptr :windowrecord.hilited) (not hilited))    (#_HiliteWindow wptr hilited)))    (defvar *foreground-event-ticks* 20)(defvar *background-event-ticks* 5)(defvar *last-null-event-time* 0)(defun get-environs (verb)  (#_GetScriptManagerVariable verb))(defun get-key-script ()  (get-environs #$smkeyscript))(defun set-key-script (code)  (#_KeyScript code))(defvar *mcl-keyscript*)(defvar *other-keyscript*)(def-ccl-pointers *mcl-keyscript* ()  (setq *mcl-keyscript*         (setq *other-keyscript*              (get-key-script))))(defun do-event (&aux wob ecode (event *current-event*))  (declare (resident))  "If event doesn't apply to a window handles the event, otherwise finds appropriatewindow object for the event then calls that object's window-event function"  (setq ecode (%get-word event))    (with-macptrs (w)    (cond ((eq $MButDwnEvt ecode)           (let ((code (#_FindWindow (rref event eventrecord.where)                                     (%inc-ptr event $evtMessage))))             (%put-word event code $evtPartCode)             (when (eq code $inDesk)               (return-from do-event))             (when (eq code $inMenubar)               (#_SetCursor *ARROW-CURSOR*)               (setq *interrupt-level* 0)               (update-menus)               (let  ((ms (#_MenuSelect (rref event eventrecord.where))))                 (#_HiliteMenu 0)                                         (menu-selected ms))               (return-from do-event))             (%setf-macptr w (%get-ptr event $evtMessage))             (when (eq code $inSysWindow)               (#_SystemClick event w)               ;;If system click closed window, remove it from *window-object-alist*               (with-macptrs ((win (#_FrontWindow)))                 (if (%ptr-eql win w)                   (progn                     (setq wob (window-object w))                     (setq *last-mouse-click-window* wob)                     (unless (or (null wob) (eq wob *selected-window*))                       (setq *selected-window* wob)                       (unselect-windows t)))                   (do () ((%null-ptr-p win)                           (when (setq wob (window-object w))                             (setf (wptr wob) nil))                           (setq *last-mouse-click-window* nil)                           (remove-window-object w)                           (reselect-windows))                     (when (%ptr-eql w win) (return))                     (%setf-macptr win (rref win windowrecord.nextwindow)))))               (return-from do-event))))          ((eq ecode $diskInsertEvt)           (unless (%izerop (%get-word event $evtMessage))             (#_DIBadMount #@(100 100) (%get-long event $evtMessage)))           (return-from do-event))          ((eq ecode $ActivateEvt)      ; ignore these. We do it ourselves.           (return-from do-event))          ((eq ecode $UpdatEvt)           (%setf-macptr w (%get-ptr event $evtMessage)))          ((and (or (eq ecode $KeyDwnEvt) (eq ecode $AutoKeyEvt))                (menukey-modifiers-p (rref event eventrecord.modifiers))                (let* ((char (%get-byte event $evtMessage-b))                        mi)                  (if (eq char 178)  ; option-, - yuck                    (setq char (char-code #\,)))                  (if (eq char 179)  ; option-. - yuck - why do we ever get here? see comment in event-dispatch                    (setq char (char-code #\.)))                  (update-menus)                  (if (%izerop (%ilogand2 -65536 (setq mi (#_MenuKey (code-char char)))))                    nil                    (progn                       (setq *interrupt-level* 0)                      (#_HiliteMenu 0)                      (menu-selected mi)                      t))))           (return-from do-event))          ((%i<= ecode 8) ;null, keydwn, autokey, keyup, mbutup events           (when (eq ecode $nullEvt)             (let ((time *last-null-event-time*))               (when (eq time                         (setq *last-null-event-time* (logand #xffff (#_LMGetTicks))))                 (return-from do-event))))           (with-macptrs ((win (#_frontwindow)))             (if (%null-ptr-p win)               (progn                 (cond ((eq ecode $nullEvt) (window-null-event-handler nil))                       ((or (eq ecode $KeyDwnEvt) (eq ecode $AutoKeyEvt))                        (let ((*interrupt-level* 0))                          (do-keydown-event *application* event))))                 (return-from do-event))               (setq wob (window-object win)))))          ((eq ecode $app4Evt)           (when (eq 1 (%get-byte event $evtMessage))   ; suspend or resume event             (if (setq *foreground* (%ilogbitp 0 (%get-byte event $evtMessage-b)))               (application-resume-event-handler  *application*)               (application-suspend-event-handler *application*)))           (return-from do-event))          ((eq ecode $kHighLevelEvent)           (do-highlevel-event event)           (return-from do-event))          (t (return-from do-event)))    (if (and ;(not (%null-ptr-p w))                (or wob (setq wob (window-object w)))               (wptr wob))     ; make sure not closed (redundant)      (let* (;(*standard-output* *terminal-io*)             ;(*evalhook* nil)             ;(*applyhook* nil)             (*interrupt-level* 0))     ;window-event always runs at level 0        (window-event wob))      (when (eq ecode $UpdatEvt)        ;; Update event on unknown window needs to be pretend-handled        ;; or it will keep happening and we'll get stuck in a loop        (#_BeginUpdate w)        (#_EndUpdate w)))))(defmethod view-key-event-handler ((a application) char)  (declare (ignore char))  (ed-beep)); set to t when windoids exist(defvar *hide-windoids-on-suspend* nil "Hide/show windoids on suspend/resume if true")(defvar *dead-keys-state* t)(eval-when (:execute :compile-toplevel)  (declaim (ftype (function (&rest t) t) map-windoids))); by the time we get here dead-keys have already been clobbered.(defmethod application-suspend-event-handler ((app application))  (unless *dead-keys-state*    (set-dead-keys t)    (setq *dead-keys-state* nil))  (setq *mcl-keyscript* (get-key-script))  (set-key-script *other-keyscript*)  (put-external-scrap)  (change-mouse-view nil)  (set-event-ticks *background-event-ticks*)  (unselect-windows)  (when *hide-windoids-on-suspend*    (map-windoids #'window-hide-for-suspend)))(defmethod application-resume-event-handler ((app application))  (setq *other-keyscript* (get-key-script))  (set-key-script *mcl-keyscript*)  (set-event-ticks *foreground-event-ticks*)  (unless *dead-keys-state*    (set-dead-keys nil))  (maybe-get-ext-scrap)  (unless (typep *selected-window* 'da-window)    (reselect-windows))  (when *hide-windoids-on-suspend*    (map-windoids #'window-show-for-resume t))); Default method justs updates cursor(defmethod window-null-event-handler (w)  (declare (ignore w))  (update-cursor)); Redefined by lib;views.lisp(defun change-mouse-view (to &optional from)  (declare (ignore to from))); Bootstrapping, real version is in "ccl:lib;windoids.lisp"(unless (fboundp 'windoid-wdef-handle-p)  (%fhave 'windoid-wdef-handle-p          #'(lambda (macptr)              (declare (ignore macptr))              nil)))(defun lisp-wdef-handle-p (macptr)  (or (windoid-wdef-handle-p macptr)      ; In case someone conses a wdef "handle" themselves.      (without-interrupts       (with-macptrs ((callback (%get-ptr macptr)))         (defpascal-callback-p callback)))))(defun remove-lisp-wdef (wptr)  (when (and (macptrp wptr)             (not (%null-ptr-p wptr)))          ; paranoia    (with-macptrs ((wdef (pref wptr :windowRecord.windowDefProc)))      (when (lisp-wdef-handle-p wdef)        (setf (pref wptr :windowRecord.windowDefProc)              (pref %temp-port% :windowrecord.WindowDefProc)))))); not redefined below - closures faster than specials? - or about the same(let ((last-window nil))  (defun window-object (wptr)    (declare (resident))    (let ()      (when (and last-window (%ptr-eql wptr (%car last-window)))         (return-from window-object (%cdr last-window))))    (dolist (a *window-object-alist*)      (when (%ptr-eql wptr (%car a))        (setq last-window a)        (return-from window-object (%cdr a))))    (when (%i< (rref wptr windowrecord.windowKind) 0)      (make-instance 'DA-window :wptr wptr :window-show nil)))    (defun set-window-object (wptr window)    (setq last-window nil)        (progn      (dolist (a *window-object-alist*)        (when (%ptr-eql wptr (car a))          (return-from set-window-object            (prog1 (%cdr a) (%rplacd a window)))))      (push (cons wptr window) *window-object-alist*)))    (defun remove-window-object (wptr &aux list)    (setq last-window nil)     (remove-lisp-wdef wptr)    (when (setq list *window-object-alist*)      (if (%ptr-eql wptr (caar list)) (setq *window-object-alist* (%cdr list))          (while (%cdr list)            (when (%ptr-eql wptr (caar (%cdr list)))              (%rplacd list (%cddr list))              (return-from remove-window-object))            (setq list (%cdr list))))))  )  #|;(defun old-window-object (wptr)  (declare (resident))  (dolist (a *window-object-alist*)    (when (%ptr-eql wptr (%car a)) (return-from old-window-object (%cdr a))))  (when (%i< (rref wptr windowrecord.windowKind) 0)    (make-instance 'DA-window :wptr wptr :window-show nil)))|##|(defvar *window-object-hash* nil)(defun set-window-object (wptr window)  (if *window-object-hash*    (if (not window)      (remhash wptr *window-object-hash*)      (setf (gethash wptr *window-object-hash*) window))    (progn      (dolist (a *window-object-alist*)        (when (%ptr-eql wptr (car a))          (return-from set-window-object            (prog1 (%cdr a) (%rplacd a window)))))      (push (cons wptr window) *window-object-alist*))))|##|(queue-fixup(setq *window-object-hash* (alist-hash-table *window-object-alist* :test #'eql));(setq *window-object-alist* nil); today hash is slower if 39 in list(defun window-object (wptr)  (or (gethash wptr *window-object-hash*)      (when (%i< (rref wptr windowrecord.windowKind) 0)        (make-instance 'DA-window :wptr wptr :window-show nil)))))|#(defun install-window-object (window &aux (wptr (wptr window)))  (setq wptr (require-type wptr 'macptr))    (setf (slot-value window 'wptr)        ;Make sure wptr is not stack consed - Reasonable but I dont understand below        (setq wptr (%setf-macptr (if (gcable-wptr-p window)                                   (make-gcable-macptr $flags_DisposWindow)                                   (%null-ptr))                                 wptr)))  (set-window-object wptr window)  nil)#|; If you revert to this way of doing things, remember to call remove-lisp-wdef(defun remove-window-object (wptr &aux list)  (if *window-object-hash*    (remhash wptr *window-object-hash*)    (when (setq list *window-object-alist*)      (if (%ptr-eql wptr (caar list)) (setq *window-object-alist* (%cdr list))          (while (%cdr list)            (when (%ptr-eql wptr (caar (%cdr list)))              (%rplacd list (%cddr list))              (return-from remove-window-object))            (setq list (%cdr list)))))))|#(defparameter *multi-click-count* 0)(defun process-multi-clicks (event)  ;called by event-dispatch on mouse-down events  (if (and (%i< (%i- (rref event eventrecord.when) *last-mouse-down-time*)                (#_LMGetDoubleTime))           (double-click-spacing-p *last-mouse-down-position*                                   (rref event eventrecord.where)))    (incf *multi-click-count*)    (setf *last-mouse-down-position* (rref event eventrecord.where)          *multi-click-count* 1))  (setq *last-mouse-down-time* (rref event eventrecord.when)))  (defun double-click-p ()    (and (and (boundp '*current-event*) *current-event*)       (eq $MButDwnEvt (rref *current-event* eventrecord.what))       (%i> *multi-click-count* 1)))(defun double-click-spacing-p (point1 point2);This should take a window arg so it may be shadowed by particular window objects  (and (%i< (%iabs (%i- (point-h point1) (point-h point2))) 4)       (%i< (%iabs (%i- (point-v point1) (point-v point2))) 4)))(defun shift-key-p ()  (if (and (boundp '*current-event*) *current-event*)    (let ((mods (rref *current-event* eventrecord.modifiers)))                 (and (%ilogbitp $ShiftKey mods)           (case *control-key-mapping*             ((:command-shift :command)              (not (%ilogbitp mods $cmdkey)))             (t t))))    (and (key-down-p 56)         (case *control-key-mapping*           ((:command-shift :command)            (not (key-down-p 55)))           (t t)))))(defun command-key-p ()  (if (and (boundp '*current-event*) *current-event*)    (%ilogbitp $CmdKey                (event-keystroke (rref *current-event* eventrecord.message)                                (rref *current-event* eventrecord.modifiers)))    (and (key-down-p 55)         (case *control-key-mapping*           (:command-shift ; command-shift is control, command is command            (not (key-down-p 56)))           (:command  ; command is control, command-shift is command            (key-down-p 56))           (t t)))))(defun option-key-p ()  (if (and (boundp '*current-event*) *current-event*)    (%ilogbitp $OptionKey (event-keystroke (rref *current-event* eventrecord.message)                                           (rref *current-event* eventrecord.modifiers)))    (key-down-p 58)))(defun caps-lock-key-p ()  (if (and (boundp '*current-event*) *current-event*)    (%ilogbitp $AlphaLock (rref *current-event* eventrecord.modifiers))    (key-down-p 57)))(defun control-key-p () ;E.g. on Mac II...  (if (and (boundp '*current-event*) *current-event*)    (%ilogbitp $ControlKey (event-keystroke (rref *current-event* eventrecord.message)                                            (rref *current-event* eventrecord.modifiers)))    (or (key-down-p 59)        (case *control-key-mapping*          (:command-shift (and (key-down-p 55)(key-down-p 56)))          (:command (and (key-down-p 55)(not (key-down-p 56))))))))(defun key-down-p (key-code)  (multiple-value-bind (byte bit) (floor key-code 8)    (%stack-block ((p 128))      (#_GetKeys p)      (%ilogbitp bit (%get-byte p byte)))))(defun key-states-p (key-codes)  (%stack-block ((p 128))    (#_GetKeys p)    (dolist (code key-codes t)      (let ((off-p (when (listp code)                     (setq code (car (the list code))))))        (multiple-value-bind (byte bit) (floor code 8)          (let ((set (%ilogbitp bit (%get-byte p byte))))            (if off-p              (when set (return nil))              (unless set (return nil)))))))))(eval-when (eval compile)  (defconstant *modifier-keys-event-mask*    (logior (ash 1 $ShiftKey) (ash 1 $CmdKey)            (ash 1 $OptionKey) (ash 1 $ControlKey))))(defun any-modifier-keys-p ()  (if (and (boundp '*current-event*) *current-event*)    (not (eql 0 (%ilogand *modifier-keys-event-mask*                          (rref *current-event* eventrecord.modifiers))))    (%stack-block ((p 128))      (#_GetKeys p)      (or (not (eql 0 (%ilogand 13 (%get-byte p 7))))   ; magic, anyone?          (%ilogbitp 7 (%get-byte p 6)))))); This will fail miserably if called from inside the event processing process(defun wait-key-event ()  "Returns event message and modifiers or nil nil if mouse-click"  (when (eq *current-process* *event-processor*)    (error "~s called from ~s" 'wait-key-event '*event-processor*))  (let* ((message nil)         (modifiers nil)         (flag-cell (list nil))         (eventhook #'(lambda (&aux (ecode (rref *current-event* eventrecord.what)))                        (cond ((car flag-cell) nil)                              ((or (eq ecode $KeyDwnEvt) (eq ecode $AutoKeyEvt))                               (setf message (rref *current-event* eventrecord.Message)                                     modifiers (rref *current-event* eventrecord.Modifiers)                                     (car flag-cell) t))                              ((eq ecode $MButDwnEvt)                               (setf (car flag-cell) t))                              (t nil)))))    (declare (dynamic-extent eventhook flag-cell) (cons flag-cell))    (unwind-protect      (let-globally ((*eventhook* eventhook))        (process-wait "Key Event" #'(lambda (flag-cell) (car flag-cell)) flag-cell)        (values message modifiers)))))#|(defun menukey-modifiers-p (mods)  (declare (resident))  (eq (%ilogand *menukey-modifier-mask* mods)      (if *emacs-mode*        (%ilogior2 (%ilsl $shiftkey 1) *menukey-modifier-value*)        (%ilogand2 (%ilognot (%ilsl $shiftkey 1)) *menukey-modifier-value*))))|#; before transformation; do something reasonable when value is unrecognized(defun menukey-modifiers-p (mods)  (declare (resident))  (if (null *control-key-mapping*)    (%ilogbitp $cmdkey mods)    (when (%ilogbitp $cmdkey mods)      (case *control-key-mapping*        (:command-shift (not (%ilogbitp $shiftkey mods)))        (:command (%ilogbitp $shiftkey mods))        (t t)))))#|(defun menukey-event-p (message mods)  (and (menukey-modifiers-p mods)       (%menu-key-p (%ilogand2 message #xFF)))); Returns pseudo-menu event (menuid, itemno) describing menu item; which has command-key equivalent of byte.; Ignores disabled items if enabled-only is non-NIL.; Returns null if no luck.(defun %menu-key-p (byte &optional enabled-only)  (old-lap   (if# (eq (cmp.b ($ $t_imm_char) arg_y)) (swap arg_y) else# (getint arg_y))   (if# (and (ge (cmp.b ($ #\a) arg_y)) (le (cmp.b ($ #\z) arg_y)))      (sub.b ($ #x20) arg_y))   (movereg arg_z d0)   (movereg arg_y d1)   (movem.l #(d0 d1 dsave0 dsave1 dsave2 asave0 asave1) (-@ sp))   (move.l (@ $MenuList) a0)   (move.l (a0) a0)   (move.w (a0 $lastMenu) d3)@menuloop   (beq @none)   (move.l (a0 d3.w) a1)   (move.l (a1) a1)   (move.w (a1 $menuID) d6)   (move.l ($ -1) d2)   (cmp.l (sp) nilreg)   (if# ne     (move.l (a1 $menuEnable) d2)     (btst ($ 0) d2)     (beq @nextmenu))   (add.w ($ $menuData) a1)   (move.l ($ 0) d0)   (move.b (@+ a1) d0)   (add.w d0 a1)   (move.l ($ 1) d1)			; start item # count@itemloop   (move.b (a1) d0)   (beq @nextmenu)   (if# (mi (cmp.w ($ 32) d1))     (btst d1 d2)     (beq @nextmenu))   (lea (a1 d0.w 5) a1)			; point at NEXT length byte   (move.b (a1 -3) d5)   (beq @nextitem)   (if# (and (ge (cmp.b ($ #\a) d5)) (le (cmp.b ($ #\z) d5)))      (sub.b ($ #x20) d5))   (cmp.b (sp 7) d5)   (if# eq     (move.w d1 d7)     (swap d7)     (move.w d6 d7)     (swap d7)     (move.l d7 (sp))@done     (movem.l (@+ sp) #(d0 d1 dsave0 dsave1 dsave2 asave0 asave1))     (movereg d0 acc)     (mkint acc)     (lfret))@nextitem   (add.w ($ 1) d1)   (bra @itemloop)@nextmenu   (sub.w ($ 6) d3)   (bne @menuloop)@none   (movem.l (@+ sp) #(d0 d1 dsave0 dsave1 dsave2 asave0 asave1))   (move.l nilreg acc)   (lfret)))|#(defvar *inside-update-menus* 0)(declaim (fixnum *inside-update-menus*))(defun update-menus-internal (what state was-inside-update-menus)  (let ((oldstate nil)        (changed nil))    (let ((*menubar-frozen* t))      (with-macptrs ((mh (#_LMGetMenuList)))        (let ((offset (%hget-word mh))              mob)          (flet ((menu-update-for-modal (mob state)                   (if was-inside-update-menus                     (ignore-errors                       (menu-update-for-modal mob state))                     (menu-update-for-modal mob state)))                 (menu-update (menu)                   (if was-inside-update-menus                     (ignore-errors (menu-update menu))                     (menu-update menu))))            (declare (dynamic-extent #'menu-update-for-modal #'menu-update))            (while (%i> offset 0)              (when (setq mob (menu-object (%hget-word (%hget-ptr mh offset))))                (let ((before (menu-enabled-p mob)))                  (cond ((eq what :disable)                         (push before oldstate)                         (menu-update-for-modal mob :disable))                        ((eq what :enable)                         (menu-update-for-modal mob (if state                                                      (if (car state) :enable :disable)                                                      :enable))                         (setq state (cdr state)))  ; << cdr folks                        (*modal-dialog-on-top*                         (menu-update-for-modal mob :disable))                        (t (menu-update mob)))                  (unless (eq before (menu-enabled-p mob))                    (setq changed t))))              (setq offset (%i- offset 6)))))))    (when changed (draw-menubar-if))    (when oldstate (nreverse oldstate)))); If state is supplied, this is called in response to a modal dialog; (before if :disable, after if :enable). If :disable, return a state; list; if :enable, use the state list.(defun update-menus (&optional what state)  (let ((was-inside-update-menus (not (eql 0 *inside-update-menus*))))    (unwind-protect      (progn        (incf *inside-update-menus*)        (update-menus-internal what state was-inside-update-menus))      (decf *inside-update-menus*))))#|(defun menus-state ()  (let (m offset state)    (with-macptrs ((mh (#_LMGetMenuList)))      (setq offset (%hget-word mh))      (while (%i> offset 0)        (when (setq m (menu-object (%hget-word (%hget-ptr mh offset))))          (push (menu-enabled-p m) state))        (setq offset (%i- offset 6))))    (nreverse state)))|#(defun menu-selected (mi &aux mob)  (when (setq mob (menu-object (point-v mi)))    (menu-select mob (point-h mi)))); Enough of balloon-help to know when to autoload it.(defvar *help-manager-present* nil)(defvar *alias-manager-present* nil)(defvar *cpu-idle-p* nil)               ; power manager will slow cpu(defvar *can-powermanager-dispatch* nil)  ; can do sleep-q stuff; If any bits in the *periodic-task-mask* are set in the ptaskstate.flags word of; a periodic task, it will not be run(defvar *periodic-task-mask* 0); A callback to store at $menuhook & $draghook to keep up the periodic tasks while the mouse is down.(defpascal draghook ()  (%run-masked-periodic-tasks (+ $ptask_draw-flag $ptask_event-dispatch-flag)))(def-ccl-pointers *help-manager-present* ()  (setq *help-manager-present*  (gestalt #$gestaltHelpMgrAttr  #$gestaltHelpMgrPresent)        *alias-manager-present* (gestalt #$gestaltAliasMgrAttr #$gestaltAliasMgrPresent)        *cpu-idle-p*            (gestalt #$gestaltPowerMgrAttr #$gestaltPMgrCPUIdle)        *can-powermanager-dispatch*  (gestalt #$gestaltPowerMgrAttr #$gestaltPMgrDispatchExists))  (progn    (#_LMSetMenuHook draghook)    (#_LMSetDragHook draghook)))(defun help-on? ()  (and *help-manager-present* (#_HMGetBalloons))) (defun set-cursor (cursor)  "If the argument is the wrong type this does a no-op"  (let ((temp *current-cursor*))    (without-interrupts     (if (fixnump cursor)       (with-macptrs ((temp2 (#_GetCursor cursor)))         (unless (%null-ptr-p temp2)           (#_SetCursor (%setf-macptr temp (%get-ptr temp2)))))       (when (and cursor (pointerp cursor) (not (%null-ptr-p cursor)))         (#_SetCursor (if (not (eql cursor *arrow-cursor*))      ; special case - today cursors are handles or fixnums                        (progn (#_LoadResource cursor)                               (%setf-macptr temp (%get-ptr cursor)))                        (%setf-macptr temp cursor))))))))(defun cursorhook (&aux wob)  (declare (resident))  (rlet ((pt :point)         (wptr-ptr :pointer))    (#_GetMouse pt)    (#_LocalToGlobal pt)    (let ((part-code (#_FindWindow  (%get-long pt)  wptr-ptr)))      (with-macptrs ((wptr (%get-ptr wptr-ptr)))        (if (and (eql part-code $inContent)                 (not (%null-ptr-p (%get-ptr wptr)))                 (setq wob (window-object wptr))                 (or (eq wob *selected-window*) (windoid-p wob)                     (setq wob nil)))          (with-focused-view wob            (#_GlobalToLocal pt)))        (window-update-cursor wob (%get-long pt))))))(defglobal *cursorhook* 'cursorhook)(defmacro with-cursor (cursor &body body)  `(unwind-protect     (let-globally ((*cursorhook* ,cursor))       (update-cursor)       ,@body)     (update-cursor)));set-cursor and update-cursor should be the same function...(defun update-cursor (&optional (hook *cursorhook*))  (when (and (let ((hmp *help-manager-present*))               (and hmp (neq hmp '*help-manager-present*)))             (help-on?))    (setq *help-manager-present* '*help-manager-present*)    (let ((*interrupt-level* 0))      (with-event-processing-enabled ;let-globally ((*processing-events* nil))        (when (or (probe-file #.(merge-pathnames *.fasl-pathname* "ccl:library;help-manager"))                  (probe-file "ccl:library;help-manager.lisp"))          (require "HELP-MANAGER" "ccl:library;help-manager")))))  (when (and *foreground* hook)    (if (or (functionp hook) (symbolp hook))      (funcall hook)      (set-cursor hook))))(defun find-named-periodic-task (name)  (dolist (task *%periodic-tasks%*)    (when (eq name (ptask.name task))      (return task))))(defun %install-periodic-task (name function interval &optional                                     (flags 0)                                    (privatedata (%null-ptr)))  (without-interrupts   (let* ((already (find-named-periodic-task name))          (state (if already (ptask.state already) (make-record ptaskstate)))          (task (or already (%istruct 'periodic-task state name nil))))     (setf (ptask.function task) function)     (setf (rref state ptaskstate.interval) interval           (rref state ptaskstate.flags) flags           (rref state ptaskstate.private) privatedata           (rref state ptaskstate.nexttick) (%tick-sum (get-tick-count) interval))     (unless already (push task *%periodic-tasks%*))     task)))(defmacro with-periodic-task-mask ((mask &optional disable-gc-polling) &body body)  (let ((thunk (gensym)))    `(let ((,thunk #'(lambda () ,@body)))       (funcall-with-periodic-task-mask ,mask ,disable-gc-polling ,thunk))))(defvar *periodic-task-masks* nil)(defvar *gc-polling-disable-count* 0)(declaim (fixnum *gc-polling-disable-count*)); All this hair is so that multiple processes can vote on the *periodic-task-mask*(defun funcall-with-periodic-task-mask (mask disable-gc-polling thunk)  (let* ((cell (list mask)))    (declare (dynamic-extent cell))    (flet ((logior-list (list)             (declare (type list list))             (let ((res 0))               (declare (fixnum res))               (loop                 (when (null list) (return res))                 (setq res (%ilogior res (pop list)))))))      (declare (inline logior-list))      (unwind-protect        (progn          (without-interrupts           (setf (cdr cell) *periodic-task-masks*                 *periodic-task-masks* cell)           (setq *periodic-task-mask* (logior-list *periodic-task-masks*))           (when disable-gc-polling             (incf *gc-polling-disable-count*)             (setf *gc-event-status-bits*                    (%ilogior (lsh 1 $gc-polling-enabled-bit) *gc-event-status-bits*))             ; making this a bignum (on 68k) is in very poor taste             ;(bitsetf $gc-polling-enabled-bit (the fixnum *gc-event-status-bits*))             ))          (funcall thunk))        (without-interrupts         (let* ((first *periodic-task-masks*)                (this first)                (last nil))           (declare (type cons first this last))           (loop             (when (eq this cell)               (if last                 (setf (cdr last) (cdr this))                 (pop first))               (return (setq *periodic-task-masks* first)))             (setq last this                   this (cdr this))))         (setq *periodic-task-mask* (logior-list *periodic-task-masks*))         (when disable-gc-polling           (when (eql 0 (decf *gc-polling-disable-count*))             ; as far as I can tell PPC gc ignores all this event stuff             (setf *gc-event-status-bits*                    (%ilogand (%ilognot (lsh 1 $gc-polling-enabled-bit)) *gc-event-status-bits*))             ;(bitclrf $gc-polling-enabled-bit (the fixnum *gc-event-status-bits*))             )))))))(defun %run-masked-periodic-tasks (&optional (mask $ptask_event-dispatch-flag))  (let-globally ((*in-scheduler* t))    (with-periodic-task-mask (mask t)      (call-with-port %temp-port% #'cmain)))); We only let one process at a time run periodic tasks.; Normally, they will run to completion since they run without-interrupts,; but if one of them does process-wait (e.g. with-focused-view), some; other process might be scheduled. This flag prevents deadlock by; letting that other process do periodic tasks as well.(defvar *running-periodic-tasks* nil)(defun cmain (&optional no-event-dispatch)  (unless (or no-event-dispatch *in-scheduler*)    (let-globally ((*in-scheduler* t))      (let* ((c *current-process*))        (when (and c (> (%tick-difference (get-tick-count) (process.nexttick c))                        0))          (suspend-current-process)))))  (flet ((maybe-run-periodic-task (task)           (let ((now (get-tick-count))                 (state (ptask.state task)))             (when (and (>= (%tick-difference now (rref state ptaskstate.nexttick))                            0)                        (eql 0 (logand (the fixnum (rref state ptaskstate.flags))                                       (the fixnum *periodic-task-mask*))))               (setf (rref state ptaskstate.nexttick) (+ now (rref state ptaskstate.interval)))               (funcall (ptask.function task))))))    (let ((event-dispatch-task *event-dispatch-task*))      (unless no-event-dispatch        (maybe-run-periodic-task event-dispatch-task))      (without-interrupts       (bitclrf $gc-allow-stack-overflows-bit *gc-event-status-bits*)       (unless *running-periodic-tasks*         (let-globally ((*running-periodic-tasks* t))           (dolist (task *%periodic-tasks%*)             (unless (eq task event-dispatch-task)               (maybe-run-periodic-task task)))))))))(defun %remove-periodic-task (name)  (without-interrupts   (let ((task (find-named-periodic-task name)))     (when task (setq *%periodic-tasks%* (delete task *%periodic-tasks%*)))     task))); Is it really necessary to keep this guy in a special variable ?(defloadvar *event-dispatch-task*   (%install-periodic-task    'event-poll   'event-poll   20   (+ $ptask_draw-flag $ptask_event-dispatch-flag)))(defun event-ticks ()  (let ((task *event-dispatch-task*))    (when task (rref (ptask.state task) ptaskstate.interval))))(defun set-event-ticks (n)  (setq n (require-type n '(integer 0 3767)))   ;  Why this weird limit ?  (let ((task *event-dispatch-task*))    (when task (setf (rref (ptask.state task) ptaskstate.interval) n)))); end of L1-events.lisp#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)