;;;-*- Mode: Lisp; Package: CCL -*-;;	Change History (most recent first):;;  10 9/3/96  akh  add some fns so l1-processes can be shared;;  8 4/30/96  akh  kill-stack-group ??;;  7 7/28/95  akh  no warnings;;  5 6/8/95   slh  %get-frame-ptr again;;  4 6/8/95   akh  %get-frame-ptr works for other than current-stack-group;;  3 4/24/95  akh  probably no change;;  2 4/4/95   akh  add free-stackseg and next-stackseg;;  3 1/25/95  akh  make-stack-group - stack size defaults to 64k;;  (do not edit before this line!!);; L1-stack-groups.lisp; Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!;; Modification History;; 3/13/95 slh  added *bind-io-control-vars-per-process*;------------- 3.0d17;07/13/93 bill symbol-value-locative-in-stack-group now looks for the;              LAST binding on *current-stack-group* if it finds no;              binding for the given stack-group.;07/09/93 bill stack-size default -> 16384.;06/29/93 bill default for stack-size in make-stack-group -> 8192.;              sg-previous-stack-group -> previous-stack-group;------------- 3.0d11;03/09/93 bill stack-group-size;02/17/93 bill sg-buffer;01/29/93 bill %in-temp-gspace looks at all stacksegs of tempvbuf;01/28/93 bill make-stack-group has without-interrupts where needed. It also leaves;              the allocation of the initial chunks to $sp-sg-preset. Added a stack-size arg.;01/24/93 bill stack-group-preset runs enough of the initial function to bind *top-listener*;01/17/93 bill sgbuf.csbuf &sgbuf.vsbuf may be 0. Check for that case.;              symbol-value-in-stack-group;01/11/92 bill (temporary-cons-p x) implies (cons-p x);12/17/92 bill typo in %in-non-lisp-area;11/20/92  gb  new file.;---------- 2.0(cl:in-package "CCL")(defvar *current-stack-group*)(eval-when (:compile-toplevel :execute)  (if (fboundp 'compile)    (require "NXENV" "ccl:compiler;nxenv")    (progn      (defmacro ea-reg (ea)        `(%ilogand2 ,ea 7))      (defmacro indirect-displaced-mode (areg)        `(%ilogior2 #o50 (ea-reg ,areg)))      (defconstant $a5 #o15)      (defconstant $jsr #o47200)      (defconstant $jsrA5 (logior $jsr (indirect-displaced-mode $a5)))))  (declaim (type stack-group *current-stack-group*))  (defmacro sg.next (sg)    `(sgbuf.next (%sg-buffer ,sg)))  (defmacro sg.prev (sg)    `(sgbuf.prev (%sg-buffer ,sg)))  (defmacro sg.name (sg)    `(sgbuf.name (%sg-buffer ,sg)))  (defmacro sg.resumer (sg)    `(sgbuf.resumer (%sg-buffer ,sg)))  (defmacro sg.cslimit (sg)    `(sgbuf.cslimit (%sg-buffer ,sg)))  (declaim (inline %sg-buffer))   (defun %sg-buffer (sg)    (lap-inline ()      (:variable sg)      (move.l (varg sg) atemp0)      (move.l (atemp0 4) acc))))(defun stack-group-p (s)  (and (typep s 'function)       (logbitp $lfatr-sg-bit (lfun-attributes s))))(setf (type-predicate 'stack-group) 'stack-group-p)(defun sg-buffer (sg)  (%sg-buffer (require-type sg 'stack-group)))(defmethod print-object ((sg stack-group) stream)  (print-stack-group sg stream nil))(defun print-stack-group (sg stream suppress-address)  (print-unreadable-object (sg stream :type t :identity (not suppress-address))    (format stream "~s" (sg.name sg))))(defun make-stack-group (name &optional (stack-size (%ilsl 2 $default-stackseg-size)))  (setq name (require-type name 'string))  (unless (and (fixnump stack-size) (> (the fixnum stack-size) 0))    (setq stack-size (require-type stack-size '(and fixnum (integer 0 *)))))  (let* ((buf (%gvector $v_sgbuf nil nil name nil nil 0 0 0 0 0 stack-size))         (imms (vector buf))         (sg (%make-lfun imms                          #.(coerce (list $jsrA5 $jsg_funcall 0 0)                                    '(vector (signed-byte 16)))                         #.(coerce (list 4 $lm_longimm)                                   '(vector (signed-byte 16)))                         (dpb 1 $lfbits-numreq                               (ash 1 $lfbits-trampoline-bit))                         (logior (ash 1 $lfatr-resident-bit)                                 (ash 1 $lfatr-noname-bit)                                 (ash 1 $lfatr-sg-bit)                                 (ash 1 $lfatr-immmap-bit)))))    (declare (dynamic-extent imms))    (without-interrupts     (let* ((current *current-stack-group*)            (prev (sg.prev current)))       (setf (sgbuf.sg buf) sg)       (setf (sg.prev sg) prev             (sg.next sg) current             (sg.prev current) sg             (sg.next prev) sg)))))(defun stack-group-size (&optional (stack-group *current-stack-group*))  (let* ((sgbuf (sg-buffer stack-group))         (csbuf (sgbuf.csbuf sgbuf))         (vsbuf (sgbuf.vsbuf sgbuf)))    (when (eq stack-group *current-stack-group*)      (lap-inline ()        (:variable csbuf vsbuf)        (move.l (varg csbuf) atemp0)        (move.l sp (atemp0 $stackseg.first))        (move.l (varg vsbuf) atemp0)        (move.l vsp (atemp0 $stackseg.first))))    (with-macptrs ((csbuf (%int-to-ptr (ash csbuf $fixnumshift)))                   (vsbuf (%int-to-ptr (ash vsbuf $fixnumshift))))      (flet ((segment-size (seg)               (+ (%get-long seg $stackseg.totalsize)                  (- (%get-long seg $stackseg.last)                     (%get-long seg $stackseg.first)))))        (+ (segment-size csbuf)           (segment-size vsbuf)))))); dunno if these make sense in 3.1(defun stack-group-maximum-size (&optional (sg *current-stack-group*))  (sg-buffer sg)                        ; type check  (sgbuf.maxsize sg))(defun (setf stack-group-maximum-size) (value &optional (sg *current-stack-group*))  (sg-buffer sg)                        ; type check  (setq value (require-type value 'fixnum))  (setf (sgbuf.maxsize sg) value))(defvar *bind-io-control-vars-per-process* nil  "If true, bind I/O control variables per process")(defun stack-group-preset (sg function &rest args)  (unless (eq (setq sg (require-type sg 'stack-group)) *current-stack-group*)    (let* ((fn (require-type function 'function)))      (let-globally ((*interrupt-level* -1))        (%primitive $sp-sg-preset                    :arg_z (if *bind-io-control-vars-per-process*                             #'(lambda ()                                  (let ((*top-listener* nil)                                       ; from CLtL2, table 22-7:                                       (*package* *package*)                                       (*print-array* *print-array*)                                       (*print-base* *print-base*)                                       (*print-case* *print-case*)                                       (*print-circle* *print-circle*)                                       (*print-escape* *print-escape*)                                       (*print-gensym* *print-gensym*)                                       (*print-length* *print-length*)                                       (*print-level* *print-level*)                                       (*print-lines* *print-lines*)                                       (*print-miser-width* *print-miser-width*)                                       (*print-pprint-dispatch* *print-pprint-dispatch*)                                       (*print-pretty* *print-pretty*)                                       (*print-radix* *print-radix*)                                       (*print-readably* *print-readably*)                                       (*print-right-margin* *print-right-margin*)                                       (*read-base* *read-base*)                                       (*read-default-float-format* *read-default-float-format*)                                       (*read-eval* *read-eval*)                                       (*read-suppress* *read-suppress*)                                       (*readtable* *readtable*))                                   (stack-group-return nil)                                   (values (apply fn args))))                             #'(lambda ()                                  (let ((*top-listener* nil))                                   (stack-group-return nil)                                   (values (apply fn args)))))                    :atemp0 sg                    :acc)        (funcall sg nil))               ; start it up, so *top-listener* is bound      t)))(defun previous-stack-group (sg)  (sg.resumer (require-type sg 'stack-group)))(defun stack-group-return (value)  (%stack-group-resume (sg.resumer *current-stack-group*) *current-stack-group* value))(defun stack-group-resume (sg value)  (%stack-group-resume (require-type sg 'stack-group) *current-stack-group* value))(defun %stack-group-resume (resumer current value)  (if resumer      (if (eq resumer current)        value        (%primitive $sp-sg-resume :atemp0 resumer :arg_z value :acc))      (error "~s has no resumer." current)))(defun %stack-group-exhausted-p (sg)  (= (the fixnum (sg.cslimit sg)) 0))(defun free-stackseg ()  (lap-inline ()    (move.l (a5 $stacksegs) acc)))(defun next-stackseg (seg)  (lap-inline ()    (:variable seg)    (move.l arg_z atemp0)    (move.l (atemp0 $stackseg.younger) acc)))(eval-when (:compile-toplevel :execute)(defmacro do-inactive-stack-groups ((s) &body body)  (let* ((current (gensym)))    `(do* ((,current *current-stack-group*)           (,s (sg.next ,current) (sg.next ,s)))          ((eq ,s ,current))       ,@body))))(def-ccl-pointers stack-groups ()  (do-inactive-stack-groups (s)    (let* ((function (sgbuf.vslimit (%sg-buffer s))))      (when (functionp function) (stack-group-preset s function)))));;; Low-level stack-frame accessors.(defun %sg-csarea-index (sg)  (lap-inline (sg)    (if# (eq (special *current-stack-group*) arg_z)      (address->index (a5 $csarea) acc)      else#      (move.l arg_z atemp0)      (move.l (atemp0 4) atemp0)      (move.l (svref atemp0 sgbuf.csbuf) atemp0)      (move.l (atemp0 $stackseg.first) atemp0)      (address->index (atemp0 $catch.cs_area) acc))))(defun %get-frame-ptr (&optional (sg *current-stack-group*))  (if (eq sg *current-stack-group*)    (%next-cfp sg (%sg-csarea-index sg) (lap-inline () (address->index sp acc)))        (let* ((sgbuf (sg-buffer sg))           (csbuf (sgbuf.csbuf sgbuf)))      (%next-cfp sg (%sg-csarea-index sg)                 (lap-inline ()                   (:variable csbuf)                   (move.l (varg csbuf) atemp0)                   (move.l (atemp0 $stackseg.first) acc)                   (add.l ($ $catchfsize) acc)                   (address->index acc acc)))))); Return T if idx is the index of a pointer to some part of the vstack;  of stack group "sg".  This is has to deal with the fact that the;  vstack may be segmented.; The caller had to have range-and-alignment-checked "idx" before doing ; "address->index" in the first place, right ?(defun %ptr-to-vstack-p (sg idx)  (lap-inline (sg idx)    (index->address arg_z atemp0)    (move.l arg_y atemp1)    (move.l (atemp1 4) atemp1)    (move.l (svref atemp1 sgbuf.vsbuf) da)    (if# ne      (move.l da atemp1)      (move.l nilreg acc)      (if# (eq (special *current-stack-group*) arg_y)        (move.l vsp (atemp1 $stackseg.first)))      (prog#       (if# (and (leu (atemp1 $stackseg.last) atemp0)                 (geu (atemp1 $stackseg.first) atemp0))         (add.w ($ $t_val) acc)         (bra (exit#)))             (if# (ne (move.l (atemp1 $stackseg.older) arg_y))         (move.l arg_y atemp1)         (bra (top#)))))))(defun %in-non-lisp-area (sg object)  (lap-inline (sg object)    (if# (eq (special *current-stack-group*) arg_y)      (lea (a5 $csarea) atemp1)      else#      (move.l arg_y atemp0)      (move.l (atemp0 4) atemp0)      (move.l (svref atemp0 sgbuf.csbuf) da)      (bif eq @retnil)      (move.l da atemp0)      (move.l (atemp0 $stackseg.first) atemp0)      (lea (atemp0 $catch.cs_area) atemp1))    (loop#     (move.l @atemp1 atemp0)     (if# (eq (tst.l @atemp0))       (move.l @atemp0 atemp0)        (move.l atemp0 atemp1) @retnil       (move.l nilreg acc)        (bra (exit#)))     (move.l @atemp0 atemp1)     (if# (and (cc atemp0 arg_z)               (cs atemp1 arg_z))       (move_t acc)       (bra (exit#))))))(defun %in-temp-space (sg object)  (lap-inline (sg object nil)    (with-preserved-registers #(dsave0)      (clr.l dsave0)      (move.l arg_x atemp0)      (move.l (atemp0 4) atemp0)      (move.l (svref atemp0 sgbuf.tempvbuf) atemp0)      (if# (ne dsave0 atemp0)        (move.l (special *current-stack-group*) da)        (move.l (special *%dynvlimit%*) db)        (prog#         (if# (eq da arg_x)           (if# (eq (atemp0 $stackseg.last) db)             (move.l (special *%dynvfp%*) (atemp0 $stackseg.lastused))))         (if# (and (cc (atemp0 $stackseg.first) arg_y)                   (cs (atemp0 $stackseg.lastused) arg_y))           (add.w ($ $t_val) acc)           (bra (exit#)))         (move.l (atemp0 $stackseg.older) atemp0)         (bif (ne dsave0 atemp0) (top#))))))); Return the scgvector that contains object, if there is one.(defun %containing-vector-on-scgvll (sg object)  (lap-inline (sg object)    (if# (eq (special *current-stack-group*) arg_y)      (lea (a5 (+ $t_vector 4 $scgvll)) atemp0)      else#      (move.l arg_y atemp0)      (move.l (atemp0 4) atemp0)      (move.l (svref atemp0 sgbuf.csbuf) da)      (bif eq @retnil)      (move.l da atemp0)      (move.l (atemp0 $stackseg.first) atemp0)      (lea (atemp0 (+ $t_vector 4 $catch.scgvll)) atemp0))    (loop#     (if# (eq (move.l (atemp0 (- (+ 4 $t_vector))) da))@retnil             (move.l nilreg acc)       (bra (exit#)))     (move.l da atemp0)     (add ($ (+ $t_vector 4)) atemp0)     (vsize atemp0 da)     (lea (atemp0 da.l $v_data) atemp1)     (if# (and (cc atemp0 arg_z)               (cs atemp1 arg_z))       (move.l atemp0 acc)       (bra (exit#))))))(defun containing-scgvector (object)  (or (%containing-vector-on-scgvll *current-stack-group* object)      (do-inactive-stack-groups (sg)        (let* ((v (%containing-vector-on-scgvll sg object)))          (when v            (return v))))))(defun in-any-tempspace (object)  (or (%in-temp-space *current-stack-group* object)      (do-inactive-stack-groups (sg)        (when (%in-temp-space sg object)          (return t)))))(defun in-any-non-lisp-area (object)  (or (%in-non-lisp-area *current-stack-group* object)      (do-inactive-stack-groups (sg)        (when (%in-non-lisp-area sg object)          (return t)))))(defun on-any-vstack (idx)  (or (%ptr-to-vstack-p *current-stack-group* idx)      (do-inactive-stack-groups (sg)        (when (%ptr-to-vstack-p sg idx)          (return t))))); This MUST return either T or NIL.(defun temporary-cons-p (x)  (and (consp x)       (let* ((idx (lap-inline (x) (address->index arg_z acc))))         (not (null (or (on-any-vstack idx)                        (in-any-tempspace x)                        (containing-scgvector x)))))))                                ; takes start pointer in arg_z, containing csarea end pointer in; arg_y, stack group in arg_x.  Returns (values <next (older) cfp or NIL>, <last csarea end pointer>).(defun %next-cfp (sg endptr start)  (declare (fixnum endptr start))  (let* ((previdx 0))    (declare (fixnum previdx))    (incf start)    (loop      (do* ()           ((/= start endptr))        (let* ((next (lap-inline (endptr)                       (index->address arg_z atemp0)                       (address->index @atemp0 acc))))          (declare (fixnum next))          (if (zerop next)            (return-from %next-cfp (values nil endptr)))          (lap-inline (next)            (:variable start endptr)            (index->address arg_z atemp0)            (address->index atemp0@+ da)            (move.l da (varg endptr))            (address->index atemp0 da)            (move.l da (varg start)))          (setq previdx 0)))           (let* ((current start))        (declare (fixnum current))        (unless (= (incf start) endptr)          (when (and (or (zerop previdx)                         (lap-inline (previdx nil)                           (index->address arg_y atemp0)                           (move.l @atemp0 da)                           (if# (ne (a5 $mvexpect) da)                             (add.w ($ $t_val) acc))))                     (%ptr-to-vstack-p sg (lap-inline (current 0)                                            (index->address arg_y atemp0)                                            (if# (and (pl (move.l @atemp0 da))                                                      (eq (progn (moveq 3 db) (and.w da db))))                                              (address->index da acc))))                     (lap-inline (start nil)                       (index->address arg_y atemp0)                       (if# (and (gt (tst.w @atemp0))                                 (eq (btst.l ($ 0) @atemp0)))                         (add.w ($ $t_val) acc))))            (return (values current endptr))))        (setq previdx current)))))(defun symbol-value-in-stack-group (sym sg)  (let ((value-locative (symbol-value-locative-in-stack-group sym sg)))    (if value-locative      (let ((res (lap-inline ()                   (:variable value-locative)                   (move.l (varg value-locative) atemp0)                   (move.l @atemp0 acc))))        (if (eq res (%unbound-marker-8))          (%err-disp $xvunbnd sym)          res))      (symbol-value sym))))(defun (setf symbol-value-in-stack-group) (value sym sg)  (let ((value-locative (symbol-value-locative-in-stack-group sym sg)))    (if value-locative      (lap-inline ()        (:variable value-locative value)        (move.l (varg value-locative) atemp0)        (move.l (varg value) acc)        (move.l acc @atemp0))      (setf (symbol-value sym) value)))); What this returns is tagged as either a cons or a fixnum.; Since it points to the value stack, and we don't hold onto it long; enough for anyone to see anyway, that's OK.(defun symbol-value-locative-in-stack-group (sym sg)  (unless (and (symbolp sym) (stack-group-p sg))    (setq sym (require-type sym 'symbol)          sg (require-type sg 'stack-group)))  (and (neq sg *current-stack-group*)       (or        ; Look for the last binding on sg's binding stack        (lap-inline ()          (:variable sym sg)          (clr.l db)          (move.l (varg sg) atemp0)          (move.l (atemp0 4) atemp0)          (move.l (svref atemp0 sgbuf.csbuf) da)          (bif eq @retnil)          (move.l da atemp0)          (move.l (atemp0 $stackseg.first) atemp0)          (move.l (atemp0 $catch.dblink) atemp0)          (move.l (varg sym) da)          (add.l ($ $sym.gvalue) da)          (sub.l atemp1 atemp1)          (bra @test)          (prog#           (if# (eq (cmp.l (atemp0 4) da))             (move.l atemp0 atemp1))           (move.l @atemp0 atemp0)           @test           (bif (ne db atemp0) (top#)))          (if# (ne db atemp1)            (lea (atemp1 8) atemp1)            (move.l atemp1 acc)            else#            @retnil            (move.l nilreg acc)))	; no binding on sg's binding stack. Look for the saved value in        ; the last binding on the *current-stack-group*'s binding stack.        (lap-inline ()          (:variable sym)          (clr.l db)          (move.l nilreg acc)          (move.l (varg sym) da)          (add.l ($ $sym.gvalue) da)          (move.l (a5 $db_link) atemp0)          (prog#           (lea (atemp0 4) atemp0)           (if# (eq (cmp.l @atemp0 da))             (move.l atemp0 acc)             (add.l ($ 4) acc))           (move.l -@atemp0 atemp0)	   (cmp.l db atemp0)           (bne (top#)))))));; maybe not really needed(defun kill-stack-group (stack-group)  (when (eq stack-group *current-stack-group*)    (error "Attempt to kill *current-stack-group*"))  ;(when (eq stack-group *initial-stack-group*)  ;  (error "Attempt to kill *initial-stack-group*"))  (unless (%stack-group-exhausted-p stack-group)    (%kill-stack-group stack-group)))    ; Kill a stack group.; Unlink it from the *current-stack-group* chain.; Free its stack areas.??; Only called on a stack group with an active thread.; Assumes sg is not *current-stack-group*; what about the chain?(defun %kill-stack-group (sg &optional shutdown-p)  (declare (ignore shutdown-p))  (without-interrupts        (setf (sg.resumer sg) nil)))           #|	Change History (most recent last):	2	12/27/94	akh	merge with d13|# ;(do not edit past this line!!)