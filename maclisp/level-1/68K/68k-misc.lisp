;;; -*- Mode: Lisp; Package: CCL -*-;;	Change History (most recent first):;;  3 10/5/97  akh  see below;;  2 7/4/97   akh  big-point;;  3 9/17/96  akh  change version;;  2 9/3/96   akh  add a comment about incompatibilities;;  1 8/27/96  akh  new file;;  (do not edit before this line!!);;;;;; level-0;68k;68k-misc.lisp;;; or level-1;68k-misc.lisp;(in-package "CCL");; 06/14/97 distinguish big points from points as in PPC version#|How come all the .lisp files show up as "document" in the finder?l1-processes can be same nowDifferences3.1 has short floats, 4.0 doesn'ttype system is different in subtle ways - maybe not hard to change ?shared libraries?? foreign functions??4.0 does better with arithmetic errors - condition includes operation and arguments provides user control over which floating point exceptions to signal3.1 missing condition object in backtrace (easy to fix)Stack allocation is different: 3.1 a process has 2 stacks allocated in Lisp's Mac heap, both stacks can grow. 4.0 a process has 3 stacks allocated in Multifinder temp memory if available, else Mac heap the value and temporary stacks can grow, the control stack cannot. stack-group-max-something?Compiler differences 4.0 inlines more arithmetic ops when arg types are declared. *single-process-p* ? terminate-when-unreachable - needs gc support - lisp stuff is in ppc-stack-groups|#(defun ppc-target-p ())(defun target-platform () :m68k); Copy N bytes from pointer src, starting at byte offset src-offset,; to ivector dest, starting at offset dest-offset.; It's fine to leave this in lap.; Depending on alignment, it might make sense to move more than; a byte at a time.; Does no arg checking of any kind.; from level-0 68k-misc(defun %copy-ptr-to-ivector (src src-offset dest dest-offset n)  (lap-inline ()    (:variable src src-offset dest dest-offset n)    (move.l (varg src) atemp0)    (move.l (atemp0 $macptr.ptr) atemp0)    (move.l (varg src-offset) da)    (getint da)    (add.l da atemp0)    (move.l (varg dest) atemp1)    (move.l (varg dest-offset) da)    (getint da)    (lea (atemp1 da.l $v_data) atemp1)    (move.l (varg n) da)    (getint da)    (dbfloop.l da      (move.b atemp0@+ atemp1@+)))  dest)(defun %copy-ivector-to-ptr (src src-byte-offset dest dest-byte-offset nbytes)  (lap-inline ()    (:variable src src-byte-offset dest dest-byte-offset nbytes)    (move.l (varg dest) atemp0)    (move.l (atemp0 $macptr.ptr) atemp0)    (move.l (varg dest-byte-offset) da)    (getint da)    (add.l da atemp0)    (move.l (varg src) atemp1)    (move.l (varg src-byte-offset) da)    (getint da)    (lea (atemp1 da.l $v_data) atemp1)    (move.l (varg nbytes) da)    (getint da)    (dbfloop.l da      (move.b atemp1@+ atemp0@+)))  dest); Copy bytes from ivector to ivector.  Worth putting more effort into later.(defun %copy-ivector-to-ivector (src src-byte-offset dest dest-byte-offset nbytes)  (lap-inline ()    (:variable src src-byte-offset dest dest-byte-offset nbytes)    (move.l (varg dest) atemp0)    (move.l (varg dest-byte-offset) da)    (getint da)    (lea (atemp0 da.l $v_data) atemp0)    (move.l (varg src) atemp1)    (move.l (varg src-byte-offset) da)    (getint da)    (lea (atemp1 da.l $v_data) atemp1)    (move.l (varg nbytes) da)    (getint da)    (dbfloop.l da      (move.b atemp1@+ atemp0@+)))  dest); from l0-init (why not leave it in l1-init????)(defconstant array-total-size-limit   #-ppc-target #.(/ (expt 2 22) 8)  #+ppc-target #.(expt 2 (- ppc::nbits-in-word ppc::num-subtag-bits))); ditto;Features for #+/- conditionalization:; #+:CORAL = common to ccl and beanie; #+:COMMON-LISP = not MacLisp, not Scheme...; #+:CCL = this particular lisp implementation(defparameter *features*  '(:ccl :ccl-2 :ccl-3    :coral :apple :digitool    :common-lisp :mcl    :cltl2 :processes    #+interfaces-2 :interfaces-2    #+ppc-target :powerpc    #+ppc-target :ppc-target    #+ppc-target :ppc-clos              ; used in encapsulate    :68k-target    :m68k    :ccl-3.1    :ccl-3.3));; from l0-init;All Lisp package variables... Dunno if this still matters, but it;used to happen in the kernel...(dolist (x '(* ** *** *APPLYHOOK* *DEBUG-IO*             *DEFAULT-PATHNAME-DEFAULTS* *ERROR-OUTPUT* *EVALHOOK*             *FEATURES* *LOAD-VERBOSE* *MACROEXPAND-HOOK* *MODULES*             *PACKAGE* *PRINT-ARRAY* *PRINT-BASE* *PRINT-CASE* *PRINT-CIRCLE*             *PRINT-ESCAPE* *PRINT-GENSYM* *PRINT-LENGTH* *PRINT-LEVEL*             *PRINT-PRETTY* *PRINT-RADIX* *QUERY-IO* *RANDOM-STATE* *READ-BASE*             *READ-DEFAULT-FLOAT-FORMAT* *READ-SUPPRESS* *READTABLE*             *STANDARD-INPUT* *STANDARD-OUTPUT* *TERMINAL-IO* *TRACE-OUTPUT*             + ++ +++ - / // /// ARRAY-DIMENSION-LIMIT ARRAY-RANK-LIMIT             ARRAY-TOTAL-SIZE-LIMIT BOOLE-1 BOOLE-2 BOOLE-AND BOOLE-ANDC1             BOOLE-ANDC2 BOOLE-C1 BOOLE-C2 BOOLE-CLR BOOLE-EQV BOOLE-IOR             BOOLE-NAND BOOLE-NOR BOOLE-ORC1 BOOLE-ORC2 BOOLE-SET BOOLE-XOR             CALL-ARGUMENTS-LIMIT CHAR-CODE-LIMIT             DOUBLE-FLOAT-EPSILON DOUBLE-FLOAT-NEGATIVE-EPSILON             INTERNAL-TIME-UNITS-PER-SECOND LAMBDA-LIST-KEYWORDS             LAMBDA-PARAMETERS-LIMIT LEAST-NEGATIVE-DOUBLE-FLOAT             LEAST-NEGATIVE-LONG-FLOAT LEAST-NEGATIVE-SHORT-FLOAT             LEAST-NEGATIVE-SINGLE-FLOAT LEAST-POSITIVE-DOUBLE-FLOAT             LEAST-POSITIVE-LONG-FLOAT LEAST-POSITIVE-SHORT-FLOAT             LEAST-POSITIVE-SINGLE-FLOAT LONG-FLOAT-EPSILON             LONG-FLOAT-NEGATIVE-EPSILON MOST-NEGATIVE-DOUBLE-FLOAT             MOST-NEGATIVE-FIXNUM MOST-NEGATIVE-LONG-FLOAT             MOST-NEGATIVE-SHORT-FLOAT MOST-NEGATIVE-SINGLE-FLOAT             MOST-POSITIVE-DOUBLE-FLOAT MOST-POSITIVE-FIXNUM             MOST-POSITIVE-LONG-FLOAT MOST-POSITIVE-SHORT-FLOAT             MOST-POSITIVE-SINGLE-FLOAT MULTIPLE-VALUES-LIMIT PI             SHORT-FLOAT-EPSILON SHORT-FLOAT-NEGATIVE-EPSILON             SINGLE-FLOAT-EPSILON SINGLE-FLOAT-NEGATIVE-EPSILON ))  (%symbol-bits x (%ilogior2 (%symbol-bits x) (ash 1 $sym_bit_special))))(defparameter *ccl-version* "3.1b1")  ; used in l1-boot(defvar *single-process-p* nil) ; its in l1-stack-groups in ccl4#| ; in l0-cfm-support - work?(defun get-shared-library-entry-point (&rest args)  (declare (ignore args))  (error "no shared libraries for 68K"))(defun get-shared-library-descriptor (&rest args)  (declare (ignore args))  (error "no shared libraries for 68K"))|#(defvar *error-reentry-count* 0)  ; from ppc-trap-support;from 68k pred - where did this stuff go?(defun fixnump (x)   (fixnump x))(defun short-float-p (thing)  (short-float-p thing))(defun double-float-p (thing)  (double-float-p thing))(defun floatp (thing) (floatp thing))(defun istructp (form)  (if (%ttagp $t_vector form)    (= (the fixnum (%vect-subtype form)) $v_istruct))); from l1-dcode in ccl4#-ppc-target(defmacro set-%saved-method-var% (value)  `(locally (declare (special %saved-method-var%))    (setq %saved-method-var% ,value)))#-ppc-clos(defun %apply-lexpr (&rest args)  (declare (ignore args))  (error "shouldn't %apply-lexpr"))(defun assq (a b)  (assq a b))(defun memq (a b)  (memq a b))(defun integer-point-h (x)  (integer-point-h x))(defun integer-point-v (x)  (integer-point-v x)); from ppc-misc - these belong in a shared file - possibly l1-utils(defun make-point (vh &optional v)  (if v    (macrolet ((signed-byte-16-p (x)                 `(and (fixnump ,x)                       (locally (declare (fixnum ,x))                         (and (<= ,x #x7fff)                              (>= ,x #x-8000))))))      (if (and (signed-byte-16-p vh)               (signed-byte-16-p v))        (locally (declare (fixnum vh v))          (if (and (< v (ash (1+ most-positive-fixnum) -16))                   (>= v (ash most-negative-fixnum -16)))            (logior (the fixnum (logand #xffff vh))                    (the fixnum (ash v 16)))            (logior (the fixnum (logand #xffff vh))                    (ash v 16))))        (make-point (max #x-8000 (min vh #x7fff))                    (max #x-8000 (min v #x7fff)))))    (if (consp vh)      (make-point (%car vh) (%cdr vh))      (require-type vh 'integer))))(defun make-big-point (vh &optional v)  (if v    (macrolet ((signed-byte-16-p (x)                 `(and (fixnump ,x)                       (locally (declare (fixnum ,x))                         (and (<= ,x #x7fff)                              (>= ,x #x-8000))))))      (if (and (signed-byte-16-p vh)               (signed-byte-16-p v))        (locally (declare (fixnum vh v))          (if (and (< v (ash (1+ most-positive-fixnum) -16))                   (>= v (ash most-negative-fixnum -16)))            (logior (the fixnum (logand #xffff vh))                    (the fixnum (ash v 16)))            (logior (the fixnum (logand #xffff vh))                    (ash v 16))))        (cons (require-type vh 'integer) (require-type v 'integer))))    (if (consp vh)      (progn        (require-type (%car vh) 'integer)        (require-type (%cdr vh) 'integer)        vh)      (require-type vh 'integer))))(defun add-big-points (pt1 pt2)  (make-big-point (+ (point-h pt1) (point-h pt2))                  (+ (point-v pt1) (point-v pt2))))(defun subtract-big-points (pt1 pt2)  (make-big-point (- (point-h pt1) (point-h pt2))                  (- (point-v pt1) (point-v pt2))))(defun point-h (p)  (if (consp p)    (require-type (%car p) 'integer)    (integer-point-h p)))(defun point-v (p)  (if (consp p)    (require-type (%cdr p) 'integer)    (integer-point-v p)))(defun add-points (pt1 pt2)  (make-point (+ (point-h pt1) (point-h pt2))              (+ (point-v pt1) (point-v pt2))))(defun subtract-points (pt1 pt2)  (make-point (- (point-h pt1) (point-h pt2))              (- (point-v pt1) (point-v pt2)))); do we or don't we need these - called by nilreg-cell-symbol(defvar  %nilreg-fcell-symbols%   #("%ERR-DISP" "CMAIN" "EVAL" "APPLY-EVALUATED-FUNCTION" "ERROR" "%DEFUN" "%DEFVAR"      "%DEFCONSTANT" "%MACRO" "%KERNEL-RESTART"))(defvar  %nilreg-vcell-symbols%  #("*PACKAGE*" "*INTERRUPT-LEVEL*" ("ALLOW-OTHER-KEYS") "%TOPLEVEL-CATCH%"      "%TOPLEVEL-FUNCTION%" "%PASCAL-FUNCTIONS%" "*ALL-METERED-FUNCTIONS*" "*%DYNVFP%*"      "*%DYNVLIMIT%*" "%UNBOUND-FUNCTION%" "*FOREGROUND*" "*BACKGROUND-SLEEP-TICKS*"     "*FOREGROUND-SLEEP-TICKS*" "*WINDOW-UPDATE-WPTR*" "*GC-EVENT-STATUS-BITS*" "*PRE-GC-HOOK*"      "*POST-GC-HOOK*" "%HANDLERS%" "%PARSE-STRING%" "%ALL-PACKAGES%" "*KEYWORD-PACKAGE*"      "%SAVED-METHOD-VAR%" "%FINALIZATION-ALIST%" "*CURRENT-STACK-GROUP*"))  ; end of 68k-misc.lisp