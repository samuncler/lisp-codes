;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  2 4/1/97   akh  see below;;  (do not edit before this line!!);; 03/18/97  akh include make-string-patch;; new file - mostly stuff from 68K version of l1-aprims that is now elsewhere for PPC(in-package :ccl)(defun %validate-radix (radix)  (if (and (typep radix 'fixnum)           (>= (the fixnum radix) 2)           (<= (the fixnum radix) 36))    radix    (progn      (check-type radix (integer 2 36))      radix)))(defun %symbol-locative-symbol (locative)  (new-lap    (:variable locative)   (if# (ne (ttagp ($ $t_symbol) arg_z da))     (wtaerr arg_z 'symbol-locative))   (move.l '0 arg_y)   (move.l arg_z atemp0)   (if# (ne (tst.w -@atemp0))     (move.l ($ $sym.gvalue) arg_y)     (if# (ne (tst.w (atemp0 (- $sym.gvalue))))       (move.l ($ $sym.fapply) arg_y)))   (sub.l arg_y arg_z)   (vpush arg_z)   (mkint arg_y)   (vpush arg_y)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun %vect-byte-size (v)  (declare (%noforcestk))   (lap-inline ()    (:vargs v)    (move.l (varg v) atemp0)    (vsize atemp0 acc)    (mkint acc)))(defun %vect-subtype (v)  (lap-inline ()    (:vargs v)    (move.l (varg v) atemp0)    (vsubtype atemp0 acc)    (ext.w acc)    (ext.l acc)    (mkint acc)))(defun characterp (arg)  (declare (%noforcestk))  (lap-inline (arg)    (sub.b ($ $t_imm_char) arg_z)    (setpred eq da)))(defun consp (arg)  (declare (%noforcestk))  (lap-inline (arg)    (if# (ne nilreg arg_z)      (ttagp ($ $t_cons) arg_z arg_z)      (setpred eq))))(defun %temp-list (&lap &rest args)  (lap    (klexpr 0)    (jsr_subprim $sp-tconslist)    (lfret)))(defun values (&lap &rest args)  (lap   (klexpr)   (jmp_subprim $sp-nvalret))); The type-checking done on the "plist" arg shouldn't be removed.; (The new definition of SYMBOLP doesn't like the 16 lsbits of symbol plists; to become 0.)(defun set-symbol-plist (sym plist)  (lap-inline ()    (:variable sym plist)    (movem.l #(arg_y arg_z) -@vsp)    (ccall list-length arg_z)    (move.l acc da)    (cmp.l nilreg da)    (movem.l vsp@+ #(arg_y arg_z))    (if# ne      (btst ($ $fixnumshift) da)      (if# ne        (ccall error '"Odd list length ~S" arg_z))      (move.l arg_y atemp0)      (jsr_subprim $sp-check-sym)      (move.l (atemp0 $sym.package-plist) atemp1)      (btst ($ $sym_vbit_typeppred) (atemp0 $sym.vbits))      (sne db)      (ttagp ($ $t_cons) atemp1 da)      (if# (and (eq nilreg arg_z) (eq (tst.b da)) (eq (tst.b db)))        (move.l (car atemp1) (atemp0 $sym.package-plist))        else#; The following line WAS just "(if# (eq (tst.b da))"; hence NIL; would get %RPLACD'ed.  Woops.        (if# (and (eq (tst.b da)) (ne atemp1 nilreg))          (if# (ne (tst.b db)) (cdr atemp1 atemp1))          (rplacd atemp1 arg_z)          else#          (vpush arg_z)          (vpush atemp0)          (move.l atemp1 arg_y)          (jsr_subprim $sp-consYZ)          (vpop atemp0)          (move.l acc (atemp0 $sym.package-plist))          (vpop acc))))))(defun symbol-plist (sym)  (lap-inline ()    (:variable sym)    (move.l arg_z atemp0)    (jsr_subprim $sp-check-sym)    (btst ($ $sym_vbit_typeppred) (atemp0 $sym.vbits))    (sne db)    (move.l (atemp0 $sym.package-plist) atemp0)    (if# (eq (ttagp ($ $t_cons) atemp0 da))      (if# (ne (tst.b db)) (cdr atemp0 atemp0))      (cdr atemp0 acc)      else#      (move.l nilreg acc))))(defun symbol-name (sym)  (lap-inline ()    (:variable  sym)    (move.l arg_z atemp0)    (jsr_subprim $sp-check-sym)    (move.l (atemp0 $sym.pname) acc)))(defun symbol-package (sym)  (lap-inline ()    (:variable  sym)    (move.l arg_z atemp0)    (jsr_subprim $sp-check-sym)    (move.l (atemp0 $sym.package-plist) arg_z)    (if# (eq (ttagp ($ $t_cons) arg_z da))      (move.l arg_z atemp0)      (car atemp0 acc))))(defun %function (sym)  (lap-inline ()    (:variable  sym)    (move.l arg_z atemp0)    (jsr_subprim $sp-check-sym)    (jsr_subprim $sp-%function)    (move.l atemp0 acc)))(defun %progvrestore (&lap saved)  (lap-inline ()    (move.l arg_z atemp0)    (until# (eq atemp0 nilreg)      (car atemp0 atemp1)      (cdr atemp0 atemp0)      (cdr atemp1 da)      (car atemp1 atemp1)      (btst ($ $sym_bit_indirect) (atemp1 $sym.vbits))      (add.w ($ $sym.gvalue) atemp1)      (if# ne        (move.l @atemp1 atemp1))      (move.l da @atemp1))    (move.l nilreg acc)))(defun copy-uvector (uv)  (lap-inline ()    (:variable uv)    (move.l arg_z atemp0)    (if# (eq (dtagp arg_z $t_vector))      (wtaerr arg_z 'uvector))    (vpush atemp0)    (vsize atemp0 acc)    (vsubtype atemp0 arg_y)    (jsr_subprim $sp-allocvect)    (move.l atemp0 acc)    (vpop atemp1)    (add.w ($ $v_data) atemp1)    (getvect atemp0 da)    (add.l ($ 3) da)                     ; Vectors are always longword-aligned,    (lsr.l ($ 2) da)                     ; so just copy enuff longwords...    (bra @1)    @0 (move.l (@+ atemp1) (@+ atemp0))    @1 (dbfl da @0)))(when (not (fboundp '%boot-fasload))  (%fhave '%boot-fasload #'%fasload)); fix faslood for extended filenames - could patch 4.0 the same way - need byte-length defined (defun %fasload (string-or-refnum)  (when (extended-string-p string-or-refnum)    ; make a phoney base-string    (let ((newstring           (make-string (byte-length string-or-refnum) :element-type 'base-character)))      (let ((j 0))        (dotimes (i (length string-or-refnum))          (let* ((char (schar string-or-refnum i))                 (code (char-code char)))            (if (< code #x100)              (setf (schar newstring j) char)              (progn                 (setf (schar newstring j)(code-char (ash code -8)))                (setf (schar newstring (setq j (1+ j)))(code-char (logand code #xff)))))            (setq j (1+ j)))))      (setq string-or-refnum newstring)))      (%boot-fasload string-or-refnum))(defun base-string-p (thing)  (declare (%noforcestk))  (lap-inline (thing nil)    (if# (and (ne (dtagp arg_y $t_vector))              (or (eq (progn (move.l arg_y atemp0) (vsubtypep ($ $v_sstr) atemp0 da)))                  (and (eq (cmp.b ($ $v_arrayh) da))                       (eq (cmp.b ($ $v_sstr) (svref atemp0 arh.fixnum $arh_type)))                       (eq (cmp.w ($ $arh_one_dim) (svref atemp0 arh.fixnum $arh_rank4))))))      (add.w ($ $t_val) acc))))(setf (type-predicate 'base-string) 'base-string-p)(defun simple-base-string-p (thing)  (declare (%noforcestk))  (lap-inline (thing nil)   (if# (and (ne (dtagp arg_y $t_vector))             (eq (progn (move.l arg_y atemp0) (vsubtypep ($ $v_sstr) atemp0 da))))     (add.w ($ $t_val) acc))))(setf (type-predicate 'simple-base-string) 'simple-base-string-p); This needs to get hairier if CHARACTER and BASE-CHARACTER become disjoint.;(defvar *default-character-type* 'base-character);(defun make-string (size &rest args &key initial-element (element-type *default-character-type* element-type-p)) )(defun make-string (size &key initial-element (element-type 'character element-type-p))  (declare (dynamic-extent args))  (when (and initial-element (not element-type-p))    ; perhaps we should whine if element type is base and initial element is extended    (setq element-type (type-of initial-element) element-type-p t))  (unless (or (eq element-type 'base-character)              (eq element-type 'standard-char)              (subtypep element-type 'base-character))    (if (subtypep element-type 'character)      ; how bout initial element?      (return-from make-string        (if initial-element          (make-array size :element-type element-type :initial-element initial-element)          (make-array size :element-type element-type)))      (error "Element type ~S is not a subtype of ~S" element-type 'character)))  (lap-inline (size)    (:variable initial-element size)   (if# (or (ne (ttagp ($ $t_fixnum) arg_z da))            (mi (getint arg_z)))     (wtaerr (varg size) 'unsigned-byte))   (jsr_subprim $sp-makestr)           ; atemp0,acc,atemp1 <- MakeStr(acc)   (move.l (varg initial-element) arg_y)   (if# (ne (cmp.l nilreg arg_y))     (if# (eq (cmp.b ($ #x0f) arg_y))       (move.b ($ $t_imm_char) arg_y))     (if# (ne (cmp.b ($ $t_imm_char) arg_y))       (wtaerr arg_y 'character))     (swap arg_y)     (vsize atemp0 da)     (bra @1)@0   (move.b arg_y (@+ atemp1))@1   (dbfl da @0))))#|(defun make-string (size &rest args &key initial-element (element-type *default-character-type* element-type-p))  (declare (dynamic-extent args))  (when (and initial-element (not element-type-p))    ; perhaps we should whine if element type is base and initial element is extended    (setq element-type (type-of initial-element) element-type-p t))  (when (and ;element-type-p             ;(neq element-type 'character)             (not (or (eq element-type 'base-character)(eq element-type 'standard-char)))) ; yech    (if (subtypep element-type 'character)      ; how bout initial element?      (return-from make-string        (if initial-element          (make-array size :element-type element-type :initial-element initial-element)          (apply #'make-array size args)))      (error "Element type ~S is not a subtype of ~S" element-type 'character)))  (lap-inline (size)    (:variable initial-element size)   (if# (or (ne (ttagp ($ $t_fixnum) arg_z da))            (mi (getint arg_z)))     (wtaerr (varg size) 'unsigned-byte))   (jsr_subprim $sp-makestr)           ; atemp0,acc,atemp1 <- MakeStr(acc)   (move.l (varg initial-element) arg_y)   (if# (ne (cmp.l nilreg arg_y))     (if# (eq (cmp.b ($ #x0f) arg_y))       (move.b ($ $t_imm_char) arg_y))     (if# (ne (cmp.b ($ $t_imm_char) arg_y))       (wtaerr arg_y 'character))     (swap arg_y)     (vsize atemp0 da)     (bra @1)@0   (move.b arg_y (@+ atemp1))@1   (dbfl da @0))))|#(defun array-element-subtype (array)  (lap-inline ()    (:variable array)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (if# eq (move.b (svref atemp0 arh.fixnum $arh_type) da))   (move.w da acc)   (ext.l acc)   (mkint acc)))(defconstant array-element-subtypes  '#(extended-character     (unsigned-byte 8)     (unsigned-byte 16)     double-float     (signed-byte 32)     (unsigned-byte 32)     bit     (signed-byte 8)     (signed-byte 16)     base-character     t))(defun array-element-type (array)  (lap-inline ()    (:variable array)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (if# eq (move.b (svref atemp0 arh.fixnum $arh_type) da))   (add.w da da)   (move.l '#.array-element-subtypes atemp0)   (move.l (atemp0 da.w (- $v_data (* 2 $v_min_arr))) acc)))(defun array-rank (array)  (lap-inline ()    (:variable array)    (move.l arg_z atemp0)    (move.l (fixnum 1) acc)    (jsr_subprim $sp-arrayarg)          ; preserves acc    (if# eq      (move.w (vref.l atemp0 arh.fixnum $arh_rank4) acc)      (vunscale.l acc))))(defun arrayp (thing)  (declare (%noforcestk))  (lap-inline (thing nil)   (if# (and (ne (dtagp arg_y $t_vector))             (ge (progn (move.l arg_y atemp0) (vsubtype atemp0 da) (sub.b ($ $v_min_arr) da)))             (le (sub.b ($ (- $v_arrayh $v_min_arr)) da)))     (add.w ($ $t_val) acc))))(defun vectorp (thing)  (declare (%noforcestk))  (lap-inline (thing nil)   (if# (and (ne (dtagp arg_y $t_vector))             (ge (progn (move.l arg_y atemp0) (vsubtype atemp0 da) (sub.b ($ $v_min_arr) da)))             (le (sub.b ($ (- $v_arrayh $v_min_arr)) da))             (or ne (eq (cmp.w ($ $arh_one_dim) (vref.l atemp0 arh.fixnum $arh_rank4)))))     (add.w ($ $t_val) acc))))(defun gvectorp (thing)  (declare (%noforcestk))  (lap-inline (thing nil)    (if# (and (ne (dtagp arg_y $t_vector))              (ne (progn (move.l arg_y atemp0)                         (btst.l ($ $header-gvector-bit) (atemp0 $vec.header)))))      (add.w ($ $t_val) acc))))(defun uvectorp (arg)  (declare (%noforcestk))  (lap-inline (arg nil)    (if# (ne (dtagp arg_y $t_vector))      (add.w ($ $t_val) acc)))); all characters are no longer base-characters.(defun extended-character-p (c)  (declare (%noforcestk))  (old-lap-inline (c nil)    (move.l ($ $t_imm_char) da)    (if# (and (eq (cmp.b da arg_y))              (ne (progn                     (rol.l ($ 8) arg_y)                    (tst.b  arg_y))))      (add.w ($ $t_val) acc))))(defun base-character-p (c)  (declare (%noforcestk))  (old-lap-inline (c nil)    (move.l ($ $t_imm_char) da)    (if# (and (eq (cmp.b da arg_y))              (eq (progn                     (rol.l ($ 8) arg_y)                    (tst.b  arg_y))))      (add.w ($ $t_val) acc))))    (defun simple-vector-p (thing)  (declare (%noforcestk))  (lap-inline (thing nil)   (if# (and (ne (dtagp arg_y $t_vector))             (eq (progn (move.l arg_y atemp0) (vsubtype= ($ $v_genv) atemp0 da))))     (add.w ($ $t_val) acc))))(defun simple-string-p (thing)  (declare (%noforcestk))  (lap-inline (thing nil)   (if# (and (ne (dtagp arg_y $t_vector))             (or (eq (progn (move.l arg_y atemp0) (vsubtypep ($ $v_sstr) atemp0 da)))                 (eq (cmp.b ($ $v_xstr) da))))     (add.w ($ $t_val) acc))))(defun stringp (thing)  (declare (%noforcestk))  (lap-inline (thing nil)    (if# (and (ne (dtagp arg_y $t_vector))              (or (eq (progn (move.l arg_y atemp0) (vsubtypep ($ $v_sstr) atemp0 da)))                  (eq (cmp.b ($ $v_xstr)  da))                  (and (eq (cmp.b ($ $v_arrayh) da))                       (or (eq (progn                                  (move.b (svref atemp0 arh.fixnum $arh_type) da)                                                              (cmp.b ($ $v_sstr) da)))                           (eq (cmp.b ($ $v_xstr) da)))                       (eq (cmp.w ($ $arh_one_dim) (svref atemp0 arh.fixnum $arh_rank4))))))      (add.w ($ $t_val) acc))))(defun bit-vector-p (thing)  (declare (%noforcestk))  (lap-inline (thing nil)    (if# (and (ne (dtagp arg_y $t_vector))              (or (eq (progn (move.l arg_y atemp0) (vsubtypep ($ $v_bitv) atemp0 da)))                  (and (eq (cmp.b ($ $v_arrayh) da))                       (eq (cmp.b ($ $v_bitv) (svref atemp0 arh.fixnum $arh_type)))                       (eq (cmp.w ($ $arh_one_dim) (svref atemp0 arh.fixnum $arh_rank4))))))      (add.w ($ $t_val) acc))));This is true for multi-dimensional simple arrays...(defun displaced-array-p (array)  (new-lap    (:variable array)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (if# eq     (vpush (svref atemp0 arh.vect))     (vpush (svref atemp0 arh.offs))    else#     (vpush nilreg)     (clr.l (-@ vsp)))                  ; (fixnum 0)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun adjustable-array-p (array)  (lap-inline ()    (:variable array)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (if# ne     (move.l nilreg acc)   else#     (btst ($ $arh_adjp_bit) (svref atemp0 arh.fixnum $arh_bits))     (setpred ne da))))(defun array-has-fill-pointer-p (array)  (lap-inline ()    (:variable array)   (move.l arg_z atemp0)   (move.l nilreg acc)   (jsr_subprim $sp-arrayarg)          ; preserves acc   (if# (and eq (ne (btst ($ $arh_fill_bit) (vref.l atemp0 arh.fixnum $arh_bits))))     ;(move.l (svref atemp0 arh.fill) acc)     (add.w ($ $t_val) acc))))(defun fill-pointer (array)  (lap-inline ()    (:variable array)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (bne @bad)   (btst ($ $arh_fill_bit) (vref.l atemp0 arh.fixnum $arh_bits))   (beq @bad)   (move.l (svref atemp0 arh.fill) acc)   (bra @done)@bad   (Tsignal_error (fixnum $XNOFILLPTR) atemp0)@done))(defun set-fill-pointer (array value)  "Returns value.  Allows value = T to mean current length."  (lap-inline ()    (:variable array value)   (move.l arg_y atemp0)   (jsr_subprim $sp-arrayarg)          ; preserves arg_z   (bne @badarr)   (btst.b ($ $arh_fill_bit) (vref.l atemp0 arh.fixnum $arh_bits))   (beq @badarr)   (if# (eq (cmp.l (a5 $t) arg_z))     (move.l (svref atemp0 arh.vlen) arg_z)    else#     (ttagp ($ $t_fixnum) arg_z da)     (bne @badidx)     (cmp.l (svref atemp0 arh.vlen) arg_z)     (bgtu @idxoob))   (move.l arg_z (svref atemp0 arh.fill))   (bra @done)@badarr	(Tsignal_error (fixnum $XNOFILLPTR) atemp0)@badidx	(wtaerr arg_z 'fixnum)@idxoob (Tsignal_error (fixnum $XARROOB) arg_z atemp0)@done))(defun %make-uvector (len &optional subtype (init nil init-p))  (unless init-p (if (eql subtype $v_floatv) (setq init 0.0d0)))  (lap-inline (init len subtype)    (:variable len subtype init init-p)    (if# (eq arg_z nilreg)      (move.l ($ $v_genv) da)     else#      (bif (or (ne (ttagp ($ $t_fixnum) arg_z da))               (ne (btst ($ $fixnumshift) arg_z))) @badz)      (move.l arg_z da)      (getint da))    (bif (or (mi (move.l arg_y acc))             (ne (ttagp ($ $t_fixnum) acc db))) @badz)    (if# (or (ne (varg init-p) nilreg)             (ne arg_x nilreg)             (ne (btst ($ $vnodebit) da)))      (jsr_subprim $sp-uvd1alloc-init)      (move.l atemp0 acc)      else#      (jsr_subprim $sp-uvd1alloc))    (bra @popj)    @badz    (wtaerr arg_z 'unsigned-byte)@popj))(defun aref (&lap array &rest subscripts)  ;(declare (arglist array &rest subscripts))  (lap    (if# (eq (cmp.w ($ 8) nargs))      (move.l arg_y atemp0)      (jmp_subprim $sp-aref1))    (klexpr 1)    (lea (vsp nargs.w) atemp1)    (move.l (atemp1) atemp0)    (if# (ne (jsr_subprim $sp-arrayarg))         ; preserves atemp1,nargs      (move.l ($ 0) acc)                ; Only aref1 for simple arrays      (move.w nargs acc)      (vunscale.l acc)      (signal_error (fixnum $XNDIMS) atemp0 acc))    (if# (mi (jsr_subprim $sp-arridx))      (signal_error (fixnum $XARROOB) db atemp0))    (move.l acc db)    (prog#     (add.l (svref atemp0 arh.offs) db)     (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))     (move.l (svref atemp0 arh.vect) atemp0)     (until# eq))    (vsubtype atemp0 da)    (jsr_subprim $sp-uvd1ref)    (lfret)))(defun aset (&lap array &rest subscripts-then-value)  ;(declare (arglist array &rest subscripts-then-value))  (lap    (if# (eq (cmp.w ($ 12) nargs))      (jmp_subprim $sp-aset1))    (klexpr 2)    (lea (vsp nargs.w 4) atemp1)    (move.l (atemp1) atemp0)    (if# (ne (jsr_subprim $sp-arrayarg))         ; preserves atemp1,nargs      (move.l ($ 0) acc)      (move.w nargs acc)      (vunscale.l acc)      (signal_error (fixnum $XNDIMS) atemp0 acc))    (if# (mi (jsr_subprim $sp-arridx))      (signal_error (fixnum $XARROOB) db atemp0))    (move.l acc db)    (move.l (vsp) acc)    (prog#     (add.l (svref atemp0 arh.offs) db)     (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))     (move.l (svref atemp0 arh.vect) atemp0)     (until# eq))    (vsubtype atemp0 da)    (jsr_subprim $sp-uvd1set)    (lfret)))(defun vector-push (elt vector)  ; Return nil if can't do it.  What a useless function!  (lap-inline ()    (:variable elt vector)    (move.l arg_z atemp0)    (move.l arg_y arg_z)    (if# (or (ne (jsr_subprim $sp-arrayarg))             (eq (btst.b ($ $arh_fill_bit) (svref atemp0 arh.fixnum $arh_bits))))      (signal_error (fixnum $XNOFILLPTR) atemp0))    (move.l (svref atemp0 arh.fill) db)    (if# (eq (svref atemp0 arh.vlen) db)      (move.l nilreg acc)     else#      (vpush atemp0)      (prog#       (add.l (svref atemp0 arh.offs) db)       (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))       (move.l (svref atemp0 arh.vect) atemp0)       (until# eq))      (vsubtype atemp0 da)      (jsr_subprim $sp-uvd1set)      (vpop atemp0)      (move.l (svref atemp0 arh.fill) acc)      (add.l '1 (svref atemp0 arh.fill)))))(defun vector-push-extend (elt vector &optional extension)  (lap-inline ()    (:variable extension vector elt)    (move.l arg_x arg_z)    (move.l arg_y atemp0)    (if# (or (ne (jsr_subprim $sp-arrayarg))             (eq (btst ($ $arh_fill_bit) (svref atemp0 arh.fixnum $arh_bits))))         (signal_error (fixnum $XNOFILLPTR) atemp0))    (move.l (svref atemp0 arh.fill) db)    (if# (eq (svref atemp0 arh.vlen) db)      (if# (eq (btst.b ($ $arh_adjp_bit) (svref atemp0 arh.fixnum $arh_bits)))           (signal_error (fixnum $XMALADJUST) atemp0))      (move.l (varg extension) da)      (if# (eq nilreg da)        (move.l db da)        (asr.l ($ (1+ $fixnumshift)) da)        (lsl.l ($ $fixnumshift) da)        (add.l '1 da)       else#        (if# (or (ne (ttagp ($ $t_fixnum) da dy))                 (le (tst.l da)))          (wtaerr da 'unsigned-byte)))      (add.l db da)      (vpush acc)      (jsr_subprim $sp-vresize)      (vpop acc)      (move.l (svref atemp0 arh.fill) db))    (vpush atemp0)    (prog#     (add.l (svref atemp0 arh.offs) db)     (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))     (move.l (svref atemp0 arh.vect) atemp0)     (until# eq))    (vsubtype atemp0 da)    (jsr_subprim $sp-uvd1set)    (vpop atemp0)    (move.l (svref atemp0 arh.fill) acc)    (add.l '1 (svref atemp0 arh.fill))))(defun array-dimension (array axis-number)  (lap-inline ()    (:variable array axis-number)    (move.l arg_y atemp0)    (jsr_subprim $sp-arrayarg)         ; preserves acc    (if# eq      (if# (ne (ttagp ($ $t_fixnum) arg_z db))         (wtaerr arg_z 'fixnum))      (move.l arg_z db)      (vscale.l db)      (move.l ($ 0) da)      (move.w (svref atemp0 arh.fixnum $arh_rank4) da)      (if# (geu (cmp.l da db))        (tsignal_error (fixnum $XARROOB) da atemp0))      (move.l (atemp0 db.w (+ $v_data (* 4 arh.dims))) acc)     else#      (if# (ne (tst.l arg_z))        (if# (eq (dtagp arg_z $t_fixnum))          (wtaerr arg_z 'fixnum))        (signal_error (fixnum $XNDIMS) atemp0 arg_z))      (jsr_subprim $sp-uvd1siz))))(defun array-dimensions (array)  (lap-inline ()    (:variable array)    (move.l arg_z atemp0)    (jsr_subprim $sp-arrayarg)    (if# eq      (preserve_regs #(asave0 dsave0))      (move.l nilreg acc)      (move.l atemp0 asave0)      (move.l '0 dsave0)      (move.w (svref asave0 arh.fixnum $arh_rank4) dsave0)      (vunscale.l dsave0)      (bra @next)      (prog#       (move.l dsave0 da)       (vscale.l da)       (move.l (asave0 da.l (+ $v_data (* 4 arh.dims))) arg_y)       (jsr_subprim $sp-consyz)       @next (sub.l '1 dsave0)       (until# cs))      (restore_regs)     else#      (jsr_subprim $sp-uvd1siz)      (jsr_subprim $sp-consZnil))))(defun array-total-size (array)  (lap-inline ()    (:variable array)    (move.l arg_z atemp0)    (if# (eq (jsr_subprim $sp-arrayarg))      (if# (eq (move.w (svref atemp0 arh.fixnum $arh_rank4) arg_x))        (move.l '1 acc)        (bra @popj))      (lea (svref atemp0 arh.dims) atemp0)      (move.l (@+ atemp0) acc)          ; First dimension      (bra @next)      (prog#       (move.l (@+ atemp0) da)          ; Next dimension       (getint da)       (swap acc)                       ; Compute acc <- acc*da       (move.w da db)       (mulu acc db)       (swap acc)       (move.l da dy)       (swap dy)       (mulu acc dy)       (add.w dy db)       (swap db)       (clr.w db)       (mulu da acc)       (add.l db acc)       @next (until# (eq (sub.w ($ 4) arg_x))))     else#      (jsr_subprim $sp-uvd1siz))    @popj))(defun equal (x y)  (lap-inline (x y)    (:variable x y)@tail    (if# (eq arg_y arg_z)@ret_t      (move_t acc)      (lfret))    (bif (eq (ttag arg_z da)) @ret_nil) ; a fixnum    (bif (eq (ttag arg_y db)) @ret_nil) ; a fixnum    (bif (ne (cmp.b da db)) @ret_nil)    (move.l arg_z atemp0)    (move.l arg_y atemp1)    (if# (eq (sub.b ($ $t_cons) db))      (bif (eq arg_y nilreg) @ret_nil)      (bif (eq arg_z nilreg) @ret_nil)      (car atemp0 arg_z)      (vpush (cdr atemp0))      (car atemp1 arg_y)      (vpush (cdr atemp1))      (ccall equal arg_y arg_z)      (if# (ne acc nilreg)        (vpop arg_y)        (vpop arg_z)        (move.l arg_y (varg x))        (move.l arg_z (varg y))        (bra @tail))      (add.w ($ 8) vsp)      (lfret))    (if# (eq (cmp.b ($ $t_dfloat) da))      (sub.w da atemp0)      (sub.w da atemp1)      (bif (and (eq (cmp.l atemp0@+ atemp1@+))                (eq (cmp.l atemp0@+ atemp1@+))) @ret_t)@ret_nil      (move.l nilreg acc)      (lfret)); all other types (including numeric types) are vectors.    (bif (ne (sub.b ($ $t_vector) da)) @ret_nil)    (vsubtype atemp0 da)    (bif (eq (cmp.b ($ $v_sstr) da)) @strequal)    (if# (eq (cmp.b ($ $v_xstr) da))      (vsubtype atemp1 da)      (bif (eq (cmp.b ($ $v_xstr) da)) @xstrequal)      (exg arg_y arg_z)      (bra @tail))    (bif (eq (cmp.b ($ $v_bitv) da)) @bitequal)    (bif (eq (cmp.b ($ $v_arrayh) da)) @arrayequal)    (if# (eq (cmp.b ($ $v_macptr) da))      (move.l (atemp0 $macptr.ptr) da)      (cmp.l (atemp1 $macptr.ptr) da)      (bne @ret_nil)      (beq @ret_t))    (bif (ne (cmp.b ($ $v_istruct) da)) @numequal)    (bif (ne (progn (vsubtype atemp1 dx) (cmp.b dx da))) @ret_nil)    (bif (eq (vsize atemp0 dtemp0)) @ret_nil)    (vsize atemp1 dtemp1)    (bif (ne dtemp0 dtemp1) @ret_nil)    (move.l (atemp0 $v_data) dtemp0)    (bif (and (ne (cmp.l 'pathname dtemp0))              (ne (cmp.l 'logical-pathname dtemp0)))         @ret_nil)    (preserve_regs #(asave0 asave1 dsave0))    (move.l atemp1 asave1)    (move.l atemp0 asave0)    (move.l dtemp1 dsave0)    (vunscale.l dsave0)    (prog#     (sub.l '1 dsave0)     (bmi (exit#))     (move.l dsave0 da)     (vscale.l da)     (ccall equalp (asave0 da.l $v_data) (asave1 da.l $v_data))     (cmp.l nilreg acc)     (bne (top#)))    (restore_regs)    (lfret); arg_z=atemp0 & arg_y=atemp1 are vectors , subtype of atemp0 is in da@numequal    (jsr_subprim $sp-vnumeql2_a)    (lfret)@arrayequal    (bif (ne (cmp.w ($ $arh_one_dim) (svref atemp0 arh.fixnum $arh_rank4))) @ret_nil)    (move.l (svref atemp0 arh.fill) dtemp0)    (move.l '0 da)    (prog#     (add.l (svref atemp0 arh.offs) da)     (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))     (move.l (svref atemp0 arh.vect) atemp0)     (bne (top#)))    (vsubtype atemp0 dtemp1)    (bif (eq (cmp.b ($ $v_bitv) dtemp1)) @xbitequal)    (if# (eq (cmp.b ($ $v_xstr) dtemp1))      (vsubtype atemp1 dtemp1)      (bif (eq (cmp.b ($ $v_xstr) dtemp1)) @xstrequal0)      (bif (eq (cmp.b ($ $v_sstr) dtemp1)) @xstrequal0)      (bif (ne (cmp.w ($ $arh_one_dim) (svref atemp1 arh.fixnum $arh_rank4))) @ret_nil)      (prog#       (btst ($ $arh_disp_bit) (svref atemp1 arh.fixnum $arh_bits))       (move.l (svref atemp1 arh.vect) atemp1)       (bne (top#)))      (vsubtype atemp1 dtemp1)      (bif (eq (cmp.b ($ $v_xstr) dtemp1)) @xstrequal0)      (bif (eq (cmp.b ($ $v_sstr) dtemp1)) @xstrequal0)      (bra @ret_nil))    (bif (ne (cmp.b ($ $v_sstr) dtemp1)) @ret_nil)    (getint da)    (lea (atemp0 da.l $v_data) atemp0) ;atemp0=ptr    (getint dtemp0) ;dtemp0=len    (bra @str2)@strequal    (getvect atemp0 dtemp0)@str2    (vsubtype atemp1 dtemp1)    (bif (eq (cmp.b ($ $v_sstr) dtemp1)) @xstr2)    (bif (eq (cmp.b ($ $v_xstr) dtemp1)) @xstrequal0)    (bif (or (ne (cmp.b ($ $v_arrayh) dtemp1))              (ne (cmp.w ($ $arh_one_dim) (svref atemp1 arh.fixnum $arh_rank4)))) @ret_nil2)    (move.l (svref atemp1 arh.fill) da)    (getint da)    (bif (ne (sub.l dtemp0 da)) @ret_nil2)    (prog#     (add.l (svref atemp1 arh.offs) da)     (btst ($ $arh_disp_bit) (svref atemp1 arh.fixnum $arh_bits))     (move.l (svref atemp1 arh.vect) atemp1)     (bne (top#)))    (vsubtype atemp1 dtemp1)    (bif (eq (cmp.b ($ $v_xstr) dtemp1)) @xstrequal0)  ; <<    (bif (ne (cmp.b ($ $v_sstr) dtemp1)) @ret_nil2)    (getint da)    (lea (atemp1 da.l $v_data) atemp1)    (bra @strcmp)@xstr2    (getvect atemp1 dtemp1)    (bif (ne dtemp0 dtemp1) @ret_nil2)    (bra @strcmp)@strlp    (cmp.b atemp0@+ atemp1@+)    (dbne dtemp0 @strlp)    (if# ne@ret_nil2      (move.l nilreg acc)      (lfret))    (add.w ($ 1) dtemp0)@strcmp    (bif (cc (sub.l ($ 1) dtemp0)) @strlp)    (move_t acc)    (lfret)@xstrequal0    (move.l (varg x) arg_y)    (move.l (varg y) arg_z)@xstrequal    (tail-ccall string= arg_y arg_z); Is now fairly clever@xbitequal    (getint dtemp0) ;dtemp0=length    (bra @bit2)@bitequal    (vsize atemp0 dtemp0)    (if# (ne (sub.l ($ 1) dtemp0))      (sub.l ($ 1) dtemp0)      (lsl.l ($ 3) dtemp0)      (move.l '0 dtemp1)      (move.b (atemp0 $v_data) dtemp1)      (add.l dtemp1 dtemp0))@bit2    (vsubtype atemp1 dtemp1)    (if# (ne (cmp.b ($ $v_bitv) dtemp1))      (bif (ne (cmp.b ($ $v_arrayh) dtemp1)) @ret_nil2)      (bif (ne (cmp.w ($ $arh_one_dim) (svref atemp1 arh.fixnum $arh_rank4))) @ret_nil2)      (move.l (svref atemp1 arh.fill) da)      (getint da)      (bif (ne (sub.l dtemp0 da)) @ret_nil2)      (prog#       (add.l (svref atemp1 arh.offs) da)       (btst ($ $arh_disp_bit) (svref atemp1 arh.fixnum $arh_bits))       (move.l (svref atemp1 arh.vect) atemp1)       (bne (top#)))      (vsubtype atemp1 dtemp1)      (bif (ne (cmp.b ($ $v_bitv) dtemp1)) @ret_nil2)      else#      (vsize atemp1 dtemp1)      (if# (ne (sub.l ($ 1) dtemp1))        (sub.l ($ 1) dtemp1)        (lsl.l ($ 3) dtemp1)        (move.l '0 da)        (move.b (atemp1 $v_data) da)        (add.l da dtemp1))      (bif (ne dtemp0 dtemp1) @ret_nil2))    (lea (atemp0 (1+ $v_data)) atemp0)    (lea (atemp1 (1+ $v_data)) atemp1)    (move.l ($ 7) da)    (move.l dtemp0 dtemp1)              ; length    (and.l da dtemp1)    (asr ($ 3) dtemp0)    (dbfloop.l dtemp0      (bif (ne (cmp.b atemp0@+ atemp1@+)) @ret_nil2))    (move.l nilreg acc)    (move.b @atemp0 da)    (move.b @atemp1 dtemp2)    (eor.b da dtemp2)    (lea (^ @mask_table) atemp0)    (and.b (atemp0 dtemp1) dtemp2)    (if# eq      (add.l ($ $t_val) acc))    (lfret)    @mask_table    (dc.w #x0080 #xc0e0 #xf0f8 #xfcfe)    ))(defun %simple-string= (str1 str2 start1 start2 end1 end2)    (declare (fixnum start1 start2 end1 end2))    (when (= (the fixnum (- end1 start1))             (the fixnum (- end2 start2)))      ; 2^2 different loops.      (locally (declare (optimize (speed 3) (safety 0)))        (if (simple-base-string-p str1)          (if (simple-base-string-p str2)            (locally (declare (type simple-base-string str1 str2))              (do* ((i1 start1 (1+ i1))                    (i2 start2 (1+ i2)))                   ((= i1 end1) t)                (declare (fixnum i1 i2))                (unless (eq (schar str1 i1) (schar str2 i2))                  (return))))            (locally (declare (type simple-base-string str1)                              (type simple-extended-string str2))              (do* ((i1 start1 (1+ i1))                    (i2 start2 (1+ i2)))                   ((= i1 end1) t)                (declare (fixnum i1 i2))                (unless (eq (schar str1 i1) (schar str2 i2))                  (return)))))          (if (simple-base-string-p str2)            (locally (declare (type simple-base-string str2)                              (type simple-extended-string str1))              (do* ((i1 start1 (1+ i1))                    (i2 start2 (1+ i2)))                   ((= i1 end1) t)                (declare (fixnum i1 i2))                (unless (eq (schar str1 i1) (schar str2 i2))                  (return))))            (locally (declare (type simple-extended-string str1 str2))              (do* ((i1 start1 (1+ i1))                    (i2 start2 (1+ i2)))                   ((= i1 end1) t)                (declare (fixnum i1 i2))                (unless (eq (schar str1 i1) (schar str2 i2))                  (return)))))))))(defun make-symbol (name)  (declare (%noforcestk))  (lap-inline (name)   (jsr_subprim $sp-sstrarg)   (jsr_subprim $sp-makesym)))(defun structurep (form)  "True if the given object is a named structure, Nil otherwise."  (lap-inline ()    (:variable form)    (if# (or (ne (ttagp ($ $t_vector) acc da))             (ne (progn (move.l acc atemp0) (vsubtypep ($ $v_struct) atemp0 da))))      (move.l nilreg acc)))); from level-0;68k;68k-symbol; Assumes that sym is NIL or some other symbol(defun %symbol->symptr (sym)  (declare (optimize (speed 3) (safety 0)))  (if sym    (require-type sym 'symbol)    (lap-inline (nil)       (add.w ($ $nil_val) acc)))); "sym" had better be a symbol(defun %symptr->symbol (sym)  (declare (optimize (speed 3) (safety 0)))  (unless (eq (lap-inline () (moveq $nil_val acc) (add.l nilreg acc))              sym)    sym))(%include "ccl:l1;l1-aprims.lisp")