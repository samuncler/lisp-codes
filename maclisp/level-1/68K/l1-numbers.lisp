;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  5 10/6/96  akh  fix load-byte and %ldb-fixnum-from bignum for byte extent beyond integer-length;;  3 2/6/95   akh  how quickly they forget. Maybe no change.;;  (do not edit before this line!!);; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.; 6/12/95 slh   Gary's fix to load-byte (lsr -> asr);-------------- 3.0d1;07/07/93 bill  most of the random-state stuff moves here from numbers.lisp.;               It's used now by "l1-clos.lisp".;-------------- 3.0d11;06/09/93 alice %parse-number-token calls new-numtoken and new-numtoken replaces %%numtkn (I hope);04/12/93 bill  fix brain damage in %ldb-fixnum-from-bignum;-------------- 2.1d5;04/08/93 alice %ldb-fixnum-from-bignum incr offset, decr #bits not vv;01/14/92 bill  ldb, dpb, & friends move here from "ccl:lib;numbers.lisp".;               load-byte & ldb don't cons when loading a fixnum from;               a bignum.;12/01/92 bill  truncate, floor, ceiling, & round now check for multiple;               values and don't cons a second return value unless it's expected.;11/20/92 gb    new vectors; logbitp a subprim;--------- 2.0;01/29/92 gb    %%numdiv uses set_fpcr vice immediate operand.;---------- f2c3;01/22/91 alice %%numdiv all double sane or not, except for fint, where sane fails;---------- f1c2;11/26/91 alice comment out the rest of float reader;------------------- 2.0b4;11/17/91 alice %%numdiv round precision double ;11/09/91 alice %%numtkn switch sane from double to extended and back, detect overflow;11/05/91 alice&gary lets use SANE for reading floats (use extended precision);07/21/91 gb   fix &lap arglists so compiler can complain more.;06/01/91 gb   Fix long numeric string overflow nonsense.;05/31/91 gb   %%NumTkn tries harder ...;05/30/91 gb   %ftanh was jsring to symbols vice lfuns.  Screw. %%NumTkn ;              tries to parse short floats with SANE.;05/08/91 gb   supposed to be short-float-clean.;03/05/91 alice report-bad-arg gets 2 args;-------------- 2.0b1;12/13/90 gb   punt float printer.;11/28/90 bill byte-mask handles a size of 0.;11/12/90 bill GZ's fix to LOGNOT;10/16/90 gb   stack-discipine bug in %%numdiv.;09/06/90 bill GZ'z patch to %%numtkn;08/20/90 bill movem -> movem.l in %%numdiv;08/02/90 (gz) cons perm ints per the New Order.;06/29/90 bill Missing unuse_regs in (defun = ...);04/30/90 gb  flush %iash.  Use newer lap control structures.  Changed;             logxor, logior, logand to call new subprims.;03/20/90 gz  Added realp.;10/3/89  gz  Remove assumptions about bignums being < 32k.;05/07/89 gb    allocvect,reservevect calls pass subtype in arg_y.;04/07/89 gb  $sp8 -> $sp.; 04/01/89 gz Split off from l1-aprims and elsewhere.(eval-when (eval compile)  (require 'lapmacros)  (require 'sanetraps)  (deflapgen _bigspread (src adest dtemp loc)    (%lap-expr 'movereg src adest)    (lap-instr `(if# (eq (ttagp ($ $t_fixnum)                                ,(if (lap-dreg-op-p src) src adest)                                ,dtemp))                  (move.l ,adest ,dtemp)                  (getint ,dtemp)                  (if# mi (neg.l ,dtemp) (bset 31 ,dtemp))                  (lea (a5 (+ ,loc $t_vector)) ,adest)                  (move.w (header $v_bignum 4) (,adest $vec.header_low))                  (move.l ,dtemp (,adest $v_data))))))(defun %iabs (int)  (declare (%noforcestk))  (lap-inline (int)   (if# (mi (tst.l arg_z))        (neg.l arg_z))   (movereg arg_z acc)))(defun lsh (integer count)  (old-lap   (if# (eq (ttagp ($ #.$t_fixnum) arg_y da))        (if# (eq (ttagp ($ #.$t_fixnum) arg_z da))             (getint arg_z)             (if# pl                  (lsl.l arg_z arg_y)              else#                  (lsr.l ($ $fixnumshift) arg_y)	; Don't propagate sign bit.                  (neg.l arg_z)                  (lsr.l arg_z arg_y)                  (mkint arg_y))             (move.l arg_y acc)             (lfret)         else# (wtaerr arg_z 'fixnum))     else# (wtaerr arg_y 'fixnum))))(defun %integer-to-string (int &optional radix)  ;(declare (arglist int &optional (radix 10)))  (old-lap-inline ()    (preserve_regs #(asave0 dsave0))    (jsr_subprim $sp-BgOutInit)    (if# (mi (tst.w dx)) (add.l ($ 1) acc))    (begin_csarea)    (sub.l (vsp) atemp0)    (movem.l #(dx dy da db atemp0 atemp1) -@sp)    (begin_csarea)    (jsr_subprim $sp-MakeStr)          ;acc = node, atemp1 = char ptr    (move.l atemp1 asave0)    (move.l acc dsave0)    (add.w ($ 4) sp)                    ; spop_csarea    (movem.l sp@+ #(dx dy da db atemp0 atemp1))    (add.l (vsp) atemp0)    (spop_csarea)    (bif (pl (tst.w dx)) @snext)    (moveq ($ #\-) acc)    (prog#      (move.b acc (@+ asave0))      @snext (until# (eq (jsr_subprim $sp-BgOutChar))))    (if# (eq (tst.l (@+ vsp))) (spop_discard_csarea))    (move.l dsave0 acc)    (restore_regs)))(defun %pr-integer (int &optional radix stream)  ;(declare (arglist int &optional (radix 10) (stream *standard-output*)))  (if stream (if (eq stream t) (setq stream *terminal-io*))      (setq stream *standard-output*))  (old-lap-inline (int radix)    (jsr_subprim $sp-BgOutInit) (equate _vtop 4)    (bif (pl (tst.w dx)) @snext)    (moveq ($ #\-) acc)    (prog#     (begin_csarea)     (sub.l (vsp) atemp0)     (movem.l #(dy da db atemp0 atemp1) -@sp)     (begin_csarea)     (mkchar acc)     (ccall stream-tyo (varg stream _vtop) acc)     (add.w ($ 4) sp)                     ; spop_csarea     (movem.l sp@+ #(dy da db atemp0 atemp1))     (add.l (vsp) atemp0)     (spop_csarea)     @snext (until# (eq (jsr_subprim $sp-BgOutChar))))    (if# (eq (tst.l (@+ vsp))) (spop_discard_csarea)))  int)(defun %parse-number-token (string &optional start end radix)  (if end (require-type end 'fixnum)(setq end (length string)))  (if start (require-type start 'fixnum)(setq start 0))  (lap-inline ()    (:variable radix)    (move.l (varg radix) acc)    (jsr_subprim $sp-radixarg)    (mkint db)    (move.l db (varg radix)))  (multiple-value-bind (string offset)(array-data-and-offset string)    (new-numtoken string (+ start offset)(- end start) radix)))(defun new-numtoken (string start len radix &optional no-rat)  (declare (fixnum start len radix))  (if (eq 0 len)    nil    (let ((c (%scharcode string start))          (nstart start)          (end (+ start len))          (hic (if (<= radix 10)                 (+ (char-code #\0) (1- radix))                 (+ (char-code #\A) (- radix 11))))          dot dec dgt)      (declare (fixnum nstart end hic))      (when (or (eq c (char-code #\+))(eq c (char-code #\-)))        (setq nstart (1+ nstart)))      (when (eq nstart end)(return-from new-numtoken nil)) ; just a sign      (do ((i nstart (1+ i)))          ((eq i end))        (let ()          (setq c (%scharcode string i))          (cond           ((eq c (char-code #\.))            (when dot (return-from new-numtoken nil))            (setq dot t)            (when dec (return-from new-numtoken nil))            (setq hic (char-code #\9)))           ((< c (char-code #\0))             (when (and (eq c (char-code #\/))(not dot)(not no-rat))              (let ((top (new-numtoken string start (- i start) radix)))                (when top                   (let ((bottom (new-numtoken string (+ start i 1) (- len i 1) radix t)))                    (when bottom                       (return-from new-numtoken (/ top bottom)))))))            (return-from new-numtoken nil))           ((<= c (char-code #\9))            (when (> c hic)              ; seen a decimal digit above base.              (setq dgt t)))           (t (when (>= c (char-code #\a))(setq c (- c 32)))              (cond ((or (< c (char-code #\A))(> c hic))                     (when (and (not dec)(eq radix 10)  ; floats make no sense in other bases I hope?                                (neq i nstart) ; need some digits first                                (memq c '#.(list (char-code #\E)(char-code #\F)(char-code #\D)                                                 (char-code #\L)(char-code #\S))))                       (return-from new-numtoken (parse-float string len start)))                      (return-from new-numtoken nil))                     (t ; seen a "digit" in base that ain't decimal                      (setq dec t)))))))      (when (and dot (or (and (neq nstart start)(eq len 2))                         (eq len 1)))  ;. +. or -.        (return-from new-numtoken nil))      (when dot         (if (eq c (char-code #\.))          (progn (setq len (1- len) end (1- end))                 (when dec (return-from new-numtoken nil))                 ; make #o9. work (should it)                 (setq radix 10 dgt nil))          (return-from new-numtoken (parse-float string len start))))      (when dgt (return-from new-numtoken nil)) ; so why didnt we quit at first sight of it?      ; and we ought to accumulate as we go until she gets too big - maybe      (cond (nil ;(or (and (eq radix 10)(< (- end nstart) 9))(and (eq radix 8)(< (- end nstart) 10)))             (let ((num 0))               (declare (fixnum num))               (do ((i nstart (1+ i)))                   ((eq i end))                 (setq num (%i+ (%i* num radix)(%i- (%scharcode string i) (char-code #\0)))))               (if (eq (%scharcode string start) (char-code #\-)) (setq num (- num)))               num))                                     (t (token2int string start len radix)))))); we know its a legal string possibly with a sign(defun token2int (string start len radix)  (lap-inline ()    (:variable len start radix string)   (move.l (varg len) acc)                      ;Get enuff room to fit the number   (getint acc)   (move.l acc da)   (asr.l 1 acc)                        ;N digits  base ² 64=2^6 => fits in 6N bits   (add.l da acc)                       ; ==> fits in [6N/16]+1 words including sign bit   (asr.l 2 acc)   (add.l ($ 1) acc)   (add.l acc acc)   (move.l ($ $v_bignum) arg_y)   (jsr_subprim $sp-reservevect)   (lea (atemp0 acc.l $v_data) atemp1)   (move.l (varg start) dy)   (getint dy)   (move.l (varg string) atemp0)   (vsubtype atemp0 dx)   (lea (atemp0 dy.l $v_data) atemp0)   (if# (eq (cmp.b ($ $v_xstr) dx))     (add.l dy atemp0))   (move.l (varg radix) db)   (getint db)   (move.l (varg len) acc)   (getint acc)   (bsr Tkn2Int)   (move.l atemp1 atemp0)   (move.l da acc)   (jsr_subprim $sp-MkPermInt)   (lfret)   ;Convert a verified string of digits (with optional sign) into a bignum   ;atemp0/acc=string, atemp1=ptr to end of sufficiently large output area, db=base   ;Returns with atemp1/da=bignum (da=0 if 0).  Preserves db, advances atemp0.   ; dx has subtype of string   Tkn2Int   (progn     (movem.l #(dsave0 dsave1 dsave2) -@sp)     (moveq 0 dsave0)                   ;dsave0=sign     (if# (eq (cmp.b ($ $v_sstr) dx))       (move.b (atemp0) dy)       Else#       (move.w (atemp0) dy))     (cmp.b ($ #\+) dy)     (beq @tsign)     (cmp.b ($ #\-) dy)     (if# eq       (moveq #x-80 dsave0)       @tsign       (if# (eq (cmp.b ($ $v_sstr) dx))                  (add.w ($ 1) atemp0)                  else#         (add.w ($ 2) atemp0))       (sub.l ($ 1) acc))     (clr.w (-@ atemp1))     (moveq 0 da)			;da=output word count - 1     (sub.l ($ 1) acc)     (moveq 0 dsave1)     (prog#      (if# (eq (cmp.b ($ $v_sstr) dx))         (move.b (@+ atemp0) dsave1)        else#        (move.w (@+ atemp0) dsave1))      (if# (ge (cmp.b ($ #\a) dsave1)) (sub.b ($ 32) dsave1))      (if# (ge (cmp.b ($ #\A) dsave1))        (sub.b ($ (- (%char-code #\A) (%char-code #\0) 10)) dsave1))      (sub.b ($ #\0) dsave1)      (lea (atemp1 da.l 2) atemp1)      (add.l da atemp1)      (move.l da dy)      (prog#       (move.w (-@ atemp1) dsave2)       (mulu db dsave2)       (add.l dsave1 dsave2)       (move.w dsave2 (atemp1))       (swap dsave2)       (move.w dsave2 dsave1)       (dbfl dy (top#)))      (if# (ne (tst.w dsave1))        (move.w dsave1 (-@ atemp1))        (add.l ($ 1) da))      (dbfl acc (top#)))     (if# (ne (tst.w (atemp1)))         ;Only eq if whole thing is 0       (if# mi         (clr.w (-@ atemp1))         (add.l ($ 1) da))       (add.l ($ 1) da)       (or.b dsave0 (atemp1)))          ;Set sign     (movem.l sp@+ #(dsave0 dsave1 dsave2))     (rts))));; Will Clingers number 1.448997445238699;; Doug Curries numbers 214748.3646, 1073741823/5000(defun bignump (thing)  (lap-inline (nil)    (:variable thing)    (move.l (varg thing) atemp0)    (if# (and (eq (ttagp ($ $t_vector) atemp0 da))              (eq (vsubtypep ($ $v_bignum) atemp0 da)))      (add.w ($ $t_val) acc))))(defun ratiop (thing)  (old-lap-inline (nil)    (move.l (varg thing) atemp0)    (if# (and (eq (ttagp ($ $t_vector) atemp0 da))              (eq (vsubtypep ($ $v_ratio) atemp0 da)))      (add.w ($ $t_val) acc))))(defun complexp (thing)  (old-lap-inline (nil)    (move.l (varg thing) atemp0)    (if# (and (eq (ttagp ($ $t_vector) atemp0 da))              (eq (vsubtypep ($ $v_complex) atemp0 da)))      (add.w ($ $t_val) acc))))(defun rationalp (thing)  (or (integerp thing) (ratiop thing)))(defun realpart (number)   (if (complexp number) (complex.real number)       (if (numberp number) number (report-bad-arg number 'number))))(defun imagpart (number)   (if (complexp number) (complex.imag number)       (if (floatp number) (float 0.0 number)           (if (rationalp number) 0               (report-bad-arg number 'number)))))(defun zerop (number)  (old-lap    (if# (eq (ttag acc da))@rettest       (tst.l acc)@reteq (setpred eq da)       (lfret))    (if# (eq (sub.b ($ $t_sfloat) da))      (cmp.l '0.0s0 acc)      (beq @reteq)      (cmp.l '-0.0s0 acc)      (bra @reteq))    (move.l acc atemp0)    (if# (eq (add.b ($ (- $t_sfloat $t_dfloat)) da))@float (sub.w ($ $t_dfloat) atemp0)       (move.l atemp0@+ da)       (bclr ($ 31) da)     ;Gotta ignore sign for floating point       (or.l (atemp0) da)       (bra @reteq))    (bif (ne (add.b ($ (- $t_dfloat $t_vector)) da)) @bad)    (vsubtype atemp0 da)    (bif (or (eq (cmp.b ($ $v_bignum) da)) (eq (cmp.b ($ $v_ratio) da))) @nil)    (if# (ne (cmp.b ($ $v_complex) da))@bad  (wtaerr acc 'number))    (move.l (atemp0 $v_data) atemp1)    (bif (ne (ttagp ($ $t_dfloat) atemp1 da)) @nil)    (move.l (atemp0 (+ $v_data 4)) atemp0)    (sub.w ($ $t_dfloat) atemp1)    (move.l atemp1@+ db)    (bclr ($ 31) db)    (or.l (atemp1) db)    (beq @float)@nil    (move.l nilreg acc)    (lfret)))(defun plusp (real-number)  (old-lap@plusp    (if# (eq (ttag acc da))@tst      (tst.l acc)      (setpred gt da)      (lfret))    (move.l acc atemp0)    (if# (eq (cmp.b ($ $t_sfloat) da))      (move.l acc da)      (move.l nilreg acc)      (if# (and (ne '0.0s0 da)                (eq (bclr ($ 3) da)))        (add.w ($ $t_val) acc))      (lfret))    (if# (eq (sub.b ($ $t_dfloat) da))      (sub.w ($ $t_dfloat) atemp0)      (tst.l atemp0@+)      (bne @pl)      (tst.l (atemp0))      (setpred ne da)      (lfret))    (bif (ne (add.b ($ (- $t_dfloat $t_vector)) da)) @bad)    (vsubtype atemp0 da)    (if# (eq (cmp.b ($ $v_bignum) da))      (tst.w (atemp0 $v_data))@pl   (setpred pl da)      (lfret))    (if# (eq (cmp.b ($ $v_ratio) da))      (move.l (atemp0 $v_data) acc)      (bra @plusp))@bad (wtaerr acc 'real)))(defun minusp (real-number)  (old-lap@minusp    (if# (eq (ttag acc da))      (tst.l acc)@mi   (setpred mi da)      (lfret))    (if# (eq (cmp.b ($ $t_sfloat) da))      (move.l acc da)      (move.l nilreg acc)      (if# (and (ne '-0.0s0 da)                (ne (bclr ($ 3) da)))        (add.w ($ $t_val) acc))      (lfret))    (move.l acc atemp0)    (if# (eq (sub.b ($ $t_dfloat) da))      (sub.w ($ $t_dfloat) atemp0)      (tst.l (atemp0))      (bpl @mi)      (move.l ($ #x7FFFFFFF) acc)      (and.l (@+ atemp0) acc)      (or.l (atemp0) acc)      (setpred ne da)      (lfret))    (bif (ne (add.b ($ (- $t_dfloat $t_vector)) da)) @bad)    (vsubtype atemp0 da)    (if# (eq (cmp.b ($ $v_bignum) da))      (tst.w (atemp0 $v_data))      (bra @mi))    (if# (eq (cmp.b ($ $v_ratio) da))      (move.l (atemp0 $v_data) acc)      (bra @minusp))@bad (wtaerr acc 'real)))(defun lognot (integer)  (old-lap    (if# (eq (ttag acc da))      (not.l acc)      (sub.w ($ $typemask) acc)      (lfret))    (move.l acc atemp0)    (if# (or (ne (sub.w ($ $t_vector) da))             (ne (vsubtypep ($ $v_bignum) atemp0 da)))      (wtaerr acc 'integer))    (preserve_regs asave0)    (move.l atemp0 asave0)    (vsize asave0 acc)    (add.l ($ 2) acc)    (move.l ($ $v_bignum) arg_y)    (jsr_subprim $sp-reservevect)    (lea (atemp0 acc.l $v_data) atemp0)    (lea (asave0 acc.l (- $v_data 2)) atemp1)    (sub.l ($ 2) acc)    (lsr.l 1 acc)    (move.l acc da)    (sub.l ($ 1) da)    (if# (mi (tst.w (asave0 $v_data)))      (prog#       (move.w (-@ atemp1) (-@ atemp0))       (sub.w ($ 1) (atemp0))       (dbcc da (top#))       (if# cs (add.w ($ 1) da) (sub.l ($ 1) da) (bcc (top#))))      (dbfloop.l da (move.w (-@ atemp1) (-@ atemp0)))      (bclr 7 (atemp0))     else#      (prog#       (move.w (-@ atemp1) db)       (not.w db)       (move.w db (-@ atemp0))       (dbfl da (top#))))    (restore_regs)    (jsr_subprim $sp-logval)    (lfret)))(defun logand (&lap &rest numbers)  (old-lap   (if# (eq (sub.w ($ 8) nargs))     (jmp_subprim $sp-logand2))   (add.w ($ 8) nargs)   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (move.l (vsp) arg_z)            ;One arg case       (jsr_subprim $sp-req-integerZ)      else#       (move.l '-1 acc))                 ;No arg case     (lfret))   (preserve_regs #(asave0 dsave0)) (equate _vtop 8)   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w _vtop) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-logand2)    (until# (eq (sub.l '1 dsave0))))   (restore_regs)   (lfret)))(defun logior (&lap &rest numbers)  (old-lap   (if# (eq (sub.w ($ 8) nargs))     (jmp_subprim $sp-logior2))   (add.w ($ 8) nargs)   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (move.l (vsp) arg_z)            ;One arg case       (jsr_subprim $sp-req-integerZ)      else#       (move.l '0 acc))                 ;No arg case     (lfret))   (preserve_regs #(asave0 dsave0)) (equate _vtop 8)   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w _vtop) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-logior2)    (until# (eq (sub.l '1 dsave0))))   (restore_regs)   (lfret)))(defun logandc1 (integer1 integer2)  (old-lap   (if# (and (eq (ttagp ($ $t_fixnum) arg_y da))             (eq (ttagp ($ $t_fixnum) arg_z da)))     (not.l arg_y)     (and.l arg_y arg_z)     (lfret))   (preserve_regs #(asave0 asave1))   (jsr_subprim $sp-bigintarg1)   (move.l atemp0 asave1)   (move.l arg_y arg_z)   (jsr_subprim $sp-bigintarg2)   (move.l atemp0 asave0)   (vsize asave0 da)   (vsize asave1 db)   (if# (le (cmp.l db da))     (if# (mi (tst.w (asave0 $v_data))) (move.l da db))     (jsr_subprim $sp-logreserv)     (prog#      (move.w (-@ asave0) dy)           ;  ~asave0 & asave1      (not.w dy)      (and.w dy (-@ asave1))      (dbfl da (top#)))     else#      (exg da db)      (exg asave0 asave1)      (if# (pl (tst.w (asave0 $v_data))) (move.l da db))      (jsr_subprim $sp-logreserv)      (prog#       (move.w (-@ asave1) dy)          ; asave0 & ~asave1       (not.w dy)       (and.w (-@ asave0) dy)       (move.w dy (asave1))       (dbfl da (top#)))      (dbfloop.l db (not.w (-@ asave1))))   (restore_regs)   (jsr_subprim $sp-logval)   (lfret)))(defun logxor (&lap &rest nums)  (old-lap   (if# (eq (sub.w ($ 8) nargs))     (jmp_subprim $sp-logxor2))   (add.w ($ 8) nargs)   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (move.l (vsp) arg_z)            ;One arg case       (jsr_subprim $sp-req-integerZ)      else#       (move.l '0 acc))                 ;No arg case     (lfret))   (preserve_regs #(asave0 dsave0)) (equate _vtop 8)   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w _vtop) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-logxor2)    (until# (eq (sub.l '1 dsave0))))   (restore_regs)   (lfret)))(defun rem (number divisor)  (old-lap-inline ()    (moveq 1 da)                         ; Truncate    (moveq -1 db)                        ; Need remainder only    (jsr #'%%numdiv)))(defun mod (number divisor)  (old-lap-inline ()    (moveq 3 da)                        ; Floor    (moveq -1 db)                       ; Need remainder only    (jsr #'%%numdiv)));These should really compile to separate entry points if only need the;quotient rather than checking at run time.(defun truncate (number &optional divisor)  (old-lap    (if# (eq arg_z nilreg) (move.l '1 arg_z))    (moveq 1 da)   (bif (eq (progn (move.l (sp 4) db) (cmp.l (a5 $mvexpect) db)))        @needboth)   ; need quotient only   (moveq 1 db)   (jsr #'%%numdiv)   (movereg arg_y acc)   (lfret)   @needboth   ; need both quotient & remainder   (moveq 0 db)   (jsr #'%%numdiv)   (vpush arg_y)   (vpush arg_z)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun floor (number &optional divisor)  (old-lap   (if# (eq arg_z nilreg) (move.l '1 arg_z))   (moveq 3 da)   (bif (eq (progn (move.l (sp 4) db) (cmp.l (a5 $mvexpect) db)))        @needboth)   ; need quotient only   (moveq 1 db)   (jsr #'%%numdiv)   (movereg arg_y acc)   (lfret)   @needboth   ; need both quotient & remainder   (moveq 0 db)   (jsr #'%%numdiv)   (vpush arg_y)   (vpush arg_z)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun ceiling (number &optional divisor)  (old-lap    (if# (eq arg_z nilreg) (move.l '1 arg_z))    (moveq 5 da)   (bif (eq (progn (move.l (sp 4) db) (cmp.l (a5 $mvexpect) db)))        @needboth)   ; need quotient only   (moveq 1 db)   (jsr #'%%numdiv)   (movereg arg_y acc)   (lfret)   @needboth   ; need both quotient & remainder   (moveq 0 db)   (jsr #'%%numdiv)   (vpush arg_y)   (vpush arg_z)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun round (number &optional divisor)  (old-lap    (if# (eq arg_z nilreg) (move.l '1 arg_z))    (moveq 7 da)   (bif (eq (progn (move.l (sp 4) db) (cmp.l (a5 $mvexpect) db)))        @needboth)   ; need quotient only   (moveq 1 db)   (jsr #'%%numdiv)   (movereg arg_y acc)   (lfret)   @needboth   ; need both quotient & remainder   (moveq 0 db)   (jsr #'%%numdiv)   (vpush arg_y)   (vpush arg_z)   (set_nargs 2)   (jmp_subprim $sp-nvalret)));DA=1 if truncate, 3 if floor, 5 if ceiling, 7 if round.;DB=1 if need quotient only, 0 if need both, -1 if remainder only;Returns with arg_y=quotient, arg_z=reminder(defun %%numdiv (&lap 0)  (old-lap   (exg arg_y arg_z)   (swap db)                            ;Save output, type info   (move.w da db)   (spush db)   (jsr_subprim $sp-Real2Dispatch)   ; sets to extend precision   (add.w da da)   (jmp (pc da.w 2))   (jmp (^ divBgBg))   (jmp (^ divBgRt))   (jmp (^ divRtBg))   (jmp (^ divRtRt))   (jmp (^ divXfXf))   ;(jmp (^ divXfXf))   divXfXf				; da = 8*2 => short arg(s), else long   (progn     (move.l da dx)     (if# (ne (tst.b (a5 $fp68881flag)))  ; first lets be double       ;(FMOVE.L ($ #x3480) FPCR)       (move.l ($ #x3480) da)       (set_fpcr da)       else#       (move.w ($ #x002d) -@sp)       (spush sp)       (move.w ($ _FSETENV) -@sp)        (dc.w #xa9eb)       (add.w ($ 2) sp))     (spop acc)     (FMOVE.x FP1 FP0)     (FDIV.x FP3 FP0)     (if# (mi (sub.w ($ 3) acc))       (FINTRZ.x FP0)                   ;Truncate = towards-zero       (bra @Xfinish))     (if# eq       (move.w ($ #x34A0) db)                  ;Floor = downward, and double       (moveq #x40 da)                  ;sane version...      else#       (if# (ne (sub.w ($ 2) acc))         (FINT.x FP0)                     ;Round = to nearest, the default         (bra @Xfinish))       (move.w ($ #x34B0) db)                  ;Ceiling = upward, and double       (moveq #x20 da))                 ;bletch     (if# (ne (tst.b (a5 $fp68881flag))) ; now set the rounding mode       (SET_FPCR db)       (FINT.x FP0)       (move.b ($ #x80) db)       (SET_FPCR db)      else#       (spush dx)      ; needed?       (move.w ($ #x000d) -@sp)  ; sane louses up FINT if double round prec.       (or.b da (sp))       (spush sp)       (move.w ($ _FSETENV) -@sp) (dc.w #xa9eb)       (add.w ($ 2) sp)       (FINT.x FP0)       (move.w ($ #x002d) -@sp)       (spush sp)       (move.w ($ _FSETENV) -@sp) (dc.w #xa9eb)       (add.w ($ 2) sp)       (spop dx))          @Xfinish     (swap acc)     (if# (gt (tst.w acc))       (vpush nilreg)                   ;Don't care about the remainder      else#       (FMUL.x FP0 FP3)                 ;Else compute the remainder       (FSUB.x FP3 FP1)       (pea (@ 1))       (move.w acc (sp))       (if# (eq (cmp.w ($ (* 2 8)) dx))         (jsr_subprim $sp-FP1SFloat)	 else#	 (jsr_subprim $sp-FP1dFloat))       (if# (lt (progn (tst.w (@+ sp)) (add.w ($ 2) sp)))   ;need the quotient?         (move.l nilreg arg_y)          ;No, all done         (rts))       (vpush acc))     ;integral XFloat to integer! FP0=float     (begin_csarea)     (sub.w ($ 12) sp)     (fmove.x fp0 @sp)    ; can't err out/gc.     (move.w (@+ sp) (sp))     (move.l sp atemp0)     (movem.l #(dsave0 dsave1) -@sp)     (move.w (@+ atemp0) da)            ;da = sign     (move.w da db)     (and.w ($ #x7FFF) db)              ;db = Exponent     (move.l (@+ atemp0) arg_y)         ;Significand     (move.l (atemp0) arg_z)     (moveq 15 dsave1)     (sub.w ($ #x403E) db)     (if# mi       (neg.w db)                       ;Negative, shift right to word boundary       (and.w db dsave1)       (lsr.w 4 db)                     ;Number of words to shift out       (dbfloop dsave1 (lsr.l 1 arg_y) (roxr.l 1 arg_z))       (move.l arg_z (atemp0))       (move.l arg_y (-@ atemp0))       (moveq (1- 4) dsave0)       (sub.w db dsave0)       (if# mi         ;Hmm, this should never happen, unless we have an unnormalized zero         #-bccl (if# (ne (or.l arg_y arg_z)) (dc.w #_debugger))         (moveq 0 dsave0))       (move.l dsave0 acc)       (moveq 0 db)      else#       (and.w db dsave1)                ;Positive, shift left to word boundary       (lsr.w 4 db)                     ;DB=Number of extra words       (moveq 0 dsave0)       (dbfloop dsave1 (lsl.l 1 arg_z) (roxl.l 1 arg_y) (roxl.w 1 dsave0))       (move.l arg_z (atemp0))       (move.l arg_y (-@ atemp0))       (move.w dsave0 (-@ atemp0))       (moveq (1- 5) acc))     (movem.l sp@+ #(dsave0 dsave1))     (if# (eq (prog# (tst.w (@+ atemp0))   ;Flush leading zeros                     (dbne acc (top#))))       (move.l '0 acc)      else#       (sub.w ($ 2) atemp0)       (if# mi (clr.w (-@ atemp0)) (add.w ($ 1) acc))       (add.w ($ 1) acc)       (if# (mi (tst.w da)) (bset 7 (atemp0)))   ;Install sign       (movem.l #(acc db atemp0) (-@ sp))       (begin_csarea)       (add.w db acc)       (add.l acc acc)       (move.l ($ $v_bignum) arg_y)       (jsr_subprim $sp-reservevect)       (lea (atemp0 $v_data) atemp1)       (spop_csarea)       (movem.l (@+ sp) #(acc db atemp0))       (move.l acc da)       (move.l atemp1 dy)       (dbfloop da (move.w (@+ atemp0) (@+ atemp1)))       (add.l db acc)       (move.l dy atemp0)       (moveq 0 da)       (dbfloop db (move.w da (@+ atemp1)))       (jsr_subprim $sp-MkPermInt))     (add.w ($ 10) sp)     (spop_csarea)     (move.l acc arg_y)     (vpop arg_z)     (rts))   divBgRt               ;arg_z=int, atemp0=bignum, atemp1=ratio, (sp) = format   (progn     (if# (eq (tst.l arg_z))       (add.w ($ 4) sp)       (move.l arg_z arg_y)       (rts))     (add.w ($ $v_data) atemp1)     (move.l (@+ atemp1) arg_y)         ; numerator     (move.l (@+ atemp1) arg_z)         ; denominator     (lea (a5 (+ $TempBignum2 $t_vector)) atemp1)     (move.w (header $v_bignum 2) (atemp1 $vec.header_low))     (move.w ($ 1) (atemp1 $v_data))     (bra divRtRt_1))                   ;atemp0/atemp1 Ö arg_y/arg_z   divRtBg              ;atemp0=ratio, arg_y=int, atemp1=bignum, (sp) = format   (progn     (if# (eq (tst.l arg_y)) (tsignal_error (fixnum $XDIVZRO)))     (preserve_regs #(asave0 asave1 dsave0 dsave1 dsave2))     (move.l atemp1 asave0)     (lea (a5 (+ $TempBignum4 $t_vector)) asave1)     (move.w (header $v_bignum 2) (asave1 $vec.header_low))     (move.w ($ 1) (asave1 $v_data))     (_bigspread (svref atemp0 ratio.den) atemp1 da $TempBignum1)     (_bigspread (svref atemp0 ratio.num) atemp0 da $TempBignum2)     (bra divRtRt_2))		;atemp0/atemp1 Ö asave0/asave1   divRtRt            ;atemp0 = ratio, atemp1=ratio, (sp) = format   (progn     (add.w ($ $v_data) atemp1)     (move.l (@+ atemp1) arg_y)         ; Numerator     (move.l (@+ atemp1) arg_z)         ; denominator     (_bigspread (svref atemp0 ratio.den) atemp1 da $TempBignum1)     (_bigspread (svref atemp0 ratio.num) atemp0 da $TempBignum2)     divRtRt_1			;atemp0/atemp1 Ö arg_y/arg_z     (preserve_regs #(asave0 asave1 dsave0 dsave1 dsave2))     (_bigspread arg_y asave0 da $TempBignum3)     (_bigspread arg_z asave1 da $TempBignum4)     divRtRt_2 			;atemp0/atemp1 Ö asave0/asave1     (vsize atemp0 dtemp0)     (vsize atemp1 dtemp1)     (vsize asave0 da)     (vsize asave1 db)     (add.l db dtemp0)     (add.l dtemp1 da)     (add.l da dtemp0)     (spush dtemp0)     (add.l ($ 1) (sp))                 ; make it gc-safe     (if# (le (tst.w (sp 4)))           ;Need remainder?       (add.l da dtemp0)		;Gonna be a ratio...       (add.l db dtemp1)       (add.l dtemp1 dtemp1)       (add.l dtemp1 dtemp0)       (moveq (+ 4 8 6) dtemp1)         ; mm_v_overhead+v_align+6       (add.l dtemp1 dtemp0))     (moveq (+ 4 8 8) dtemp1)           ; mm_v_overhead+v_align+8     (add.l dtemp1 dtemp0)     (move.l atemp0 dsave0)     (move.l atemp1 dsave1)     (move.l ($ $v_bignum) arg_y)     (jsr_subprim $sp-reservevect)     (lea (atemp0 dtemp0.l $v_data) atemp1)     (spop dtemp1)     (sub.l ($ 1) dtemp1)     (vpush atemp1)     (lea (atemp0 dtemp1.l (+ $v_data 8 4 8)) atemp1) ;v_data+mm_v_overhead+v_align+8     (exg asave0 atemp1)     (move.l dsave1 atemp0)     (jsr_subprim $sp-xBigMul)     (lea (atemp0 (+ -4 -4)) asave0)    ; -4-mm_v_overhead     (exg atemp0 dsave0)     (move.l dtemp0 dsave2)     (move.l asave1 atemp1)     (jsr_subprim $sp-xBigMul)     (move.l dsave0 atemp1)     (move.l dsave2 dtemp1)     (spop da)     (bsr nBgDiv)     ;atemp0/dtemp0 = rem, atemp1/dtemp1 = quotient, da=thing     ;dsave1,asave1 = original denoms.     (move.l atemp0 asave0)     (move.l dtemp0 dsave0)     (move.w da dsave2)     (if# le                            ; If need reminder, handle it.       (movem.l #(atemp1 dtemp1) -@sp)   ; save quotient       (move.l dsave1 atemp0)		;Get back original denoms       (move.l asave1 atemp1)       (move.l asave0 asave1)		;save rem again.       (move.l dsave0 dsave1)       (if# ne         (vsize atemp0 dtemp0)         (vsize atemp1 dtemp1)         (add.l dtemp1 dtemp0)         (add.l dsave1 dtemp0)         (add.l dsave1 dtemp0)         (lea (asave0 dtemp0.l (+ 8 4 4)) asave0) ;v_align+mm_v_overhead+4         (jsr_subprim $sp-xBigMul)         (move.l @vsp asave0)         (move.l atemp0 atemp1)         (move.l dtemp0 dtemp1)         (move.l asave1 atemp0)         (move.l dsave1 dtemp0)         (jsr_subprim $sp-nBgReduce)         ;atemp1/dtemp1, atemp0/dtemp0         (move.l atemp0 asave1)         (move.l dtemp0 dsave1)         (move.l atemp1 atemp0)         (move.l dtemp1 dtemp0)         (jsr_subprim $sp-MkPermInt)         (exg dtemp0 dsave1)         (move.l asave1 atemp0)         (jsr_subprim $sp-MkPermInt)         (move.l arg_z dsave0))         ; answer is dsave0/dsave1       (movem.l sp@+ #(atemp1 dtemp1))      else#       (move.l '0 dsave0)               ; 0 means no ratio       (move.l nilreg dsave1))          ; and dsave1 has the answer     (add ($ 4) vsp)     (if# (ge (tst.w dsave2))           ; If need quotient, make one       (move.l atemp1 atemp0)       (move.l dtemp1 dtemp0)       (jsr_subprim $sp-MkPermInt)      else#       (move.l nilreg arg_z))     (move.l arg_z da)     (move.l dsave0 arg_y)     (move.l dsave1 arg_z)     (restore_regs)                     ; Make it safe to cons again.     (vpush da)     (if# (ne (tst.l arg_y))            ; if arg_y is 0, arg_z is the answer       (jsr_subprim $sp-MakeRat))        ; else it's arg_y/arg_z     (vpop arg_y)     (rts))   divBgBg	             ;arg_z/arg_y, atemp0/atemp1,  (sp) = format   (progn     (if# (eq (tst.l arg_y)) (tsignal_error (fixnum $XDIVZRO)))     (if# (eq (tst.l arg_z))       (add.w ($ 4) sp)       (move.l arg_z arg_y)       (rts))     (preserve_regs asave0)     (move.l atemp0 asave0)     (vpush atemp1)     (vsize atemp0 dtemp0)     (vsize atemp1 dtemp1)     (add.l dtemp1 dtemp0)     (moveq (+ 4 4 8) dtemp1)             ; 4+mm_v_overhead+v_align     (add.l dtemp1 dtemp0)     (move.l ($ $v_bignum) arg_y)     (jsr_subprim $sp-reservevect)     (lea (atemp0 dtemp0.l $v_data) atemp0)     (vpop atemp1)     (getvect atemp1 dtemp1)     (add.l dtemp1 atemp1)     (lsr.l 1 dtemp1)     (move.l dtemp1 dtemp0)     (bmovup.w atemp1 atemp0 dtemp0)     (move.l atemp0 atemp1)     (sub.w ($ 4) atemp0)                 ;mm_v_overhead     (getvect asave0 dtemp0)     (add.l dtemp0 asave0)     (lsr.l 1 dtemp0)     (move.l dtemp0 db)     (bmovup.w asave0 atemp0 db)     (spop da)     (bsr nBgDiv)                         ;[0] = remainder, [1] = quotient.     (move.l nilreg asave0)     (if# (le (tst.w da))       (movem.l #(atemp1 dtemp1 da) -@sp)   ; save quotient       (jsr_subprim $sp-MkPermInt)          ; cons up reminder       (move.l arg_z asave0)       (movem.l sp@+ #(atemp1 dtemp1 da)))     (move.l nilreg arg_z)     (if# (ge (tst.w da))       (move.l atemp1 atemp0)       (move.l dtemp1 dtemp0)       (jsr_subprim $sp-MkPermInt))     (move.l arg_z arg_y)     (move.l asave0 arg_z)     (vpop asave0)     (rts))   ;atemp0/dtemp0=Numerator, atemp1/dtemp1=Denominator   ;-4(atemp0) clobberable.  da=output,,rounding   ;Compute quotient and remainder with appropriate rounding.   ;Returns atemp0/dtemp0=(signed) reminder clobbering denominator   ;	 atemp1/dtemp1=(signed) quotient clobbering numerator and 4 bytes above   ;	 da = output   nBgDiv   (progn     (movem.l #(asave0 asave1 dsave0 dsave1 dsave2) -@sp)     (spush da)     (move.w ($ #x8000) dsave1)     (move.w dsave1 dsave2)     (and.w (atemp0) dsave1)              ;dsave1 = sign of numerator     (sub.w dsave1 (atemp0))              ;Clear it in memory.     (if# eq (add.w ($ 2) atemp0) (sub.l ($ 1) dtemp0))     (and.w (atemp1) dsave2)              ; sign of denominator     (sub.w dsave2 (atemp1))     (if# eq (add.w ($ 2) atemp1) (sub.l ($ 1) dtemp1))     (eor dsave1 dsave2)                  ;dsave2 = sign of quotient     (move.l atemp1 asave0)               ;save denominator.     (move.l dtemp1 dsave0)     (jsr_subprim $sp-nBgUnsDivide)      ;[0] = remainder, [1] = quotient.     (move.w sp@+ da)                     ;output info     (move.w sp@+ db)                     ;rounding info     (tst.l dtemp0)                       ;any remainder?     (beq @retq)                          ;exact, clean up quotient and return.     (sub.w ($ 3) db)     (bmi @down)                          ;1=truncate     (if# eq       (bif (mi (tst.w dsave2)) @up)      ;3=floor       (bra @down))     (if# (eq (sub.w ($ 2) db))       (bif (pl (tst.w dsave2)) @up)      ;5=ceiling       (bra @down))     (move.l dsave0 db)                   ;7=round.  Compare 2*remainder and denom     (sub.l dtemp0 db)     (if# eq       (move.w (atemp0) db)       (lsl.w 1 db)       (bcs @up)                          ;2*remainder much bigger, round up.       (movem.l #(dtemp0 atemp0 dsave0 asave0 dsave1) -@sp)       (add.w ($ 2) atemp0)       (sub.l ($ 1) dtemp0)       (moveq 0 dsave1)       (bra @rnext))                     ;Z flag set.     (sub.l ($ 1) db)     (bne @down)                          ;Denom much bigger, round down     (movem.l #(dtemp0 atemp0 dsave0 asave0 dsave1) -@sp)     (moveq 0 dsave1)     (sub.l ($ 1) dtemp0)     (prog#      (move.w db dsave0)      (move.w (@+ atemp0) db)      (lsl.w 1 db)      (addx.w dsave1 dsave0)      (cmp.w (@+ asave0) dsave0)      @rnext      (dbne dtemp0 (top#))      (if# eq        (add.w ($ 1) dtemp0) (sub.l ($ 1) dtemp0) (bcc (top#))        (cmp.w (asave0) db)))     (movem.l sp@+ #(dtemp0 atemp0 dsave0 asave0 dsave1))     (bltu @down)                       ;Denom bigger, round down     (bgtu @up)                         ;Denom smaller, round up     (move.l dtemp1 db)                 ;Exactly equal, round to even     (beq @down)     (add.l db db)     (btst 0 (atemp1 db.l -1))     (beq @down);Rounding up. Increment quotient and subtract remainder from denominator.     @up     (bif (gt (tst.w da)) @upquo)       ;wants remainder?     (lea (asave0 dsave0.l) asave1)     ; yes, do it.     (add.l dsave0 asave1)     (add.l dtemp0 atemp0)     (add.l dtemp0 atemp0)     (sub.l ($ 1) dtemp0)               ;clears carry     (bra @upsub)     @upsub0     (swap dtemp0)     @upsub     (subx.w (-@ atemp0) (-@ asave1))     (dbf dtemp0 @upsub)     (if# cs       (swap dtemp0)       (dbf dtemp0 @upsub0)       (prog# (sub.w ($ 1) (-@ asave1)) (until# cc))      else#       (swap dtemp0)       (dbf dtemp0 @upsub0))     (move.l asave0 atemp0)     (move.l dsave0 dtemp0)     (prog#       (tst.w (@+ atemp0))       (dbne dtemp0 (top#))       (if# eq (add.w ($ 1) dtemp0) (sub.l ($ 1) dtemp0) (bcc (top#))))     (sub.w ($ 2) atemp0)		;(Doesn't affect flags)     (if# mi       (clr.w (-@ atemp0))       (add.l ($ 1) dtemp0))     (bchg 15 dsave1)                   ;Sign of remainder,     (add.w dsave1 (atemp0))            ;  opposite of denominator     (tst.w da)                         ;wants quotient?     (bmi @ret)                         ;no, done.     @upquo     (if# (or (eq (tst.l dtemp1))       ;Increment quotient              (mi (tst.w (atemp1))))       (clr.w (-@ atemp1))       (add.l ($ 1) dtemp1))     (lea (atemp1 dtemp1.l) asave1)     (add.l dtemp1 asave1)     (prog# (add.w ($ 1) (-@ asave1)) (until# cc))     (bra @retq);Rounding down.  Just copy remainder over denominator.     @down     (bif (gt (tst.w da)) @retq)        ;Wants remainder?     (move.l dtemp0 dsave0)             ; Yup, do it.     (move.l asave0 asave1)     (if# (mi (tst.w (atemp0)))       (clr.w (@+ asave0))       (add.l ($ 1) dtemp0))     (bmovdown.w atemp0 asave0 dsave0)     (move.l asave1 atemp0)     (add.w dsave1 (atemp0))		;same sign as denominator     ;(bra @retq)     @retq     (if# (ne (tst.l dtemp1))           ;Clean up quotient       (if# (mi (tst.w (atemp1)))         (clr.w (-@ atemp1))         (add.l ($ 1) dtemp1))       (add.w dsave2 (atemp1)))		;Sign of quotient     @ret     (movem.l sp@+ #(asave0 asave1 dsave0 dsave1 dsave2))     (rts))   ))(defun = (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (ccall number-arg (vsp 8))     (unuse_regs)     (move_t acc)     (lfret))   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (prog#    (move.l (asave0) arg_z)    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-eqlregacc)    (while# eq)    (sub.l (fixnum 1) dsave0)    (until# eq))   (restore_regs)                     ; (doesn't affect flags)   (retcc eq)))(defun - (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (move.l (vsp 8) acc)     (jsr_subprim $sp-minus1)    else#     (vunscale.l dsave0)     (lea (vsp nargs.w 8) asave0)     (move.l (asave0) arg_z)     (prog#      (move.l (-@ asave0) arg_y)      (jsr_subprim $sp-minus2)      (sub.l (fixnum 1) dsave0)      (until# eq)))   (restore_regs)   (lfret)))(defun / (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (move.l (vsp 8) acc)     (jsr_subprim $sp-quo1)    else#     (vunscale.l dsave0)     (lea (vsp nargs.w 8) asave0)     (move.l (asave0) arg_z)     (prog#      (move.l (-@ asave0) arg_y)      (jsr_subprim $sp-quo2)      (sub.l (fixnum 1) dsave0)      (until# eq)))   (restore_regs)   (lfret)))(defun + (&lap &rest nums)  (old-lap   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (ccall number-arg (vsp))      else#       (move.l (fixnum 0) acc))     (lfret))   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-plus2)    (sub.l (fixnum 1) dsave0)    (until# eq))   (restore_regs)   (lfret)))(defun * (&lap &rest nums)  (old-lap   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (ccall number-arg (vsp))      else#       (move.l (fixnum 1) acc))     (lfret))   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-times2)    (sub.l (fixnum 1) dsave0)    (until# eq))   (restore_regs)   (lfret)))(defun < (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (move.l (vsp 8) acc)     (jsr_subprim $sp-real1chk)     (bra @ret_t))   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (prog#    (move.l (asave0) arg_z)    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-numcmp2)    (bge @ret_nil)    (sub.l (fixnum 1) dsave0)    (until# eq))@ret_t   (unuse_regs)   (move_t acc)   (lfret)@ret_nil   (restore_regs)   (move.l nilreg acc)   (lfret)))(defun <= (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (move.l (vsp 8) acc)     (jsr_subprim $sp-real1chk)     (bra @ret_t))   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (prog#    (move.l (asave0) arg_z)    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-numcmp2)    (bgt @ret_nil)    (sub.l (fixnum 1) dsave0)    (until# eq))@ret_t   (unuse_regs)   (move_t acc)   (lfret)@ret_nil   (restore_regs)   (move.l nilreg acc)   (lfret)))(defun > (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (move.l (vsp 8) acc)     (jsr_subprim $sp-real1chk)     (bra @ret_t))   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (prog#    (move.l (asave0) arg_z)    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-numcmp2)    (ble @ret_nil)    (sub.l (fixnum 1) dsave0)    (until# eq))@ret_t   (unuse_regs)   (move_t acc)   (lfret)@ret_nil   (restore_regs)   (move.l nilreg acc)   (lfret)))(defun >= (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0))   (move.l nargs dsave0)   (if# eq     (move.l (vsp 8) acc)     (jsr_subprim $sp-real1chk)     (bra @ret_t))   (vunscale.l dsave0)   (lea (vsp nargs.w 8) asave0)   (prog#    (move.l (asave0) arg_z)    (move.l (-@ asave0) arg_y)    (jsr_subprim $sp-numcmp2)    (blt @ret_nil)    (sub.l (fixnum 1) dsave0)    (until# eq))@ret_t   (unuse_regs)   (move_t acc)   (lfret)@ret_nil   (restore_regs)   (move.l nilreg acc)   (lfret)))(defun max (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0 dsave1)) (equate _vtop 12)   (move.l nargs dsave0)   (if# eq     (move.l (vsp _vtop) acc)     (jsr_subprim $sp-real1chk)    else#     (vunscale.l dsave0)     (lea (vsp nargs.w _vtop) asave0)     (move.l (asave0) dsave1)     (prog#      (move.l (-@ asave0) arg_y)      (move.l dsave1 arg_z)      (jsr_subprim $sp-cmp2acc)      (if# lt (move.l (asave0) dsave1))   ; arg_y > arg_z      (sub.l (fixnum 1) dsave0)      (until# eq))     (move.l dsave1 acc))   (restore_regs)   (lfret)))(defun min (&lap num &rest more)  (old-lap   (klexpr 1)   (preserve_regs #(asave0 dsave0 dsave1)) (equate _vtop 12)   (move.l nargs dsave0)   (if# eq     (move.l (vsp _vtop) acc)     (jsr_subprim $sp-real1chk)     else#     (vunscale.l dsave0)     (lea (vsp nargs.w _vtop) asave0)     (move.l (asave0) dsave1)     (prog#      (move.l (-@ asave0) arg_y)      (move.l dsave1 arg_z)      (jsr_subprim $sp-cmp2acc)      (if# gt (move.l (asave0) dsave1))   ; arg_y < arg_z      (sub.l (fixnum 1) dsave0)      (until# eq))     (move.l dsave1 acc))   (restore_regs)   (lfret)))(defun integerp (thing)  (declare (%noforcestk))  (old-lap   (if# (and (ne (ttag acc da))             (eq (sub.w ($ $t_vector) da)))     (move.l acc atemp0)     (vsubtypep ($ $v_bignum) atemp0 da))   (retcc eq)))(defun numberp (thing)  (declare (%noforcestk))  (lap-inline ()    (:variable thing)    (dtagp acc $t_fixnum $t_dfloat $t_sfloat)    (bne @t)    (btst acc ($ (ash 1 $t_vector)))    (beq @nil)    (move.l acc atemp0)    (vsubtype atemp0 da)    (cmp.b ($ $v_bignum) da)    (beq @t)    (cmp.b ($ $v_ratio) da)    (beq @t)    (cmp.b ($ $v_complex) da)    (beq @t)@nil (move.l nilreg acc)    (bra @ret)@t  (move_t acc)@ret))(defun realp (thing)  (declare (%noforcestk))  (old-lap     (dtagp acc $t_fixnum $t_dfloat $t_sfloat)   (bne @t)   (dtagp acc $t_vector)   (beq @nil)   (move.l acc atemp0)   (vsubtype atemp0 da)   (cmp.b ($ $v_bignum) da)   (beq @t)   (cmp.b ($ $v_ratio) da)   (beq @t)@nil (move.l nilreg acc)   (lfret)@t (move_t acc)   (lfret)))(defun oddp (integer)  (old-lap   (if# (eq (ttag acc da))     (btst ($ $fixnumshift) acc)    else#     (move.l acc atemp0)     (if# (or (ne (sub.w ($ $t_vector) da))              (ne (vsubtypep ($ $v_bignum) atemp0 da)))       (wtaerr arg_z 'integer))     (vsize atemp0 dtemp0)     (btst ($ 0) (atemp0 dtemp0.l (1- $v_data))))   (retcc ne)))(defun evenp (integer)  (old-lap   (if# (eq (ttag acc da))     (btst ($ $fixnumshift) acc)    else#     (move.l acc atemp0)     (if# (or (ne (sub.w ($ $t_vector) da))              (ne (vsubtypep ($ $v_bignum) atemp0 da)))       (wtaerr arg_z 'integer))     (vsize atemp0 dtemp0)     (btst ($ 0) (atemp0 dtemp0.l (1- $v_data))))   (retcc eq)))(defun integer-length (integer)  (old-lap   (if# (eq (ttag acc da))     (move.l acc da)     (if# (mi (move.l acc da)) (not.l da))     (move.l ($ (- 31 $fixnumshift 1)) acc)  @0 (lsl.l ($ 1) da)     (dbmi acc @0)     (add.w ($ 1) acc)     (mkint acc)     (lfret))   (move.l acc atemp0)   (bif (or (ne (sub.w ($ $t_vector) da))            (ne (vsubtypep ($ $v_bignum) atemp0 da))) @bad)   (getvect atemp0 da)   (lsr.l 1 da)   (sub.l ($ 1) da)   (move.l da acc)   (lsl.l 4 acc)   (move.l ($ (1- 15)) dy)   (move.w (atemp0) db)@1 (lsl.w 1 db)   (dbmi dy @1)   (add.w ($ 1) dy)   (add.w dy acc)   ;acc=IntLen(|A|)=haulong(A)   (bif (pl (tst.w (@+ atemp0))) @ret)   (if# (eq (tst.w dy))     (move.w (@+ atemp0) db)     (sub.l ($ 1) da))   (lsl.w 1 db)   (bra @11)@10 (tst.w (@+ atemp0))@11 (dbne da @10)    (if# eq      (add.w ($ 1) da) (sub.l ($ 1) da) (bcc @10)      (sub.l ($ 1) acc))@ret (mkint acc)     (lfret)@bad (wtaerr arg_z 'integer)))(defun ash (int count)  (old-lap   (ttag acc da)   (if# ne     ;Strictly speaking should allow bignums (esp. if int is 0), so...     (vpush arg_y)     (jsr_subprim $sp-req-integerZ)     (vpop arg_y)     (if# (eq (dtagp acc $t_fixnum))       (move.l acc atemp0)       (move.l (fixnum most-positive-fixnum) acc)       (if# (mi (tst.w (atemp0 $v_data))) (not.l acc))))   (getint acc)   (move.l acc da)			;da = shift count   (if# mi     (neg.l da)                         ; Shift right     (ttag arg_y db)     (if# ne       (sub.w ($ $t_vector) db)       (bne @bad_y)       (move.l arg_y atemp0)       (vsubtypep ($ $v_bignum) atemp0 db)       (bne @bad_y)       (bra BgAsr))     (move.l arg_y acc)     (move.l ($ (- 32 $fixnumshift)) db)     (if# (gt (cmp.l db da)) (move.l db da))     (add.w ($ $fixnumshift) da)     (move.l arg_y acc)     (asr.l da acc)     (mkint acc)    else#     (ttag arg_y db)                    ; Shift left     (if# ne       (sub.w ($ $t_vector) db)       (bne @bad_y)       (move.l arg_y atemp0)       (vsubtypep ($ $v_bignum) atemp0 db)       (beq BgAsl)       @bad_y       (wtaerr arg_y 'integer))     (move.l arg_y acc)     (beq @ret)     (move.l ($ (- 32 $fixnumshift)) db)     (cmp.l db da)     (bge BgAsl_fixnum)     (asl.l da acc)     (bvs BgAsl_fixnum))   @ret   (lfret)   BgAsl_fixnum   ;da=count, arg_y = fixnum   (move.l arg_y acc)   (move.l da arg_y)                    ; preserve count   (jsr_subprim $sp-xbigintarg1)   (move.l arg_y da)   BgAsl	;da=count, atemp0=bignum   (preserve_regs #(asave0 dsave0))   (move.l atemp0 asave0)   (move.l ($ #xF) db)                  ;db = # bits   (and.l da db)   (lsr.l 4 da)                         ;da = # words   (getvect atemp0 acc)   (lsr.l 1 acc)   (add.l da acc)   (move.w ($ #x7FFF) dy)   (and.w (atemp0) dy)   (asl.w db dy)   (if# vs (add.l ($ 1) acc))   (begin_csarea)   (spush db)   (spush da)   (begin_csarea)   (jsr_subprim $sp-ConsBignum)        ;acc=atemp0<- bignum   (spop_csarea)   (getvect atemp0 da)   (lea (atemp0 da.l) atemp1)   (move.l ($ 0) db)   (spop da)   (dbfloop.l da (move.w db (-@ atemp1)))   (getvect asave0 da)   (add.l da asave0)   (lsr.l 1 da)   (spop db)                            ;# bits   (move.l ($ 0) dsave0)   (dbfloop.l da            (move.l ($ 0) dy)            (move.w (-@ asave0) dy)            (lsl.l db dy)            (or.w dsave0 dy)            (move.w dy (-@ atemp1))            (swap dy)            (move.w dy dsave0))   (if# (ne atemp0 atemp1) (clr.w (-@ atemp1)))   (sub.w ($ 1) db)                     ;shift the sign bit   (if# pl     (bclr db dy)     (if# ne (bset ($ 15) dy))     (or.w dy (atemp1)))   (spop_csarea)   (restore_regs)   (lfret)   BgAsr   (move.l atemp0 atemp1)   (getvect atemp1 acc)   (move.l acc db)   (lsl.l 3 db)   (sub.l ($ 1) db)			;number of bits in bignum   (if# (le (cmp.l da db))              ; <= shift, nothing left...     @punt     (move.l '0 acc)     (if# (mi (tst.w (atemp1))) (move.l '-1 acc))     (lfret))   (preserve_regs asave0)   (move.l atemp0 asave0)   (moveq #xF db)                       ;db=r   (and.w da db)   (swap db)   (lsr.l 4 da)                         ;da=k   (tst.w (atemp1))   (if# mi     (st db)     (move.l da dy)     (if# ne       (add.l acc atemp1)       (sub.l ($ 1) dy)       (prog#         (tst.w (-@ atemp1))         (dbne dy (top#))	 (seq db)	 (if# eq	   (add.w ($ 1) dy)	   (sub.l ($ 1) dy)	   (bcc (top#)))	 )))   (spush db)   (sub.l da acc)   (sub.l da acc)   (add.l ($ 2) acc)   (move.l ($ $v_bignum) arg_y)   (jsr_subprim $sp-reservevect)       ;atemp0=bignum, acc=size   (lea (asave0 acc.l (- $v_data 2)) atemp1)	;atemp1 = old   (lea (atemp0 acc.l $v_data) atemp0)   ;atemp0 = new   (sub.l ($ 2) acc)   (lsr.l 1 acc)                        ;acc = number of words   (move.l atemp0 asave0)   (move.l acc da)   (bmovup.w atemp1 atemp0 da)   (bclr ($ 7) (atemp0))   (spop db)   (tst.b db)   (if# ne     (move.l ($ 1) da)     (prog# (sub.w da (-@ asave0)) (until# cc)))   (swap db)			;number of bits   (sub.l ($ 1) acc)   (dbfloop db            (move.l atemp0 asave0)	;shift it one bit at a time...            (move.l acc da)            (lsr (@+ asave0))	    (bra @sh2)	    @sh0 (swap da)	    @sh1 (roxr (@+ asave0))	    @sh2 (dbf da @sh1)	         (swap da)		 (dbf da @sh0))   (restore_regs)   (tst.w (@+ atemp0))			;Normalize   (bne @41)   (tst.l acc)   (beq @punt)   (tst.w (atemp0))   (if# mi     @41     (sub.w ($ 2) atemp0)     (add.l ($ 1) acc))   (if# (mi (tst.w (atemp1)))     (lea (atemp0 acc.l) atemp1)     (add.l acc atemp1)     (move.l ($ 1) da)     (prog# (add.w da (-@ atemp1)) (until# cc))     (if# (mi (tst.w (atemp0)))       (clr.w (-@ atemp0))       (add.l ($ 1) acc))     (bset 7 (atemp0)))   (jsr_subprim $sp-MkPermInt)   (lfret)));Not CL.  Used by transforms.(defun byte-mask (size)  ;(1- (ash 1 size))  (unless (and (fixnump size) (%i>= size 0)) (report-bad-arg size '(integer 0 #.most-positive-fixnum)))  (old-lap-inline ()   (move.l (varg size) da)   (getint da)   (if# (lt (cmp.l ($ (- 32 $fixnumshift)) da))     (move.l ($ 1) acc)     (lsl.l da acc)     (sub.l ($ 1) acc)     (mkint acc)    else#     (lsr.l ($ 4) da)     (add.l ($ 1) da)     (move.l da dtemp0)     (jsr_subprim $sp-consbignum)     (move.l (varg size) da)     (getint da)     (move.l ($ 15) db)     (and.w da db)     (lsr.l ($ 4) da)     (lea (atemp0 da.l (+ 2 $v_data)) atemp1)     (add.l da atemp1)     (moveq -1 dy)     (dbfloop.l da (move.w dy (-@ atemp1)))     (moveq 1 dy)     (lsl.w db dy)     (sub.w ($ 1) dy)     (move.w dy (-@ atemp1)))));Not CL. Used by transforms.(defun load-byte (size position integer)  (if (and (bignump integer)           (<= size #.(integer-length most-positive-fixnum))           (fixnump position))    (%ldb-fixnum-from-bignum integer size position)    (let ((mask (byte-mask size)))      (if (and (fixnump mask) (fixnump integer))        (locally (declare (fixnum mask integer))          (%ilogand mask             (if (>= position 32)              (if (minusp integer) -1 0)              ; %IASR DOESN'T WORK FOR POS > 32 OR 64 OR SOMETHING              ; and besides we haven't checked for pos being fixnum              (%iasr position integer))))        (logand mask (ash integer (- position)))))))(defun %ldb-fixnum-from-bignum (bignum size position)  (declare (fixnum position size))  (if (> (+ position size)(integer-length bignum))    (let ((mask (byte-mask size)))      (logand mask (ash bignum (- position))))    (lap-inline ()      (:variable bignum size position)      (move.l (varg bignum) atemp0)      (getvect atemp0 db)                 ; number of bytes      (lsl.l ($ 3) db)                    ; number of bits in bignum      (move.l (varg position) da)      (getint da)      (move.l db dx)      (sub.l da dx)                       ; bits from atemp0 for bfextu      (move.l (varg size) dy)      (getint dy)      (sub.l dy dx)      (if# mi        (add.l dx dy)        (move.l ($ 0) dx))      (if# eq        ; skip sign bit        (add.l ($ 1) dx)        (sub.l ($ 1) dy))      (move.l ($ 0) acc)      (if# (gt (tst.l dy))        (bfextu @atemp0 dx dy acc)        (if# (mi (tst.b @atemp0))          ; bignum is negative. Need to complement/negate result          (eor.l ($ #xffffffff) acc)          (move.w da -@sp)                  ; save low bits of position          (lsr.l ($ 3) db)                  ; number of bytes in bignum          (add.l db atemp0)          (lsr.l ($ 3) da)                  ; number of full bytes before position          (move.b ($ 0) dx)          (dbfloop.l da            (bif (ne (cmp.b -@atemp0 dx)) @nooverflow))          (clr.l dx)          (move.w @sp dx)          (and.w ($ 7) dx)          (move.w ($ 1) da)          (lsl.w dx da)          (sub.w ($ 1) da)          (move.b -@atemp0 db)          (and.b da db)          (bif ne @nooverflow)          (add.l ($ 1) acc)          @nooverflow                    (add.l ($ 2) sp)          (move.l ($ 1) da)          (lsl.l dy da)          (sub.l ($ 1) da)          (and.l da acc)))      (jsr_subprim $sp-mkulong)      )    ));Not CL. Used by transforms.(defun deposit-byte (value size position integer)  (let ((mask (byte-mask size)))    (logior (ash (logand value mask) position)            (logandc1 (ash mask position) integer))))(defun deposit-field (value bytespec integer)  (logior (logandc1 bytespec integer) (logand bytespec value)));;;;;;;;;;  Byte field functions ;;;;;;;;;;;;;;;;(defun byte (size position)  (unless (and (integerp position) (not (minusp position))) (report-bad-arg position 'unsigned-byte))  (ash (byte-mask size) position))(defun byte-position (bytespec)  ;(- (integer-length bytespec) (logcount bytespec))  (old-lap   (if# (eq (ttag acc da))     (move.l arg_z da)     (beq @exit)     (ble @bad)     (move.l ($ (1- $fixnumshift)) acc)     (prog# (add.w ($ 1) acc) (until# (ne (btst acc da))))     (sub.w ($ $fixnumshift) acc)   else#    (move.l acc atemp0)    (bif (or (ne (sub.w ($ $t_vector) da))             (ne (vsubtypep ($ $v_bignum) atemp0 da))             (mi (tst.w (atemp0 $v_data)))) @bad)    (getvect atemp0 da)    (add.l da atemp0)    (lsr.l 1 da)    (move.l da acc)    (sub.l ($ 1) da)    (prog# (move.w (-@ atemp0) dy)           (dbne da (top#))	   (if# eq	     (add.w ($ 1) da)	     (sub.l ($ 1) da)	     (bcc (top#))))    (sub.l da acc)    (sub.l ($ 1) acc)    (lsl.l ($ 4) acc)    (move.l ($ -1) da)    (prog# (add.l ($ 1) da) (until# (ne (btst da dy))))    (add.l da acc))   (mkint acc)   @exit   (lfret)   @bad   (wtaerr acc '(integer (0)))))(defun byte-size (bytespec) (logcount bytespec))(defun ldb (bytespec integer)  (if (and (fixnump bytespec) (fixnump integer))    (%ilsr (byte-position bytespec) (%ilogand bytespec integer))    (let ((size (byte-size bytespec))          (position (byte-position bytespec)))      (if (and (bignump integer)               (<= size #.(integer-length most-positive-fixnum))               (fixnump position))        (%ldb-fixnum-from-bignum integer size position)        (ash (logand bytespec integer) (- position))))))(defun mask-field (bytespec integer)  (logand bytespec integer))(defun dpb (value bytespec integer)  (if (and (fixnump value) (fixnump bytespec) (fixnump integer))    (%ilogior (%ilogand bytespec (%ilsl (byte-position bytespec) value))              (%ilogand (%ilognot bytespec) integer))    (deposit-field (ash value (byte-position bytespec)) bytespec integer)))(defun ldb-test (bytespec integer)  (logtest bytespec integer)); random associated stuff except for the print-object method which is still in; "lib;numbers.lisp"(defun random-state (seed-1 seed-2)  (unless (and (fixnump seed-1) (%i<= 0 seed-1) (%i< seed-1 #x10000))    (report-bad-arg seed-1 '(unsigned-byte 16)))  (unless (and (fixnump seed-2) (%i<= 0 seed-2) (%i< seed-2 #x10000))    (report-bad-arg seed-2 '(unsigned-byte 16)))  (%gvector $v_istruct            'random-state            (%ilsl (%i- 16 $fixnumshift) seed-1)            (%ilsl (%i- 16 $fixnumshift) seed-2)))(defparameter *random-state* (random-state #xFBF1 9))(defun make-random-state (&optional state &aux (seed-1 0) (seed-2 0))  (if (eq state t)    (lap-inline ()      (:variable seed-1 seed-2)      (move.l (@ $Ticks) acc)      (move.w acc (varg seed-1))      (swap acc)      (move.w acc (varg seed-2)))    (progn      (setq state (require-type (or state *random-state*) 'random-state))      (setq seed-1 (%svref state 1) seed-2 (%svref state 2))))  (%gvector $v_istruct 'random-state seed-1 seed-2))(defun random-state-p (thing) (istruct-typep thing 'random-state))(defun random (number &optional state)  (setq state (require-type (or state *random-state*) 'random-state))  (lap-inline ()    (:variable number state)    (preserve_regs #(asave0 dsave0 dsave1))    (move.l (varg state 12) asave0)    (move.l (varg number 12) arg_y)    (bif (ne (dtagp arg_y $t_sfloat $t_dfloat)) float)    (move.l arg_y arg_z)    (jsr_subprim $sp-bigintarg1)    (bif (le (tst.l (atemp0 $v_data))) @notposerr)   ; arg_y = number    (move.l atemp0 dsave0)    (vsize atemp0 dtemp0)    (add.l ($ 6) dtemp0)    (move.l ($ $v_bignum) arg_y)    (jsr_subprim $sp-reservevect)    (lea (atemp0 dtemp0.l $v_data) atemp0)    (move.l dsave0 atemp1)    (getvect atemp1 dtemp1)    (lsr.l 1 dtemp1)    (tst.w (atemp1))    (if# eq (add.w ($ 2) atemp1) (sub.l ($ 1) dtemp1))    (move.w (svref asave0 1) dsave0)    (move.w (svref asave0 2) dsave1)    (move.l dtemp1 dtemp0)    (prog#     (bsr nextseed)     (move.w dsave1 (-@ atemp0))     (dbfl dtemp0 (top#)))    (move.w dsave1 (svref asave0 2))    (move.w dsave0 (svref asave0 1))    (unuse_regs)    (move.l dtemp1 dtemp0)    (add.l ($ 1) dtemp0)    (if# (eq (and.w ($ #x7FFF) (@+ atemp0)))      (prog#       (bif (eq (sub.l ($ 1) dtemp0)) @zero)       (until# (ne (tst.w (@+ atemp0))))))    (sub.w ($ 2) atemp0)    (jsr_subprim $sp-nBgUnsDivide)    (bif (eq (tst.l dtemp0)) @zero)    (if# (mi (tst.w (atemp0)))      (clr.w (-@ atemp0))      (add.l ($ 1) dtemp0))    (jsr_subprim $sp-mkpermint)    (bra @exit)    @zero    (move.l '0 acc)    (bra @exit)    ;Argument is not a positive number    @notposerr    (wtaerr arg_y '(number (0) *))    Float    (if# (ne (dtagp arg_y $t_sfloat))      (bif (or (ne (btst ($ 3) arg_y)) (eq ($ 0.0s0) arg_y)) @notposerr)      (move.l arg_y arg_z)      (jsr_subprim $sp-SFloatFP1)      (fmove.x fp1 fp0)      else#      (move.l arg_y atemp0)      (sub.w ($ $t_dfloat) atemp0)      (bif (or (mi (tst.l (@+ atemp0))) (and eq (eq (tst.l (atemp0))))) @notposerr)      (fmove.d (atemp0 -4) fp0))    (move.w (svref asave0 1) dsave0)    (move.w (svref asave0 2) dsave1)    (moveq ($ (1- 4)) dtemp0)    (prog#      (bsr NextSeed)      (move.w dsave1 (-@ sp))      (dbf dtemp0 (top#)))    (move.w dsave1 (svref asave0 2))    (move.w dsave0 (svref asave0 1))    (restore_regs)    (bclr 7 (sp))    (move.l ($ #x3FFF0000) (-@ sp))    (fmove.x @sp fp1)    (fmul.x fp0 fp1)    (add.w ($ 12) sp)    (if# (ne (dtagp arg_y $t_sfloat))      (jsr_subprim $sp-FP1SFloat)      (bra @exit))    (jsr_subprim $sp-FP1DFloat)    (bra @exit)    ;advance random seed in dsave0.w/dsave1.w.  Clobbers db only.    NextSeed    (mulu ($ #x41a7) dsave0)    (mulu ($ #x41a7) dsave1)    (swap dsave1)    (moveq 0 db)    (move.w dsave1 db)    (add.l db dsave0)    (add.l dsave0 dsave0)    (lsr.w 1 dsave0)    (swap dsave0)    (clr.w dsave1)    (swap dsave1)    (add.l dsave1 dsave0)    (if# (ne (bclr 31 dsave0))      (add.l ($ 1) dsave0))    (if# (eq (tst.l dsave0))      (move.w ($ 1) dsave0))    (move.w dsave0 dsave1)    (swap dsave0)    (rts)@exit))#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)