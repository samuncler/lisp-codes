;;;-*-Mode: LISP; Package: CCL -*-;; Copyright 1986-1988 Coral Software Corp.;; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.; 07/22/92 bill %sort-list-error -> sort-list-error; ------------- 2.0; 04/30/90 gb   new &lap arglist.  Cosmetic.  Or maybe not.; 12/06/89 bill Moved from sort.lisp.;;; Low-level list sorting routines.  Used by CLOS and SORT.#| ;Replaced by lap code below(defun %sort-list (list pred key)  (declare (special list pred key))  (do ((height 0 (%i+ height 1))       (result () (%merge-lists result (sort-prefix height) pred key)))      ((null list) result)))(defun sort-prefix (height)  (declare (special list pred key))  (cond ((null list) ())	 ((eq height 0) (%rplacd (prog1 list (setq list (cdr list))) nil))	 (T (%merge-lists (sort-prefix (%i- height 1))                          (sort-prefix (%i- height 1))                          pred key))))(defun %merge-lists (l1 l2 test &optional (key #'identity))  ; Merge two sorted non-null lists in a stable manner.  (if (null l1)    (return-from %merge-lists l2))  (if (null l2)    (return-from %merge-lists l1))  (if (null key) (setq key #'identity))  (prog (link res k1 k2)    (if (funcall test                 (setq k2 (funcall key (%car l2)))                 (setq k1 (funcall key (%car l1))))      (progn (setq res l2 link l2 l2 (%cdr l2))             (go getl2))      (progn (setq res l1 link l1 l1 (%cdr l1))             (go getl1)))    linkl1    (setf (%cdr link) l1 link l1 l1 (%cdr l1))    getl1    (when (null l1)      (setf (%cdr link) l2)      (return res))    (setq k1 (funcall key (%car l1)))    compare    (unless (funcall test k2 k1)      (go linkl1))        linkl2    (setf (%cdr link) l2 link l2 l2 (%cdr l2))    getl2    (when (null l2)      (setf (%cdr link) l1)      (return res))    (setq k2 (funcall key (%car l2)))    (go compare)))|#; lap version; list is type-checked (have to, otherwise we'd need another pass;                       to check for a proper list).; pred had better be functionp.; key had better be functionp.; Note: the set_nargs calls are commented out because the lap version; of %merge-lists doesn't look at it.(defun %sort-list (list pred key)  (declare (%noforcestk))  (old-lap   (preserve_regs #(asave0 asave1 dsave0 dsave1 dsave2))   (defreg aLIST asave0 aRESULT asave1 dPRED dsave0 dKEY dsave1 dHEIGHT dsave2)   (move.l '0 dHEIGHT)   (move.l nilreg aRESULT)   (move.l (varg list) aLIST)   (move.l (varg pred) dPRED)   (move.l (varg key) dKEY)   @loop   (cmp.l nilreg aLIST)   (if# eq     (move.l aRESULT acc)     (restore_regs)     (spop vsp)     (rts))   (bsr @sort-prefix)   (vpush aRESULT)   (move.l acc arg_x)   (move.l dPRED arg_y)   (move.l dKEY arg_z);   (set_nargs 4)   (jsr #'%merge-lists)   (move.l acc aRESULT)   (add.l '1 dHEIGHT)   (bra @loop)   @sort-prefix   (cmp.l aLIST nilreg)   (if# eq (move.l nilreg acc) (rts))   (cmp.l '0 dHEIGHT)   (if# eq     (move.l aLIST acc)                 ; must type check for proper list     (bif (eq (dtagp acc $t_cons)) @error)     (move.l aLIST atemp0)     (move.l (cdr aLIST) aLIST)     (move.l nilreg (cdr atemp0))     (rts))   (vpush dHEIGHT)   (sub.l '1 dHEIGHT)   (bsr @sort-prefix)   (vpush acc)   (bsr @sort-prefix)   (move.l (vsp 4) dHEIGHT)   (vpop @vsp)   (move.l acc arg_x)   (move.l dPRED arg_y)   (move.l dKEY arg_z);   (set_nargs 4)   (jmp #'%merge-lists)   @error                               ; Was not a proper list   (set_nargs 0)   (jmp #'sort-list-error)));; The no-key version of %sort-list;; list had better be a list.;; pred had better be functionp.(defun %sort-list-no-key (list pred)  (declare (%noforcestk))  (old-lap   (preserve_regs #(asave0 asave1 dsave0 dsave2))   (defreg aLIST asave0 aRESULT asave1 dPRED dsave0 dHEIGHT dsave2)   (move.l '0 dHEIGHT)   (move.l nilreg aRESULT)   (move.l (varg list) aLIST)   (move.l (varg pred) dPRED)   @loop   (cmp.l nilreg aLIST)   (if# eq     (move.l aRESULT acc)     (restore_regs)     (spop vsp)     (rts))   (bsr @sort-prefix)   (move.l aRESULT arg_x)   (move.l acc arg_y)   (move.l dPRED arg_z);   (set_nargs 3)   (jsr #'%merge-lists-no-key)   (move.l acc aRESULT)   (add.l '1 dHEIGHT)   (bra @loop)   @sort-prefix   (cmp.l aLIST nilreg)   (if# eq (move.l nilreg acc) (rts))   (cmp.l '0 dHEIGHT)   (if# eq     (move.l aLIST acc)                 ; must type check for proper list     (bif (eq (dtagp acc $t_cons)) @error)     (move.l aLIST acc)     (move.l aLIST atemp0)     (move.l (cdr aLIST) aLIST)     (move.l nilreg (cdr atemp0))     (rts))   (vpush dHEIGHT)   (sub.l '1 dHEIGHT)   (bsr @sort-prefix)   (vpush acc)   (bsr @sort-prefix)   (vpop arg_x)   (vpop dHEIGHT)   (move.l acc arg_y)   (move.l dPRED arg_z);   (set_nargs 3)   (jmp #'%merge-lists-no-key)   @error                               ; Was not a proper list   (set_nargs 0)   (jmp #'sort-list-error)))(defun sort-list-error ()  (error "List arg to SORT not a proper list"));; Lap version of %merge-lists does not check its args.  Be careful!;; Expects l1 & l2 to be proper lists.;; test is functionp.  key is functionp.(defun %merge-lists (&lap l1 l2 test key)  (old-lap    (cmp.l @vsp nilreg)                 ; (null l1)    (if# eq (move.l arg_x acc) (add.l ($ 4) vsp) (rts))    (cmp.l arg_x nilreg)                ; (null l2)    (if# eq (vpop acc) (rts))    (preserve_regs)                     ; 5 saved registers = offset of 5*4 = 20    (defreg aLINK asave0 dKEY dsave0 aTEST asave1 dL1 dsave1 dL2 dsave2)    (move.l (vsp 20) dL1)               ; l1    (move.l arg_x dL2)                  ; l2    (move.l arg_y aTEST)                ; test    (move.l arg_z dKEY)                 ; key    (vpush nilreg)    (vpush nilreg)                      ; the keys are stored here.    (move.l dL2 atemp0)    (move.l dKEY atemp1)    (move.l (car atemp0) arg_z)    (set_nargs 1)    (jsr @atemp1)                     ; (funcall key (car l2))    (move.l acc @vsp)    (move.l dL1 atemp0)    (move.l dKEY atemp1)    (move.l (car atemp0) arg_z)    (set_nargs 1)    (jsr @atemp1)                     ; (funcall key (car l1))    (move.l acc (vsp 4))    (move.l @vsp arg_y)    (set_nargs 2)    (jsr @aTEST)                        ; (funcall test k2 k1)    (cmp.l acc nilreg)    (if# eq      (move.l dL1 (vsp 28))             ; Return value on stack      (move.l dL1 aLINK)      (move.l (cdr aLINK) dL1)      (bra @getV1)     else#      (move.l dL2 (vsp 28))             ; Return value on stack      (move.l dL2 aLINK)      (move.l (cdr aLINK) dL2)      (bra @getv2))    @compare    (set_nargs 2)    (jsr @aTEST)    (cmp.l acc nilreg)    (if# eq      (move.l dL1 (cdr aLINK))      (move.l dL1 aLINK)      (move.l (cdr aLINK) dL1)      @getv1      (cmp.l nilreg dl1)      (if# eq        (move.l dl2 (cdr aLINK))        (bra @exit))      (move.l dL1 atemp0)      (move.l dKEY atemp1)      (move.l (car atemp0) arg_z)      (set_nargs 1)      (jsr @atemp1)                     ; (funcall key (car l1))      (move.l acc (vsp 4))      (move.l @vsp arg_y)      (bra @compare)     else#      (move.l dL2 (cdr aLINK))      (move.l dL2 aLINK)      (move.l (cdr aLINK) dL2)            @getv2      (cmp.l nilreg dl2)      (if# eq        (move.l dl1 (cdr aLINK))        (bra @exit))      (move.l dL2 atemp0)      (move.l dKEY atemp1)      (move.l (car atemp0) arg_z)      (set_nargs 1)      (jsr @atemp1)                     ; (funcall key (car l2))      (move.l acc @vsp)      (move.l acc arg_y)      (move.l (vsp 4) arg_z)      (bra @compare))    @exit    (add ($ 8) vsp)                      ; pop keys    (restore_regs)    (vpop acc)    (rts)));; The no-key version of %merge-lists.;; Again, l1 & l2 must be proper lists & test is functionp.(defun %merge-lists-no-key (&lap 0)  ;(l1 l2 test)  (old-lap    (cmp.l arg_x nilreg)                 ; (null l1)    (if# eq (move.l arg_y acc) (rts))    (cmp.l arg_y nilreg)                ; (null l2)    (if# eq (move.l arg_x acc) (rts))    (preserve_regs #(asave0 asave1 dsave1 dsave2))   ; 4 saved registers = offset of 4*4 = 16    (defreg aLINK asave0 dKEY dsave0 aTEST asave1 dL1 dsave1 dL2 dsave2)    (move.l arg_x dL1)    (move.l arg_y dL2)    (move.l arg_z aTEST)    (move.l dL2 atemp0)    (move.l (car atemp0) arg_y)    (move.l dL1 atemp0)    (move.l (car atemp0) arg_z)    (set_nargs 2)    (jsr @aTEST)                        ; (funcall test k2 k1)    (cmp.l acc nilreg)    (if# eq      (vpush dL1)         ; Return value on stack      (move.l dL1 aLINK)      (move.l (cdr aLINK) dL1)      (bra @getV1)     else#      (vpush dL2)         ; Return value on stack      (move.l dL2 aLINK)      (move.l (cdr aLINK) dL2)      (bra @getv2))    @compare    (move.l dL2 atemp0)    (move.l (car atemp0) arg_y)    (move.l dL1 atemp0)    (move.l (car atemp0) arg_z)    (set_nargs 2)    (jsr @aTEST)    (cmp.l acc nilreg)    (if# eq      (move.l dL1 (cdr aLINK))      (move.l dL1 aLINK)      (move.l (cdr aLINK) dL1)      @getv1      (cmp.l nilreg dl1)      (bne @compare)      (move.l dl2 (cdr aLINK))      (bra @exit)     else#      (move.l dL2 (cdr aLINK))      (move.l dL2 aLINK)      (move.l (cdr aLINK) dL2)            @getv2      (cmp.l nilreg dl2)      (bne @compare)      (move.l dl1 (cdr aLINK))      #|(bra @exit)|#)    @exit    (vpop acc)    (restore_regs)    (rts)))