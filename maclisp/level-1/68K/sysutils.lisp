;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  2 2/13/97  akh  moved some stuff to common file;;  12 9/3/96  akh  get addtional machine-types from 4.0 sources;;  10 1/30/96 akh  structure-class-p patch from bill;;  9 8/31/95  akh  below s.b. font-codes, also change to not assume 0 is chicago.;;  8 8/31/95  akh  use position #'eq in font-spec - compiles better;;  7 8/18/95  akh  merge-font-codes - DONT require fixnums;;  6 7/27/95  akh  newer *known-gestalt-machine-types*;;  3 5/4/95   akh  make stp-specialist tables be hash tables;;  2 4/25/95  akh  Fix (ugh) subtypep for extended and base strings.;;  11 3/24/95 akh  teach parse-array-type about extended strings;;  8 3/2/95   akh  change element-type-subtype for new regime;;  7 2/7/95   akh  string-width errors if string too long;;  6 2/3/95   akh  merge leibniz patches;;  5 2/2/95   akh  merge leibniz patches;;  (do not edit before this line!!);; sysutils.lisp - things which have outgrown l1-utils; Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!;; Modification History;; 5/16/95 slh   new improved trap-implemented-p; 3/24/95 slh   complement: something bizarre (having to do with 'F' local?) caused;               it to compile with F being special; so changed F to FN.; 3/11/95 slh   use gestalt bitnum arg; 3/02/95 slh   removed array-dimension-limit, array-total-size-limit checks;-------------  3.0d17; 1/25/95 slh   make-array-1 checks array-dimension-limit;-------------  3.0d16;01/05/95 alice dont say format nil - it doesnt boot. (fix this better later);12/26/94 alice class-cell-typep moved to l1-clos for boot reasons;05/27/94 bill  (typep 1/2 '(complex rational)) no longer returns true.;03/09/93 bill  font-codes-string-width now takes optional start & end parameters;-------------  3.0d13;07/29/93 bill  Use the #$kMachineNameStrID to get (machine-type).;               Say "#n" instead of "Unknown" when we don't find *environs* values;               in the number->name alists.;07/28/93 bill  add Quadra 950, LC II, & PowerBook 145 to *known-gestalt-machine-types*;-------------- 3.0d12;06/21/93 alice init-uvector-contents error more grammatical?;05/17/93 alice type predicates for simple-base-string, simple-extended-string, base-character and extended-character;05/16/93 alice describe-array fewer foo-p's - make it work for simple-mumble-string etc. ;05/04/93 alice St-Array-Element-Type distinquishes base-character from character;02/03/93 alice added font-codes-string-width, font-codes-line-height ;10/14/92 alice moved font-codes-info to l1-edbuf;03/16/93 bill kill managed-vector-space. Nobody calls it and it no longer makes sense.;01/29/93 bill *%dynvlimit%*;---------- 2.1d1;11/20/92 gb  don't cons temp-vector space.  Move #'TRUE & #'FALSE elsewhere.  Half-understand;             fat strings.  New headers.  [Signal compiler-warnings, appleevent-detection from;             earlier patches.]; 09/11/92 bill (typep ar '(simple-array double-float (4 4))) now has a chance of;               returning true. (dotimes (i rank) ...) -> (dotimes (i rank t) ...); 04/13/92 bill in redefine-kernel-function: CCL -> MCL;-------- 2.0;03/09/92 gb's fix to the :appleevents determination in *environs*;---------- 2.0f3;02/07/92 (gb from bootpatch0) ST-ARRAY-DIMENSIONS-ENCOMPASS got broken at some point.;02/04/92 bill the ff & ms args to font-info are &aux, not &optional.;---------- 2.0f2;01/14/92 gb   Don't call SUB-SUBTYPE unless you're willing to let it decide the whole issue.;12/27/91 bill remove ignored optional args from font-codes-info.;12/06/91 gb   update *known-gestalt-machine,-keyboard-types* for 10/91 hardware.;---------- 2.0b4;11/04/91 gb   maybe more subtypep fixes.;10/28/91 bill  GB's fix to (def-subtypep-specialist 1 or ...);10/29/91 alice def-load-pointers => def-ccl-pointers;10/22/91 gb   *suppress-compiler-warnings*.;10/11/91 gb   flush more of subtypep.;---------- 2.0b3;09/05/91 bill gestalt -> l1-aprims;09/04/91 bill initialize *setgworld-available?* & *screen-gdevice*;08/24/91 gb   use new trap syntax.;08/01/91 gb   class objects are type specifiers.;07/01/91 gb   (make-array :element-type 'float) == (make-array :element-type t), new badarg scheme,;	       account for defconstant wimpiness, find structure class info in env, cl-types elsewhere,;              use declaim now that it does something.;06/24/91 bill font-info's ff & ms args should have been &optional not &aux;---------- 2.0b2;05/28/91 bill structurep -> l1-aprims;05/20/91 gb   flush (Gensym) temp-number stuff.  Pathnames are equalp iff they're equal.;              incorporate short-floats into type system.;04/02/91 bill fix the integer subtypep specialists, signed-byte & unsigned-byte have symbol subtypes;03/05/91 alice report-bad-arg usually gets 2 args, equalp call eql instead of eq;02/28/91 alice add an eval-p optional arg to signal-compiler-warning;02/18/91 gb   %uvsize -> uvsize.;---------- 2.0b1;02/06/91 bill  %alloc-temp-vector-space & %clear-temp-vector-space patches from patch2.0b1p0;01/14/91 gb   flush *use-wait-next-event*.;01/09/90 gb   :fpu is NIL when known to have no FPU in *environs*.;01/01/91 gb   cerror when redefining functions as macros or vice versa.  Use FROZEN-DEFINITION-P;              to identify functions which should cerror on redefinition when *warn-if-redefine-kernel*;              is on.  Revive PRELOAD-ALL-FUNCTIONS.;12/8/90  joe  Add :appleevents to sysenvirons;11/30/90 bill font-codes defaults to :srcor vice :srccopy;11/21/90 gb   16 bits.  Know about newer machine types.  Equalp compares hash tables.;11/12/90 bill Make sysenvirons notice 8 or 32-bit quickdraw.;              gb: gestalt checks only low 16 bits of d0 on first return.;10/25/90 gz   $v_ulongv. Check for the common compound types in element-type-subtype.;10/12/90 gb   new(er) lap.  No $v_shortv.  Make-array errs on bad typespecs.;              %require-type.;10/03/90 bill %class-cpl -> %inited-class-cpl.;              subtypep now errors when given two class names and the first one can not be initialized.;              It used to return (values nil nil), but CLtL 2 says this is not allowed.;09/21/90 bill add type to def-accessors for deferred-warnings.;09/12/90 gb   %temp-cons in compiler now.;08/12/90 bill add ignored ff-mask, ms-mask args to font-codes-info;08/10/90 bill with-temporary-consing, %temp-cons, %really-temp-cons;08/02/90 gb   Use _gestalt vice _sysenvirons.  %uvref,-set -> uvref,uvset.;07/24/90 akh  add make-array-1, and make-uarray-1 - no keyword args;06/21/90 gb   typep checks %deftype-expander before special-casing structures;              & classes.; -------- 2.0a1;06/10/90 gb   know about IIfx machine-type.;06/02/90 gb   deferred warnings.;05/30/90 bill (type-predicate 'structure-object) -> 'structurep;05/29/90 bill Move %temp-port% to l1-windows.;05/23/90 bill nil to font-codes for old-ff or olf-ms gets default of 0.;05/19/90 gb   dispatch in *sysenvirons* initialization.; 05/04/90 gz  Removed this upgraded-array-element-type, see l1-aprims.;05/04/90 bill fron gb: in typep: add "type" arg to call to error.;05/01/90 bill font-line-height; 04/30/90 gb  constantly, complement.  New compiler warning stuff. flushed;              lisp:common, string-char types.  Add base-character, (void);              extended-character, base-string, simple-base-string.  Macptr;              is subtype of T; integrate REAL type into disgusting spice;              subtypep alists.  Add UPGRADED-ARRAY-ELEMENT-TYPE.  Make-uarray;              will cons arrays in temp vector space.  Really.  Set-macro-function;              dtrt, %macro-have dtwt.  *lisp-package* et morte, vive ;              *common-lisp-package*.;04/19/90 gz   In font-codes, allow old-ff/ms to be nil.;04/16/90 bill Update font-codes to return mask values for the updated codes.;              font-info & real-font return values for the current port;              if their font-spec arg is NIL.;              Added merge-font-codes;04/12/90 bill %getpen;04/07/90 bill font-codes makes no changes for a null font-spec.;03/31/90 gz   Use class-of in type-of.;03/28/90 gz   Check dims in make-array.;03/20/90 gz   realp is a type predicate for real.;              Added EQL type specifier to TYPEP.;              element-type-subtype returns nil for the empty type.;03/05/90 bill *use-wait-next-event* T if _WaitNextEvent trap exists.;02/21/90  mly %type-expander -> %deftype-expander.;02/20/90 bill %temp-port% becomes a window.;01/03/89  gz  Use uvectorp.;              Made type-of return 'function instead of 'lfun.;12/29/89  gz  print compiler warnings to *error-output* per x3j13/COMPILER-WARNING-STREAM;12/27/89 bill %temp-port might get written to.  Set it's size to 0, so we don't;              get garbage written on the screen.;12/27/89  gz  Remove obsolete #-bccl conditionals.  Moved deftype et. al. elsewhere.;              No more flavors-instance.  Delay calling type-expand in typep until;              necessary.  Defstructs are in hash tables now.;              Support function specs/setf functions.;08-Dec-89 jaj Update sysenvirons for new machines & keyboards.;11/25/89 gb  make-uarray can make temp vectors.  Can you say "with-compilation-unit" ?;12-Nov-89 Mly Teach print-compiler-warnings-aux a few new tricks;11/24/89 gz  structures now have superclasses in slot 0.;11/06/89 gb  *%dynvfp%* now a value cell.  Unscramble temp-vector code.;10/20/89 bill Remove streamp test from type-of (streams are all;              standard-instance's).  Add standard-method-p test.;10/4/89  gz  flush fhave, fset-globally -> fset.;9/28/89  gb unsigned short, byte vectors.;9/17/89  gb  punt on object lisp support in fset-*.;9/11/89  gz  flush fwhere, where. Moved {software,machine}-{type,version} elsewhere.;             Re-initialize *environs* when loading.;8/29/89  gb  juggled function binding stuff a bit.;8/24/89  gb  temporary vector consing.;7/20/89  gz  moved color stuff to color.lisp.;4/19/89  gz  make-uvector, for transforms.;17-mar-89 as color stuff;             use POSITION instead of rolling own;4/19/89  gz  Added built-in-type-p, parse-array-type, flushed (buggy) array-typep.;4/10/89  gz  Check class relationship first in subtypep.;             No more object-lisp %class-object's.;the Seventh of April 1989 gb  $sp8 -> $sp.  Space before colon when printing warnings.;4/4/89   gz  $mac-time-offset defined elsewhere.  Moved number predicates;             to l1-numbers.; 03/24/89  gb   no more parse-defmacro.;7-apr-89 as  %str-cat takes rest arg;03/03/89 gz  Flushed list-to-array, array-to-list.  Moved copy-list to l1-aprims.;             Moved byte field stuff to numbers.lisp, min/max to l1-aprims.;             Changes for toy clos.;03/02/89 gb  Muck around with function (sub)types.  Temp numbers ride again.;12/26/88 gz  %%get-font-info from the editor (looks kinda like font-info, eh...);             Don't assume a valid curport in string-width, font-info, real-font.;12/25/88 gz  $arh_simple -> $arh_simple_bit (changed location).;12/20/88 gz  Fixes in make-array.;12/15/88 gz  Fix in equalp for pathnames.;12/05/88 gz  added require-type.;12/02/88 gb  say "unbound-marker-8" in (broken) WHERE.;11/22/88 gb  make, describe -array set, look at $arh_simple, as do complex/simple-array-p.;10/27/88 gb  Equalp does (eq (char-upcase x) ...) vice (char-equal x ...); actually faster.;             no-error-string-char-p unnecessary.;10/25/88 gb  Moved identity to l1-utils.;10/23/88 gb  8.9 upload.;9/11/88 gb   Set correct bits ($Sym_bit_unshad) in fset-globally.;9/02/88 gz  no more list-nreverse.;9/01/88 gz  Integrated object lisp with the type system :-).;8/28/88 gz  moved array-data-and-offset to l1-utils (needed by l1-files).;8/23/88 gz  commented out function locking.  Print warning on one line;            if there's only one.  Flushed read-structure-class-p,;            sub-subtypep-structure-class-p. structure-class-p looks at;            *compile-time-defstructs*.;8/11/88 gz  Made *trace-print-level/length* default to NIL like all other;            listener output.;7/29/88 gz   Fixed up type-of;6/21/88 jaj  removed call to print-listener-prompt;6/7/88  jaj  moved string-width, font-info, real-font here from dialogs;5/26/88 jaj  force a copy-str of " . " in *environs*;5/23/88 jaj  compiler-warnings don't print for anonymous fns;             added *multifinder* and *use-wait-next-event*;5/20/88 jaj  added *environs* changed [machine|software]-[type|version];             added bootstrapping versions of mac-to-universal-time and;             universal-to-mac-time;5/19/88 as   keywordized a couple rlets;5/13/88 jaj  type-of complex is either (complex float) or (complex rational);5/11/88 jaj  added print-compiler-warnings, print-warnings;3/11/88 jaj  font-codes now merges properly with styles (added (%ilsr 8 ));6/02/88  gb  Use %symbol-bits.;4/01/88  gz  New macptr scheme.  Flushed pre-1.0 edit history.;             Fix the (type-of #C(1 3/4)) bug.;2/14/88  gb  bugnum->bignum (count-temp-numbers), other typos in max-temp-numbers.;             preload-all-functions bumps by 6 vice 8.;2/8/88   jaj num-temp-floats/max-temp-floats -> count-temp-numbers/max-temp-numbers;             and extended to return multiple values;1/28/88 jaj  don't call position (so it works in level-1).;12/22/87 gb  tempoary-floats -> temporary-numbers;1/12/88 cfry fixed read-structure-class-p to permit random-states;         so that they can be read back in since they are printed as structures; 12/23/87 cfry added read-structure-class-p;12/22/87 cfry fixed sub-subtypep for hash-tables, pathnames, random-states,;                    readtable;12/11/87 cfry fixed (equalp #\a 1);12/07/87 cfry  fixes to subtypep;               require alltraps => traps, trap-support;10/25/87 jaj added gb's temporary floats;10/21/87 jaj changed fset to work with global only fns.  fset and fset-globally;             now call %fhave instead of fhave.  They also error if redefining;             special forms and warn and remove macrop property if redefining;             macros.;10/16/87 jaj fhave won't redefine globally defunned lfuns;10/13/87 smh typep, structure-typep, and subtypep understand flavor instances;10/13/87 smh type-of understands flavor instances; 10/08/87 cfry fixed (subtypep 'array 'sequence) to return NIL NIL.; 9/8/87  as  font-codes accepts optional args for default ff and ms; 8/20/87 gz  Fix in equalp on structures.;---------------------------release 1.0-----------------------------(in-package :ccl)(eval-when (:execute :compile-toplevel)  (require 'level-2)  (require 'sysequ)  (require 'toolequ)  (require 'defrecord)  (require 'optimizers)  (require 'backquote)  (require 'fredenv)  (require 'defstruct-macros)  '(require 'lap)  '(require 'lapmacros))(queue-fixup (let ((s1-tbl *stp-specialist-1-table*)       (s2-tbl *stp-specialist-2-table*))   (when (listp s1-tbl)     (setq *stp-specialist-1-table*           (make-hash-table :size (round (* 1.2 (length s1-tbl)))))     (dolist (x s1-tbl)       (setf (gethash (car x) *stp-specialist-1-table*) (cdr x))))   (when (listp s2-tbl)     (setq *stp-specialist-2-table*           (make-hash-table :size (round (* 1.2 (length s2-tbl)))))     (dolist (x s2-tbl)       (setf (gethash (car x) *stp-specialist-2-table*) (cdr x))))));;; Arrays and vectors, including make-array.(defun element-type-subtype (type)  "Convert element type specifier to internal array subtype code"  (cond ;Check for some common cases explicitly before going into a   ;full subtypep...   ((eq type t) $v_genv)   ((or (eq type 'extended-character)(eq type 'character)) $v_xstr)   ((or #|(eq type 'character)|# (eq type 'base-character)) $v_sstr)   ((eq type 'bit) $v_bitv)   ((eq type 'double-float) $v_floatv)   ((and (consp type)         (if (eql (%car type) 'signed-byte)           (let ((size (car (%cdr type))))             (and (null (%cddr type))                  (fixnump size)                  (%i< 0 size)                  (cond ((%i<= size 8) $v_sbytev)                        ((%i<= size 16) $v_swordv)                        ((%i<= size 32) $v_slongv)                        (t $v_genv))))           (and (eql (%car type) 'unsigned-byte)                (let ((size (car (%cdr type))))                  (and (null (%cddr type))                       (fixnump size)                       (%i< 0 size)                       (cond ((eq size 1) $v_bitv)                             ((%i<= size 8) $v_ubytev)                             ((%i<= size 16) $v_uwordv)                             ((%i<= size 32) $v_ulongv)                             (t $v_genv))))))))   ((subtypep type 'bit) $v_bitv)   ((subtypep type '(signed-byte 8)) $v_sbytev)   ((subtypep type '(unsigned-byte 8)) $v_ubytev)   ((subtypep type '(signed-byte 16)) $v_swordv)   ((subtypep type '(unsigned-byte 16)) $v_uwordv)   ((subtypep type '(signed-byte 32)) $v_slongv)   ((subtypep type '(unsigned-byte 32)) $v_ulongv)   ((subtypep type 'double-float) $v_floatv)   ((subtypep type 'character) $v_sstr) ;; for now.   ((subtypep type nil) nil)   ((not (type-specifier-p type)) nil)   (t $v_genv)));; Type-of, typep, and a bunch of other predicates.;;; Data type predicates.;;; Translation from type keywords to specific predicates.(eval-when (eval compile)(defconstant type-pred-pairs  '((array . arrayp)    (atom . atom)    (base-string . base-string-p)    (bignum . bignump)    (bit . bitp)    (bit-vector . bit-vector-p)    (character . characterp)    (compiled-function . compiled-function-p)    (complex . complexp)    (cons . consp)    (double-float . double-float-p)        (fixnum . fixnump) ;not cl    (float . floatp)    (function . functionp)    (hash-table . hash-table-p)    (integer . integerp)    (real . realp)    (keyword . keywordp)    (list . listp)    (long-float . double-float-p)    (nil . false)    (null . null)    (number . numberp)    (package . packagep)    (pathname . pathnamep)    (logical-pathname . logical-pathname-p)    (random-state . random-state-p)    (ratio . ratiop)    (rational . rationalp)    (readtable . readtablep)    (sequence . sequencep)    (short-float . short-float-p)    (signed-byte . integerp)    (simple-array . simple-array-p)    (simple-base-string . simple-base-string-p)    (simple-extended-string . simple-extended-string-p)    (simple-bit-vector . simple-bit-vector-p)    (simple-string . simple-string-p)    (simple-vector . simple-vector-p)    (single-float . double-float-p)    (stream . streamp)    (string . stringp)    (base-character . base-character-p)    (extended-character . extended-character-p)    (structure . structurep)    (structure-object . structurep)    (symbol . symbolp)    (symbol-locative . symbol-locative-p) ; not cl    (t . true)    (unsigned-byte . unsigned-byte-p) ;unsigned-byte-p is not cl.    (vector . vectorp)    ))(defmacro init-type-predicates ()  `(dolist (pair ',type-pred-pairs)     (setf (type-predicate (car pair)) (cdr pair)))))(init-type-predicates);necessary since standard-char-p, by definition, errors if not passed a char.(setf (type-predicate 'standard-char)      #'(lambda (form) (and (characterp form) (standard-char-p form))))(defun type-of (form)  (cond ((null form) 'null)        ((arrayp form) (describe-array form))        (t (let ((class (class-of form)))             (if (eq class *istruct-class*)               (uvref form 0)               (let ((name (class-name class)))                 (if name                   (if (eq name 'complex)                     (cond ((floatp (realpart form)) '(complex float))                           (t '(complex rational)))                     name)                   (%type-of form))))))));;; Create the list-style description of an array.;made more specific by fry. slisp used  (mod 2) , etc.(defun describe-array (array)  "Not CL. slisp. Used by type-of."  (let ((type (%type-of array)))    (if (eq (array-rank array) 1)      (let ((length (length array)))        (if (eq type 'complex-array)          (let ((class (class-name (class-of array))))            (if (eq class 'vector)              `(vector ,(array-element-type array) ,length)              (list class length)))          (if (eq type 'simple-array)  ; i think it never is eq            (let ((elt-type (array-element-type array)))              (if (eq elt-type t)                (list 'simple-vector length)                `(simple-array ,(array-element-type array) (,length))))            (list type length))))      (let ()        `(,type ,(array-element-type array) ,(array-dimensions array))))));;;; TYPEP and auxiliary functions.(defun %deftype-expander (form)         ; redefined later  form  nil)(defun type-specifier-p (form &aux sym)  (cond ((symbolp form)         (or (type-predicate form)             (structure-class-p form)             (%deftype-expander form)             (find-class form nil)             ))        ((consp form)         (setq sym (%car form))         (or (type-specifier-p sym)             (memq sym '(member satisfies mod))             (and (memq sym '(and or not))                  (dolist (spec (%cdr form) t)                    (unless (type-specifier-p spec) (return nil))))))        (t (typep form 'class))))(defun built-in-type-p (type)  (if (symbolp type)    (or (type-predicate type)        (let ((class (find-class type nil)))          (and class (typep class 'built-in-class))))    (and (consp type)         (or (and (memq (%car type) '(and or not))                  (every #'built-in-type-p (%cdr type)))             (memq (%car type) '(array simple-array vector simple-vector                                 string simple-string bit-vector simple-bit-vector                                  complex integer mod signed-byte unsigned-byte                                 rational float short-float single-float                                 double-float long-float real member))))))(defun type-expand (form)               ; redefined later  form)(defun typep (object type &aux temp)  "Returns T if OBJECT is of the specified TYPE, otherwise NIL."  (declare (resident))  (flet ((bad-typespec () (error "~S is not a known type specifier." type)))    (not (null          (cond ((symbolp type)                 (cond ((setq temp (type-predicate type))                        (funcall temp object))                       ((%deftype-expander type)                        (typep object (type-expand type)))                       ((structurep object)                        (memq type (%svref object 0)))                       ((setq temp (find-class type nil))                        (memq temp (%inited-class-cpl (class-of object))))                       (t (bad-typespec))))                ((listp type)                 ;; This handles list-style type specifiers.                 (case (%car type)                   (satisfies (funcall (cadr type) object))                   (eql (eql object (cadr type)))                   (member (member object (cdr type)))                   (not (not (typep object (cadr type))))                   (or (dolist (x (cdr type) nil)                         (if (typep object x) (return t))))                   (and (dolist (x (cdr type) t)                          (if (not (typep object x)) (return nil))))                   (integer (and (integerp object) (test-limits object type)))                   (rational (and (rationalp object) (test-limits object type)))                   ((float short-float single-float double-float long-float)                    (and (floatp object) (test-limits object type)))                   (real (and (typep object 'real) (test-limits object type)))                   (mod (and (integerp object)                             (>= object 0)                             (< object (cadr type))))                   (signed-byte                    (and (integerp object)                         (let ((n (cadr type)))                           (or (not n)                                (eq n '*)                               (> n (integer-length object))))))                   (unsigned-byte                    (and (integerp object)                         (not (minusp object))                         (let ((n (cadr type)))                           (or (not n) (eq n '*)                               (>= n (integer-length object))))))                   (complex (and (complexp object)                                 (or (not (cdr type))                                     (and (typep (complex.real object) (cadr type))                                          (typep (complex.imag object) (cadr type))))))                   (t (multiple-value-bind (rank elt-type dim simple-p) (parse-array-type type)                        (if (null rank)     ; not an array type                          (if (%deftype-expander (car type))                            (typep object (type-expand type))                            (bad-typespec))                          (and (arrayp object)                               (and (or (null simple-p) (typep object 'simple-array))                                    (or (eq rank '*)                                        (and (eq rank (array-rank object))                                             (or (eq dim '*)                                                 (if (eq rank 1)                                                   (eq (length object) dim)                                                   (dotimes (i rank t)                                                     (declare (fixnum rank))                                                     (unless                                                       (or (eq (%car dim) '*)                                                           (eq (%car dim) (array-dimension object i)))                                                       (return nil))                                                     (setq dim (%cdr dim)))))))                                    (vector-eltype object elt-type))))))))                ((typep type 'class)                 (memq type (%inited-class-cpl (class-of object))))                (t (bad-typespec)))))));This is like check-type, except it returns the value rather than setf'ing;anything, and so can be done entirely out-of-line.(defun require-type (arg type)  (if (typep arg type)    arg    (%kernel-restart $xwrongtype arg type))); Might want to use an inverted mapping instead of (satisfies ccl::obscurely-named)(defun %require-type (arg predsym)  (if (funcall predsym arg)    arg    (%kernel-restart $xwrongtype arg `(satisfies ,predsym))));True if form is of given structure type or if it includes that type.;Used by defstruct predicates.(defun structure-typep (form type)  (and (structurep form)       (not (null (memq type (%svref form 0))))))(defun class-typep (form class)  (memq class (%inited-class-cpl (class-of form))))#| ; moved to l1-clos(defun class-cell-typep (form class-cell)  (unless (listp class-cell)    (setq class-cell (require-type class-cell 'list)))  (locally (declare (type list class-cell))    (let ((class (cdr class-cell)))      (if class        (not (null (memq class (%inited-class-cpl (class-of form)))))        (typep form (car class-cell))))))|#;;; Given that the object is a vector of some sort, and that we've already;;; verified that it matches CAR of TYPE, see if the rest of the type;;; specifier wins.  Mild hack: Eltype Nil means either type not supplied;;; or was Nil.  Any vector can hold objects of type Nil, since there aren't;;; any, so (vector nil) is the same as (vector *).;;;(defun vector-eltype (object eltype) ;CALLS subtypep !!!    (or (null eltype)        (eq eltype '*);        (let ((arrtype (array-element-type object)));          (or (equal eltype arrtype);              (and (subtypep eltype arrtype);                   (subtypep arrtype eltype))))        ;(equal (array-element-type object) (upgraded-element-type eltype))        (eq (array-element-subtype object) (element-type-subtype eltype))        ));;; Test sequence for specified length.(defun test-length (object length)  (or (null length)      (eq length '*)      (= length (length object))));;; Test whether a number falls within the specified limits.(defun test-limits (object type)  (let ((low (cadr type))        (high (caddr type)))    (and (cond ((null low) t)               ((eq low '*) t)               ((numberp low) (>= object low))               ((and (consp low) (numberp (car low)))                (> object (car low)))               (t nil))         (cond ((null high) t)               ((eq high '*) t)               ((numberp high) (>= high object))               ((and (consp high) (numberp (car high)))                (> (car high) object))               (t nil)))))(defun parse-array-type (type &aux (dims '*))  ;(declare (values rank elt-type dim-or-dims simple-p))  ;rank is * or non-negative fixnum.  ;if rank=*, dim-or-dims=*.  ;if rank=1, dim-or-dims=* or a non-negative fixnum  ;otherwise dim-or-dims=* or a list containing *'s and non-negative fixnums,  ;  with at least one fixnum in the list.  (let* ((name type) args temp (invalid-string "Invalid array type specifier ~S."))    (when (consp type)      (setq name (%car type) args (%cdr type)))    (when (setq temp (assq name '((array             nil *         *)                                  (simple-array      t   *         *)                                  (bit-vector        nil bit       1)                                  (simple-bit-vector t   bit       1)                                  (string            nil character 1)                                  (extended-string   nil character 1)                                  (simple-extended-string nil character 1)                                  (base-string       nil base-character 1)                                  (simple-string     t   character 1)                                  (simple-base-string t   base-character 1)                                  (vector            nil *         1)                                  (simple-vector     t   t         1))))      (debind (simple-p elt-type rank) (%cdr temp)        (when args          (if (eq elt-type '*)            (debind (etype &optional (size '*)) args              (setq elt-type etype)              (if (eq rank '*)                (unless (eq size '*)                  (if (listp size)                    (if (eq (setq rank (length size)) 1)                      (setq dims (%car size))                      (dolist (x size)                        (unless (eq x '*)                          (unless (and (fixnump x) (%i>= x 0)) (report-bad-arg type '(integer 0 #.most-positive-fixnum)))                          (setq dims size))))                    (if (and (fixnump size) (%i>= size 0))                      (setq rank size)                      (error invalid-string type))))                (setq dims size)))            (debind (size) args (setq dims size)))          (when (eq rank 1)            (unless (or (eq dims '*)                        (and (fixnump dims) (%i>= dims 0)))              (error invalid-string type))))        (values rank elt-type dims simple-p)))));;;; Assorted mumble-P type predicates. ;;;; No functions have been in the kernel for the last year or so.;;;; (Just thought you'd like to know.)(defun symbol-locative-p (form)  (lap-inline ()    (:variable form)    (move.l acc atemp0)    (move.l nilreg acc)    (if# (and (eq (ttagp ($ $t_symbol) atemp0 da))              (ne (tst.w -@atemp0)))      (add.w ($ $t_val) acc))))(defun complex-array-p (form)  (and (eq (%type-of form) 'complex-array)       (lap-inline ()         (:variable form)          (move.l nilreg acc)          (move.l (varg form) atemp0)	  (btst ($ $arh_simple_bit) (svref atemp0 arh.fixnum $arh_bits))	  (if# eq (add.l ($ $t_val) acc)))))(defun simple-array-p (form)  "Returns T if the object is a simple array, else returns NIL.   A simple-array may have no fill-pointer, may not be displaced,   and may not be adjustable."  (and (arrayp form)       (or (neq (%type-of form) 'complex-array)           (lap-inline ()             (:variable form)             (move.l nilreg acc)             (move.l (varg form) atemp0)	     (btst ($ $arh_simple_bit) (svref atemp0 arh.fixnum $arh_bits))	     (if# ne (add.l ($ $t_val) acc))))))(defun simple-bit-vector-p (form)  "Returns T if the object is a simple bit vector, else returns NIL."  (eq (%type-of form) 'simple-bit-vector)); Subtypep.;;; Subtypep-specialist-Tables;;; The Subtypep-specialist tables are A lists of (name . function) where name;;;  is a symbol which is the car of some list style type specifier.  The;;;  specialist functions are versions of Sub-Subtypep which work for one ;;;  particular case.  The entry for foo in the specialist-1 table handles;;;  the case for (sub-subtypep (foo ...) xxx), and the entry for foo in the;;;  specialist-2 table handles the case for (sub-subtypep xxx (foo ...)).;;;;;; The specialists in the type1 table are usually more comprehensive, because;;;  the type1 specialists are given the first chance.(defparameter *stp-specialist-1-table* ())(defparameter *stp-specialist-2-table* ());;; Note: This code CANNOT be ported without some work since it reflects;;; the nature of the type system in a particular implementation.;;; Particularly interesting are the float and array types.;;;;;; ST-Range>= is used for comparing the lower limits of subranges of numbers.;;;  St-range>= returns T if n1 >= n2, or if the range whose lower limit is;;;  n1 is within a range whose lower limit is n2.  N1 and n2 may take on one;;;  of three distinct types of values:   A number is an inclusive lower bound,;;;  a list of a number is an exclusive lower bound, and the symbol * ;;;  represents  minus infinity which is not greater than any other number.;;;;;; (st-range>= '(3) 3) => T,    (st-range>= 3 '(3)) => ().(defun st-range>= (n1 n2)  (cond   ((eq n2 '*) T)            ;anything is >= -inf.   ((eq n1 '*) ())	     ; -inf not >= anything else.   ((listp n1)    (if (listp n2)	(>= (car n1) (car n2))	(>= (car n1) n2)))   (T (if (listp n2)	  (> n1 (car n2))    ;this case must be strictly greater than	  (>= n1 n2)))));;; St-range<= is like St-range>= except that it is used to compare upper;;;  bounds.  It returns true iff n1 is the upper bound of a range which is;;;  within the range bounded by n2.  Here, * represents + infinity which is;;;  not less than any other number.(defun st-range<= (n1 n2)  (cond   ((eq n2 '*) T)            ;anything is <= +inf   ((eq n1 '*) ())	     ; +inf is not <= anything else   ((listp n1)    (if (listp n2)	(<= (car n1) (car n2))	(<= (car n1) n2)))   (T (if (listp n2)	  (< n1 (car n2))    ;this case must be strictly less than.	  (<= n1 n2)))));;; Type-Arg  --  Internal;;;;;;    Grab the n'th argument out of a type specifier, defaulting;;; to Default if it doesn't exist.;;;(defun type-arg (type &optional (arg 0) (default '*))  (let ((arg (1+ arg)))    (if (and (consp type) (> (list-length type) arg))	       (nth arg type) ;fry mod from: (elt (the list type) arg)       	default)));;; Array hacking helping functions;;; St-Array-Dimensions-Encompass returns true iff the first array dimension;;; specifier is the same as, or more specific than, the second array;;; dimension specifier.(defun st-array-dimensions-encompass (first-spec second-spec)  (prog* ()    (return     (cond ((eq second-spec '*)	    t)	   ((integerp second-spec)	    (cond ((eq first-spec '*)		   nil)	          ((integerp first-spec)		   (= second-spec first-spec))	          ((listp first-spec)		   (= second-spec (list-length first-spec)))	          (t		   (go punt))))	   ((listp second-spec)	    (cond ((eq first-spec '*)		   nil)	          ((integerp first-spec)		   (do ((second-spec second-spec (cdr second-spec)))		       ((null second-spec) t)		     (if (not (eq (car second-spec) '*))		       (return nil))))	          ((listp first-spec)                   (do ((second-spec second-spec (cdr second-spec))		     (first-spec first-spec (cdr first-spec)))		    ((or (null second-spec) (null first-spec))		     (and (null second-spec) (null first-spec)))		  (if (not (or (eq (car second-spec) '*)			       (eq (car second-spec) (car first-spec))))		      (return nil))))	          (t (go punt))))	   (t (go punt))))    punt    (throw 'hairy-subtypep (values nil nil))));;; Ugh.(defun array-type-element-type (atype)  (let ((etype (catch 'hairy-subtypep (st-array-element-type atype))))    (if (neq etype '*) etype)));;; St-Array-Element-Type determines the element type of an array specified.(defun st-array-element-type (spec)  (if (symbolp spec)      (case spec	((array vector simple-array) '*)	(simple-vector t)	((bit-vector simple-bit-vector) 'bit)	((string simple-string) 'character)        ((extended-string simple-extended-string) 'extended-character)        ((base-string simple-base-string) 'base-character) ;; for now, for inconsistency w/upgraded-array-element-type	(t (throw 'hairy-subtypep (values () ()))))      (case (car spec)        ((array vector simple-array)         (if (cdr spec)           (if (eq (cadr spec) '*)             '*             (upgraded-array-element-type (cadr spec)))))	(simple-vector t)	((bit-vector simple-bit-vector) 'bit)	((string simple-string) 'character)        ((extended-string simple-extended-string) 'extended-character)        ((base-string simple-base-string) 'base-character) ;; for now        (t (throw 'hairy-subtypep (values () ()))))));;; Array-Element-Subtypep  --  Internal;;;;;;    Returns true if the type components of the array types type1 and type2;;; do not prohibit Type1 being a subtype of Type2.  This is true when:;;;  1] The arrays are of the same specialized type: string, bit-vector...;;;  2] The element type of Type2 is *.;;;  3] They are not Common Lisp specialized array types, and Type1;;;     is subtype to Type2.;;;(defun array-element-subtypep (type1 type2)  (let ((et1 (st-array-element-type type1))        (et2 (st-array-element-type type2)))       (or (eq et2 '*)           (eq et1 et2)           (and (not (member et1 '(bit  t)))  ;What is this about anyhow???                (not (member et2 '(bit  t)))                (sub-subtypep et1 et2)))))(defun st-array-dimensions (spec)  (if (symbolp spec)      (case spec	((array simple-array) '*)	((vector simple-vector bit-vector simple-bit-vector		 string simple-string base-string simple-base-string extended-string simple-extended-string)	 '(*))	(t (throw 'hairy-subtypep (values () ()))))      (case (car spec)	((array simple-array) (or (caddr spec) '*))	((vector simple-vector) (if (caddr spec) (list (caddr spec)) '(*)))	((bit-vector simple-bit-vector str string simple-string base-string simple-base-string                     extended-string simple-extended-string)	 (if (cadr spec) (list (cadr spec)) '(*)))	(t (throw 'hairy-subtypep (values () ()))))));;; Def-subtypep-specialist defines a specialist for handling list type;;;  specifiers.  Name is the car of the list types to be handled, and number;;;  distinguishes whether this is the specialist for type1 or type2.  Forms ;;;  are the body of a function which has two args, type1 and type2.  The ;;;  form returned by the macro, pushes the binding of the specialist function;;;  on the appropriate a-list.  Name can be a list of names, as well.#|(eval-when (compile eval)(defmacro def-subtypep-specialist (number name &rest forms)  (if (listp name)    `(let ((fun #'(lambda (type1 type2) ,@forms)))       ,@(mapcar #'(lambda (name)                    `(push (cons ',name fun)                           ,(if (= number 1)                              '*stp-specialist-1-table*                              '*stp-specialist-2-table*)))                 name))    `(push (cons ',name #'(lambda (type1 type2) ,@forms))           ,(if (= number 1)              '*stp-specialist-1-table*              '*stp-specialist-2-table*))))) |#(eval-when (eval compile)  (defmacro def-subtypep-specialist (number name &rest forms)    `(def-subtypep-sp-aux ,number ',name       (function (lambda (type1 type2) ,@forms)))))(defun def-subtypep-sp-aux (number name def)  (if (not (consp name))    (setq name (list name)))  ; these dudes are 29 elts long - is a hash table cheaper?  (dolist (the-name name)    (if (eq number 1)      (push (cons the-name def) *stp-specialist-1-table*)      (push (cons the-name def) *stp-specialist-2-table*))));;; There are several specialists for lost causes.  They might as well all be;;;  the same function.(defun always-too-hairy (type1 type2)  (declare (ignore type1 type2))  (throw 'hairy-subtypep (values () ())))(eval-when (compile eval)(defmacro def-subtypep-too-hairy (number name)  `(push (cons ',name #'always-too-hairy)         ,(if (eq number 1)            '*stp-specialist-1-table*            '*stp-specialist-2-table*))));;; Call-subtypep-specialist returns a form which looks up a specialist;;;  function and calls it.  number specifies whether to call the type1;;;  specialist or the type2 specialist.(eval-when (compile eval #-bccl load)#+franz(defmacro call-subtypep-specialist (number type1 type2)  `(funcall (or (cdr (assq (car ,(if (eq number 1) 'type1 'type2))                            ,(if (eq number 1)                               '*stp-specialist-1-table*                               '*stp-specialist-2-table*)))                #'always-too-hairy)            ,type1            ,type2))#-franz(defmacro call-subtypep-specialist (number type1 type2)  (let ((table (if (eq number 1)                 '*stp-specialist-1-table*                 '*stp-specialist-2-table*))        (thing (if (eq number 1) 'type1 'type2)))     `(funcall (or (if (listp ,table)                    (cdr (assq  (car ,thing) ,table))                    (gethash (car ,thing) ,table))                #'always-too-hairy)            ,type1            ,type2))));;; The function Subtypep-Init is around for a couple of reasons.  First,;;; we want all these lambdas scattered all over the place to get compiled.;;; Second, we want to put them onto lists, but can't do that in the;;; cold load.#|;; The function Subtypep-Init is NOT around because we want all these lambdas;; scattered all over the place to get compiled.(defun subtypep-init ()|#;;;    Array specialists;;; For some array type to be a subtype of another, the following;;; things must be true:;;; the major type of type2 must have the same "simpleness" as the major;;;  type of type1,;;; the dimensions of type2 must be encompassed by the dimensions of;;;  of type1.;;; the element type must permit the subtype relation.  See ;;; Array-Element-Subtypep.;;; For the case where type1 is (array ...)(def-subtypep-specialist 1 (array simple-array vector simple-vector			    bit-vector simple-bit-vector			    string simple-string                             base-string simple-base-string                             extended-string simple-extended-string)  (when (eq type2 'sequence) (setq type2 'vector))  (let ((type2-major (or (and (listp type2) (car type2)) type2)))       (cond ((eq type2 'atom) ;fry mod.  Fry seems to have decided that ATOM is a type specifier.              t)             (t              (and (if (memq type2-major '(simple-array simple-vector                                           simple-bit-vector simple-string simple-base-string simple-extended-string))                       (memq (car type1) '(simple-array simple-vector                                           simple-bit-vector simple-string simple-base-string simple-extended-string))                       t)                   (array-element-subtypep type1 type2)                   (st-array-dimensions-encompass (st-array-dimensions type1)					(st-array-dimensions type2)))))));;; For the case where type2 is (array ...)(def-subtypep-specialist 2 (array simple-array vector simple-vector                            bit-vector simple-bit-vector			    string simple-string                            base-string simple-base-string                             extended-string simple-extended-string)  (let ((type1-major (or (and (listp type1) (car type1)) type1)))    (and (if (memq (car type2) '(simple-array simple-vector				 simple-bit-vector simple-string simple-base-string simple-extended-string))	     (memq type1-major '(simple-array simple-vector				 simple-bit-vector simple-string simple-base-string simple-extended-string))	     t)	 (array-element-subtypep type1 type2))));;;    Complex numbers(def-subtypep-specialist 1 complex  (cond   ;;(complex ...) is a subtype of any type that COMPLEX is a subtype of,   ((subtypep 'complex type2) T)   ;;but not a subtype of any symbol type that COMPLEX is not a subtype of.   ((symbolp type2) ())   ;;Case where Type2 is another complex   ((eq (car type2) 'complex)    (subtypep (type-arg type1) (type-arg type2)))   ;;punt to specialist for type2   (T (call-subtypep-specialist 2 type1 type2))));; specialist for the case where type2 is (complex ...)(def-subtypep-specialist 2 complex  (declare (ignore type2))  (cond ((symbolp type1) ())	(T (throw 'hairy-subtypep (values () ())))));;;    Functions, Satisfies, Members, Ands, Ors, Nots(def-subtypep-too-hairy 1 function)(def-subtypep-too-hairy 2 function)(def-subtypep-too-hairy 1 satisfies)(def-subtypep-too-hairy 2 satisfies)(def-subtypep-too-hairy 1 member)(def-subtypep-too-hairy 2 member);;; (subtypep '(and t1 t2 ...) 't3) <=>;;; (or (subtypep 't1 't3) (subtypep 't2 't3) ...  (too-hairy));;; because '(and t1 t2 ...) denotes the intersection of types t1, t2, ...;;;;;; We can't ever return (values nil t) because the intersection might;;; be a subtype even if none of the components are.;;;;;; So, either all of the components are subtypes or we aren't sure.  Right ?(def-subtypep-specialist 1 and  (dolist (type1 (cdr type1) t)    (unless (sub-subtypep type1 type2)      (throw 'hairy-subtypep (values nil nil)))));;; (subtypep 't1 '(and t2 t3 ...)) <=>;;; (and (subtypep 't1 't2) (subtypep 't1 't3) ...);;; because '(and t2 t3 ...) denotes the intersection of types t2, t3, ...(def-subtypep-specialist 2 and  (dolist (type2 (cdr type2) t)    (unless (sub-subtypep type1 type2)      (throw 'hairy-subtypep (values nil nil)))));;; (subtypep '(or t1 t2 ...) 't3) <=>;;; (and (subtypep 't1 't3) (subtypep 't2 't3) ...);;; because '(or t1 t2 ...) denotes the union of types t1, t2, ...(def-subtypep-specialist 1 or  (dolist (type1 (cdr type1) t)    (unless (sub-subtypep type1 type2)      (throw 'hairy-subtypep (values nil nil)))));;; (subtypep 't1 '(or t2 t3 ...)) <=>;;; (or (subtypep 't1 't2) (subtypep 't1 't3) ...  (too-hairy));;; because '(or t1 t2 ...) denotes the union of types t1, t2, ...;;;;;; We can't ever return (values nil t) because the t2..tn might;;; form an exhaustive partition of t1, i.e. ;;; (subtypep 'float '(or short-float long-float));;;(def-subtypep-specialist 2 or  (dolist (type2 (cdr type2) (throw 'hairy-subtypep (values nil nil)))    (when (sub-subtypep type1 type2)      (return t))))#| This is hard...  -- Ram;;; (subtypep '(not t1) t2) <=> (not (subtypep 't1 't2))(def-subtypep-specialist 1 not  (not (sub-subtypep (cadr type1) type2)));;; (subtypep t1 '(not t2)) <=> (not (subtypep 't1 't2))(def-subtypep-specialist 2 not  (not (sub-subtypep type1 (cadr type2))))|#(def-subtypep-too-hairy 1 not)(def-subtypep-too-hairy 2 not);;;    Integers;;; Inclusivate-Arg  --  Internal;;;;;;    Make an integer type arg inclusive.;;;(defun inclusivate-arg (type arg)  (let ((n (type-arg type arg)))    (cond ((eq n '*) '*)          ((consp n)           (if (integerp (car n))             (if (= arg 0) ;fry mod               (1+ (car n))               (1- (car n)))             (error "Limit ~S is not an integer in type spec: ~S"                     (car n) type)))          ((not (integerp n))           (error "Limit ~S is not an integer in type spec: ~S" n type))          (t n))))(def-subtypep-specialist 1 integer  (let* ((low1 (inclusivate-arg type1 0))	 (high1 (inclusivate-arg type1 1)))    (cond     ((subtypep 'integer type2) T)     ((eq type2 'fixnum)      (sub-subtypep type1 '(integer #.most-negative-fixnum #.most-positive-fixnum)))     ((eq type2 'bignum)      (or (sub-subtypep type1 '(integer * #.(1- most-negative-fixnum)))          (sub-subtypep type1 '(integer #.(1+ most-positive-fixnum) *))))     ((eq type2 'bit) (sub-subtypep type1 '(integer 0 1)))     ((eq type2 'signed-byte) t)     ((eq type2 'unsigned-byte)      (and (st-range>= low1 0) (st-range<= 0 high1)))     ((symbolp type2) ())          ;; integer versus integer     ((eq (car type2) 'integer)      (let ((low2 (inclusivate-arg type2 0))	    (high2 (inclusivate-arg type2 1)))	(and (st-range>= low1 low2)		;T if range1 is within	     (st-range<= high1 high2))))	; range2          ;; integer versus rational     ((eq (car type2) 'rational)      (sub-subtypep `(rational ,low1 ,high1) type2))          ;; Otherwise, maby the specialist for type2 can help     ;; Maby, maby not.     (T (call-subtypep-specialist 2 type1 type2))     )));; specialist for the case where type2 is (integer ...)(def-subtypep-specialist 2 integer  (cond ((eq type1 'bit)	 (sub-subtypep '(integer 0 1) type2))        ((eq type1 'unsigned-byte)         (sub-subtypep '(integer 0 *) type2))        ((eq type1 'signed-byte)         (sub-subtypep '(integer * *) type2))        ((eq type1 'fixnum)         (sub-subtypep '(integer #.most-negative-fixnum #.most-positive-fixnum) type2))	((symbolp type1)	 nil)	(t	 (throw 'hairy-subtypep (values () ())))));;;    Rationals(def-subtypep-specialist 1 rational  (let ((low1 (type-arg type1 0))	(high1 (type-arg type1 1)))    (cond     ((subtypep 'rational type2) T)     ((symbolp type2) ())     ;; rational to rational     ((eq (car type2) 'rational)      (let ((low2 (type-arg type2 0))	    (high2 (type-arg type2 1)))	(and (st-range>= low1 low2)     ;T if type1 range is within	     (st-range<= high1 high2))	; type2 range.	))     ;; otherwise maybe the specialist for type2 can help     (T (call-subtypep-specialist 2 type1 type2)))))(def-subtypep-specialist 2 rational  (declare (ignore type2))  (cond ((symbolp type1) ())	(T (throw 'hairy-subtypep (values () ())))));;;    Floats(def-subtypep-specialist 1 (float single-float                             short-float double-float long-float)  (let ((low1 (type-arg type1 0))        (high1 (type-arg type1 1)))    (cond     ((subtypep 'float type2) T)     ((symbolp type2) ())          ;; float to float     ((subtypep (car type2) 'float)      (let ((low2 (type-arg type2 0))            (high2 (type-arg type2 1)))        (and (st-range>= low1 low2)     ;T if type1 range is within             (st-range<= high1 high2))	; type2 range.        ))          ;; otherwise maybe the specialist for type2 can help     (T  (call-subtypep-specialist 2 type1 type2)))))(def-subtypep-specialist 2 (float single-float                             short-float double-float long-float)  (declare (ignore type2))  (cond ((symbolp type1) ())	(T (throw 'hairy-subtypep (values () ())))));;;    Mods, Signed-Bytes, Unsigned-Bytes;; these forms all turn different flavors of (integer ...) into something;; that the specialist for integer can understand.(def-subtypep-specialist 1 mod  (sub-subtypep `(integer 0 ,(1- (nth 1 type1))) type2))(def-subtypep-specialist 2 mod  (sub-subtypep type1 `(integer 0 ,(1- (nth 1 type2)))))(def-subtypep-specialist 1 signed-byte  (let ((arg (type-arg type1 0 nil)))    (if arg      (let ((highest (ash 1 (1- arg))))        (sub-subtypep `(integer ,(- highest) ,(1- highest)) type2))      (sub-subtypep 'integer type2))))(def-subtypep-specialist 2 signed-byte  (let ((arg (type-arg type2 0 nil)))    (if arg      (let ((highest (ash 1 (1- arg))))        (sub-subtypep type1 `(integer ,(- highest) ,(1- highest))))      (sub-subtypep type1 'integer))))(def-subtypep-specialist 1 unsigned-byte  (let ((arg (type-arg type1 0 nil)))    (if arg      (let ((highest (byte-mask arg)))	  ;gets n bits of 1's        (sub-subtypep `(integer 0 ,highest) type2))      (sub-subtypep '(integer 0) type2))))(def-subtypep-specialist 2 unsigned-byte  (let ((arg (type-arg type2 0 nil)))    (if arg      (let ((highest (byte-mask arg)))	  ;gets n bits of 1's        (sub-subtypep type1 `(integer 0 ,highest)))      (sub-subtypep type1 '(integer 0)))));;;    Float types;;; The following paren closes subtypep-init#| ) |#;;; Sub-Subtypep;;; Sub-Subtypep returns T if TYPE1 is a subtype of TYPE2, () if it is not.;;;  Some cases can not be decided.  If this occurs, the values () () are;;;  thrown to the catch tag 'HAIRY-SUBTYPEP.;;;;;; If type1 is a list, then call a specialized function which handles that;;;  particular list type when it appears as type1.  Otherwise, if type2 is a;;;  list, then call the specialist which handles that particular list type;;;  when it appears as type2.;;;;;; If both types are symbols, then lookup the subtype relation in the;;;  *symbol-subtype-table*. ;;;;;; Specialist functions are associated with the name of the car of the list;;;  types.  The macro get-subtype-specialist is used look up the function.;;;  The numeric arg specifies whether to get the specialist for the type1;;;  case or the type2 case.(defun simplify-type (type &aux length symbol)  "assumes a well-formed type-specifier that's already been expanded.   Returns a type specifier that is equivalent to TYPE which might be simpler."  (cond ((or (symbolp type)(classp type))         type)        (t (setq length (length type))           (setq symbol (car type))           (cond ((= length 1)                  symbol)                 ((eq (cadr type) '*)                  (cond ((= length 2) ; (foo *)                         symbol)                        (t                         (cond ((eq (caddr type) '*) ;(foo * *)                                symbol)                               ((equal type '(array * (*)))                                'vector)                               (t type)))))                  (t type)))))                             (defun sub-subtypep (type1 type2)  "Returns T iff type1 is a subtype of type2."  (let* ((type1 (simplify-type (type-expand type1)))         (type2 (simplify-type (type-expand type2)))         (class2 (if (symbolp type2) (find-class type2 nil) (if (typep type2 'class) type2)))         (class1 (if class2 (if (symbolp type1) (find-class type1 nil) (if (typep type1 'class) type1)))))    (cond     (class1      (memq class2 (%inited-class-cpl class1)))     ((equal type1 type2) t)     ((eq type2 '*) t)     ((and (eq type2 t) (not (eq type1 '*))) t)     ((eq type1 nil) t)     ((and (eq type1 'array) (eq type2 'sequence)) nil)     ((listp type1)      (call-subtypep-specialist 1 type1 type2))     ((listp type2)      (call-subtypep-specialist 2 type1 type2))     ((structure-class-p type2)      (let ((sd (structure-class-p type1)))        (and sd (not (null (memq type2 (sd-superclasses sd)))))))     ((structure-class-p type1)      (or (sub-subtypep 'structure type2)          ;I think this case might actually be a known-false, but I don't	  ;want to take the chance, so just punt..	  (throw 'hairy-subtypep (values () ()))))     (T      (throw 'hairy-subtypep (values () (not (null class2))))))));;; Subtypep;;; Subtypep returns two values which may be any of the three following pairs.;;;;;;   T T    -- TYPE1 is a subtype of TYPE2.;;;   () T   -- TYPE1 is not a subtype of TYPE2.;;;   () ()  -- Couldn't tell.;;;;;; Passing the not-sure  value around is too complex.  Sub-Subtypep returns;;;  the first value, and throws (values () ()) if it encounters an ;;;  undecideable case somewhere up the stack.(defun subtypep (type1 type2)  "Returns T if type1 is a subtype of type2.  If second value is (), couldn't  decide."  (catch 'hairy-subtypep (values (not (not (Sub-Subtypep type1 type2))) T)));(defun mouse-down-p ()  (#_button))(defun preload-all-functions (&aux (p (%get-long (%currenta5) $slfuns_start))                                   (q (%get-long (%currenta5) $slfuns_end))                                   (n 0))  "Load all CCL functions."  (loop    (when (eq p q) (return n))    (%lfun-vector (lap-inline (p) (jsr_subprim $sp-getulong)) t)    (setq p (%i+ p 8) n (1+ n))))#|(let ((the-ptr nil))  (defun %alloc-temp-vector-space (size)    (when (or (eql 0 (%get-long (%currentA5) $dynvbase)) (null the-ptr))      (let* ((p (#_NewPtr (+ 7 size))))        (setq the-ptr p              p (%int-to-ptr (logand (lognot 7) (+ (%ptr-to-int p) 7))))        (lap-inline (p)            (move.l arg_z atemp0)           (move.l (atemp0 $macptr.ptr) (special *%dynvfp%*)))         (%put-ptr (%currenta5) p $dynvbase)        (%incf-ptr p size)        (%put-ptr (%currenta5) p $dynvlimit)        t)))  (defun %clear-temp-vector-space  ()    (if (and the-ptr             (eq (lap-inline () (move.l (a5 $dynvbase) acc)) *%dynvfp%*))      (progn        (lap-inline (the-ptr (setq the-ptr nil))         (move.l arg_y atemp0)         (move.l (atemp0 $macptr.ptr) atemp0)         (jsr_subprim $sp-rtrap)         (dc.w #_DisposPtr) 				; doesn't GC         (move.l '0 da)         (move.l da (a5 $dynvbase))         (move.l da (a5 $dynvlimit))         (move.l da (special *%dynvfp%*)))        t))))|#(defun temp-cons (arg_y arg_z)  (%primitive $sp-TconsYZ :arg_y arg_y :arg_z arg_z :acc))#|(defun managed-vector-space ()  (new-lap   (move.l (a5 $dynvlimit) acc)   (sub.l (a5 $dynvbase) acc)   (mkint acc)   (lfret)))(def-ccl-pointers make-managed ()  (%alloc-temp-vector-space 40960))|#(declaim (special *%dynvfp%*))(declaim (special *%dynvlimit%*))(defmacro with-managed-allocation (&body body &environment env)   (multiple-value-bind (body decls)   	(parse-body body env nil)     `(let ((*%dynvfp%* *%dynvfp%*)            (*%dynvlimit%* *%dynvlimit%*))        ,@decls        ,@body)))(defun copy-into-float (src dest)  (declare (%noforcestk))  (lap-inline (src dest)   (move.l arg_y atemp0)   (move.l arg_z atemp1)   (sub.w ($ $t_dfloat) atemp0)   (sub.w ($ $t_dfloat) atemp1)   (move.l atemp0@+ atemp1@+)   (move.l @atemp0 @atemp1))); Return the location of the pen.; Maybe this should check if the result will fit in a fixnum.; It won't if the vertical coordinate is > 4095.(defun %getpen ()  (lap-inline ()    (move.l (a5) atemp0)    (move.l (atemp0) atemp0)    (move.l (atemp0 $pnloc) acc)    (mkint acc)))(%include "ccl:level-1;sysutils.lisp")    #|	Change History (most recent last):	2	12/27/94	akh	merge with d13  3   1/5/95   akh   dont say format nil in def-ccl-pointers|# ;(do not edit past this line!!)