;;;-*-Mode: LISP; Package: CCL -*-;; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.;08/09/93 bill  %use-package-conflict-check now remembers to merge NIL & nilsym everywhere;-------------- 3.0d12;05/26/93 alice find-package handles fat strings (i hope), %%findpkg is history;05/23/93 alice %%defrefstring error is 'base-string not 'string;11/20/92  gb  extra arg to vsubtypep;07/02/92 bill remove (dbg) from import-1;------------- 2.0;02/23/92  gb  Missing ~S in EXPORT's "missing symbols need to be imported first" CERROR format string.;02/21/92  (gb from bootpatch0) Blessings upon UNEXPORT-1.;-------- 2.0f2;01/06/92  gb  allow symbols as package names again ...;12/24/91  gb  Restarts for package-name conflicts.;--------- 2.0b4;10/27/91  gb  Check & signal conflicts in export; no more export-1, fasl-extern baggage.;--------- 2.0b3;07/21/91  gb  Fix some of the conflict checking, add some more.  Wtaerr fixes.  Declaim.;02/01/91 bill with-package-iterator support;              Fix the WHILE# loop in UNINTERN (crashed on uninterning a shadowing symbol);12/10/90  gb  %define-package doesn't :use anything on creation.;              RENAME-PACKAGE might really work this time.;12/05/90  gb  make rename-package actually do something.;11/10/90  gb  use new package functions.;10/16/90  gb  new-lap here and there.;09/03/90  gb  define %%deref-sym-char-or-string, which conses.  Too bad.;08/10/90  gb  new package cell accessors.  Bill's fix to RENAME-PACKAGE.;07/24/90 bill fix find-all-symbols.;06/20/90  gb  SHADOW allows strings as well as symbols.  DEFPACKAGE shadows in;              package being defined.; ----- 2.0a1;06/10/90  gb  define & export *MAKE-PACKAGE-USE-DEFAULTS*, use it in MAKE-PACKAGE;              and %DEFINE-PACKAGE.;06/06/90  gb  pkg-arg-allow-deleted restartable error.;05/22/90  gb  no more symtagp.;05/14/90  gb  deprecate IN-PACKAGE with extreme prejudice.  Add set-package, %define-;              package. Move %%derefstring & %%deref-sym-or-string here.;04/30/90  gb  default make-package :USE arg to COMMON-LISP.;12/29/89  gz  find-package allows package arg, per x3j13/PACKAGE-FUNCTION-CONSISTENCY.;	       Added %pkgtab-count, %resize-package.;12-Nov-89 Mly Make %%find-pkg-sym and callers conform to its documentation (caller should do getvect).;             This fixes bugs in UNINTERN.  Why is this all in lap?;10/16/89 gz  $sp-findsym no longer returns keywords.  $sp-exportcheck preserves;	      da/db/dy. Braino in delete-package.;10/3/89  gb  mis-parenthesization in use-package .;9/27/89  gb  typo in delete-packge.;9/3/89   gz  Package accessors here from l1-aprims.;             DELETE-PACKAGE per x3j13.;08/29/89 gb  (loop# ...) -> (prog# ...) in use-package .  Import takes pname;             of symbol before calling $sp-findsym.;08/01/89 gz  atemp0 -> atemp1 in unexport.;04/07/89 gb  $sp8 -> $sp.; 03/24/89  gz  error numbers are fixnums. $packagesP -> %all-packages%.;               More stuff from kernel. $v_pkg.; 03/03/89  gb  New file.(declaim (special %all-packages%))(declaim (list %all-package%))(declaim (type package *package*));Entry: acc=argument, error if not string (simple or otherwise) but today m.b.base.;Exit:  Atemp0=simple string, Dtemp0=offset (unboxed), Dtemp1=length (unboxed)(defun %%derefstring (&lap 0)  (old-lap-inline ()   (move.l arg_z atemp0)   (if# (eq (ttagp ($ $t_vector) arg_z da))     (move.l '0 dtemp0)     (vsubtype atemp0 da)     (if# (eq (cmp.b ($ $v_sstr) da))       (vsize atemp0 dtemp1)       (bra @done))     (if# (and (eq (cmp.b ($ $v_arrayh) da))               (eq (cmp.b ($ $v_sstr) (svref atemp0 arh.fixnum $arh_type)))               (eq (cmp.w ($ $arh_one_dim) (svref atemp0 arh.fixnum $arh_rank4))))       (move.l (svref atemp0 arh.fill) dtemp1)       (getint dtemp1)       (move.l atemp0 da)       (prog#        (add.l (svref atemp0 arh.offs) dtemp0)        (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))        (move.l (svref atemp0 arh.vect) atemp0)        (bne (top#)))       (getint dtemp0)       (vsize atemp0 da)       (sub.l dtemp0 da)       (if# (ge da dtemp1)         (move.l da dtemp1))       (bra @done)))   (twtaerr atemp0 'base-string)@done))(defun %%deref-sym-or-string (&lap sym-or-string)  (old-lap   (if# (eq arg_z nilreg)     (move.l (nilreg (+ $nil_val $sym.pname)) arg_z)     (jmp (function %%derefstring)))   (if# (and (eq (ttagp ($ $t_symbol) arg_z da))             (eq               (progn                (move.l arg_z atemp0)                (tst.w (atemp0 (- $t_symbol))))))     (move.l (atemp0 $sym.pname) arg_z))   (jmp (function %%derefstring))))(defun %%deref-sym-char-or-string (&lap sym-char-or-string)  (old-lap   (if# (ne (cmp.w ($ $t_imm_char) arg_z))     (jmp #'%%deref-sym-or-string))   (vpush arg_z)   (moveq 1 arg_z)   (moveq $v_sstr arg_y)   (jsr_subprim $sp-allocvect)   (move.b (vsp 1) (atemp0 $v_data))   (add ($ 4) vsp)   (moveq 0 dtemp0)   (moveq 1 dtemp1)   (rts)))#|; beware read uses this no longer and she doesn't know about fat strings; Name (simple string) in atemp0/da; returns package or NIL in acc.  Can't err.(defun %%FindPkg (&lap name)  (lap-inline ()   (with-preserved-registers #(asave0 asave1)     (move.l da db)     (move.l atemp0 dy)     (move.l (special %all-packages%) asave0)	;asave0=list of packages     (loop#      (car asave0 acc)      (null acc)      (beq @exit)      (move.l acc asave1)      (move.l (svref asave1 pkg.names) asave1)      (while# (ne asave1 nilreg)        (car asave1 atemp1)        (getvect atemp1 dx)        (cmp.l dx da)        (bra @1)@0      (cmp.b atemp0@+ atemp1@+)@1      (dbne da @0)        (if# eq          (add.w ($ 1) da)          (sub.l ($ 1) da)          (bcc @0)          (bra @exit))        (move.l db da)        (move.l dy atemp0)        (cdr asave1 asave1))      (cdr asave0 asave0))@exit)))|#(defun %string= (string1 string2 start1 end1)  (when (eq (length string2) (%i- end1 start1))    (do* ((i start1 (%i+ 1 i))          (j 0 (%i+ 1 j)))         ((%i>= i end1))      (when (not (eq (%scharcode string1 i)(%scharcode string2 j)))        (return-from %string= nil)))    t))(defun %find-package (str offset len)  (dolist (pkg %all-packages%)    (dolist (name (pkg.names pkg))      (when (%string= str name offset (%i+ offset len))        (return-from %find-package pkg)))))      (defun find-package (name)  (if (packagep name)     name    (if (symbolp name)      (let ((name (symbol-name name)))        (%find-package name 0 (length name)))      (multiple-value-call #'%find-package (array-data-and-offset name)(length name)))))#|(defun find-package (name)  (if (packagep name)    name    (old-lap-inline (name)      (jsr #'%%deref-sym-or-string)      (lea (atemp0 acc.l $v_data) atemp0)      (move.l arg_y da)      (jsr #'%%findpkg))))|#(defun set-package (name &aux (pkg (find-package name)))  (if pkg    (setq *package* pkg)    (set-package (%kernel-restart $xnopkg name))))(defun export (sym-or-syms &optional (package *package*))  (setq package (pkg-arg package))  (if (atom sym-or-syms)    (let* ((temp (cons sym-or-syms nil)))      (declare (dynamic-extent temp))      (export temp package))    (progn      (dolist (sym sym-or-syms)        (unless (symbolp sym) (return (setq sym-or-syms  (mapcar #'(lambda (s) (require-type s 'symbol)) sym-or-syms)))))      ; First, see if any packages used by the package being "exported from" already contain a      ; distinct non-shadowing symbol that conflicts with one of those that we're trying to export.      (let* ((conflicts (check-export-conflicts sym-or-syms package)))        (if conflicts          (progn             (resolve-export-conflicts conflicts package)            (export sym-or-syms package))          (let* ((missing nil) (need-import nil))            (dolist (s sym-or-syms)               (multiple-value-bind (foundsym foundp) (%findsym (symbol-name s) package)                (if (not (and foundp (eq s foundsym)))                  (push s missing)                  (if (eq foundp :inherited)                    (push s need-import)))))            (when missing              (cerror "Import missing symbols before exporting them from ~S."                      "The following symbols need to be imported to ~S before they can be exported ~                       from that package:~%~S" package missing)              (import missing package))            (if need-import (import need-import package))            ; Can't lose now: symbols are all directly present in package.            ; Ensure that they're all external; do so with interrupts disabled            (without-interrupts             (let* ((etab (pkg.etab package))                    (ivec (car (pkg.itab package))))               (dolist (s sym-or-syms t)                 (multiple-value-bind (foundsym foundp internal-offset)                                      (%findsym (symbol-name s) package)                   (when (eq foundp :internal)                     (setf (%svref ivec internal-offset) (%unbound-marker-8))                     (lap-inline ()                       (:variable foundsym etab)                       (move.l (varg foundsym) acc)                       (if# (eq acc nilreg)                         (move.l (a5 $nilsym) acc))                       (vpush acc)                       (move.l acc atemp0)                       (sympname atemp0 atemp0)                       (vsize atemp0 da)                       (move.l (varg etab 4) acc)                       (jsr #'%%GetSym)                       (vpop acc)                       (move.l (varg etab) atemp1)                       (move.l dy db)                       (jsr #'%%Hadd)))))))))))))(defun check-export-conflicts (symbols package)  (let* ((conflicts nil))    (dolist (user (pkg.used-by package) conflicts)      (dolist (s symbols)        (multiple-value-bind (foundsym foundp) (%findsym (symbol-name s) user)          (if (and foundp (neq foundsym s) (not (memq foundsym (pkg.shadowed user))))            (push (list (eq foundp :inherited) s user foundsym) conflicts)))))))  (defun packagep (x)  (old-lap-inline ()    (move.l acc atemp0)    (move.l nilreg acc)    (if# (and (eq (ttagp ($ $t_vector) atemp0 da))              (eq (vsubtypep ($ $v_pkg) atemp0 da)))      (add.w ($ $t_val) acc))))(defun keywordp (x)  (old-lap-inline ()   (if# (and (eq (ttagp ($ $t_symbol) arg_z da))             (eq               (progn                 (move.l arg_z atemp0)                (tst.w (atemp0 (- $t_symbol))))))     (move.l (atemp0 $sym.package-plist) atemp0)     (if# (eq (ttagp ($ $t_cons) atemp0 da))       (car atemp0 atemp0))     (cmp.l (special *keyword-package*) atemp0))   (setpred eq)));No type/range checking.  For DO-SYMBOLS and friends.(defun %htab-symbol (array index)  (old-lap   (vscale.l arg_z)   (move.l arg_y atemp0)   (move.l (atemp0 arg_z.l $v_data) acc)   (bif (eq nilreg acc) @popj)   (bif (eq (sub.w ($ $undefined) acc)) @retnil)   (add.w ($ $undefined) acc)   (lea (nilreg $nil_val) atemp0)   (if# (eq atemp0 acc)     (move.l nilreg acc))   (vpush acc)   (move_t -@vsp)   (set_nargs 2)   (jmp_subprim $sp-nvalret)@retnil   (move.l nilreg acc)@popj   (lfret)))(defun find-all-symbols (name)  (lap-inline ()    (:variable name)    (with-preserved-registers #(dsave0 dsave1 asave0)      (jsr_subprim $sp-symorsstr)      (move.l nilreg dsave1)      (move.l acc dsave0)      (move.l (special %all-packages%) asave0)      (bra @next)      (until# (eq (progn (car asave0 acc) (cmp.l acc nilreg)))        (cdr asave0 asave0)        (move.l dsave0 atemp0)        (vsize atemp0 da)        (jsr #'%%find-pkg-sym)        (if# ne          (move.l dsave1 atemp0)          (prog#           (while# (ne atemp0 nilreg))           (bif (eq (car atemp0) acc) @next)           (cdr atemp0 atemp0)           (bra (top#)))          (move.l acc arg_y)          (move.l dsave1 arg_z)          (jsr_subprim $sp-consyz)          (move.l acc dsave1))        @next)      (move.l dsave1 acc))))(defun list-all-packages () (copy-list %all-packages%))(defun rename-package (package new-name &optional new-nicknames)  (setq package (pkg-arg package)        new-name (ensure-simple-string (string new-name)))  (let* ((names (pkg.names package)))    (declare (type cons names))    (rplaca names (new-package-name new-name package))    (rplacd names nil))  (%add-nicknames new-nicknames package)); Someday, this should become LISP:IN-PACKAGE.(defun old-in-package (name &key                         nicknames                         (use nil use-p)                         (internal-size 60)                        (external-size 10))  (let ((pkg (find-package (setq name (string name)))))    (if pkg      (progn        (use-package use pkg)        (%add-nicknames nicknames pkg))      (setq pkg            (make-package name                           :nicknames nicknames                          :use (if use-p use *make-package-use-defaults*)                          :internal-size internal-size                          :external-size external-size)))    (setq *package* pkg)))(defvar *make-package-use-defaults* '("COMMON-LISP" "CCL")); On principle, this should get exported here.  Unfortunately, we; can't execute calls to export quite yet.;(export '*make-package-use-defaults* )(defun make-package (name &key                          nicknames                          (use *make-package-use-defaults*)                          (internal-size 60)                          (external-size 10))  (setq internal-size (require-type internal-size 'fixnum)        external-size (require-type external-size 'fixnum))  (let ((pkg (%gvector $v_pkg                          (%%newhash internal-size)                         (%%newhash external-size)                         nil                         nil                         (list (new-package-name name))                         nil)))      (use-package use pkg)      (%add-nicknames nicknames pkg)      (push pkg %all-packages%)      pkg))(defun new-package-name (name &optional package)  (do* ((prompt "Enter package name to use instead of ~S ."))       ((let* ((found (find-package (setq name (if (symbolp name) (symbol-name name) (ensure-simple-string name))))))          (or (not found)              (eq package found)))        name)    (restart-case (%error "Package name ~S is already in use." (list name) (%get-frame-ptr))      (new-name (new-name)                :report (lambda (s) (format s prompt name))                :interactive                 (lambda ()                   (list (block nil (catch-cancel (return (get-string-from-user                                                          (format nil prompt name))))                               nil)))                (if new-name (setq name new-name))))))       (defun new-package-nickname (name package)  (if (symbolp name) (setq name (symbol-name name)))  (let* ((other (find-package (setq name (if (symbolp name) (symbol-name name) (ensure-simple-string name)))))         (prompt "Enter package name to use instead of ~S ."))    (if other      (unless (eq other package)        (let* ((conflict-with-proper-name (string= (package-name other) name))               (condition (make-condition 'package-name-conflict-error                                          :package package                                          :format-arguments (list name other)                                          :format-string (%str-cat "~S is already "                                                                   (if conflict-with-proper-name                                                                     "the "                                                                     "a nick")                                                                   "name of ~S."))))          (restart-case (%error condition nil (%get-frame-ptr))            (continue ()                      :report (lambda (s) (format s "Don't make ~S a nickname for ~S" name package)))            (new-name (new-name)                      :report (lambda (s) (format s prompt name))                      :interactive                       (lambda ()                         (list (block nil (catch-cancel (return (get-string-from-user                                                                (format nil prompt name))))                                     nil)))                      (if new-name (new-package-nickname new-name package)))            (remove-conflicting-nickname ()                                         :report (lambda (s)                                                   (format s "Remove conflicting-nickname ~S from ~S." name other))                                         :test (lambda (&rest ignore) (declare (ignore ignore)) (not conflict-with-proper-name))                                         (rplacd (pkg.names other)                                                 (delete name (cdr (pkg.names other)) :test #'string=))                                         name))))      name)))(defun %add-nicknames (nicknames package)  (let ((names (pkg.names package)))    (dolist (name nicknames package)      (let* ((ok-name (new-package-nickname name package)))        (if ok-name (push ok-name (cdr names)))))))(defun find-symbol (string &optional package)  (multiple-value-bind (sym flag)                       (%findsym (ensure-simple-string string) (pkg-arg (or package *package*)))    (values sym flag))); Somewhat saner interface to %%FindSym(defun %findsym (&lap string package)  (old-lap   (move.l arg_y atemp0)   (vsize atemp0 da)   (jsr #'%%findsym)   (vpush acc)   (if# (ne da nilreg)     (tst.l da)     (if# mi (move.l ':internal da)      elseif# eq (move.l ':external da)      else# (move.l ':inherited da)))   (vpush da)   (vunscale.l db)   (vpush db)   (vunscale.l dy)   (vpush dy)   (set_nargs 4)   (jmp_subprim $sp-values)))(defun intern (str &optional (package *package*))  (setq package (pkg-arg package))  (setq str (ensure-simple-string str))  (old-lap   (move.l (varg str) atemp0)   (vsize atemp0 da)   (move.l (varg package) arg_z)   (jsr #'%%findsym)   (if# eq     (move.l (varg package) atemp0)     (move.l (varg str) arg_z)     (jsr #'%%addsym)     (move.l nilreg da)     else#     (tst.l da)     (if# mi (move.l ':internal da)          elseif# eq (move.l ':external da)          else# (move.l ':inherited da)))   (vpush acc)   (vpush da)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun unintern (symbol &optional (package *package*))  (setq package (pkg-arg package))  (setq symbol (require-type symbol 'symbol))  (multiple-value-bind (found-p foundsym table index) (%find-package-sym (symbol-name symbol) package)    (when (and found-p (eq symbol foundsym))      (when (memq symbol (pkg.shadowed package))        ; A conflict is possible if more than one similarly-named external symbol         ; exists in the packages used by this one.        ; Grovel around looking for such conflicts; if any are found, signal an        ; error (via %kernel-restart) which offers to either shadowing-import one        ; of the conflicting symbols into the current package or abandon the attempt        ; to unintern in the first place.        (let* ((first nil)               (first-p nil)               (name (symbol-name symbol))               (others nil))          (declare (dynamic-extent first))          (without-interrupts           (dolist (pkg (%svref package pkg.used))             (let ((found nil)                   (conflicting-sym nil))               (lap-inline (name (%svref pkg pkg.etab))                 (:variable found conflicting-sym)                 (move.l arg_y atemp0)                 (vsize atemp0 da)                 (jsr #'%%Getsym)                 (if# eq                   (move_t (varg found))                   (if# (eq (a5 $nilsym) acc)                     (move.l nilreg acc))                   (move.l acc (varg conflicting-sym))))               (when found                 (if first-p                   (push conflicting-sym others)                   (setq first-p t first conflicting-sym))))))          (when others            ; If this returns, it will have somehow fixed things.            (return-from unintern (%kernel-restart $xunintc symbol package (cons first others)))))        ; No conflicts found, but symbol was on shadowing-symbols list.  Remove it atomically.        (lap-inline (symbol package)          (if# (eq arg_y nilreg)            (move.l (a5 $nilsym) arg_y))          (move.l arg_z atemp1)          (lea (svref atemp1 pkg.shadowed (- $_cdr)) atemp1)          (prog#           (move.l atemp1 atemp0)           (cdr atemp1 atemp1)           (if# (ne nilreg atemp1)             (if# (eq (car atemp1) arg_y)               (rplacd atemp0 (cdr atemp1))               (bra (exit#)))             (bra (top#))))))      ; Now remove the symbol from package; if package was its home package, set its package to NIL.      ; If we get here, the "table" and "index" values returned above are still valid.      (%svset (car table) index (%unbound-marker-8))      (lap-inline (package symbol)        (if# (eq nilreg arg_z)          (lea (nilreg (+ $nil_val $sym.package-plist)) atemp1)          else#          (move.l arg_z atemp1)          (lea (atemp1 $sym.package-plist) atemp1))        (move.l @atemp1 da)        (if# (eq (ttagp ($ $t_cons) da dx))          (move.l da atemp1)          (add.w ($ $_car) atemp1)          (move.l @atemp1 da))        (if# (eq da arg_y)        (move.l nilreg @atemp1)))      t)))(defun import-1 (package sym)  (multiple-value-bind (conflicting-sym type internal-offset external-offset) (%findsym (symbol-name sym) package)    (if (and type (neq conflicting-sym sym))      (let* ((external-p (eq type :inherited))             (condition (make-condition 'import-conflict-error                                         :package package                                        :imported-sym sym                                        :conflicting-sym conflicting-sym                                        :conflict-external external-p)))        (restart-case (error condition)          (continue ()                    :report (lambda (s) (format s "Ignore attempt to import ~S to ~S." sym package)))          (resolve-conflict ()                            :report (lambda (s)                                      (let* ((package-name (package-name package)))                                        (if external-p                                           (format s "~A ~s in package ~s ." 'shadowing-import sym package-name)                                          (format s "~A ~s from package ~s ." 'unintern conflicting-sym package-name))))                            (if external-p                               (shadowing-import-1 package sym)                              (progn                                (unintern conflicting-sym package)                                (import-1 package sym))))))      (unless (or (eq type :external) (eq type :internal))        (%insertsym sym package internal-offset external-offset)))))(defun %insertsym (&lap sym package internal-offset external-offset)  (lap    (vpop atemp0)    (if# (eq nilreg atemp0)      (lea (atemp0 $nil_val) atemp0))    (move.l arg_x atemp1)    (move.l arg_y db)    (vscale.l db)    (move.l arg_z dy)    (vscale.l dy)    (move.l atemp0 arg_z)    (jsr #'%%InsertSym)    (move.l nilreg acc)    (rts)))(defun import (sym-or-syms &optional package)  (setq package (pkg-arg (or package *package*)))  (if (listp sym-or-syms)    (dolist (sym sym-or-syms)      (import-1 package sym))    (import-1 package sym-or-syms))  t)(defun shadow-1 (package sym)  (lap-inline ()    (:variable package sym)    (jsr_subprim $sp-symorsstr)    (move.l acc atemp0)    (move.l (varg package) acc)    (vpush atemp0)    (vsize atemp0 da)    (jsr #'%%FindSym)    (bif (and ne (le (tst.l da))) @done)   ;Already present in package, nothing to do.    (vpop acc)    (move.l (varg package) atemp0)    (jsr #'%%AddSym)		;Make a fresh symbol and insert it    (bra @addshadowed)@done    (add.w ($ 4) vsp)                   ; Flush pname    (move.l (varg package) atemp0)    (lea (svref atemp0 pkg.shadowed (- $_cdr)) atemp1)	;See if already in the list   (prog#    (cdr atemp1 atemp1)    (bif (eq atemp1 nilreg) @addShadoweD)		;No, so add it.    (until# (eq (car atemp1) acc)))   (bra @exit)@addShadowed   (move.l (varg package) atemp0)   (move.l acc arg_y)			;Cons sym on   (move.l (svref atemp0 pkg.shadowed) arg_z)   (jsr_subprim $sp-consYZ)	;If this errs out, we're in bad shape!   (move.l (varg package) atemp0)   (move.l acc (svref atemp0 pkg.shadowed))@exit   (move.l nilreg acc)))(defun shadow (sym-or-symbols-or-string-or-strings &optional package)  (if package    (setq package (pkg-arg package))    (setq package *package*))  (if (listp sym-or-symbols-or-string-or-strings)    (dolist (s sym-or-symbols-or-string-or-strings)      (shadow-1 package s))    (shadow-1 package sym-or-symbols-or-string-or-strings))  t)(defun unexport (sym-or-symbols &optional package)  (setq package (pkg-arg (or package *package*)))  (if (listp sym-or-symbols)    (dolist (sym sym-or-symbols)      (unexport-1 package sym))    (unexport-1 package sym-or-symbols))  t)(defun unexport-1 (package sym)  (when (eq package *keyword-package*)    (error "Can't unexport ~S from ~S ." sym package))  (multiple-value-bind (foundsym foundp internal-offset external-offset)                       (%findsym (symbol-name sym) package)    (when (eq foundp :external)      (let* ((evec (car (pkg.etab package)))             (itab (pkg.itab package))             (ivec (car itab))             (icount&limit (cdr itab)))        (declare (type cons etab itab icount&limit))        (setf (svref evec external-offset) (%unbound-marker-8))        (setf (svref ivec internal-offset) (or foundsym (lap-inline () (move.l (a5 $nilsym) acc))))        (if (eql (setf (car icount&limit)                       (the fixnum (1+ (the fixnum (car icount&limit)))))                 (the fixnum (cdr icount&limit)))          (%%Hresize itab)))))  nil); Both args must be packages.(defun %use-package-conflict-check (using-package package-to-use)  (let ((already-used (pkg.used using-package)))    (unless (or (eq using-package package-to-use)                (memq package-to-use already-used))      ; There are two types of conflict that can potentially occur:      ;   1) An external symbol in the package being used conflicts       ;        with a symbol present in the using package      ;   2) An external symbol in the package being used conflicts       ;        with an external symbol in some other package that's already used.      (let* ((ext-ext-conflicts nil)             (used-using-conflicts nil)             (shadowed-in-using (pkg.shadowed using-package))             (to-use-etab (pkg.etab package-to-use)))        (without-interrupts         (dolist (already already-used)           (let ((user (if (memq package-to-use (pkg.used-by already))                          package-to-use                         (if (memq package-to-use (pkg.used already))                           already))))             (if user               (let* ((used (if (eq user package-to-use) already package-to-use))                      (user-etab (pkg.etab user))                      (used-etab (pkg.etab used)))                 (dolist (shadow (pkg.shadowed user))                   (unless (memq shadow shadowed-in-using)                     (let* ((sname (lap-inline (shadow) (if# (eq acc nilreg)                                                           (move.l (nilreg (+ $nil_val $sym.pname)) acc)                                                          else#                                                          (move.l acc atemp0)                                                          (move.l (atemp0 $sym.pname) acc)))))                       (when (%getsym sname user-etab)   ;  external in user                         (multiple-value-bind (external-in-used used-sym) (%getsym sname used-etab)                           (when (and external-in-used (neq used-sym shadow))                             (push (list shadow used-sym) ext-ext-conflicts))))))))   ; Remember what we're doing here ?               ; Neither of the two packages use the other.  Iterate over the external               ; symbols in the package that has the fewest external symbols and note               ; conflicts with external symbols in the other package.               (let* ((smaller (if (%i< (%cadr to-use-etab) (%cadr (pkg.etab already)))                                 package-to-use                                 already))                      (larger (if (eq smaller package-to-use) already package-to-use))                      (larger-etab (pkg.etab larger))                      (smaller-v (%car (pkg.etab smaller))))                 (dotimes (i (uvsize smaller-v))                   (declare (fixnum i))                   (let ((sym (%svref smaller-v i)))                     (when (and sym                                (neq sym (%unbound-marker-8))                                (not (memq sym shadowed-in-using)))                       (multiple-value-bind (found-in-larger sym-in-larger) (%getsym (lap-inline (sym)                                                                                       (move.l acc atemp0)                                                                                       (move.l (atemp0 $sym.pname) acc))                                                                                     larger-etab)                         (when (and found-in-larger (neq sym-in-larger sym) (not (memq sym-in-larger shadowed-in-using)))                           (push (list sym sym-in-larger) ext-ext-conflicts))))))))))         ; Now see if any non-shadowed, directly present symbols in the using package conflicts with         ; an external symbol in the package being used.  There are two ways of doing this; one of         ; them -may- be much faster than the other.         (let* ((to-use-etab-size (%cadr to-use-etab))                (present-symbols-size (%i+ (%cadr (pkg.itab using-package)) (%cadr (pkg.etab using-package)))))           (unless (eql 0 present-symbols-size)             (if (%i< present-symbols-size to-use-etab-size)               ; Faster to look up each present symbol in to-use-etab.               (let ((htabvs (list (%car (pkg.etab using-package)) (%car (pkg.itab using-package)))))                 (declare (dynamic-extent htabvs))                 (dolist (v htabvs)                   (dotimes (i (uvsize v))                     (declare (fixnum i))                     (let ((sym (%svref v i)))                       (when (and sym (neq sym (%unbound-marker-8)) (not (memq sym shadowed-in-using)))                         (multiple-value-bind (found-p to-use-sym) (%getsym (lap-inline (sym)                                                                              (move.l acc atemp0)                                                                              (move.l (atemp0 $sym.pname) acc))                                                                            to-use-etab)                           (when (and found-p (neq to-use-sym sym))                             (push (list sym to-use-sym) used-using-conflicts))))))))               ; See if any external symbol present in the package being used conflicts with               ;  any symbol present in the using package.               (let ((v (%car to-use-etab)))                 (dotimes (i (uvsize v))                   (declare (fixnum i))                   (let ((sym (%svref v i)))                     (when (and sym (neq sym (%unbound-marker-8)))                       (multiple-value-bind (found-p using-sym) (%find-package-sym (lap-inline (sym)                                                                                     (move.l acc atemp0)                                                                                     (move.l (atemp0 $sym.pname) acc))                                                                                   using-package)                         (when (and found-p                                     (neq sym (if (null using-sym)                                               (lap-inline () (move.l (a5 $nilsym) acc))                                               using-sym))                                    (not (memq using-sym shadowed-in-using)))                           (push (list using-sym sym) used-using-conflicts)))))))))))        (values ext-ext-conflicts used-using-conflicts)))))(defun use-package-1 (using-package package-to-use)  (if (eq (setq package-to-use (pkg-arg package-to-use))          *keyword-package*)    (error "~S can't use ~S." using-package package-to-use))  (do* ((used-external-conflicts nil)        (used-using-conflicts nil))       ((and (null (multiple-value-setq (used-external-conflicts used-using-conflicts)                     (%use-package-conflict-check using-package package-to-use)))             (null used-using-conflicts)))    (if used-external-conflicts      (%kernel-restart $xusecX package-to-use using-package used-external-conflicts)      (if used-using-conflicts        (%kernel-restart $xusec package-to-use using-package used-using-conflicts))))  (unless (memq using-package (pkg.used-by package-to-use))   ;  Not already used in break loop/restart, etc.    (push using-package (pkg.used-by package-to-use))    (push package-to-use (pkg.used using-package))))(defun use-package (packages-to-use &optional package)  (setq package (pkg-arg (or package *package*)))  (if (listp packages-to-use)    (dolist (to-use packages-to-use)      (use-package-1 package to-use))    (use-package-1 package packages-to-use))  t)(defun shadowing-import-1 (package sym)  (lap-inline ()    (:variable package sym)    (with-preserved-registers #(asave0 dsave0 asave1)      (move.l (varg package 12) asave0)      ; acc=symbol (maybe), asave0 = package (definitely)      (move.l acc atemp0)      (jsr_subprim $sp-check-sym)      (move.l atemp0 dsave0)	;dsave0 = symbol      (move.l asave0 acc)		;Package      (sympname atemp0 atemp0)      (vsize atemp0 da)      (jsr #'%%find-pkg-sym)      (beq @insert)		;No symbols with same pname, just go for it.      (lea (svref asave0 pkg.shadowed (- $_cdr)) atemp0)	;See if have a shadowing symbol      (prog#       (move.l atemp0 asave1)       (cdr atemp0 atemp0)       (if# (eq atemp0 nilreg)         ;Found a non-shadowing symbol in the package.         ;Is it our symbol?         (bif (eq atemp1 dsave0) @mkshad)	;Yes, then just add it to shadowing symbols         (bra @remove))       (until# (eq (car atemp0) acc)))      ;Found a shadowing symbol in the package      (if# (eq dsave0 atemp1)             ;Is it our symbol?        (bra @exit))                      ;Yes, nothing to do!      (rplacd asave1 (cdr atemp0))        ;Some other symbol, splice it out      ; Have some other symbol of same name present in package. Unintern it.      @remove      (lea (atemp1 $sym.package-plist) atemp1)      (move.l @atemp1 da)      (if# (eq (ttagp ($ $t_cons) da dx))        (move.l da atemp1)        (add.w ($ $_car) atemp1)        (move.l @atemp1 da))      (if# (eq da asave0)        (move.l nilreg @atemp1))      (move.l db atemp1)      (car atemp1 atemp1)		;htab found in      (move.l ($ $undefined) db)      (move.l db (atemp1 dy.l $v_data))      ; Ok, have dealt with conflicting sym if any.  Insert our symbol.      @insert      (move.l asave0 acc)		;Package      (move.l dsave0 atemp0)      (sympname atemp0 atemp0)      (vsize atemp0 da)      (jsr #'%%findsym)      (move.l dsave0 acc)		;Symbol Ptr      (move.l asave0 atemp1)	;Package      (jsr #'%%insertsym)      ; Symbol is now present in the package.  Put it on the unshadowable list.      @mkshad      (move.l dsave0 acc)      (lea (nilreg $nil_val) atemp0)      (if# (eq atemp0 acc)        (move.l nilreg acc))      (move.l acc arg_y)      (move.l (svref asave0 pkg.shadowed) arg_z)      (jsr_subprim $sp-consYZ)      (move.l acc (svref asave0 pkg.shadowed))      @exit      (move.l nilreg acc))))(defun shadowing-import (sym-or-syms &optional package)  (setq package (pkg-arg (or package *package*)))  (if (listp sym-or-syms)    (dolist (sym sym-or-syms)      (shadowing-import-1 package sym))    (shadowing-import-1 package sym-or-syms))  t)(defun unuse-package (packages-to-unuse &optional package)  (let ((p (pkg-arg (or package *package*))))    (flet ((unuse-one-package (unuse)            (setq unuse (pkg-arg unuse))            (setf (pkg.used p) (nremove unuse (pkg.used p))                  (pkg.used-by unuse) (nremove p (pkg.used-by unuse)))))      (declare (dynamic-extent #'unuse-one-package))      (if (listp packages-to-unuse)        (dolist (u packages-to-unuse) (unuse-one-package u))        (unuse-one-package packages-to-unuse))      t)))(defun delete-package (package)  (unless (packagep package)    (setq package (or (find-package package)                      (progn                        (cerror "Do nothing" (%rsc-string $xnopkg) package)                        (return-from delete-package nil)))))  (unless (memq package %all-packages%)    (return-from delete-package nil))  (when (pkg.used-by package)    (cerror "unuse ~S" "~S is used by ~S" package (pkg.used-by package)))  (while (pkg.used-by package)    (unuse-package package (car (pkg.used-by package))))  (while (pkg.used package)    (unuse-package (car (pkg.used package)) package))  (setf (pkg.shadowed package) nil)  (setq %all-packages% (nremove package %all-packages%))  (setf (pkg.names package) nil)  (lap-inline (package)    (move.l ($ $undefined) db)    (move.l acc atemp1) (move.l (svref atemp1 pkg.itab) atemp1) (car atemp1 atemp1)    (getvect atemp1 da) (asr.l ($ 2) da)    (dbfloop da      (move.l (@+ atemp1) atemp0)      (if# (and (ne (cmp.l nilreg atemp0))                (ne (cmp.l db atemp0))                (eq (progn (lea (atemp0 $sym.package-plist) atemp0)                           (move.l @atemp0 dx)                           (if# (eq (ttagp ($ $t_cons) dx dy))                             (move.l dx atemp0)                             (add.w ($ $_car) atemp0)                             (move.l @atemp0 dx))                           (cmp.l dx acc))))        (move.l nilreg @atemp0)))    (move.l acc atemp1) (move.l (svref atemp1 pkg.etab) atemp1) (car atemp1 atemp1)    (getvect atemp1 da) (asr.l ($ 2) da)    (dbfloop da      (move.l (@+ atemp1) atemp0)      (if# (and (ne (cmp.l nilreg atemp0))                (ne (cmp.l db atemp0))                (eq (progn (lea (atemp0 $sym.package-plist) atemp0)                           (move.l @atemp0 dx)                           (if# (eq (ttagp ($ $t_cons) dx dy))                             (move.l dx atemp0)                             (add.w ($ $_car) atemp0)                             (move.l @atemp0 dx))                           (cmp.l dx acc))))        (move.l nilreg @atemp0))))  (let ((itab (pkg.itab package)) (etab (pkg.etab package)) (v '#(nil nil nil)))    (%rplaca itab v) (%rplaca etab v)    (%rplaca (%cdr itab) 0) (%rplaca (%cdr etab) 0)    (%rplacd (%cdr itab) #x4000) (%rplacd (%cdr etab) #x4000))  t);%%find-pkg-sym(atemp0=string, da=len, acc=package). Find symbol present in package.;Returns with acc=sym, atemp1=sym ptr, Z clear; or acc=UNDEFINED, Z set.;Preserves atemp0/da. If found, db gets table, dy gets table offset(defun %%find-pkg-sym (&lap 0)  (lap-inline ()   (move.l acc atemp1)   (move.l (svref atemp1 pkg.itab) acc)   (vpush acc)                          ;save table   (vpush atemp1)                       ;save package   (jsr #'%%GetSym)   (vpop atemp1)   (beq @found)   (move.l (svref atemp1 pkg.etab) acc)	;External table   (move.l acc (vsp))   (jsr #'%%GetSym)   (beq @found)   (add.w ($ 4) vsp)   (moveq 0 db)                         ; Z set   (rts)@found   (vpop db)   (move.l acc atemp1)   (if# (eq (a5 $nilsym) acc) (move.l nilreg acc))   (rts)))                              ;Z clear; Uninterruptable; returns (values foundp sym-if-found htab-if-found offset-if-found).; Arg_z must be a package; arg_y must be a simple string.(defun %find-package-sym (&lap pname package)  (old-lap   (move.l arg_y atemp0)   (vsize atemp0 da)   (jsr #'%%find-pkg-sym)   (if# eq     (vpush nilreg)     (vpush nilreg)     (vpush nilreg)     (vpush nilreg)     else#     (move_t (-@ vsp))     (vpush acc)     (vpush db)     (vunscale.l dy)     (vpush dy))   (set_nargs 4)   (jmp_subprim $sp-values)))  ; Atomic.  Returns (values found-p symbol htab-index).; String must be a simple-string; htab is (htab-vector . htab-count-info).  (defun %getsym (&lap string htab)  (old-lap   (move.l arg_y atemp0)   (vsize atemp0 da)   (jsr #'%%GetSym)   (if# ne     (vpush nilreg)     (vpush nilreg)     (vpush nilreg)     else#     (move_t (-@ vsp))     (vpush acc)     (vunscale.l dy)     (vpush dy))   (set_nargs 3)   (jmp_subprim $sp-values)));For the inspector, number of symbols in pkg.(defun %pkgtab-count (pkgtab &aux (n 0))  (dovector (x (pkgtab-table pkgtab))    (when (and x (neq x (%unbound-marker-8)))      (setq n (%i+ n 1))))  n)(defun %resize-package (pkg)  #-bccl (unless (packagep pkg) (report-bad-arg pkg 'package))  (%%HreSIze (pkg.itab pkg))  (%%hResiZe (pkg.etab pkg))  pkg);These allow deleted packages, so can't use pkg-arg which doesn't.(defun pkg-arg-allow-deleted (pkg)  (lap-inline ()    (:variable pkg)    (if# (and (or (ne (ttagp ($ $t_vector) acc da))                  (ne (progn (move.l acc atemp1) (vsubtypep ($ $v_pkg) atemp1 da))))              (eq (progn (ccall find-package acc) (cmp.l nilreg acc))))      (move.l (varg pkg) acc)      (lfunlk)      (Tsignal_restart (fixnum $xnopkg) acc))))(defun package-name (pkg) (%car (pkg.names (pkg-arg-allow-deleted pkg))));;>> Shouldn't these copy-list their result so that the user;;>>  can't cause a crash through evil rplacding?;Of course that would make rplacding less evil, and then how would they ever learn?(defun package-nicknames (pkg) (%cdr (pkg.names (pkg-arg-allow-deleted pkg))))(defun package-use-list (pkg) (pkg.used (pkg-arg-allow-deleted pkg)))(defun package-used-by-list (pkg) (pkg.used-by (pkg-arg-allow-deleted pkg)))(defun package-shadowing-symbols (pkg) (pkg.shadowed (pkg-arg-allow-deleted pkg))); This assumes that all symbol-names and package-names are strings.(defun %define-package (name size                              external-size ; extension (may be nil.)                             nicknames                             shadow                             shadowing-import-from-specs                             use                             import-from-specs                             intern                             export)  (if (eq use :default) (setq use *make-package-use-defaults*))  (let* ((pkg (find-package name)))    (if pkg      ; Restarts could offer several ways of fixing this.      (unless (string-equal (package-name pkg) name)        (error "~s is already a nickname for ~s" name pkg))      (setq pkg (make-package name                              :use nil                              :internal-size (or size 60)                              :external-size (or external-size                                                 (max (length export) 1)))))    (unuse-package (package-use-list pkg) pkg)    (rename-package pkg name nicknames)    (flet ((operation-on-all-specs (function speclist)             (let ((to-do nil))               (dolist (spec speclist)                 (let ((from (pop spec)))                   (dolist (str spec)                     (multiple-value-bind (sym win) (find-symbol str from)                       (if win                         (push sym to-do)                         ; This should (maybe) be a PACKAGE-ERROR.                         (cerror "Ignore attempt to ~s ~s from package ~s"                                 "Cannot ~s ~s from package ~s" function str from))))))               (when to-do (funcall function to-do pkg)))))            (dolist (sym shadow) (shadow sym pkg))      (operation-on-all-specs 'shadowing-import shadowing-import-from-specs)      (use-package use pkg)      (operation-on-all-specs 'import import-from-specs)      (dolist (str intern) (intern str pkg))      (when export        (let* ((syms nil))          (dolist (str export)            (multiple-value-bind (sym found) (find-symbol str pkg)              (unless found (setq sym (intern str pkg)))              (push sym syms)))          (export syms pkg)))      pkg))); The guts of with-package-iterator(defun %start-with-package-iterator (p)  (let ((pkgs (pkg-iter.pkgs p)))    (if (listp pkgs)      (every #'find-package pkgs)      (find-package pkgs)))  (%pkg-iter-next-package p))(defun %pkg-iter-next-package (p)  (setf (pkg-iter.state p) #'%pkg-iter-next-package)  (let ((pkgs (pkg-iter.pkgs p))        (types (pkg-iter.types p))        pkg)    (declare (fixnum types))    (when pkgs      (if (listp pkgs)        (setq pkg (pop pkgs))        (setq pkg pkgs              pkgs nil))      (setf (pkg-iter.pkg p) (setq pkg (find-package pkg))            (pkg-iter.pkgs p) pkgs)      (cond ((logbitp $pkg-iter-external types) (%start-pkg-iter-externals p))            ((logbitp $pkg-iter-internal types) (%start-pkg-iter-internals p))            ((logbitp $pkg-iter-inherited types) (%start-pkg-iter-inherited p))))))(defun %start-pkg-iter-externals (p)  (let ((tbl (car (uvref (pkg-iter.pkg p) pkg.etab))))    (setf (pkg-iter.state p) #'%get-pkg-iter-external          (pkg-iter.tbl p) tbl          (pkg-iter.index p) (length tbl)))  (%get-pkg-iter-external p))(defun %start-pkg-iter-internals (p)  (let ((tbl (car (uvref (pkg-iter.pkg p) pkg.itab))))    (setf (pkg-iter.state p) #'%get-pkg-iter-internal          (pkg-iter.tbl p) tbl          (pkg-iter.index p) (length tbl)))  (%get-pkg-iter-internal p))(defun %start-pkg-iter-inherited (p)  (let* ((pkgs (uvref (pkg-iter.pkg p) pkg.used))         (pkg (pop pkgs))         tbl)    (if pkg      (setf (pkg-iter.state p) #'%get-pkg-iter-inherited            (pkg-iter.used p) pkgs            (pkg-iter.tbl p) (setq tbl (car (uvref pkg pkg.etab)))            (pkg-iter.index p) (length tbl))      (setf (pkg-iter.state p) nil)))  (%get-pkg-iter-inherited p))(defun %next-pkg-iter-symbol (tbl index)  (declare (fixnum index))  (let (sym found)    (loop      (when (<= index 0)        (return nil))      (multiple-value-setq (sym found) (%htab-symbol tbl (decf index)))      (when found        (return (values sym index))))))(defun %get-pkg-iter-external (p)  (multiple-value-bind (sym index)                        (%next-pkg-iter-symbol                        (pkg-iter.tbl p) (pkg-iter.index p))    (if index      (progn        (setf (pkg-iter.index p) index)        (values t sym :external (pkg-iter.pkg p)))      (let ((types (pkg-iter.types p)))        (declare (fixnum types))        (cond ((logbitp $pkg-iter-internal types) (%start-pkg-iter-internals p))              ((logbitp $pkg-iter-inherited types) (%start-pkg-iter-inherited p))              (t (%pkg-iter-next-package p)))))))(defun %get-pkg-iter-internal (p)  (multiple-value-bind (sym index)                        (%next-pkg-iter-symbol                        (pkg-iter.tbl p) (pkg-iter.index p))    (if index      (progn        (setf (pkg-iter.index p) index)        (values t sym :internal (pkg-iter.pkg p)))      (let ((types (pkg-iter.types p)))        (declare (fixnum types))        (cond ((logbitp $pkg-iter-inherited types) (%start-pkg-iter-inherited p))              (t (%pkg-iter-next-package p)))))))(defun %get-pkg-iter-inherited (p)  (let (pkg)    (multiple-value-bind (sym index)                          (%next-pkg-iter-symbol (pkg-iter.tbl p) (pkg-iter.index p))      (if index        (progn          (setf (pkg-iter.index p) index                pkg (pkg-iter.pkg p))          ; Note: this will be slow if there are a lot of shadowed symbols.          ; The alternative is find-symbol, which is much slower in the normal          ; case of few shadowed symbols.          (if (and (pkg.shadowed pkg)                   (%name-present-in-package-p (symbol-name sym) pkg))            (%get-pkg-iter-inherited p)            (values t sym :inherited pkg)))        (progn          (let ((pkgs (pkg-iter.used p))                tbl)            (if pkgs              (progn                (setf pkg (pop pkgs)                      (pkg-iter.used p) pkgs                      (pkg-iter.tbl p) (setq tbl (car (uvref pkg pkg.etab)))                      (pkg-iter.index p) (length tbl))                (%get-pkg-iter-inherited p))              (%pkg-iter-next-package p)))))))); For do-symbols and with-package-iterator; string must be a simple string; package must be a package(defun %name-present-in-package-p (string package)  (lap-inline ()    (:variable package string)    (move.l (varg package) arg_z)    (move.l (varg string) atemp0)    (vsize atemp0 da)    (jsr #'%%find-pkg-sym)    (if# eq      (move.l nilreg acc)))); This is supposed to be (somewhat) like the lisp machine's MAKE-PACKAGE.; Accept and ignore some keyword arguments, accept and process some others.(defun lispm-make-package (name &key                                 (use *make-package-use-defaults*)                                nicknames                                ;prefix-name                                ;invisible                                (shadow nil shadow-p)                                (export nil export-p)                                (shadowing-import nil shadowing-import-p)                                (import nil import-p)                                (import-from nil import-from-p)                                ;relative-names                                ;relative-names-for-me                                ;size                                ;hash-inherited-symbols                                ;external-only                                ;include                                ;new-symbol-function                                ;colon-mode                                ;prefix-intern-function                                &allow-other-keys)  ;  (declare (ignore prefix-name invisible relative-names relative-names-for-me  ;                   size hash-inherited-symbols external-only include  ;                   new-symbol-function colon-mode prefix-intern-function))  (let ((pkg (make-package name :use NIL :nicknames nicknames)))    (when shadow-p (shadow shadow pkg))    (when shadowing-import-p (shadowing-import shadowing-import pkg))    (use-package use pkg)    (when import-from-p      (let ((from-pkg (pop import-from)))        (dolist (name import-from)          (multiple-value-bind (sym win) (find-symbol (string name) from-pkg)            (when win (import-1 pkg sym))))))    (when import-p (import import pkg))    (when export-p      (let* ((syms nil))        (dolist (name export)          (multiple-value-bind (sym win) (find-symbol (string name) pkg)            (unless win (setq sym (intern (string name) pkg)))            (push sym syms)))        (export syms pkg)))    pkg))#|	Change History (most recent last):	2	12/27/94	akh	merge with d13|# ;(do not edit past this line!!)