;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  5 10/5/97  akh  ssee below;;  4 6/2/97   akh  resurrect boundp;;  2 4/1/97   akh  see below;;  18 10/1/96 akh  %put/hput-single/double;;  17 9/27/96 akh  get/set-single/double from 4.0 + 68k support;;  13 9/14/95 akh  put-string-contents - ignore script;;  11 5/22/95 akh  record-source-file uses *enqueued-window-title* instead of guessing;;  10 5/1/95  akh  getindstring takes and uses script arg;;  9 4/28/95  akh  fixes for extended strings;;  8 4/26/95  akh  subtypep stuff;;  8 3/2/95   akh  *default-character-type* = 'base-character;;  7 2/6/95   akh  add some functions that are called early due to new compiler optimizers.;;  6 2/3/95   akh  add adjoin-eq and adjoin-eql for bootstrapping reasons;;  5 2/3/95   akh  fixes so MCL will build from scratch;;  4 1/31/95  akh  put back old handlep - new one may not work says bill;;  3 1/30/95  akh  added handlep from patch;;  (do not edit before this line!!); L1-utils.lisp; Copyright 1986-1988 Coral Software Corporation.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc.;This file is %included into Level-1.lisp;This file has miscellaneous utilities including objects and defpascal;; Modification History;; 09/05/97 akh  %put-string-segment-contents for extended and start not 0; 05/07/97 bill boundp moved to "ccl:level-0;l0-symbol.lisp; -------------  4.1/3.2;  4/12/95 slh   added *app-optional-modules*;  4/07/95 slh   fold *app-keys* into *app-modules*;  4/04/95 slh   added *app-class-name*;  3/31/95 slh   proclaim-ftype & proclaimed-ftype from nfcomp; create *nx-proclaimed-ftypes*;                 hash table when needed; new *app-keys* (aren't loaded as modules);  3/30/95 slh   merge in base-app changes;--------------  3.0d18; 01/26/95 alice new handlep from handlep-patch;------------- 3.0d16;10/03/93 alice record-source-file uses window-title (front-window) when no file - better than nothing;-----------;;start of added text;01/05/93 bill  lfun-bits now always returns a fixnum;-------------- 3.0d13;07/28/93 bill  getindstring moves here from "ccl:library;interfaces.lisp";-------------- 3.0d11;07/02/93 alice added %put-string-segment-contents;06/19/93 alice %get-string and %put-string and %put-cstring take script arg.;06/14/93 alice %get-string and %get-cstring  know about system script.;05/17/93 bill  handlep no longer knows deep dark secrets of the Mac memory manager.;               macptr<= & macptr-evenp move here from level-2.lisp.;               (This doesn't work yet, so the old code is still there.;                new-handlep is the attempt at a new way).;-------------- 3.0d8;05/16/93 alice %type-of has simple-base-string and simple-extended-string;05/03/93 alice %type-of distinguishes base from extended on basis of high byte ;		rather than byte above type ;-------------- 2.1d6;10/20/92 alice record-source-file - (namestring (back-translate; 02/11/93 bill in %get-cstring: %inc-ptr -> %incf-ptr - less consing.; 02/05/93 bill asseql & memeql call $sp-assq or $sp-memq if EQ is the same as EQL for the item.; 12/29/92 bill (member 1 '((1) (2)) :key #'first :test-not #'eql) no longer jsr's to '0;11/20/92 gb    Everything you know is wrong: flip car & cdr, change lfun bits location, new headers,;               etc.  #'TRUE & #'FALSE moved here.;--------------- 2.0;04/03/92 bill fix Engber's typo in %put-string's error message.;03/18/92 bill  Since, it's used as a setf inverse, %set-ostype needs to;               return its STR argument.;03/13/92 bill  gb's %set-string fix so that (setf (%get-string foo) bar);               works correctly.;-------------  2.0f3;12/10/91 gb    no ralph bit.;12/06/91 gb    coerce-to-function simpler; coerce uses something hairier.;-------- 2.0b4;11/20/91 bill  GB's patch to %defun, *nx-globally-inline*;11/01/91 gb    nuke "with-invisible-references".;09/12/91 alice coerce-to-function for '(lambda ) wants arg_z not arg_y;---------------- 2.0b2;08/24/91 gb    (%un)fhave clears a line or two of cache.  Forget about (PCL) funcallable-instances.;08/24/91 gb    use new trap syntax.;08/14/91 bill  require-null-or-handlep;07/19/91 bill  gensym post-increments *gensym-counter*;08/19/91 gb    define %SET-STRING.;07/21/91 alice record-source-file don't bitch if function and undefined (i.e. someone did fmakunbound);07/21/91 gb    new vector subtypes, badarg scheme.  Remove "full long" support, define some;               things open-coded by compiler.  %defparameter (for fasloader, NYI.);               Leave similar constants alone (this is a mess.)  cl-types here, defun is a;               macro and thus in level-2.  No more %(f)unhave, make (f)makunbound do it.;07/09/91 bill  optimize make-keyword;07/01/91 bill  %get-cstr moves here from l1-edcmd & changes its name to %get-cstring;               %store-cstr moved here from ff & changes its name to %put-cstring.;06/13/91 alice record-source-file minimize retention of back-translated pathnames; 		and dont backtranslate unless we are recording source files!;--------------- 2.0b2;05/23/91 bill make special-form-p know about fbind;05/20/91 gb   add ARRAY-DATA-OFFSET-SUBTYPE.  %PUT-STRING allows non-simple strings.  New RECORD-ARGLIST;              scheme in %MACRO.  New type stuff for short-floats.;03/05/91 alice report-bad-arg gets 2 args, bad named arg had its IF clauses backwards (maybe dont use?);03/04/91 alice record-source-file - back-translate-pathname if given a physical pathname - do we like this?;01/17/91 gb   handlep checks sign bit of (a5 $memflags).;--------------------- 2.0b1;01/08/91 gb   add %vreflet, %primitive to special forms;12/05/90 gb   new-lap a special form.  Compiler now needs to know what is syntactically;              a special form.  %lfun-vector loads by default.;11/26/90 akh  %make-function heed *compile-definitions*, %type-of knows interpreted;11/20/90 gb   load-time-value is a special form.;11/06/90 bill null-or-handlep (called by DEFTRAP type-checking code);10/25/90 akh  get-sstring requires string;10/25/90 gz   unsigned long vectors.;10/16/90 gb   new lap stuff; new type-predicate scheme.;10/04/90 bill bootstrapping-fmakunbound handles (setf foo);10/03/90 bill %class-cpl -> %inited-class-cpl;09/24/90 bill type-check the list in position.;09/18/90 alice fix source-file-or-files;08/29/90 alice record-source-file take a method object for methods - try to save space;09/06/90 bill *%saved-method-var%* &  set-*%saved-method-var%*;08/25/90 bill in %type-of: Check for trampoline bit before method-function;              bit so that closures can have the next-method-bits set.;08/24/90 bill (setf (assq ...) ...).  %macro's second arg can be;              (doc body-pos) to record position of &body in;              *fred-special-indent-alist*.;08/23/90 bill break closure-function out of function-name;08/02/90 gb   plist accessors for new symbols.;08/01/90 alice record-source-file remember class for methods (s.b. classes) & other good stuff;07/25/90 alice record-source-file bitch when redefining by any means (not just loading);07/04/90 bill new type checking for generic-functions & combined-methods.;06/26/90 bill nremove made me wince.;06/13/90 gb   macro-function is defined on symbols only.;06/08/90 gb   Locally is a special form.;05/30/90 gb   eval-redef set-car, set-cdr, rplaca, rplacd. Remove %immediate accessors.;05/28/90 gb   Don't use %move-vect in %put-string.;05/25/90 alice bugger %defun for encapsulations;05/23/90 gb   flush calls to symtagp.;05/22/90 gb   flush proclaimed{parameter,bound}-p.;05/09/90 gb   misguided paren in %assoc-test-not.;05/04/90 gb   note-function-info when compiling defun.;05/04/90 gz   Improved similar-as-constants-p a bit in case someday never comes...;04/30/90 gb   new, not-so-sticky gensym.  New macroexpansion environment stuff.;03/15/90 bill Remove function entry from %get-full-long & %put-full-long:;              they must be uninterruptable as they are called by rref expansion;              with dereferenced handles.;03/13/90 gz   (setf (%get-point)).;01/17/90 gz   Changed lfun-name to check hash table, $lfatr-noname-bit.;12/29/89 gz   Made self-evaluating-p more accurate.;              Made %unfhave preserve the indirect bit.;12/27/89 bill Simplified and corrected inherit-from-p;12/27/89 gz   Added %ostype-ptr.  Accept non-simple strings in %put-ostype.;              Added add-to-alist.  Moved redefine-kernel-function, fmakunbound elsewhere,;              don't call it, assume fset takes care of it.;              Watch out for swappable functions in %type-of, %lfun-vector.;              Low level support for function specs/setf functions (%fhave, fboundp,;              symbol-function).  Moved high-level function spec stuff elsewhere.;12/15/89 gz   Added nfunction and without-interrupts to special forms.;12/05/89 gb   new &laps for old.  Defun expands into "global-function-name" decl.;11/22/89 gb   32-bit handlep, %strip-address.;11/18/89 gz   (macro ... -> (defmacro ...  Moved qlfun to level-2.;              non-nil-symbol-p.;              define-constant uses EQUALP (for now) and continuable error.;              %lambda-list property -> hash table.;              Use set-documentation to set documentation.;              Moved init-list-default to level-2 (why was it here???);              Made %macro (i.e. defmacro) go through set-macro-function.;              Bootstrapping store-setf-method.;              Don't use plists for source files.;              Flushed 'object and 'flavors-instance from %type-of.;13-Nov-89 Mly (per GB) _SysBeep wants 16 bits on tha'stack;10/31/89 bill Test $lfbits-ralph-bit for generic-function, method-function,;              and combined-method in %type-of.;10/22/89 bill add combined-method to %type-of;10/19/89 bill %type-of returns 'method-function for the function inside a method.;              instead of standard-method.;10/13/89 gb  function-name doesn't descend named trampolines.;10/4/89 gz   fset-globally -> fset.;9/30/89 gz   %lfun-vector, use it in lfun-bits, lfun-name.;9/28/89 gb  unsigned short, byte vectors.;09/27/89 gb simple-string -> ensure-simple-string.  Don't default;             macroexpansion environment anymore.  Forget macroexpansion-;             object-p (bootstrapping artifact.)  %defvar records source always.;             no instance/object variables.;9/17/89 gb   removed (ask nil ...). Moved object lisp code to lib;objects. No;             $sym.gfunc (defunct.);9/14/89 bill Add *level-1-loaded* flag to prevent full-pathname call from;             inside of record-source-file until level-1 is loaded.;9/13/89 gz   Made %unhave pay attention to indirect bit.;9/11/89 gz   No more %sym-fn-loc, %sym-value-loc.;             (%cdr (%sym-fn-loc x)) -> fboundp, (%cdr (%sym-value-loc x)) -> %sym-value.;9/09/89 bill Add beep function. A cheap output-device at boot time.;09/05/89 gz  proclaim-notspecial;8/30/89 bill record-source-file: always record methods as methods; old code;             sometimes recorded them as functions.;             get-source-files-with-types: added;8/24/89 gb   Macros aren't on plist anymore, aren't functionp.;             juggled function binding stuff a bit.;             Pass vector subtype in arg_y when creating vectors.;7/25/89 bill expand inherit-from-p to work with clos objects & classes;7/20/89  gz  moved set-part-color-loop to color.lisp.;5/19/89  gz  Don't give redefinition warnings for methods.  All this stuff really;             needs to be redone.;5/3/89   gz  Moved indirect cell initialization to level-1.lisp;4/4/89   gz  Moved export, find-package to l1-symhash, purge-functions to misc.;             Flushed this define-pascal-function.  No more kernel lfuns.;             watch out for indirect bit in define-constant.  Allow for bignum;             lfun bits, just in case.  Initialize indirect value/fn cells for;             kernel.;03/17/89 as  bootstrap support for color menus, delete, position;             rassoc moved here from lists;03/15/89 gb  verify-call-count uses $xtoofew, $xtoomany.;14-apr-89 as  record-arglist for the sake of defmacro;03/09/89 gz  symbolic names for lfunish things. lfun bits can be bignums.;             Bootstrapping record-source-file, require-type.;	      macro-function.;7-apr-89  as  %str-cat takes rest arg;03/03/89 gb  Moved SIMPLE-STRING, here; should rename it.  Added export, find-package.;02/28/89  gz  Added lfun-name;02/19/89  gz  removed xx-closure as vector subtypes, added standard-instance.;              Don't use %uvref/%uvset here.;02/10/89  gz  Added proclaimed-notinline-p; 2/15/89  gb  Adjust sp vice add in ASSOC.; 2/02/89  gb  Handlep.  Damn.;01/03/89  gz  moved #@ to l1-readloop.;12/29/88  gb  a5, heap, lfuns. Added KERNEL-FUNCTION-P.;12/26/88  gz  subtype in array headers.  Float and longword vectors.;              Added istruct-typep. mark -> buffer-mark. full-namestring -> full-pathname.;12/16/88  gz flushed %str-mem-bak,%str-member-i,%str-mem-esc,%str-mem-esc-bak;             Moved get-properties, gentemp, copy-symbol to misc.;12/13/88 gz  %defvar returns nil if unbound.  Flush redundant cmp.b in %type-of;12/08/88 gb  try not recording source when defvar re-defined. Right ?;11/27/88 gz  added eq, eql.;11/24/88 gz  put record-source-file here!;11/23/88 gb restore_regs mumbo-jumbo.;11/19/88 gb  no trampolines in fhave, new functionp, compiled-function-p.;10/25/88 gb  Moved identity, assoc, member, adjoin here.;10/23/88 gb  8.9 upload.; 9/27/88 gz   Mods to point fns to handle bignums. Added %get-point, %put-point.;              lapified %strip-address.; 9/22/88 gb   new immediate map in %fhave.; 9/13/88 gb   nilreg is an address register.; 9/8/88  gb   no cfp.; 9/02/88 gz   Use arrayarg subprim in array-data-and-offset. Make macptr a;              built-in type.; 8/28/88 gz   added array-data-and-offset, get-sstring, bad-named-arg.; 8/20/88 gz   #'eq -> 'eq for bootstrapping reasons.;              Pay attention to compile-time instance variables.;              Split up proclaim into transformable pieces, err out on bad spec,;               handle [not]inline differently.;              Don't incidentally proclaim variables bound.;              proclaimed-parameter-p checks special as well.;              Added alist-adjoin.;              %fhave and %proclaim-special here from level-1.lisp, added %type-of; 8/17/88 gz   Flushed libfasl.; 8/18/88 gb   funcallable-instances are functionp.; 8/16/88 gb   some lap from bindings.a; 8/2/88  gb   %ptr accessors moved to l1-aprims; introduced some lap.; 6/27/88 jaj  proclaim instance-variable -> object-variable <list>; 6/23/88 jaj  #+bccl (%unfhave '%save-application); 6/23/88 as   removed %doc-string-file; 6/9/88  jaj  check for %doc-string-file in %rsc-string; 6/8/88  jaj  added proclaim ignore, unignore; 5/20/88 jaj  check for *read-suppress* in #@. init-list-default uses;              a gensym instead of "the-init-list"; 5/9/88  jaj  added proclaim instance-variable; 2/25/88 jaj  %global-to-local and %local-to-global changed to use traps;              (so that they work with color grafports); 7/28/88 gb   %inc-ptr a macro; continue to seek magic incantations for other;              -ptr accessors.; 6/02/88 gb   Stop using %sym-plist-loc.  Use kernel (%set-)symbol-plist.;              Use %symbol-bits.; 5/20/88 gb   %proclaim-special passes init-p flag.  Added ;              proclaimed-parameter-p. use %ndefvar to pass init-p flag.; 3/29/88 gz   New macptr scheme. Removed %pstr-len. Flushed pre-1.0 edit history.; 2/16/88 jaj  removed %pstr-pointer (now in kernel), %pstr-len simplified;              (almost gone); 1/26/88 cfry I set *save-doc-strings* to T to be CL compatable.; 10/21/87 jaj redefine-kernel-function only cerrors if sym-pkg is ccl or lisp; 10/15/87 jaj check for *warn-if-redefine-kernel* in redefine-kernel-function; 10/15/87 cfry fixed gentemp to be able to take a non-simple string; 10/14/87 cfry init-list-default changed from a defun to a defmacro; 10/6/87 gb  function-spec stuff for flavors.;----------------------------Version 1.0------------------------------;The following forms (up thru defn of %DEFUN) must come before any DEFUN's.;Any (non-kernel) functions must be defined before they're used!(old-lap-inline   ((qlfun %fhave (sym def)          (old-lap           (move.l arg_y atemp0)           (if# (and (eq (ttagp ($ $t_cons) arg_y da))                     (ne (cmp.l nilreg arg_y)))             (if# (ne (cmp.l 'setf (car atemp0)))               (vpush arg_y)               (vpush arg_z)               (ccall function-spec-handler arg_y)               (move.l acc atemp0)               (vpop arg_z)               (vpop arg_y)               (lfunlk)               (set_nargs 2)               (jmp_subprim $sp-funcall))             (cdr atemp0 atemp0)             (if# (or (ne (ttagp ($ $t_cons) atemp0 da))                      (ne (cmp.l (cdr atemp0) nilreg)))               (wtaerr arg_y 'cons))             (vpush arg_z)             (ccall setf-function-name (car atemp0))             (move.l acc atemp0)             (vpop arg_z))           (preserve_regs #(asave0 dsave0))           (jsr_subprim $sp-check-sym)           (move.l atemp0 asave0)           (move.l arg_z dsave0)           (ttag dsave0 da)           (move.l dsave0 atemp0)           (if# (ne (cmp.b ($ $t_lfun) da))             (if# (or (ne (cmp.b ($ $t_cons) da))                      (ne (cmp.l ($ #x4ead $sp-apply-macro) (car atemp0))))               (wtaerr dsave0 'function)))           (lea (asave0 $sym.fapply) atemp0)           (move.w ($ $jmp_absl) (@+ atemp0))           (if# (ne (btst ($ $sym_bit_indirect) (asave0 $sym.fbits)))             (move.l @atemp0 atemp0)             (move.w ($ $jmp_absl) (@+ atemp0)))           (move.l dsave0 @atemp0)           (move.l dsave0 acc)           (move.l asave0 atemp0)           (restore_regs)           (spop vsp)           (jmp_subprim $mmu_flush_sym_cache))))  (move.l '%fhave arg_y)  (move.l arg_z atemp0)  (set_nargs 2)  (jsr @atemp0))(setq %lisp-system-fixups% nil)(%fhave '%proclaim-special        (qlfun %proclaim-special (sym &optional initp)               (lap-inline ()                 (:variable sym initp)                 (move.l arg_y atemp0)                 (jsr_subprim $sp-check-sym)                 (move.b (atemp0 $sym.vbits) da)                 (bset ($ $sym_bit_special) da)                 (move.b da (atemp0 $sym.vbits))                 (movereg arg_z acc))))(%fhave 'lfunp (qlfun lfunp (arg)  (old-lap   (ttagp ($ $t_lfun) arg_z da)   (retcc eq))));See also %%class-of in l1-clos.(%fhave '%type-of (qlfun %type-of (thing)  (old-lap    (lfunlk)    (ttag arg_z da)    (add.w da da)    (jmp (pc da.w 2))    (bra pagetype)            ;fixnum    (bra vector)              ;vector    (bra symtype)             ;symbol    (bra pagetype)            ;float    (bra list)                ;list    (bra pagetype)            ;???    (bra functype)            ;lfun    (if# (eq (cmp.b ($ $t_imm_char) arg_z))      (if# (eq (progn (rol.l ($ 8) arg_z)                      (tst.b arg_z))) ;(cmp.w ($ $t_imm_char) arg_z))        (move.l 'base-character acc)        (rts))       (move.l 'extended-character acc)      (rts))pagetype    (add.w da da)    (move.l '#(fixnum uvector symbol double-float list short-float lfun immediate) atemp0)    (move.l (atemp0 da.w $v_data) acc)    (rts)symtype    (move.l arg_z atemp0)    (bif (eq (tst.w -@atemp0)) pagetype)    (move.l 'symbol-locative acc)    (rts)list    (if# (ne (cmp.l nilreg arg_z))      (move.l 'cons acc))    (rts)vector    (move.l arg_z atemp0)    (vsubtype atemp0 da)    (ext.w da)    (add.w da da)    (move.l '#(ivector               bignum               macptr               dead-macptr               lfun-vector               ivector               simple-extended-string               simple-unsigned-byte-vector               simple-unsigned-word-vector               simple-float-vector               simple-long-vector	       simple-unsigned-long-vector	       simple-bit-vector	       simple-byte-vector	       simple-word-vector	       simple-base-string                   ; Maybe "(simple-base-string)" ?	       simple-vector	       complex-array	       structure	       buffer-mark               package	       lock	       internal-structure	       ratio	       complex	       standard-instance	       gvector	       gvector	       sgbuf	       population	       pool	       hash-table-vector) atemp0)    (move.l (atemp0 da.w $v_data) acc)    (rts); remember to make this recognize evaluated things  - ok we rememberedfunctype    (move.l arg_z atemp0)    (if# (and (geu (a5 $slfuns_start) arg_z) (ltu (a5 $slfuns_end) arg_z))      (if# (ne (cmp.w ($ $jmp_absl) (atemp0)))        (jsr_subprim $sp-swapin))      (move.l (atemp0 2) atemp0))    (move.w (atemp0 ($lf_attrib)) da)    (lea (atemp0 ($lf_lfunv)) atemp1)    (getvect atemp1 dy)    (add.l dy atemp1)    (if# (ne (btst ($ $lfatr-slfunv-bit) da))        (sub ($ 4) atemp1))    (move.l -@atemp1 da)    (if# (ne (btst.l ($ $lfbits-trampoline-bit) da))            (move.w (atemp0 2) dy)      (if# (eq (cmp.w ($ $sp-funcall_cclosure) dy))        (if# (ne (btst.l ($ $lfbits-evaluated-bit) da))          (move.l 'interpreted-lexical-closure acc)          (rts))        (move.l 'compiled-lexical-closure acc)        (rts))      (if# (eq (cmp.w ($ $jsg_funcall) dy))        (move.l 'stack-group acc)        (rts))      (if# (eq (cmp.w ($ $sp-funcall_iclosure) dy))        (move.l 'interpreted-lexical-closure acc)        (rts)))      (if# (ne (btst.l ($ $lfbits-evaluated-bit) da))        (move.l 'interpreted-function acc)        (rts))      (if# (ne (btst.l ($ $lfbits-method-bit) da))        (move.l 'method-function acc)        (rts))      (if# (ne (btst.l ($ $lfbits-gfn-bit) da))        (move.l 'standard-generic-function acc)        (rts))      (if# (ne (btst.l ($ $lfbits-cm-bit) da))        (move.l 'combined-method acc)        (rts))    (move.l 'lfun acc)    (rts))))(%fhave 'functionp        (qlfun functionp (f)               (lfunp f)))(%fhave '%lfun-vector        (qlfun %lfun-vector (lfun &optional (load-p t))          (lap-inline ()            (:variable lfun load-p)            (move.l (varg lfun) atemp0)            (if# (ne (ttagp ($ $t_lfun) atemp0 da))              (wtaerr atemp0 'function))            (if# (and (geu (cmp.l (a5 $slfuns_start) atemp0))                      (ltu (cmp.l (a5 $slfuns_end) atemp0)))              (if# (ne (cmp.w ($ $jmp_absl) (atemp0)))                (if# (eq (cmp.l (varg load-p) nilreg))                  (move.l nilreg acc)                  (bra return))                (jsr_subprim $sp-swapin))              (move.l (atemp0 2) atemp0))            (add.w ($ ($lf_lfunv)) atemp0)            (move.l atemp0 acc)            return)))(%fhave 'lfun-bits        (qlfun lfun-bits (lfun &optional newbits)          (setq lfun (%lfun-vector lfun t))          (lap-inline ()            (:variable lfun newbits)            (move.l (varg lfun) atemp0)            (move.w (atemp0 ($lfv_attrib)) db)	    (getvect atemp0 da)	    (add.l da atemp0)            (if# (ne (btst ($ $lfatr-slfunv-bit) db))              (sub.w ($ 4) atemp0))            (move.l -@atemp0 acc)            (mkint acc)            (move.l (varg newbits) arg_y)            (if# (ne nilreg arg_y)              (exg arg_y acc)              (jsr_subprim $sp-getlong)              (exg arg_y acc)              (move.l (varg lfun) atemp0)              (move.w (atemp0 ($lfv_attrib)) db)	      (getvect atemp0 da)	      (add.l da atemp0)              (if# (ne (btst ($ $lfatr-slfunv-bit) db))                (sub.w ($ 4) atemp0))	      (move.l arg_y -@atemp0)))))(%fhave 'compiled-function-p        (qlfun compiled-function-p (form)          (and (functionp form)               ;(not (logbitp $lfbits-trampoline-bit (lfun-bits form)))               ;Can't call logbitp yet.               (lap-inline ((%lfun-vector form t))                 (move.l arg_z atemp0)                 (move.l nilreg acc)                 (move.w (atemp0 ($lfv_attrib)) db)		 (vsize atemp0 da)		 (vsize atemp0 da)		 (lea (atemp0 da.l (- $v_data 4)) atemp0)                 (if# (ne (btst ($ $lfatr-slfunv-bit) db))                   (sub.w ($ 4) atemp0))                 (if# (eq (btst.l ($ $lfbits-trampoline-bit) @atemp0))                   (add.w ($ $t_val) acc))))))(%fhave 'lfun-vector-name        (qlfun lfun-vector-name (lfunv &optional (new-name nil set-name-p))          (lap-inline ()            (:variable lfunv new-name set-name-p)            (move.l (varg lfunv) atemp1)            (if# (or (ne (btst.w ($ $lfatr-noname-bit) (atemp1 ($lfv_attrib))))                     (eq (btst.w ($ $lfatr-immmap-bit) (atemp1 ($lfv_attrib)))))              (if# (ne (varg new-name) nilreg)                (wtaerr atemp1 'null))              (move.l nilreg acc)             else#              (lea (atemp1 ($lfv_lfun)) atemp0)              (getvect atemp1 acc)	      (lea (atemp1 acc.l -4) atemp1)              (move.w (atemp0 ($lf_attrib)) da)              (if# (ne (btst ($ $lfatr-slfunv-bit) da))                (sub.w ($ 4) atemp1))              (while# (ne (progn (moveq 0 acc) (move.b (-@ atemp1) acc)))                (if# (cs (add.b acc acc))                  (move.b (-@ atemp1) da)                  (lsl.w 8 da)                  (add.w da acc))                (add.l acc atemp0))              (move.l (atemp0) acc)              (if# (and (ne (varg set-name-p) nilreg) (ne (varg new-name) acc))                (move.l (varg new-name) (atemp0)))))))(%fhave 'lookup-lfun-name        (qlfun bootstrapping-lookup-lfun-name (lfun) lfun (values nil nil)))(queue-fixup (defvar *lfun-names* (make-hash-table :test #'eq :weak t)) (defun lookup-lfun-name (lfun) (gethash lfun *lfun-names*)))(%fhave 'lfun-name        (qlfun lfun-name (lfun &optional (new-name nil set-name-p) &aux lfunv)          (multiple-value-bind (stored-name stored?) (lookup-lfun-name lfun)            (unless stored?              (setq stored-name (lfun-vector-name (setq lfunv (%lfun-vector lfun t)))))            (when (and set-name-p (neq new-name stored-name))              (if (and stored? (eq new-name (lfun-vector-name (setq lfunv (%lfun-vector lfun t)))))                (remhash lfun *lfun-names*)                (if (lap-inline (nil)   ; (read-only-lfun-name? lfun)                      (:variable lfun)                      (move.l (varg lfun) atemp0)                      (if# (or (and (geu (cmp.l (a5 $slfuns_start) atemp0))                                    (ltu (cmp.l (a5 $slfuns_end) atemp0)))                               (eq (btst.w ($ $lfatr-immmap-bit) (atemp0 ($lf_attrib))))                               (ne (btst.w ($ $lfatr-noname-bit) (atemp0 ($lf_attrib)))))                        (add.w ($ $t_val) acc)))                  (puthash lfun *lfun-names* new-name)                  (lfun-vector-name lfunv new-name))))            stored-name))); Remember that %DEFUN calls this and that it calls %nth-immediate (defined in;  the compiler) in the case where its argument isn't compiled-function-p.(%fhave 'closure-function        (qlfun closure-function (fun)          (while (and (functionp fun)  (not (compiled-function-p fun)))            (setq fun (%nth-immediate (%lfun-vector fun t) 0))            (when (vectorp fun)              (setq fun (svref fun 0))))          fun))(%fhave 'function-name         (qlfun function-name (fun)               (or (and (functionp fun) (lfun-name fun))                   (if (compiled-function-p (setq fun (closure-function fun)))                     (lfun-name fun)                     (if (and (consp fun) (eq (%car fun) 'lambda))                       (dolist (x (cddr fun))                         (when (and (consp x) (eq (%car x) 'block))                           (return (car (%cdr x))))))))))(%fhave '%symbol-bits (qlfun %symbol-bits (sym &optional new)                             (old-lap-inline ()                              (move.l arg_y atemp0)                              (jsr_subprim $sp-check-sym)                              (move.l arg_z da)                              (move.l ($ 0) acc)                              (move.w (atemp0 $sym.fbits) acc)                              (mkint acc)                              (cmp.l da nilreg)                              (if# ne                                   (getint da)                                   (move.w da (atemp0 $sym.fbits)))))); unbound indirect symbol has "JMP cell", where cell has "JSR <unbound>"; unbound direct symbol has "JSR <unbound>"(%fhave '%unfhave (qlfun '%unfhave (sym)                    (old-lap-inline ()                      (move.l arg_z atemp0)                      (jsr_subprim $sp-check-sym); Does any code care that %UNFHAVE returns "previously-fboundp" ?                      (move.l nilreg acc)                      (move.w ($ $jsr_absl) dy)                      (lea (atemp0 $sym.entrypt) atemp1)                      (and.b ($ #.(lsh 1 $sym_bit_indirect)) (atemp0 $sym.fbits))                      (if# ne                        (move.l (atemp1) atemp1)                        (move.w dy (@+ atemp1))                        (move.w ($ $jmp_absl) dy))                      (move.w dy (atemp0 $sym.fapply))                      (move.l (special %unbound-function%) dx)                      (if# (ne (atemp1) dx)                        (move.l dx (atemp1))                        (add ($ $t_val) acc))                      (jsr_subprim $mmu_flush_sym_cache))))(%fhave 'fmakunbound        ; redefined in sysutils.        (qlfun bootstrapping-fmakunbound (name)          (when (consp name)            (unless (eq (%car name) 'setf)              (error "Function spec handler not loaded yet"))            (setq name (setf-function-name (cadr name))))          (%unfhave name)          name))(%fhave 'fset ;Redefined in sysutils.        (qlfun bootstrapping-fset (name fn)          (fmakunbound name)          (%fhave name fn)          fn))(%fhave 'record-source-file ;Redefined below        (qlfun bootstrapping-record-source-file (fn &optional type)          (declare (ignore fn type))          nil))(%fhave 'fboundp        (qlfun fboundp (name)           "Returns non-NIL if name has a definition in the dynamic environment.Value returned is non-nil (but not a function) if name names amacro or special form, functional value otherwise."           ;There is lots of code around that actually does depend on this           ;returning the symbol-function of name if it is not a macro/special form.           (old-lap             (move.l arg_z atemp0)             (if# (and (eq (ttagp ($ $t_cons) arg_z da))                       (ne (cmp.l nilreg arg_z)))               (if# (ne (cmp.l 'setf (car atemp0)))   ; setf handled directly for speed...                 (vpush arg_z)                        ;  else general case.                 (ccall function-spec-handler arg_z)                 (move.l acc atemp0)                 (vpop arg_z)                 (lfunlk)                 (set_nargs 1)                 (jmp_subprim $sp-funcall))               (cdr atemp0 atemp0)               (if# (or (ne (ttagp ($ $t_cons) atemp0 da))                        (ne (cmp.l (cdr atemp0) nilreg)))                 (wtaerr arg_z 'cons))               (ccall setf-function-name (car atemp0))               (move.l acc atemp0))             (jsr_subprim $sp-check-sym)             (move.l (atemp0 $sym.entrypt) acc)             (if# (ne (btst ($ $sym_bit_indirect) (atemp0 $sym.fbits)))               (move.l acc atemp0)               (move.l (atemp0 2) acc))             (if# (eq (special %unbound-function%) acc)               (move.l nilreg acc))	       (lfret))))(declaim (special *fasload-print*))(setq *fasload-print* nil)(declaim (special *save-doc-strings*))(setq *save-doc-strings* nil)(%fhave 'set-documentation        (qlfun bootstrapping-set-documentation (symbol doc-type string)          (declare (ignore symbol doc-type))          string))(setq *warn-if-redefine-kernel* nil)(%fhave '%defun-encapsulated-maybe ;Redefined in encapsulate        (qlfun bootstrapping-defun-encapsulated (name fn)          (declare (ignore name fn))          nil))(%fhave 'encapsulated-function-name  ;Redefined in encapsulate - used in l1-io        (qlfun bootstrapping-encapsulated-function-name (fn)          (declare (ignore fn))          nil))(%fhave '%traced-p  ;Redefined in encapsulate - used in l1-io        (qlfun bootstrapping-%traced-p (fn)          (declare (ignore fn))          nil))(%fhave '%advised-p  ;Redefined in encapsulate used in l1-io        (qlfun bootstrapping-%advised-p (fn)          (declare (ignore fn))          nil))(%fhave 'set-function-info (qlfun set-function-info  (name info) (declare (ignore info)) name))(%fhave '%defun (qlfun %defun (named-fn &optional info &aux (name (function-name named-fn)))   (record-source-file name 'function)   (if (not (%defun-encapsulated-maybe name named-fn))     (fset name named-fn))   (set-function-info name info)   (when *fasload-print* (format t "~&~S~%" name))   name))(defun get (sym key &optional default)  (declare (%noforcestk))  (old-lap-inline ()    (move.l arg_x atemp0)    (if# (and (eq (ttagp ($ $t_symbol) arg_x da))              (eq (tst.w (atemp0 (- $t_symbol)))))      (btst ($ $sym_vbit_typeppred) (atemp0 $sym.vbits))      (sne db)      (move.l (atemp0 $sym.package-plist) atemp0)      elseif# (eq nilreg atemp0)      (btst ($ $sym_vbit_typeppred) (nilreg (+ $nil_val $sym.vbits)))      (sne db)      (move.l (nilreg (+ $sym.package-plist $nil_val)) atemp0)      else# (jsr_subprim $sp-check-sym))    (if# (eq (ttagp ($ $t_cons) atemp0 da))      (cdr atemp0 atemp0)      (if# (ne (tst.b db))        (cdr atemp0 atemp0))      (until# (eq atemp0 nilreg)              (cmp.l (car atemp0) arg_y)              (cdr atemp0 atemp0)              (if# eq                (car atemp0 acc)                (bra @exit))              (cdr atemp0 atemp0))      (movereg arg_z acc))@exit))(defun put (sym key value)  (old-lap-inline ()    (move.l arg_x atemp0)    (jsr_subprim $sp-check-sym)    (btst ($ $sym_vbit_typeppred) (atemp0 $sym.vbits))    (sne db)    (move.l (atemp0 $sym.package-plist) da)    (if# (or (eq nilreg da)             (ne (ttagp ($ $t_cons) da dx)))      (vpush arg_z)      (vpush atemp0)      (vpush da)      (vpush arg_y)      (jsr_subprim $sp-consZnil)      (jsr_subprim $sp-consvpopZ)      (jsr_subprim $sp-consvpopZ)      (vpop atemp0)      (move.l arg_z (atemp0 $sym.package-plist))      (vpop acc)      else#      (move.l da atemp0)      (cdr atemp0 atemp0)      (if# (ne (tst.b db)) (move.l atemp0 da) (cdr atemp0 atemp0))      (move.l atemp0 atemp1)      (until# (eq atemp0 nilreg)              (cmp.l (car atemp0) arg_y)              (cdr atemp0 atemp0)              (if# eq                (rplaca atemp0 arg_z)                (movereg arg_z acc)                (bra @exit))              (cdr atemp0 atemp0))      (vpush arg_z)      (vpush da)      (vpush arg_y)      (move.l arg_z arg_y)      (move.l atemp1 arg_z)      (jsr_subprim $sp-consyz)      (jsr_subprim $sp-consvpopz)      (vpop atemp0)      (rplacd atemp0 acc)      (vpop acc))    @exit    ))(%include "ccl:l1;l1-utils.lisp")   ; record source file etal;|##|(defun set-type-predicate (type function)  (let ((pair (assq type *type-predicate-alist*)))    (if pair (%rplacd pair function) (push (cons type function) *type-predicate-alist*))    function))|#(defun set-type-predicate (type function)  (lap-inline ()    (:variable type function)    (move.l arg_y atemp0)    (jsr_subprim $sp-check-sym)    (move.l (atemp0 $sym.package-plist) da)    (if# (or (eq da nilreg)             (ne (ttagp ($ $t_cons) da db)))      (bset ($ $sym_vbit_typeppred) (atemp0 $sym.vbits))      (vpush atemp0)      (vpush da)      (move.l (varg function 8) arg_z)      (jsr_subprim $sp-consZnil)      (jsr_subprim $sp-consvpopZ)      (vpop atemp0)      (move.l acc (atemp0 $sym.package-plist))      else#      (move.l da atemp1)      (if# (ne (bset ($ $sym_vbit_typeppred) (atemp0 $sym.vbits)))  ; already there        (cdr atemp1 atemp0)        (rplaca atemp0 (varg function))        else#        (cdr atemp1 arg_z)        (move.l (varg function) arg_y)        (vpush atemp1)        (jsr_subprim $sp-consYZ)        (vpop atemp1)        (rplacd atemp1 arg_z))))  function)(defun get-type-predicate (type)  (old-lap-inline ()    (move.l arg_z atemp0)    (jsr_subprim $sp-check-sym)    (move.l nilreg acc)    (if# (ne (btst ($ $sym_vbit_typeppred) (atemp0 $sym.vbits)))      (move.l (atemp0 $sym.package-plist) atemp0)      (cdr atemp0 atemp0)      (car atemp0 acc))))(defun loading-file-source-file ()  *loading-file-source-file*)(setq *save-local-symbols* t)(%fhave 'require-type (nfunction bootstrapping-require-type                                 (lambda (thing type)                                   (declare (ignore type))                                   thing)))(%fhave '%require-type         (nfunction bootstrapping-%require-type                   (lambda (thing predicate)                     (declare (ignore predicate))                     thing)))(defun non-nil-symbol-p (arg)  "Returns symbol if true"  (declare (%noforcestk))  (old-lap-inline ()    (if# (or (ne (ttagp ($ $t_symbol) arg_z da))             (ne (progn (move.l arg_z atemp0)                        (tst.w -@atemp0))))      (move.l nilreg acc))))(defun macptrp (thing)  (declare (%noforcestk))  (old-lap-inline ()   (if# (eq (ttagp ($ $t_vector) arg_z da))        (move.l arg_z atemp0)        (vsubtypep ($ $v_macptr) atemp0 da))   (setpred eq da)))(setf (type-predicate 'macptr) 'macptrp)(defun istruct-typep (thing type)  (declare (%noforcestk))  (old-lap-inline ()   (if# (or (ne (ttagp ($ $t_vector) arg_y da))            (ne (progn (move.l arg_y atemp0) (cmp.l (atemp0 $v_data) acc)))            (ne (vsubtypep ($ $v_istruct) atemp0 da)))     (move.l nilreg acc)     else#     (move_t acc))))(defun %address-of (arg); %address-of a fixnum is a fixnum, just for spite.; %address-of anything else is the address of that thing as an integer.  (old-lap-inline ()    (if# (ne (ttagp ($ $t_fixnum) arg_z da))      (jsr_subprim $sp-mkulong))))       ; coerce to non-negative integer(defun %coerce-to-pointer (arg); returns a (possibly invalid !) pointer iff its; argument is a fixnum. ; Screw: should accept an integer.  (old-lap-inline ()    (if# (eq (ttagp ($ $t_fixnum) arg_z da))      (getint arg_z))))(defun %scale-pointer (ptr offset); adds the unboxed fixnum (someday integer) offset to ptr, returning; a new, probably invalid, pointer.  (old-lap-inline ()    (getint arg_z)		; no questions asked    (add.l arg_y arg_z)))	; no prisoners taken(defun %extract-pointer (ptr offset); adds the unboxed fixnum (someday integer) offset and ptr, returning; the contents of the addressed location.  (old-lap-inline ()    (getint arg_z)		; no questions asked    (add.l arg_y arg_z)    (move.l arg_z atemp0)    (move.l (atemp0) acc)))	; take one prisoner#| ; this may not work(defun handlep (p)  (and (macptrp p)       (macptr-evenp p)       (flet ((%ptr-in-zone-p (p zone lim)                (declare (type macptr p zone lim))                (and (macptr<= zone p) (macptr<= p lim))))         (declare (inline %ptr-in-zone-p))         (flet ((%handle-in-zone-p (p zone lim sys-p)                  (declare (type macptr p zone lim))                  (with-macptrs ((ptr (%get-ptr p)))                    (and (macptr-evenp ptr)                         (%ptr-in-zone-p ptr zone lim)                         (if sys-p                           (eql p (%setf-macptr ptr (#_RecoverHandle :sys ptr)))                           (eql p (%setf-macptr ptr (#_RecoverHandle ptr))))))))           (declare (inline %handle-in-zone-p))           (with-macptrs ((app-zone (#_ApplicZone))                          (app-lim (pref app-zone :zone.bkLim)))             (if (%ptr-in-zone-p p app-zone app-lim)               (%handle-in-zone-p p app-zone app-lim nil)               (with-macptrs ((sys-zone (#_SystemZone))                              (sys-lim (pref sys-zone :zone.bkLim)))                 (and (%ptr-in-zone-p p sys-zone sys-lim)                      (%handle-in-zone-p p sys-zone sys-lim t)))))))))|#(defun macptr<= (p1 p2)  ; (<= (%ptr-to-int p1) (%ptr-to-int p2))  (lap-inline ()    (:variable p1 p2)    (move.l (varg p1) atemp0)    (jsr_subprim $sp-macptrptr)    (move.l (varg p2) atemp0)    (jsr_subprim $sp-macptrptr)    (move.l (varg p1) atemp1)    (move.l nilreg acc)    (if# (cc (cmp.l (svref atemp1 macptr.ptr) atemp0))      (add.l ($ $t_val) acc))))(defun macptr-evenp (p)  ; (evenp (%ptr-to-int p))  (lap-inline ()    (:variable p)    (move.l (varg p) atemp0)    (jsr_subprim $sp-macptrptr)    (move.l nilreg acc)    (move.l atemp0 da)    (btst ($ 0) da)    (if# eq (add.l ($ $t_val) acc))))#| ; This doesn't work yet. Don't know quite why.; This is quite a bit slower than the LAP version above, but it's not; called very often and the LAP version above doesn't work on the; new PowerPC ROM.; This doesn't quite work yet. I don't know why - Bill(defun new-handlep (p)  (and (macptrp p)       (macptr-evenp p)       (flet ((%ptr-in-zone-p (p zone lim)                (declare (type macptr p zone lim))                (and (macptr<= zone p) (macptr<= p lim))))         (declare (inline %ptr-in-zone-p))         (flet ((%handle-in-zone-p (p zone lim sys-p)                  (declare (type macptr p zone lim))                  (with-macptrs ((ptr (%get-ptr p)))                    (and (macptr-evenp ptr)                         (%ptr-in-zone-p ptr zone lim)                         (if sys-p                           (eql p (%setf-macptr ptr (#_RecoverHandle :sys ptr)))                           (eql p (%setf-macptr ptr (#_RecoverHandle ptr))))))))           (declare (inline %handle-in-zone-p))           (with-macptrs ((app-zone (#_ApplicZone))                          (app-lim (pref app-zone :zone.bkLim)))             (if (%ptr-in-zone-p p app-zone app-lim)               (%handle-in-zone-p p app-zone app-lim nil)               (with-macptrs ((sys-zone (#_SystemZone))                              (sys-lim (pref sys-zone :zone.bkLim)))                 (and (%ptr-in-zone-p p sys-zone sys-lim)                      (%handle-in-zone-p p sys-zone sys-lim t)))))))))|#(defun null-or-handlep (arg)  (and (macptrp arg)       (or (%null-ptr-p arg)           (handlep arg))))(defun require-null-or-handlep (arg)  (if (null-or-handlep arg)    arg    (require-type arg '(satisfies null-or-handlep))));Must come before any macro defns.(defun %macro-have (symbol macro-function)  (%fhave symbol           (cons #.(logior (lsh #x4ead 13) (logand #x1fff (lsh $sp-apply-macro -3)))                 macro-function)))  ; Gak!(%fhave 'set-macro-function #'%macro-have)   ; redefined in sysutils.; Define special forms.(dolist (sym '(block catch compiler-let declare eval-when               flet function go if labels let let* macrolet               multiple-value-call multiple-value-prog1               progn progv quote return-from setq tagbody               the throw unwind-protect locally load-time-value; These are implementation-specific special forms :	       nfunction without-interrupts               macro-bind debind symbol-macrolet lap lap-inline               old-lap old-lap-inline new-lap %vreflet %primitive               fbind new-lap-inline))  (%macro-have sym sym))(defun special-form-p (symbol)   "CL. Given a symbol returns non-nil if the symbol defines one of the forms   designated special by CLtL or by this implementation.   The non-nil value returned is not functionp."  (let ((def (fboundp symbol)))    (and (consp def)         (not (lfunp (cdr def))))))(locally (declare (special *fred-special-indent-alist*))   (setq *fred-special-indent-alist* nil))  (defun %macro (named-fn &optional doc &aux body-pos arglist)  ; "doc" is either a string or a list of the form :  ; (doc-string-or-nil . (body-pos-or-nil . arglist-or-nil))  (if (listp doc)    (setq body-pos (cadr doc)          arglist (cddr doc)          doc (car doc)))  (let* ((name (function-name named-fn)))    (record-source-file name 'function)    (set-macro-function name named-fn)    (when (and doc *save-doc-strings*)      (set-documentation name 'function doc))    (when body-pos      (setf (assq name *fred-special-indent-alist*) body-pos))    (when arglist      (record-arglist name arglist))    (when *fasload-print* (format t "~&~S~%" name))    name))(defun %sym-value (sym)  (old-lap-inline ()   (move.l arg_z atemp0)   (jsr_subprim $sp-check-sym)   (btst ($ $sym_bit_indirect) (atemp0 $sym.vbits))   (add.w ($ $sym.gvalue) atemp0)   (if# ne (move.l @atemp0 atemp0))   (move.l @atemp0 acc)))                              ; not moved to "ccl:level-0;l0-symbol.lisp"(defun boundp (sym)  (not (eq (%sym-value sym) (%unbound-marker-8)))) ; undefinedp(defun symbol-value (sym)  (old-lap-inline ()   (move.l arg_z atemp0)   (jsr_subprim $sp-check-sym)   (jsr_subprim $sp-symeval)))(defun set (sym val)  (old-lap-inline ()   (move.l arg_y atemp0)   (jsr_subprim $sp-check-sym)   (jsr_subprim $sp-setqsym)))(defun %defvar (var &optional doc)  "Returns boundp"  (%proclaim-special var)  (record-source-file var 'variable)  (cond ((not (boundp var))         (when (and doc *save-doc-strings*)           (set-documentation var 'variable doc))         (when *fasload-print* (format t "~&~S~%" var))         nil)        (t t)))(defun %defparameter (var value &optional doc)  (%proclaim-special var)  (record-source-file var 'variable)  (when (and doc *save-doc-strings*)    (set-documentation var 'variable doc))  (when *fasload-print* (format t "~&~S~%" var))  (set var value)  var)(defun %defglobal (var value &optional doc)  (%symbol-bits var (logior (ash 1 $sym_vbit_global) (the fixnum (%symbol-bits var))))  (%defparameter var value doc));Needed early for member etc.(defun eq (x y) (eq x y))(defun eql (x y) (eql x y))(defun identity (x) x)(%fhave 'find-unencapsulated-definition #'identity); If passed a symbol, will return symbol-function, NOT entry point.(defun coerce-to-function (arg)  (if (functionp arg)    arg    (if (symbolp arg)      (lap-inline (arg)        (move.l arg_z atemp0)        (jsr_subprim $sp-%function)        (move.l atemp0 acc))      (report-bad-arg arg 'function)))); takes arguments in arg_x, arg_y, arg_z, returns "multiple values" in those; registers as well.  Test(-not) arguments are NOT validated beyond what is done; here.; if both :test and :test-not supplied, signal error.; if test provided as #'eq or 'eq, return first value 'eq.; if test defaulted, provided as 'eql, or provided as #'eql, return first value 'eql.; if test-not provided as 'eql or provided as #'eql, return second value 'eql.; if key provided as either 'identity or #'identity, return third value nil.(defun %%keyconflict (&lap test-fn test-not-fn key)  (old-lap-inline ()   (defreg test-fn arg_x)   (defreg test-not-fn arg_y)   (defreg key arg_z)   (defreg eqfunc da)   (defreg eqlfunc db)   (move.l 'eq atemp0)   (btst ($ $sym_bit_indirect) (atemp0 $sym.fbits))   (add.w ($ $sym.entrypt) atemp0)   (if# ne     (move.l @atemp0 atemp0)     (add.w ($ 2) atemp0))   (move.l @atemp0 eqfunc)   (move.l 'eql atemp0)   (btst ($ $sym_bit_indirect) (atemp0 $sym.fbits))   (add.w ($ $sym.entrypt) atemp0)   (if# ne     (move.l @atemp0 atemp0)     (add.w ($ 2) atemp0))   (move.l @atemp0 eqlfunc)   (if# (and (ne nilreg test-fn)             (ne nilreg test-not-fn))     (tsignal_error (fixnum $xkeyconflict) ':test test-fn ':test-not test-not-fn))   (if# (and (eq nilreg test-fn)             (eq nilreg test-not-fn))     (move.l 'eql test-fn)     else#     (if# (ne nilreg test-fn)       (move.l 'eq atemp1)       (if# (and (ne test-fn atemp1)                 (eq eqfunc test-fn))         (move.l atemp1 test-fn)         else#         (move.l 'eql atemp1)         (if# (and (ne test-fn atemp1)                   (eq eqlfunc test-fn))           (move.l atemp1 test-fn)))       else#       (move.l 'eql atemp1)       (if# (and (ne test-not-fn atemp1)                 (eq eqlfunc test-not-fn))         (move.l atemp1 test-not-fn))))   (move.l 'identity atemp1)   (btst ($ $sym_bit_indirect) (atemp1 $sym.fbits))   (lea (atemp1 $sym.entrypt) atemp0)   (if# ne     (move.l @atemp0 atemp0)     (add.w ($ 2) atemp0))   (if# (or (eq atemp1 key)            (eq @atemp0 key))     (move.l nilreg key))));;; Assoc.; (asseql item list) <=> (assoc item list :test #'eql :key #'identity)(defun asseql (item list)  (declare (%noforcestk))  (old-lap-inline ()   (if# (eq (dtagp arg_y $t_dfloat $t_vector))     (add.l ($ 4) sp)     (jmp_subprim $sp-assq))   (with-preserved-registers #(asave0 asave1 dsave0 dsave1)     (defreg item dsave0)     (defreg list asave0)     (defreg pair asave1)     (defreg timer dsave1)     (move.l arg_y item)     (move.l arg_z list)     (move.l nilreg pair)     (move.l '0 timer)     (bra @test)     (prog#         (car list pair)      (cdr list list)      (if# (ne pair nilreg)  ; mildly controversial all of a sudden.        (if# (ne (ttagp ($ $t_cons) pair da))          (wtaerr pair 'list))        (car pair arg_z)        (move.l item arg_y)        (jsr_subprim $sp-eql-pred)        (beq (exit#)))      (if# (eq (sub.w '1 timer))        (jsr_subprim $eventch_jmp)        (move.l '0 timer))@test      (move.l list arg_z)      (jsr_subprim $sp-endp)      (bne (top#))      (move.l nilreg pair))     (move.l pair acc)))); (assoc-test item list test-fn) ;   <=> ;     (assoc item list :test test-fn :key #'identity); test-fn may not be FUNCTIONP, so we coerce it here.(defun assoc-test (item list test-fn)  (%assoc-test    item    list    (the compiled-function (coerce-to-function test-fn)))); In this case, we "know" that test-fn is jsr-able.  We're dangerous.(defun %assoc-test (item list test-fn)  (declare (%noforcestk))  (old-lap-inline ()   (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)   (defreg item dsave0)   (defreg list asave0)   (defreg pair asave1)   (defreg test-fn dsave1)   (defreg timer dsave2)   (move.l arg_x item)   (move.l arg_y list)   (move.l arg_z test-fn)   (move.l '0 timer)   (bra @test)   (prog#    (car list pair)    (cdr list list)    (if# (ne pair nilreg)      (if# (ne (ttagp ($ $t_cons) pair da))        (wtaerr pair 'list))      (car pair arg_z)      (move.l item arg_y)      (move.l test-fn atemp0)      (set_nargs 2)      (jsr @atemp0)      (bif (ne acc nilreg) (exit#)))    (if# (eq (sub.w '1 timer))      (jsr_subprim $eventch_jmp)      (move.l '0 timer))@test    (move.l list arg_z)    (jsr_subprim $sp-endp)    (bne (top#))    (move.l nilreg pair))   (move.l pair acc)))); (assoc-test-not item list test-not-fn) ;   <=> ;     (assoc item list :test-not test-not-fn :key #'identity); test-not-fn may not be FUNCTIONP, so we coerce it here.(defun assoc-test-not (item list test-not-fn)  (%assoc-test-not   item    list    (the compiled-function (coerce-to-function test-not-fn)))); In this case, we "know" that test-not-fn is jsr-able.  We're dangerous.(defun %assoc-test-not (item list test-not-fn)  (declare (%noforcestk))  (old-lap-inline ()   (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)     (defreg item dsave0)     (defreg list asave0)     (defreg pair asave1)     (defreg test-not-fn dsave1)     (defreg timer dsave2)     (move.l arg_x item)     (move.l arg_y list)     (move.l arg_z test-not-fn)     (move.l '0 timer)     (bra @test)     (prog#      (car list pair)      (if# (ne pair nilreg)        (if# (ne (ttagp ($ $t_cons) pair da))          (wtaerr pair 'list))        (car pair arg_z)        (move.l item arg_y)        (move.l test-not-fn atemp0)        (set_nargs 2)        (jsr @atemp0)        (bif (eq acc nilreg) (exit#)))      (cdr list list)      (if# (eq (sub.w '1 timer))        (jsr_subprim $eventch_jmp)        (move.l '0 timer))      @test      (move.l list arg_z)      (jsr_subprim $sp-endp)      (bne (top#))      (move.l nilreg pair))     (move.l pair acc))))(defun assoc (item list &key test test-not key)  (old-lap   (ccall %%keyconflict (varg test) (varg test-not) (varg key))   (defreg key-p arg_z)   (defreg test-p arg_x)   (defreg test-not-p arg_y)   (move.l (varg item) da)   (move.l (varg list) db)   (if# (eq nilreg key-p)     (lfunlk)     (move.l 'eq atemp1)     (if# (eq test-p atemp1)       (move.l da arg_y)       (move.l db arg_z)       (jmp_subprim $sp-assq))     (move.l 'eql atemp1)     (if# (eq test-p atemp1)       (cjmp asseql da db))     (if# (ne nilreg test-p)       (cjmp assoc-test da db test-p))     (cjmp assoc-test-not da db test-not-p))   (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)     (defreg list asave0)     (defreg item dsave0)     (defreg test dsave1)     (defreg test-not dsave2)     (defreg key asave1)     (move.l da item)     (move.l db list)     (move.l test-p test)     (move.l test-not-p test-not)     (ccall coerce-to-function key-p)     (move.l acc key)     (if# (ne test nilreg)       (ccall coerce-to-function test)       (move.l acc test)       (defreg pair test-not)       (pea (@w 1))       (bra @test)       (prog#        (car list pair)        (cdr list list)        (if# (ne nilreg pair)          (if# (ne (ttagp ($ $t_cons) list da))            (wtaerr pair 'list))          (move.l pair atemp0)          (car atemp0 arg_z)          (set_nargs 1)          (jsr @key)          (move.l item arg_y)          (movereg acc arg_z)          (move.l test atemp0)          (set_nargs 2)          (jsr @atemp0)          (bif (ne nilreg acc) (exit#)))        (if# (eq (sub.w '1 @sp))          (jsr_subprim $eventch_jmp))        @test        (move.l list arg_z)        (jsr_subprim $sp-endp)        (bne (top#))        (move.l nilreg pair))       (move.l pair acc)       (add.w ($ 4) sp)       (unuse_regs)       (lfret))     (ccall coerce-to-function test-not)     (move.l acc test-not)     (defreg pair test)     (pea (@w 1))     (bra @test-not)     (prog#      (car list pair)      (cdr list list)      (if# (ne nilreg pair)        (if# (ne (ttagp ($ $t_cons) list da))          (wtaerr pair 'list))        (move.l pair atemp0)        (car atemp0 arg_z)        (set_nargs 1)        (jsr @key)        (move.l item arg_y)        (movereg acc arg_z)        (move.l test-not atemp0)        (set_nargs 2)        (jsr @atemp0)        (bif (eq nilreg acc) (exit#)))      (if# (eq (sub.w ($ 1) @sp))        (jsr_subprim $eventch_jmp))      @test-not      (move.l list acc)      (jsr_subprim $sp-endp)      (bne (top#))      (move.l nilreg pair))     (move.l pair acc))   (add.w ($ 4) sp)   (lfret)));;;; Member.; (memeql item list) <=> (member item list :test #'eql :key #'identity)(defun memeql (item list)  (declare (%noforcestk))  (old-lap-inline ()    (if# (eq (dtagp arg_y $t_dfloat $t_vector))      (add.l ($ 4) sp)      (jmp_subprim $sp-memq))    (with-preserved-registers #(asave0 dsave0 dsave1)      (defreg item dsave0)      (defreg list asave0)      (defreg timer dsave1)      (move.l arg_y item)      (move.l arg_z list)      (move.l '0 timer)      (bra @test)      (prog#       (car list arg_y)       (move.l item arg_z)       (jsr_subprim $sp-eql-pred)       (beq (exit#))       (cdr list list)       (if# (eq (sub.w '1 timer))         (jsr_subprim $eventch_jmp)         (move.l '0 timer))@test       (move.l list acc)       (jsr_subprim $sp-endp)       (bne (top#)))      (move.l list acc)))); (member-test item list test-fn) ;   <=> ;     (member item list :test test-fn :key #'identity); test-fn may not be FUNCTIONP, so we coerce it here.(defun member-test (item list test-fn)  (%member-test    item    list    (the compiled-function (coerce-to-function test-fn)))); In this case, we "know" that test-fn is jsr-able.  We're dangerous.(defun %member-test (item list test-fn)  (declare (%noforcestk))  (declare (compiled-function test-fn))  (old-lap-inline ()    (with-preserved-registers #(asave0 asave1 dsave0 dsave1)      (defreg item dsave0)      (defreg list asave0)      (defreg test-fn asave1)      (defreg timer dsave1)      (move.l arg_x item)      (move.l arg_y list)      (move.l arg_z test-fn)      (move.l '0 timer)      (bra @test)      (prog#       (move.l item arg_y)       (car list arg_z)       (set_nargs 2)       (jsr @test-fn)       (bif (ne nilreg acc) (exit#))       ; "It is an error for the :TEST function to have any side effects."       (cdr list list)       (if# (eq (sub.w '1 timer))         (jsr_subprim $eventch_jmp)         (move.l '0 timer))       @test       (move.l list acc)       (jsr_subprim $sp-endp)       (bne (top#)))      (move.l list acc)))); (member-test-not item list test-not-fn) ;   <=> ;     (member item list :test-not test-not-fn :key #'identity); test-not-fn may not be FUNCTIONP, so we coerce it here.(defun member-test-not (item list test-not-fn)  (%member-test-not   item    list    (the compiled-function (coerce-to-function test-not-fn)))); In this case, we "know" that test-not-fn is jsr-able.  We're dangerous.(defun %member-test-not (item list test-not-fn)  (declare (%noforcestk))  (declare (compiled-function test-not-fn))  (old-lap-inline ()    (with-preserved-registers #(asave0 asave1 dsave0 dsave1)      (defreg item dsave0)      (defreg list asave0)      (defreg test-not-fn asave1)      (defreg timer dsave1)      (move.l arg_x item)      (move.l arg_y list)      (move.l arg_z test-not-fn)      (move.l '0 timer)      (bra @test)      (prog#       (move.l item arg_y)       (car list arg_z)       (set_nargs 2)       (jsr @test-not-fn)       (bif (eq nilreg acc) (exit#))       ; "It is an error for the :TEST-NOT function to have (just had) any side effects."       (cdr list list)       (if# (eq (sub.w '1 timer))         (jsr_subprim $eventch_jmp)         (move.l '0 timer))       @test       (move.l list acc)       (jsr_subprim $sp-endp)       (bne (top#)))      (move.l list acc))))(defun member (item list &key test test-not key)  (old-lap   (ccall %%keyconflict (varg test) (varg test-not) (varg key))   (defreg key-p arg_z)   (defreg test-p arg_x)   (defreg test-not-p arg_y)   (move.l (varg item) da)   (move.l (varg list) db)   (if# (eq nilreg key-p)     (lfunlk)     (move.l 'eq atemp1)     (if# (eq test-p atemp1)       (move.l da arg_y)       (move.l db arg_z)       (jmp_subprim $sp-memq))     (move.l 'eql atemp1)     (if# (eq test-p atemp1)       (cjmp memeql da db))     (if# (ne nilreg test-p)       (cjmp member-test da db test-p))     (cjmp member-test-not da db test-not-p))     (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)     (defreg list asave0)     (defreg item dsave0)     (defreg test dsave1)     (defreg test-not dsave2)     (defreg key asave1)     (move.l da item)     (move.l db list)     (move.l test-p test)     (move.l test-not-p test-not)     (ccall coerce-to-function key-p)     (move.l acc key)     (if# (ne test nilreg)       (ccall coerce-to-function test)       (move.l acc test)       (defreg timer test-not)       (move.l '0 timer)       (bra @test)       (prog#        (car list arg_z)        (set_nargs 1)        (jsr @key)        (move.l item arg_y)        (movereg acc arg_z)        (move.l test atemp0)        (set_nargs 2)        (jsr @atemp0)        (bif (ne nilreg acc) (exit#))        (cdr list list)        (if# (eq (sub.w '1 timer))          (jsr_subprim $eventch_jmp)          (move.l '0 timer))@test        (move.l list acc)        (jsr_subprim $sp-endp)        (bne (top#)))       (move.l list acc)       (unuse_regs)       (lfret))     (ccall coerce-to-function test-not)     (move.l acc test-not)     (defreg timer test)     (move.l '0 timer)     (bra @test-not)     (prog#      (car list arg_z)      (set_nargs 1)      (jsr @key)      (move.l item arg_y)      (movereg acc arg_z)      (move.l test-not atemp0)      (set_nargs 2)      (jsr @atemp0)      (bif (eq nilreg acc) (exit#))      (cdr list list)      (if# (eq (sub.w '1 timer))        (jsr_subprim $eventch_jmp)        (move.l '0 timer))@test-not      (move.l list acc)      (jsr_subprim $sp-endp)      (bne (top#)))     (move.l list acc))     (lfret)))(defun adjoin (item list &key test test-not key)  (lap-inline ()    (:variable item list test test-not key)    (ccall %%keyconflict (varg test) (varg test-not) (varg key))    (defreg key-p arg_z)    (defreg test-p arg_x)    (defreg test-not-p arg_y)    (move.l (varg item) da)    (move.l (varg list) db)    (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)      (defreg item dsave0)      (defreg list asave0)      (defreg key asave1)      (defreg test dsave1)      (defreg test-not dsave2)      (move.l da item)      (move.l db list)      (move.l test-p test)      (move.l test-not-p test-not)      (move.l key-p key)      (if# (eq nilreg key)        (vpush item)        (move.l list arg_x)        (if# (eq nilreg test-not)          (move.l ':test arg_y)          (move.l test arg_z)          else#          (move.l ':test-not arg_y)          (move.l test-not arg_z))        (set_nargs 4)        else#        (ccall coerce-to-function key)        (move.l acc key)        (move.l item arg_z)        (set_nargs 1)        (jsr @key)        (vpush acc)        (vpush list)        (if# (eq nilreg test-not)          (vpush ':test)          (move.l test arg_x)          else#          (vpush ':test-not)          (move.l test-not arg_x))        (move.l ':key arg_y)        (move.l key arg_z)        (set_nargs 6))      (jsr (function member))      (if# (ne nilreg acc)        (move.l list acc)        else#        (move.l item arg_y)        (move.l list arg_z)        (jsr_subprim $sp-consYZ)))))(defun adjoin-eq (elt list)  (if (memq elt list)    list    (cons elt list)))(defun adjoin-eql (elt list)  (if (memeql elt list)    list    (cons elt list)))(defun union-eq (list1 list2)  (let ((res list2))    (dolist (elt list1)      (unless (memq elt res)        (push elt res)))    res))(defun union-eql (list1 list2)  (let ((res list2))    (dolist (elt list1)      (unless (memeql elt res)        (push elt res)))    res)); Fix this someday.  Fix EQUALP, while you're at it ...(defun similar-as-constants-p (x y)  (if (and (stringp x) (stringp y)) ;The most obvious case where equalp & s-a-c-p need to differ...    (string= x y)    (equalp x y)))(defun define-constant (var value)  (block nil    (if (constant-symbol-p var)      (if (similar-as-constants-p (%sym-value var) value)        (return)        ;This should really be a cell error, allow options other than redefining (such        ; as don't redefine and continue)...        (cerror "Redefine ~S anyway"                "Constant ~S is already defined with a different value"                var)))      (old-lap-inline ()        (move.l (varg var) atemp0)        (jsr_subprim $sp-check-sym)        (or.b ($ (%ilogior (%ilsl $sym_bit_special 1) (%ilsl $sym_bit_const 1)))              (atemp0 $sym.vbits))        (add.w ($ $sym.gvalue) atemp0)        (if# (ne (btst ($ $sym_bit_indirect) (atemp0 (- $sym.vbits $sym.gvalue))))          (move.l (atemp0) atemp0))        (move.l (varg value) (atemp0))))  var)(defun %defconstant (var value &optional doc)   (%proclaim-special var)   (record-source-file var 'constant)   (define-constant var value)   (when (and doc *save-doc-strings*)     (set-documentation var 'variable doc))   (when *fasload-print* (format t "~&~S~%" var))   var)(defparameter *nx1-compiler-special-forms* ())(defparameter *nx-proclaimed-types* ())(defparameter *nx-proclaimed-ftypes* nil)(defun compiler-special-form-p (sym)  (or (eq sym 'quote)      (if (memq sym *nx1-compiler-special-forms*) t)))(defun evaluator-special-form-p (sym)  (declare (ignore sym)) '(get sym 'special-in-evaluator) nil)(defparameter *nx-known-declarations* ())(defparameter *nx-proclaimed-inline* ())(defparameter *nx-proclaimed-ignore* ())(defparameter *nx-globally-inline* ())(defun constant-symbol-p (sym)  (and (symbolp sym)       (%ilogbitp $sym_vbit_const (%symbol-bits sym))))(defconstant *cl-types* '(arrayatombase-character bignumbitbit-vector character#|lisp:common|#compiled-function complex cons                    double-floatextended-characterfixnumfloatfunctionhash-tableintegerkeywordlist long-floatnil nullnumber  packagepathname random-state  ratiorationalreadtablerealsequence short-floatsigned-byte simple-arraysimple-bit-vectorsimple-stringsimple-base-stringsimple-extended-string simple-vector single-floatstandard-charstream  string#|lisp:string-char|#symboltunsigned-byte vector))(defun proclaim (spec)  (case (car spec)    (special (apply #'proclaim-special (%cdr spec)))    (notspecial (apply #'proclaim-notspecial (%cdr spec)))    (optimize (%proclaim-optimize (%cdr spec)))    (inline (apply #'proclaim-inline t (%cdr spec)))    (notinline (apply #'proclaim-inline nil (%cdr spec)))    (declaration (apply #'proclaim-declaration (%cdr spec)))    (ignore (apply #'proclaim-ignore t (%cdr spec)))    (unignore (apply #'proclaim-ignore nil (%cdr spec)))    (type (apply #'proclaim-type (%cdr spec)))    (ftype (apply #'proclaim-ftype (%cdr spec)))    ;(function (proclaim-ftype (cons 'function (cddr spec)) (cadr spec)))    (t (unless (memq (%car spec) *nx-known-declarations*) ;not really right...         (if (memq (%car spec) *cl-types*)           (apply #'proclaim-type spec)           (warn "Unknown declaration specifier(s) in ~S" spec))))))(defun proclaim-type (type &rest vars)  (declare (dynamic-extent vars))  (dolist (var vars)    (if (symbolp var)      (let ((spec (assq var *nx-proclaimed-types*)))        (if spec          (rplacd spec type)          (push (cons var type) *nx-proclaimed-types*)))      (warn "Invalid type declaration for ~S" var))))#| redefined from nfcomp(defun proclaim-ftype (type &rest names)  (declare (ignore type names))  ;remember to accept (setf name)'s when implement this.  nil)|#(defun proclaim-ftype (ftype &rest names)  (declare (dynamic-extent names))  (unless *nx-proclaimed-ftypes*    (setq *nx-proclaimed-ftypes* (make-hash-table :test #'eq)))  (dolist (name names)    (setf (gethash (ensure-valid-function-name name) *nx-proclaimed-ftypes*) ftype)))(defun proclaimed-ftype (name)  (when *nx-proclaimed-ftypes*    (gethash (ensure-valid-function-name name) *nx-proclaimed-ftypes*)))(defun proclaim-special (&rest vars)  (declare (dynamic-extent vars))  (dolist (sym vars) (%proclaim-special sym)))(defun proclaim-notspecial (&rest vars)  (declare (dynamic-extent vars))  (dolist (sym vars) (%proclaim-notspecial sym)))(defun proclaim-inline (t-or-nil &rest names)  (declare (dynamic-extent names))  ;This is just to make it more likely to detect forgetting about the first arg...  (unless (or (eq nil t-or-nil) (eq t t-or-nil)) (report-bad-arg t-or-nil '(member t nil)))  (dolist (name names)    (setq name (ensure-valid-function-name name))    (if (listp *nx-proclaimed-inline*)      (setq *nx-proclaimed-inline*          (alist-adjoin name                        (or t-or-nil (if (compiler-special-form-p name) t))                        *nx-proclaimed-inline*))            (setf (gethash name *nx-proclaimed-inline*)            (or t-or-nil (if (compiler-special-form-p name) t))))))(defun proclaim-declaration (&rest syms)  (declare (dynamic-extent syms))  (dolist (sym syms)    (setq *nx-known-declarations*           (adjoin sym *nx-known-declarations* :test 'eq))))(defun proclaim-ignore (t-or-nil &rest syms)  (declare (dynamic-extent syms))  ;This is just to make it more likely to detect forgetting about the first arg...  (unless (or (eq nil t-or-nil) (eq t t-or-nil)) (report-bad-arg t-or-nil '(member t nil)))  (dolist (sym syms)    (setq *nx-proclaimed-ignore*          (alist-adjoin sym t-or-nil *nx-proclaimed-ignore*))))(queue-fixup (when (listp *nx-proclaimed-inline*)  (let ((table (make-hash-table :size 100 :test #'eq)))    (dolist (x *nx-proclaimed-inline*)      (let ((name (car x)) (value (cdr x)))        (when (symbolp name)          (setf (gethash name table) value))))    (setq *nx-proclaimed-inline* table))))(defun %proclaim-notspecial (sym)  (old-lap-inline ()    (move.l acc atemp0)    (jsr_subprim $sp-check-sym)    (bclr ($ $sym_bit_special) (atemp0 $sym.vbits))))(defun proclaimed-special-p (sym)  (%ilogbitp $sym_vbit_special (%symbol-bits sym)))(defun proclaimed-inline-p (sym)  (if (listp *nx-proclaimed-inline*)    (%cdr (assq sym *nx-proclaimed-inline*))    (gethash sym *nx-proclaimed-inline*)))(defun proclaimed-notinline-p (sym)  (if (listp *nx-proclaimed-inline*)    (and (setq sym (assq sym *nx-proclaimed-inline*))         (null (%cdr sym)))    (null (gethash sym *nx-proclaimed-inline* t))))(defun self-evaluating-p (form);   (or (numberp form);       (characterp form);       (null form);       (eq form t);       (keywordp form);       (arrayp form) ; making the following redundant;       ;(stringp form);       ;(bit-vector-p form);       )  (and (atom form)       (or (not (non-nil-symbol-p form))           (eq form t)           (keywordp form)))  )(defun constantp (form)   (or (self-evaluating-p form)       (quoted-form-p form)       (constant-symbol-p form)))(defun eval-constant (form)  (if (quoted-form-p form) (%cadr form)      (if (constant-symbol-p form) (symbol-value form)          (if (self-evaluating-p form) form              (report-bad-arg form '(satsifies constantp)))))); SETQ'd above before we could DEFVAR.(defvar *fred-special-indent-alist*); avoid hanging onto beezillions of pathnames(defvar *last-back-translated-name* nil)(defvar *default-character-type* 'base-character)  ; god help you if you change this(defvar %lambda-lists% ())(%fhave 'record-arglist        (qlfun bootstrapping-record-arglist (name args)          "only used by defmacro"          ; Bootstrapping: always save macro arglists, nuke-em before saving released image.            (let ((pair (assq name %lambda-lists%)))              (if pair                (rplacd pair args)                (push (cons name args) %lambda-lists%))              args)));Support the simple case of defsetf.(%fhave 'store-setf-method        (qlfun bootstrapping-store-setf-method (name fn &optional doc)          (declare (ignore doc))          (put name 'bootstrapping-setf-method (require-type fn 'symbol))))(%fhave '%setf-method        (qlfun bootstrapping-%setf-method (name)          (get name 'bootstrapping-setf-method)))(%fhave 'symbolp #'(lambda (x) (symbolp x)))(%fhave 'function-spec-p #'symbolp)     ; redefined later;;; Lisp Development System/Application Module Loading(defvar *lds* t  "True to load all Lisp Development System modules")(defvar *app-optional-modules* nil  "Optional modules to load into application and keys to control contents")(defvar *app-modules* nil  "Custom modules to load into application")#| *app-modules* keys::unbind-macros:unintern-macros:unbind-constants:unintern-constants:clear-vars|#; (lds <lds-form>); (lds <lds-form> <else-form> ...); (lds <lds-form> :module <module(s)>); (lds <lds-form> :module <module(s)> <else-form> ...)(defmacro lds (form &rest base-forms &aux modules)  (when (eq (first base-forms) :module)    (setq modules (second base-forms)          base-forms (cddr base-forms)))  `(if ,(if (null modules)          '*lds*          `(or *lds* (,(if (listp modules) 'intersection 'memq)                      ',modules *app-modules*)))     ,form     ,@(if base-forms `((progn ,@base-forms)))))(defun lds-key-aux (test keys forms)  `(,test (,(if (listp keys) 'intersection 'memq)           ',keys *app-modules*)          ,@forms))(defmacro lds-key (keys &rest forms)  (lds-key-aux 'when keys forms))(defmacro lds-not-key (keys &rest forms)  (lds-key-aux 'unless keys forms))#| tests(lds (print "included"))(lds (print "included")     (print "other") (print "another"))(lds (print "included") :module :eval)(lds (print "included") :module :eval     (print "other") (print "another"))(lds (print "included") :module (:eval :compiler))(lds (print "included") :module (:eval :compiler)     (print "other") (print "another"))(setq *lds* nil)(setq *lds* t)(setq *app-modules* nil)(setq *app-modules* '(:eval))(setq *app-modules* '(:compiler))(lds-key :uno (foo))(lds-key :uno (foo)(bar))(lds-key (:uno :dos) (foo))(lds-key (:uno :dos) (foo) (bar))(lds-not-key :uno (foo))(lds-not-key :uno (foo) (bar))(lds-not-key (:uno :dos) (foo))(lds-not-key (:uno :dos) (foo) (bar))|#; defmacro uses (setf (assq ...) ...) for &body forms.(defun adjoin-assq (indicator alist value)  (let ((cell (assq indicator alist)))    (if cell       (setf (cdr cell) value)      (push (cons indicator value) alist)))  alist)(defmacro setf-assq (indicator place value)  (let ((res (gensym)))    `(let (,res)       (setf ,place (adjoin-assq ,indicator ,place (setq ,res ,value)))       ,res)))(defsetf assq setf-assq)(defun quoted-form-p (form)   (and (consp form)        (eq (%car form) 'quote)        (consp (%cdr form))        (null (%cdr (%cdr form)))))(defun lambda-expression-p (form)  (and (consp form)       (eq (%car form) 'lambda)       (consp (%cdr form))       (listp (%cadr form))));;;;;FUNCTION BINDING Functions; A symbol's entrypoint contains:;  1) something tagged as $t_lfun if the symbol is;     not fbound as a macro or special form;;  2) a cons, otherwise, where the cdr is a fixnum;     whose value happens to be the same bit-pattern;     as a "jsr_subprim $sp-apply-macro" instruction.;     The car of this cons is either:;     a) a function -> macro-function;;     b) a symbol: special form not redefined as a macro.;     c) a cons whose car is a function -> macro function defined;        on a special form.(defun macro-function (form &optional env)  (setq form (require-type form 'symbol))  (when env    ; A definition-environment isn't a lexical environment, but it can    ; be an ancestor of one.    (unless (istruct-typep env 'lexical-environment)      (report-bad-arg env 'lexical-environment))    (let ((cell nil))      (tagbody        top        (if (setq cell (%cdr (assq form (lexenv.functions env))))          (return-from macro-function                        (if (eq (car cell) 'macro) (%cdr cell))))        (unless (listp (setq env (lexenv.parent-env env)))          (go top)))))      ; Not found in env, look in function cell.  (old-lap-inline (form)    (move.l arg_z atemp0)    (if# (eq nilreg atemp0)	(lea (atemp0 $nil_val) atemp0))    (move.l nilreg acc)      (btst ($ $sym_bit_indirect) (atemp0 $sym.fbits))          ; In case we ever have indirect macros ...      (move.l (atemp0 $sym.entrypt) atemp0)      (if# ne (move.l (atemp0 2) atemp0))      (if# (eq (ttagp ($ $t_cons) atemp0 da))        (if# (eq ($ #x4ead $sp-apply-macro) (car atemp0))          (cdr atemp0 acc)          (if# (eq (ttagp ($ $t_cons) acc da))            (move.l acc atemp0)            (car atemp0 acc))          (if# (ne (ttagp ($ $t_lfun) acc da))            (move.l nilreg acc))))))(defun symbol-function (name)  "Returns the definition of name, even if it is a macro or a special form.   Errors if name doesn't have a definition."  (or (fboundp name) ;Our fboundp returns the binding      (prog1 (%err-disp $xfunbnd name))))(%fhave 'fdefinition #'symbol-function)(defun kernel-function-p (f)  (declare (ignore f))  nil)(defun %make-function (name fn env)  (let ((compile-it *compile-definitions*))    (when (and compile-it (neq compile-it t))      (setq compile-it (funcall compile-it env)))    (if (not compile-it)      ; bad things will probably occur if env contains unmunched function bindings      ; but enclose says the behavior in that case is "undefined"      (make-evaluated-function name fn env)      (compile-user-function fn name env))))    ;;;;;;;;; VAULE BINDING Functions(defun ensure-simple-string (s)  (old-lap-inline ()   (jsr_subprim $sp-sstrarg))); This leaves the SPECIAL and INDIRECT bits alone, clears the others.(defun makunbound (sym)  (if (and *warn-if-redefine-kernel*           (constant-symbol-p sym))    (cerror "Make ~S be unbound anyway."            "~S is a constant; making it unbound might be a bad idea." sym))             (lap-inline (sym)   (move.l arg_z atemp0)   (jsr_subprim $sp-check-sym)   (and.b ($ #.(logior (%ilsl $sym_bit_indirect 1) (%ilsl $sym_bit_special 1))) (atemp0 $sym.vbits))   (btst ($ $sym_bit_indirect) (atemp0 $sym.vbits))   (add ($ $sym.gvalue) atemp0)   (if# ne (move.l @atemp0 atemp0))   (move.l ($ $undefined) @atemp0)))(defun gensym (&optional string-or-integer)  "Behaves just like Common Lisp. Imagine that."  (let ((prefix "G")        (counter nil))    (if (integerp string-or-integer)      (setq counter string-or-integer) ; & emit-style-warning      (if (stringp string-or-integer)        (setq prefix (ensure-simple-string string-or-integer))        (if string-or-integer ;not string or index or NIL          (report-bad-arg string-or-integer '(or string integer (eql nil))))))    (unless counter      (setq *gensym-counter* (1+ (setq counter *gensym-counter*))))    (make-symbol (%str-cat prefix (%integer-to-string counter)))))(defun make-keyword (name)  (if (and (symbolp name) (eq (symbol-package name) *keyword-package*))    name    (values (intern (string name) *keyword-package*)))); (%gvector subtype &rest args)(defun %gvector (&lap subtype &rest args)  (old-lap   (jmp_subprim $sp-gvector)))(defun vector (&lap &rest args)  (old-lap   (if# (ne (tst.w nargs))     (if# (eq (cmp.w ($ 8) nargs))       (vpush arg_y)       (vpush arg_z)       elseif# mi       (vpush arg_z)       else#       (movem.l #(arg_x arg_y arg_z) -@vsp)))   (jmp_subprim $sp-vector))); destructive, removes first match only(defun remove-from-alist (thing alist) (let ((start alist))  (if (eq thing (%caar alist))   (%cdr alist)   (let* ((prev start)          (this (%cdr prev))          (next (%cdr this)))    (while this     (if (eq thing (%caar this))      (progn       (%rplacd prev next)       (return-from remove-from-alist start))      (setq prev this            this next            next (%cdr next))))    start))));destructive(defun add-to-alist (thing val alist &aux (pair (assq thing alist)))  (if pair    (progn (%rplacd pair thing) alist)    (cons (cons thing val) alist)));non-destructive...(defun alist-adjoin (thing val alist &aux (pair (assq thing alist)))  (if (and pair (eq (%cdr pair) val))    alist    (cons (cons thing val) alist)))(defun %str-assoc (str alist)  (assoc str alist :test #'string-equal)); what if this is the first byte of some 2 byte char in some script?(defvar *pathname-escape-character* #\  "Not CL.  A Coral addition for compatibility between CL spec and the Mac.   The initial value for this variable is the character with ascii number 182,   made by the option-d key, or with the form #\266.   Inspired by mpw's use of this character as escape.")(defun caar (x) (car (car x)))(defun cadr (x) (car (cdr x)))(defun cdar (x) (cdr (car x)))(defun cddr (x) (cdr (cdr x)))(defun caaar (x) (car (car (car x))))(defun caadr (x) (car (car (cdr x))))(defun cadar (x) (car (cdr (car x))))(defun caddr (x) (car (cdr (cdr x))))(defun cdaar (x) (cdr (car (car x))))(defun cdadr (x) (cdr (car (cdr x))))(defun cddar (x) (cdr (cdr (car x))))(defun cdddr (x) (cdr (cdr (cdr x))))(defun cadddr (x) (car (cdr (cdr (cdr x)))))(%fhave 'type-of #'%type-of)(defun handle-locked-p (h)   (%ilogbitp 7 (#_HGetState h)))(defun %global-to-local (port point)  (%stack-block ((pt 4))    (%put-point pt point)    (with-port port      (#_GlobalToLocal pt))    (%get-point pt)))(defun %local-to-global (port point)  (%stack-block ((pt 4))    (%put-point pt point)    (with-port port      (#_LocalToGlobal pt))    (%get-point pt)))(defun cpu-number ()  "Returns the cpu number, ie 68000, 68020, ..."  (+ 68000 (* (%get-byte (%int-to-ptr #x12f)) 10)))(defun pointerp (thing &optional errorp)  (if (and (macptrp thing)           (> (%get-long (%int-to-ptr $BufPtr)) (%ptr-to-int thing)))      t      (if errorp (error "~S is not a pointer" thing) nil)))(defun zone-pointerp (thing &aux (flags-offset #+ppc-target -12 #-ppc-target (if (%ilogbitp 7 (%get-byte (%currentA5) $memflags)) -12 -8)))  (when (pointerp thing)    (with-macptrs ((zone (#_ApplicationZone))                   (zone-end (%get-ptr zone))                   (four (%int-to-ptr 4)))      (and (macptr-evenp thing)           (not (macptr<= thing four))           (with-macptrs ((p (%get-ptr thing -4)))             (cond ((and (macptr<= zone thing) (macptr<= thing zone-end))                    (and (eql zone p)                         (eq #x40 (%ilogand #xc0 (%get-byte thing flags-offset)))))                   ((and (macptr<= (%setf-macptr zone (#_SystemZone)) thing)                         (macptr<= thing (%setf-macptr zone-end (%get-ptr zone))))                    (and (eql zone p)                         (eq #x40 (%ilogand #xc0 (%get-byte thing flags-offset)))))))))))#| ; doesn't work in 24 bit mode(defun handlep (p)  (and (macptrp p)       (macptr-evenp p)       (flet ((%handle-in-zone-p (hdl zone lim)                (declare (type macptr hdl zone lim))                (flet ((%ptr-in-zone-p (p zone lim)                         (declare (type macptr p zone lim))                         (and (macptr<= zone p) (macptr<= p lim))))                  (declare (inline %ptr-in-zone-p))                  (and (%ptr-in-zone-p hdl zone lim)                       (with-macptrs ((mp (%get-ptr hdl)))                         (and (%ptr-in-zone-p mp zone lim)                              (macptr-evenp mp)                              (> 0 (the fixnum (%get-signed-byte mp -12)))                              (eql hdl (%setf-macptr mp (%inc-ptr zone (%get-long mp -4))))))))))         (declare (inline %handle-in-zone-p))         (with-macptrs ((app-zone (#_ApplicationZone))                        (app-lim (pref app-zone :zone.bkLim)))           (or (%handle-in-zone-p p app-zone app-lim)               (with-macptrs ((sys-zone (#_SystemZone))                              (sys-lim (pref sys-zone :zone.bkLim)))                 (%handle-in-zone-p p sys-zone sys-lim)))))))|#; this old one works in 24 bit mode too(defun handlep (thing)  (old-lap-inline ()    (bra @test)      ; Return Z iff acc is a handle in the zone whose header is   ; in atemp1.   @handle-in-zone    (if# (cc atemp1 acc)     andif# (cs (atemp1 $bklim) acc)     (move.l acc atemp0)     (move.l @atemp0 da)     (if# (mi (tst.b (a5 $memflags)))       (move.l ($ -12) db)       else#       (move.l ($ -8) db)       (and.l (@w #$Lo3bytes) da))     (move.l da atemp0)     (if# (and (cc atemp1 atemp0)               (cs (atemp1 $bklim) atemp0)               (eq (btst ($ 0) da))               (mi (tst.b (atemp0 db 0))))       (add.l (atemp0 -4) atemp1)       (if# (eq atemp1 acc)         (rts))))   else#   (move.l ($ 1) da) 		;Clear Z flag, in case eq bkLim(atemp0)   (rts)@test    (if# (eq (ttagp ($ $t_vector) arg_z da))     (move.l arg_z atemp0)     andif# (eq (vsubtypep ($ $v_macptr) atemp0 da))     (move.l (atemp0 $macptr.ptr) acc)     andif# (eq (btst ($ 0) acc))     (move.l (@w $syszone) atemp1)     (bsr @handle-in-zone)     (if# ne       (move.l (@w $applzone) atemp1)       (bsr @handle-in-zone)))   (setpred eq da)))(defun pointer-size (macptr)  (setq macptr (require-type macptr 'macptr))  (cond ((handlep macptr) (#_GetHandleSize  macptr))        ((zone-pointerp macptr) (#_GetPtrSize macptr))        (t nil)))(defun %get-ostype (pointer &optional (offset 0))  (values (make-keyword (%str-from-ptr (%inc-ptr pointer offset) 4))))(defun %hget-ostype (handle &optional (offset 0))  (with-pointers ((p handle offset))    (%get-ostype p 0)))     (defun %put-ostype (pointer str &optional (offset 0))  (setq str (string str))  (%put-byte pointer (%char-code (char str 0)) offset)  (%put-byte pointer (%char-code (char str 1)) (%i+ offset 1))  (%put-byte pointer (%char-code (char str 2)) (%i+ offset 2))  (%put-byte pointer (%char-code (char str 3)) (%i+ offset 3)))(defun %set-ostype (pointer offset &optional (str (prog1 offset                                                   (setq offset 0))))  (%put-ostype pointer str offset)  str)(defsetf %get-ostype %set-ostype)(defun %hset-ostype (handle offset &optional (str (prog1 offset                                                   (setq offset 0))))  (with-pointers ((p handle offset))    (%put-ostype p str 0)))(defsetf %hget-ostype %hset-ostype)(defun %hput-ostype (handle val &optional (offset 0))  (%hset-ostype handle offset val)  nil)(defun %ostype-ptr (str)  (%stack-block ((type 4))    (%put-ostype type str)    (%get-ptr type)))(defun dtagp (thing mask)  (lap-inline ()    (:variable thing mask)    (getint arg_z)    (btst arg_y arg_z)    (setpred ne da)));from  pointer to new string - perhaps he should have a script arg(defun %get-string (pointer &optional (offset 0) script)  (with-pointers ((p pointer offset))  ;Can be a handle...    (%str-from-ptr-in-script (%incf-ptr p 1)(%get-byte p -1) script))); from ccl4 version(defun ostype-p (x)  (or (integerp x)      (and (stringp x)           (eql 4 (length x))           (or (eq 'base-character (array-element-type x))               (dotimes (i 4 t)                 (unless (< (the fixnum (char-code (char x i))) 256)                   (return nil)))))      (and (symbolp x)           (ostype-p (symbol-name x)))))(defun getindstring (resourceID index &optional script)  (declare (fixnum resourceID index))  (let* ((strH (#_GetResource "STR#" resourceID)))    (declare (dynamic-extent strH))    (unless (or (ccl:%null-ptr-p strH) (<= index 0))      (without-interrupts       (#_LoadResource strH)       (let* ((offset 2)              (nstrings (ccl::%hget-unsigned-word strH 0)))         (declare (fixnum offset nstrings))         (unless (> index nstrings)           (dotimes (i (the fixnum (1- index))       ; index is "1-origin".                       (ccl::%str-from-ptr-in-script                        (%inc-ptr (%get-ptr strH) (the fixnum (1+ offset)))                        (ccl::%hget-unsigned-byte strH offset)                        script))             (declare (fixnum i))             (setq offset (+ offset 1 (ccl::%hget-unsigned-byte strH offset))))))))))(defun %get-cstring (pointer &optional (offset 0) (end offset))  (with-pointers ((p pointer))    (loop (if (%izerop (%get-byte p end))            (return)            (setq end (%i+ end 1))))    (%str-from-ptr-in-script (%incf-ptr p offset) (%i- end offset))))(defun %put-rect (pointer top left bot right &optional (offset 0))  (%put-word pointer top offset)  (%put-word pointer left (%i+ offset 2))  (%put-word pointer bot (%i+ offset 4))  (%put-word pointer right (%i+ offset 6)));Add an item to a dialog items list handle.(defun %rsc-string (n)  (with-macptrs (strh)    (%setf-macptr strh (#_GetString n))    (if (and (not (%null-ptr-p strh)) (not (%null-ptr-p (%get-ptr strh))))      (%get-string strh)      (%str-cat "Error #" (%integer-to-string n)))))(defun string-arg (arg) (or (string-argp arg) (error "~S is not a string" arg)))(defun string-argp (arg) (if (symbolp arg) (symbol-name arg)   (if (stringp arg) (ensure-simple-string arg)     nil)))(defun symbol-arg (arg)  (unless (symbolp arg)    (report-bad-arg arg 'symbol))  arg)(defun %strip-address (ptr)  (old-lap-inline ()   (move.l arg_z atemp0)   (jsr_subprim $sp-macptrptr)         ; typecheck   ;(tst.b (a5 $old-mac-and-old-system-p))   (exg atemp0 arg_z)   ;(jsr_subprim $sp-rtrap)            ; Not with a straight face, I can't   (dc.w #_StripAddress)   (move.l acc (svref atemp0 macptr.ptr))   (move.l atemp0 acc)));Sets locked-ptr and returns original if needs to be unlocked.  For use;in with-pointer.(defun %thing-pointer (pointer offset locked-ptr)  (if (macptrp pointer)    (let ((unlock-ptr nil))      (if (handlep pointer)        (progn          (unless (handle-locked-p pointer)            (setq unlock-ptr pointer)            (#_HLock :errchk pointer))          (%setf-macptr locked-ptr (%get-ptr pointer))          (%strip-address locked-ptr))        (%setf-macptr locked-ptr pointer))      (%incf-ptr locked-ptr offset)      unlock-ptr)    (report-bad-arg pointer '(satisfies macptrp)))); Sets locked-ptr and returns original if it needs to be unlocked.; For use in with-dereferenced-handles(defun %dereference-handle (handle offset locked-ptr)  (unless (macptrp handle)    (report-bad-arg handle 'macptr))  (let ((unlock-handle nil))    (unless (handle-locked-p handle)      (setq unlock-handle handle)      (#_HLock :errchk handle))    (%setf-macptr locked-ptr (%get-ptr handle))    (unless (eql offset 0)      (%incf-ptr locked-ptr offset))    unlock-handle))(defun %put-string (pointer str &optional (offset 0) (maxsize 255) script)  (with-pointers ((p pointer (1+ offset)))    (let ((n (%put-string-contents p str  maxsize script)))      (%put-byte p n -1))))(defun %put-string-contents (p str &optional maxsize script)  (declare (ignore script))  (setq str (require-type str 'string))  (flet ((err () (error "String too big to fit in record")))    (let ((size (length str)))      (if (and maxsize (%i> size maxsize))        (err)        (multiple-value-bind (v start) (array-data-and-offset str)          (cond           ((simple-base-string-p v)            (lap-inline ()              (:variable size p v start)              (move.l (varg size) dtemp0)              (getint dtemp0)              (move.l (varg p) atemp1)              (move.l (atemp1 $macptr.ptr) atemp1)              (move.l (varg v) atemp0)              (move.l (varg start) dtemp1)              (getint dtemp1)              (lea (atemp0 dtemp1.l $v_data) atemp0)              (dc.w #_blockmove))            size)           (t (let (; (table (get-char-byte-table script))                    (j 0))                (when (not maxsize)(setq  maxsize most-positive-fixnum))                (dotimes (i size)                  (let ((c (%scharcode v i)))                    (if (and #|table|# (%i> c #xff)) #|(eq (svref table (%ilsr 8 c)) 1))|#                      (progn                         (when  (%i>= j (%i- maxsize 1))(err))                        (%put-word p c j)                        (setq j (%i+ j 2)))                      (progn                        (when (%i>= j maxsize)(err))                        (%put-byte p c j)                        (setq j (%i+ j 1))))))                j)))))))); start and end are character positions; maxsize is a byte count.(defun %put-string-segment-contents (p str start end &optional maxsize script)  (declare (ignore script))  (multiple-value-setq (str start end)(string-start-end str start end))  (flet ((err () (error "String too big to fit in record")))    (let ((size (- end start)))      (if (and maxsize (%i> size maxsize))        (err)        (cond         ((simple-base-string-p str)          (lap-inline ()            (:variable size p str start)            (move.l (varg size) dtemp0)            (getint dtemp0)            (move.l (varg p) atemp1)            (move.l (atemp1 $macptr.ptr) atemp1)            (move.l (varg str) atemp0)            (move.l (varg start) dtemp1)            (getint dtemp1)            (lea (atemp0 dtemp1.l $v_data) atemp0)            (dc.w #_blockmove))          size)         (t (let (;(table (get-char-byte-table script))                  (j 0))              (when (not maxsize)(setq  maxsize most-positive-fixnum))              (dotimes (i size)                                (let ((c (%scharcode str (%i+ i start))))                                    ;(cerror "b" "foo ~s ~s ~S" i j C)                  (if (and #|table|# (%i> c #xff) #|(eq (svref table (%ilsr 8 c)) 1)|#)                    (progn                       (when  (%i>= j (%i- maxsize 1))(err))                      (%put-word p c j)                      (setq j (%i+ j 2)))                    (progn                      (when (%i>= j maxsize)(err))                      (%put-byte p c j)                      (setq j (%i+ j 1))))))              j)))))))(defun %set-string (pointer offset &optional (string (prog1 offset (setq offset 0))))  (%put-string pointer string offset)  string)(defun %put-cstring (pointer str &optional (offset 0) maxsize script)  (with-pointers ((p pointer offset))    (let ((n (%put-string-contents p str (if maxsize (1- maxsize)) script)))      (%put-byte p 0 n))))(defun %get-double-float (macptr &optional (offset 0) (res (%copy-float 0.0)))  (unless (macptrp macptr)    (setq macptr (require-type macptr 'macptr)))  (unless (typep res 'double-float)    (setq res (require-type res 'double-float)))  (%copy-ptr-to-ivector macptr offset res                         #+ppc-target (* 4 ppc::double-float.value-cell)                        #-ppc-target (- (+ $v_data $t_dfloat))                        8)  res)(defun %hget-double-float (handle &optional (offset 0) (res (%copy-float 0.0)))  (unless (macptrp handle)    (setq handle (require-type handle 'macptr)))  (unless (typep res 'double-float)    (setq res (require-type res 'double-float)))  (with-macptrs ((pointer (%get-ptr handle)))    (%copy-ptr-to-ivector pointer offset res                           #+ppc-target (* 4 ppc::double-float.value-cell)                          #-ppc-target (- (+ $v_data $t_dfloat))                          8))  res)(defun %set-double-float (macptr offset &optional (value nil value-p))  (unless value-p    (setq value offset          offset 0))  (unless (macptrp macptr)    (setq macptr (require-type macptr 'macptr)))  (unless (typep value 'double-float)    (setq value (require-type value 'double-float)))  (%copy-ivector-to-ptr value                         #+ppc-target (* 4 ppc::double-float.value-cell)                        #-ppc-target (- (+ $v_data $t_dfloat))                        macptr offset 8)  value)(%fhave'%put-double-float #'%set-double-float)(defun %hset-double-float (handle offset &optional (value nil value-p))  (unless value-p    (setq value offset          offset 0))  (unless (macptrp handle)    (setq handle (require-type handle 'macptr)))  (unless (typep value 'double-float)    (setq value (require-type value 'double-float)))  (with-macptrs ((pointer (%get-ptr handle)))    (%copy-ivector-to-ptr value                           #+ppc-target (* 4 ppc::double-float.value-cell)                          #-ppc-target (- (+ $v_data $t_dfloat))                          pointer offset 8))  value)(%fhave'%hput-double-float #'%hset-double-float)  (defun %get-single-float (macptr &optional (offset 0) (res (%copy-float 0.0)))  (unless (macptrp macptr)    (setq macptr (require-type macptr 'macptr)))  (rlet ((double :double-float))    (with-macptrs ((single (%inc-ptr macptr offset)))      (%single-float-ptr->double-float-ptr single double)      (%get-double-float double 0 res))))(defun %hget-single-float (handle &optional (offset 0) (res (%copy-float 0.0)))  (unless (macptrp handle)    (setq handle (require-type handle 'macptr)))  (unless (fixnump offset)    (setq offset (require-type offset 'fixnum)))  (locally (declare (fixnum offset))     (rlet ((double :double-float))      (with-macptrs ((pointer (%get-ptr handle))                     (single (%inc-ptr pointer offset)))        (%single-float-ptr->double-float-ptr single double)        (%get-double-float double 0 res)))))(defun %set-single-float (macptr offset &optional (value nil value-p))  (unless value-p    (setq value offset          offset 0))  (unless (macptrp macptr)    (setq macptr (require-type macptr 'macptr)))  (rlet ((double :double-float))    (setf (%get-double-float double) value)    (with-macptrs ((single (%inc-ptr macptr offset)))      (%double-float-ptr->single-float-ptr double single)))  value)(%fhave'%put-single-float #'%set-single-float)(defun %hset-single-float (handle offset &optional (value nil value-p))  (unless value-p    (setq value offset          offset 0))  (unless (macptrp handle)    (setq handle (require-type handle 'macptr)))  (unless (fixnump offset)    (setq offset (require-type offset 'fixnum)))  (rlet ((double :double-float))    (setf (%get-double-float double) value)    (with-macptrs ((pointer (%get-ptr handle))                   (single (%inc-ptr pointer offset)))      (%double-float-ptr->single-float-ptr double single)))  value)(%fhave'%hput-single-float #'%hset-single-float); Copy a single float pointed at by the macptr in single; to a double float pointed at by the macptr in double - surely a better way#-ppc-target (defun %single-float-ptr->double-float-ptr (single double)  (let* ((hi (%get-word single))         (low (%get-word single 2))         (negative (logbitp 16 hi))         (expt (logand #xff (the fixnum (ash hi -7))))         (normalized-expt (- expt #x7f))         (double-expt (+ normalized-expt #x3ff))         (double-expt-with-sign          (if negative             (the fixnum (+ (ash 1 11) double-expt))            double-expt))         (mantissa (logior low (the fixnum (ash (logand hi #x7f) 16))))         (word0 (+ (the fixnum (ash double-expt-with-sign 4))                   (the fixnum (ash mantissa -19))))         (word1 (logand (the fixnum (ash mantissa -3)) #xffff))         (word2 (ash (the fixnum (logand mantissa 7)) 13)))    (declare (fixnum hi low expt normalized-expt double-expt                     double-expt-with-sign mantissa word0 word1 word2))    (setf (%get-word double) word0          (%get-word double 2) word1          (%get-word double 4) word2          (%get-word double 6) 0)    double))#-ppc-target(defun %double-float-ptr->single-float-ptr (double single)  (let* ((w0 (%get-unsigned-word double 0))         (w1 (%get-unsigned-word double 2))         (w2 (%get-unsigned-word double 4))         ;(w3 (%get-unsigned-word double 6))                 (expt (logand 2047 (ash w0 -4)))         mant sexpt s0)        (setq sexpt (+ 127 (- expt 1023)))        (setq mant (logior (ash (logand #xf w0) 19)                       (ash w1 3)                       (ash w2 -13)))        (if (minusp sexpt)      (progn  ; denorm         (setq mant (ash (logior mant #x800000) sexpt))        (setq sexpt 0))      (if (>= sexpt 255) ; call it infinity - doesn't do nans right        (progn (setq sexpt 255)               (setq mant 0))        (progn          (let ((round (logand #x100000 mant)))            (when (neq 0 round)              (if (eq 0 (logand #xfffff mant))                (if (oddp mant)(setq mant (1+ mant)))                (setq mant (1+ mant)))              (when (> mant #x7fffff)                (setq sexpt (1+ sexpt))                (setq mant 0)                (when (>= sexpt 255)(setq sexpt 255 mant 0))))))))    (setq s0 (logior (logand w0 #x8000) (ash sexpt 7)(ash mant -16)))    (setf (%get-word single 0) s0)    (setf (%get-word single 2) (logand mant #xffff))))(defun array-data-and-offset (array)  (old-lap   (move.l (fixnum 0) arg_y)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (if# eq     (prog#      (add.l (svref atemp0 arh.offs) arg_y)      (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))      (move.l (svref atemp0 arh.vect) atemp0)      (until# eq)))   (vpush atemp0)   (vpush arg_y)   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun array-data-offset-subtype (array)  (old-lap   (move.l (fixnum 0) arg_y)   (move.l arg_z atemp0)   (jsr_subprim $sp-arrayarg)   (if# eq     (prog#      (add.l (svref atemp0 arh.offs) arg_y)      (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))      (move.l (svref atemp0 arh.vect) atemp0)      (until# eq)))   (vpush atemp0)   (vpush arg_y)   (vsubtype atemp0 da)   (ext.w da)   (ext.l da)   (mkint da)   (vpush da)   (set_nargs 3)   (jmp_subprim $sp-nvalret)));Returns a simple string and adjusted start and end, such that; 0<= start <= end <= (length simple-string).(defun get-sstring (str &optional (start 0) (end (length (require-type str 'string))))  (multiple-value-bind (sstr offset) (array-data-and-offset (string str))    (setq start (+ start offset) end (+ end offset))    (when (< (%vect-byte-size sstr) end) (setq end (%vect-byte-size sstr)))    (when (< end start) (setq start end))    (values sstr start end)));e.g. (bad-named-arg :key key 'function)(defun bad-named-arg (name arg &optional (type nil type-p))  (if type-p    (%err-disp $err-bad-named-arg-2 name arg type)    (%err-disp $err-bad-named-arg name arg)))(defun verify-arg-count (call min &optional max)  "If call contains less than MIN number of args, or more than MAX   number of args, error. Otherwise, return call.   If Max is NIL, the maximum args for the fn are infinity." (or (verify-call-count (car call) (%cdr call) min max) call))(defun verify-call-count (sym args min &optional max &aux argcount)  (if (%i< (setq argcount  (list-length args)) min)    (%err-disp $xtoofew (cons sym args))    (if (if max (%i> argcount max))      (%err-disp $xtoomany (cons sym args)))))(defun getf (place key &optional (default ()))  (let ((p (pl-search place key))) (if p (%cadr p) default)))(defun remprop (sym key)  (old-lap-inline ()   (move.l arg_y atemp0)   (jsr_subprim $sp-check-sym)   (move.l (atemp0 $sym.package-plist) atemp1)   (if# (and (ne nilreg atemp1)             (eq (ttagp ($ $t_cons) atemp1 da)))     (btst ($ $sym_vbit_typeppred) (atemp0 $sym.vbits))     (sne db)     (with-preserved-registers #(asave0)       (move.l atemp1 asave0)       (if# (ne (tst.b db))         (cdr asave0 asave0)         (move.l asave0 atemp1))       (move.l atemp0 dy)       (bra @test)@loop       (cmp.l (car atemp0) arg_z)       (cdr atemp0 atemp0)       (if# eq         (rplacd atemp1 (cdr atemp0))         (move_t acc)         (if# (and (eq (cdr asave0) nilreg)                   (eq (tst.b db)))           (move.l dy atemp0)           (car asave0 (atemp0 $sym.package-plist)))         (unuse_regs)         (bra @ret))       (move.l atemp0 atemp1)@test       (cdr atemp1 atemp0)       (cmp.l nilreg atemp1)       (bne @loop)))   (move.l nilreg acc)@ret)); If this returns non-nil, safe to do %rplaca of %cdr to update.(defun pl-search (plist key) (unless (plistp plist)  (report-bad-arg plist '(satisfies plistp))) (old-lap-inline (plist key)   (move.l arg_y atemp0)   (until# (eq atemp0 nilreg)     (cmp.l (car atemp0) arg_z)     (beq @done)     (cdr atemp0 atemp0)     (cdr atemp0 atemp0))@done   (move.l atemp0 acc)))#|(defun make-point (vh &optional v)  (lap-inline ()    (:variable vh v)    (if# (eq (cmp.l arg_z nilreg))      (if# (ne (ttagp ($ $t_fixnum) arg_y da))       (move.l arg_y acc)               ; typecheck       (jsr_subprim $sp-getpoint))      (move.l arg_y acc)      (lfret))    (if# (or (ne (ttagp ($ $t_fixnum) arg_z da))             (ne (progn (getint arg_z)                        (move.l arg_z da)                        (ext.l da)                        (cmp.l arg_z da))))      (wtaerr (varg v) '(signed-byte 16)))    (if# (or (ne (ttagp ($ $t_fixnum) arg_y da))             (ne (progn (getint arg_y)                        (move.l arg_y da)                        (ext.l da)                        (cmp.l arg_y da))))      (wtaerr (varg vh) '(signed-byte 16)))    (swap arg_z)    (move.w arg_y arg_z)    (jsr_subprim $sp-mkpoint)))|#(defun point-string (point)  (%str-cat "#@("            (%integer-to-string (point-h point))            " "            (%integer-to-string (point-v point))            ")"))#|(defun add-points (pt1 pt2)  (old-lap-inline ()   (jsr_subprim $sp-getpoint)   (exg acc arg_y)   (jsr_subprim $sp-getpoint)   (add.w arg_y acc)   (swap arg_y)   (swap acc)   (add.w arg_y acc)   (swap acc)   (jsr_subprim $sp-mkpoint)))(defun subtract-points (pt1 pt2)        ; (- pt1 pt2)  (old-lap-inline ()   (jsr_subprim $sp-getpoint)   (exg acc arg_y)   (jsr_subprim $sp-getpoint)   (sub.w arg_y acc)   (swap arg_y)   (swap acc)   (sub.w arg_y acc)   (swap acc)   (jsr_subprim $sp-mkpoint)))|#(defun position (item sequence &rest ignored-keys)  (declare (ignore ignored-keys)           (dynamic-extent ignored-keys))  (xposition item sequence))(defun xposition (item sequence)  (if (listp sequence)    (do* ((list sequence (%cdr list))          (count 0 (1+ count)))         ((endp list) nil)      (when (eql (car list) item) (return count)))    (dotimes (i (length sequence))      (declare (fixnum i))      (when (eql (aref sequence i) item) (return i)))))(defun position-positional-test-key (item sequence test key)  (declare (ignore test key))  (xposition item sequence))(defun delete (item list &rest ignored-keys)  (declare (ignore ignored-keys)           (dynamic-extent ignored-keys)           (inline delete))  (if list      (if (eq item (car list))          (delete item (%cdr list))          (%rplacd list (delete item (%cdr list))))))(defun rassoc (item alist &key (test #'eql test-p) test-not (key #'identity))  (declare (list alist))  "Returns the cons in alist whose cdr is equal (by a given test or EQL) to   the Item."  (if (or test-p (not test-not))    (progn      (if test-not (error "Cannot specify both :TEST and :TEST-NOT."))      (dolist (pair alist)        (if (atom pair)          (if pair (error "Invalid alist containing ~S: ~S" pair alist))          (when (funcall test item (funcall key (cdr pair))) (return pair)))))    (progn      (unless test-not (error "Must specify at least one of :TEST or :TEST-NOT"))      (dolist (pair alist)        (if (atom pair)          (if pair (error "Invalid alist containing ~S: ~S" pair alist))          (unless (funcall test-not item (funcall key (cdr pair))) (return pair)))))))(defun *%saved-method-var%* ()  (declare (special %saved-method-var%))  %saved-method-var%)(defun set-*%saved-method-var%* (new-value)  (declare (special %saved-method-var%))  (setq %saved-method-var% new-value))(defsetf *%saved-method-var%* set-*%saved-method-var%*)(defun beep (&optional (times 1) idlecount)  (dotimes (i times) (declare (fixnum i)) (#_sysbeep 10))  (when idlecount (dotimes (i idlecount) (declare (fixnum i)))))(defun dbg (&optional x)  "Enter the debugger with the address of the arg in d0"  (old-lap-inline ()    (dc.w #_debugger))  x)(defun true  (&rest p) (declare (ignore p)) t)(defun false (&rest p) (declare (ignore p)) nil);end of L1-utils.lisp#|	Change History (most recent last):	2	12/27/94	akh	merge with d13|# ;(do not edit past this line!!)