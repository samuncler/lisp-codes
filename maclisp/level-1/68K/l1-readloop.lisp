;;;-*-Mode: LISP; Package: CCL -*- ;;	Change History (most recent first):;;  6 8/25/97  akh  cancel modal?;;  5 7/4/97   akh  see below;;  4 6/9/97   akh  see below;;  3 4/1/97   akh  see below;;  31 9/27/96 akh  fix read-form-internal symbols for french etc.;;  30 9/3/96  akh  fix interactive-abort for modal dialogs;;  27 11/21/95 bill (toplevel) dwim;;  25 7/27/95 akh  fix for reading long strings (255 not 256);;  24 7/27/95 akh  interactive-abort - fix for modal-dialog change;;  22 7/27/95 akh  merge patch to toplevel-function for application;;  18 5/22/95 akh  eval-enqueue calls method application-eval-enqueue;;                  commented out the clause that prevents abort in idle listeners?;;  10 4/24/95 akh  some little thing;;  6 4/6/95   akh  %real-err-fn-name avoids call-check-regs;;  4 4/4/95   akh  call-check-regs no rest arg, cheap-eval-in-env no apply;;  16 3/2/95  akh  add method application-file-creator;;                  break-loop sets *modal-dialog-on-top* to nil;;  15 2/9/95  akh  process-to-abort - if 2 processes choose main unless option-key-p;;  14 2/7/95  akh  prepare-to-quit - dont bind *quitting* to nil;;  13 2/6/95  akh  break and error tell us process name if not "main".;;  12 2/3/95  slh  copyright thang;;  11 1/31/95 akh  break-loop-handle-error sets *processing-events* nil;;  10 1/30/95 akh  fix readtable-case :invert in package token;;                  add support for command-/, \, and b menu items;;  8 1/25/95  akh  cancel text conditional on *quitting* in some dialogs;;                  *modal-dialog-on-top* is a list now;;  7 1/17/95  akh  with and without event processing moved to l1-events;;                  Try the invert changes again;;                  use without-event-processing;;  6 1/12/95  akh  revert - something is wrong with :invert changes;;  5 1/11/95  akh  aargh;;  4 1/11/95  akh  move modeline;;  3 1/11/95  akh  fix readtable-case :invert when escaped chars;;  (do not edit before this line!!);; break-loop resets *modal-dialog-on-top* and *eventhook* - hmm needs more thought re hook(in-package "CCL");L1-readloop.lisp; Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!;; Modification History;; akh - bill's cancel modal dialog patch; 06/07/97 akh   #@ for big points; 03/23/97 akh   interactive-abort checks option-key-p; 03/25/97 bill  Copy the PPC version of TOPLEVEL.; -------------  3.2b1; 10/01/96 slh   startup-finished, find-restart-in-process here (for MCL-Appgen); 11/21/95 bill  make toplevel do the right thing in a non-initial process;  8/01/95 slh   application toplevel-function: call open-application,;                 startup-finished; add open-application method;  6/09/95 slh   totally rad about box;  6/08/95 slh   help-specs; about box update;  5/04/95 slh   process-to-abort: ignore idling listeners;  4/27/95 slh   toplevel-function methods here;                process-to-abort: reverse process list, so most recent (?) is first;  4/26/95 slh   application-about-dialog stuff here;  4/16/95 slh   add licensor thingy to about dialog;  4/11/95 slh   application-overwrite-dialog -> l1-files.lisp, inline in only place;                used; about dialog stuff -> app method;  4/04/95 slh   application-file-creator: use *ccl-file-creator*;  4/01/95 akh   call-check-regs -no more rest arg - twas silly though exposed a bug;  3/30/95 slh   merge in base-app changes;--------------  3.0d18; 3/07/95 slh   error-header, uses *main-listener-process-name*; 2/27/95 slh   %break-message: space after "Error:";-------------  3.0d17;01/30/95 alice fix package part of readtable-case :invert, command-/ and-\ somewhat better;-------------  3.0d16;01/05/94 bill  bug in call-check-regs error form: reported dsave0's value 3 times,;               omitted dsave1 & dsave2.;-------------  3.0d13;08/18/93 bill  interactive-abort doesn't query for process if *modal-dialog-on-top*.;-------------  3.0d12;07/22/93 bill  %error now does the right thing if application-error returns.;               Nobody expects %error to return.;06/11/93 alice %read-form-internal tries to keep his chars and bytes straight.;		and calls new-numtoken instead of %%numtkn which is gonesville;06/05/93 alice read calls %%find-pkg (in fasload.lisp) not %find-package;05/29/93 alice read now supposedly deals with fat chars and is smart enuf to make;		a fat pname  or string if one of the chars is actually fat, not otherwise.;05/26/93 alice read calls %find-package vice %%findpkg ???;07/01/93 alice simple-condition format-arguments initform nil;05/22/93 alice interactive-abort chooses front window if window-process & *break-level* neq 0.;05/21/93 alice interactive-abort and break do front window process iff *current-process* else ask;		at least there's a good chance a user can get at a looping process;05/15/93 alice %%name-char do #\nnn as word not byte ;05/08/93 alice interactive-abort and break do the obvious for 1 process, ask if more.;-------------- 2.1d7;05/01/93 alice %break-message binds a bunch more printing vars - maybe too many;04/29/93 bill process-is-listener-p, process-is-toplevel-listener-p;              read-loop binds *eval-queue*, so that eval-enqueue gets the top listener, not;              just whichever one gets around to looking at *eval-queue* first.;              all-processes & friends -> *all-processes* & friends;04/26/93 bill prepare-to-quit shuts down *active-processes* and waits for each shutdown to complete.;04/23/93 bill with-background-process in toplevel-read.;04/21/93 bill the new abort-break made <command>-<period> do nothing if typed at top-level in the Listener;              (after fixing a bug in process-preset);              It should clear-input and print "Aborted".;              Go back to the old way.;              with-non-background-process in read-loop;04/21/93 bill %read-form handles %parse-string% in a way that is compatible with multiple processes.;04/02/93 bill restore missing arg to (format nil "...close it with extreme prejudice" ...);03/31/93 bill quit handles cancel correctly.;-------------- 2.1d5;04/29/93 alice break application-error (lisp-dev-envir) into 2 parts - nuke noop overwrite dialog;------------- 2.1d4;03/04.93 alice *error-print-circle* initially nil, reset to T in pprint.lisp;02/13/93 alice add #\dot and #\altCheckMark to *name-char-alist*;01/12/92 alice *listener-indent* option kludge;11/04/92 alice read-loop has one restart instead of two - makes choose-restart look less cluttered with redundancies;		changed abort-break - do we like it?;10/29/92 alice toplevel-read protected-form - don't make a listener - causes save-application to fail when invoked via menu or dialog;10/15/92 alice don't use format ~a to print a condition - may contain circles;08/09/92 gb 	break-loop binds %handlers% to nil;07/22/92 alice %error heed *debugger-hook*;06/23/92 alice let things on *eval-queue* be functions.;-------------- 2.1d3;03/24/93 bill bind *quitting* in prepare-to-quit;02/19/93 bill signal binds *break-on-signals* nil around the break loop;              entered due to *break-on-signals* being non-nil.;02/17/93 bill def-kernel-restart $xstkover;02/16/93 bill cerror no longer gets "Too many arguments" error if given a condition;              instead of a string as its second arg and a non-empty list of additional args.;              (typep x 'condition) -> (condition-p x) ;01/28/93 bill eval-enqueue does funcall-in-top-listener-process;01/27/93 bill call-check-regs prints more info;01/25/93 bill %read-form now signals an end-of-file error instead of a simple-error;01/24/93 bill user-break arg to break-loop & cbreak-loop no longer necessary;              as we can't break in the middle of processing events anymore.;              break-loop no longer binds *processing-events*.;11/20/92 gb   #+/#- in lisp;  move some stack accessors to backtrace.lisp; change;              r/e/p loop for stack groups; new application class with some methods.;              pass *current-stack-group* to stack walkers.  Backtrace context in;              a vector.; 10/26/92 bill without-event-processing, with-event-processing-enabled.; 08/24/92 bill in prepare-to-quit: close windows from back to front & bring windows that;               need saving to the front before closing them.; 06/02/92 bill break-loop no longer binds *eventhook* to nil.;               Instead, process-event is smarter about not reentering *eventhook* functions.; 05/18/92 bill break-loop now has a SIGNAL firewall.;-------- 2.0;02/21/92 (gb from bootpatch0)  ABORT takes &optional condition arg.;-------- 2.0f2;01/08/92 gb    mumble more clearly.;12/27/91 gb    mumble something about stack overflow in TOPLEVEL-LOOP.;12/24/91 gb    don't retain lambda expressions if &LAP, &METHOD, &RESTV involved.;12/18/91 gb    simple-storage-condition, package-name-conflict error.;12/16/91 gb    %signal-error -> %err-disp; more hair in %err-disp.;-------- 2.0b4;11/14/91 gb    (per bill) queue-fixup not a nop, copies correct readtable.;11/13/91 bill  queue-fixup for setting *readtable* is a NOP as the fixups are run when *readtable* is bound.;11/11/91 bill  shadow -> shadow-1 so we don't need to cons.  Fix argument order in one call to unintern;               GB's fix to the fix of #+ & #-;11/11/91 gb    read-features even when *read-suppress* true; fix use-package restarts;;               retain-lambda-expression sometimes does.;10/27/91 gb    resolve-export-conflicts.;10/10/91 gb    BREAK-LOOP binds *RERD-SUPPRESS*. CHEAP-EVAL-IN-ENV tries to resolve compile-time;               constants.  Try to handle type errors when :datum is #<unbound>.  No-such-package;               restart more careful about *package*.;09/30/91 gb    make-load-form on LEXICAL-ENVIRONMENT. ;09/16/91 bill  Don't ignore CANCEL button on request to save a window during QUIT; ------- 2.0b3;09/06/91 alice file-error can have args besides pathname;09/05/91 bill  Alice's patch to print-listener-prompt;08/24/91 gb    fix macroexpand.  Use new trap syntax.;08/19/91 bill  let LOAD-TRAP-CONSTANT do the work for #$;08/01/91 bill  interactive-abort honors *inhibit-abort*;07/26/91 bill  make QUIT ignore some errors and throw to toplevel before;               doing PREPARE-TO-QUIT;08/19/91 gb    use %type-error-type in $xwrongtype restart.;07/21/91 gb    fix wtaerrs.  Defconstant wimpiness. #'TYPE-ERROR -> #'SIGNAL-TYPE-ERROR.;               Fix some restarts.  Use %type-error-type mechanism.  Applicable-restart-p;               applies restart-test, used in find-,compute-restarts.;07/03/91 alice break-loop do restart window too - add it to list on *backtrace-dialogs*;07/02/91 bill  no more (declare (downward-function ...)) in READ;06/27/91 bill  selection-eval changes the buffer's package if a single-selection;               is evaluated which changes *package*.  Add evalp optional arg.;06/24/91 alice if *backtrace-on-break* do it after the break message;06/17/91 alice now #\177 is "DEL";---------- 2.0b2;05/30/91 bill  for #_ & #$ - in *traps-package* only for reading.;05/28/91 alice *name-char-alist* ForwardDelete <= #\177, Delete <= backspace;05/21/91 alice add *error-print-circle* = what *print-circle* is bound to by %break-message & break-loop;05/20/91 gb    "check-error-global" scheme: needs some work.  Typecheck *readtable*, *package* in %READ-FORM.;               UNINTERN-CONFLICT class, restart handler.  One scheme of handling changes to *package* during;               selection eval.  Rename #'PROGRAM-ERROR to #'SIGNAL-PROGRAM-ERROR.  Add %SYMBOL-MACROEXPAND;;               should be used more often than it is.;04/16/91 alice *name-char-alist* add home, end etc.;04/04/91 bill  close *open-file-streams* in prepare-to-quit;03/14/91 bill  bind *print-readably* to NIL in the break-loop;02/28/91 bill  Bind *idle* around event-dispatch call in toplevel-read;02/12/91 bill  cheap-eval-in-environment does UNWIND-PROTECT explicitly to avoid an extra compile from window-enqueue-region;03/04/91 alice %break-message - if it is a simple-program-error with a non null context, omit "while executing foo";02/26/91 alice function type-error, %signal-error knows about type-error;02/11/91 alice cheap-eval-in-env - special case step macro (blech), bind *compile-definitions* nil;----------------- 2.0b1;01/28/91 bill  in toplevel-print: set *, **, ***, /, //, /// just before starting to print.;01/14/91 gb    let last arg default in ensure-value-of-type.;01/07/91 gb    use *autoload-lisp-package* in no-package restart.  Make ceie handle locally, (symbol-)macrolet.;12/31/90 gb    scatter some (declare (resident))'s around indiscriminately.  Comment-out call-check-regs.;               print CONTINUE format string with *PRINT-ARRAY* off and *PRINT-CIRCLE* on.  Make sure that;               %initial-readtable% and *readtable* are disjoint.  %cfp-lfun identifies swappable functions;               by jumptable address.;12/14/90 alice cheap-eval-in-environment - handle locally at top level correctly in interpreter;12/12/90 bill require-lisp-package restart for no-such-package error.;              invoke-restart-interactively prints the restart before doing anything.;12/8/90  joe   rearrange read-loop so that *eval-queue* is looked at first. This is a;               purely cosmetic change so that an extra prompt isn't printed under AEvents.;11/27/90 bill  get-next-queued-form;11/19/90 gb    muffle-warning.  Bootstrap backtrace; use new package functions in reader.;10/23/90 bill  interactive-abort does abort-break if *in-read-loop*, abort just invokes the restart.;10/20/90 bill  fix bad interaction of selection-eval with new setting of *, **, ***, etc in toplevel-print.;10/16/90 gb    stack-cons restarts.  Make sure toplevel loop doesn't set * unless;               toplevel-print returns.;10/12/90 bill  Let one error happen in %break-message before disabling *signal-printing-errors*;10/10/90 bill  add user-break arg to cbreak-loop & break-loop so that event-abort;               restart is skipped if user interrupts event processing.;10/05/90 bill  fix %readtab-fn2spec;09/28/90 bill  Bind *signal-printing-errors* to NIL in %break-message;09/25/90 bill  add child-frame optional arg to cfp-lfun & count-values-in-frame;09/12/90 bill  bind *signal-printing-errors* to NIL in break-loop;09/07/90 bill  #_ & #$ dispatch-macro-characters,;               stream-tyi-guaranteed-function-and-args;08/27/90 bill  break-loop binds *modal-dialog-on-top* in just the right place.;08/25/90 bill  *single-defvar-is-defparameter* -> *always-eval-user-defvars*;08/23/90 bill  :none -> :unspecific from GZ, "~s" -> "~:s" for undefined-function-call;               report.;08/11/90 bill  process-single-selection in selection-eval;08/02/90 gb   (clear-input *debug-io*) only when we're about to read from it,;              not when we write to it.  (Among other things, type-ahead shouldn't;              get flushed by redefinition warnings.) %uvref -> uvref.;07/31/90 bill  New get-string-from-user arglist.;07/18/90 alice bind *print-circle* and *print-array* in %break-message;------ 2.0d48;07/13/90 alice garys fix to cfp-lfun;06/19/90 gb   macroexpand-1 returns (values nil nil) when non symbol-macro binding;              encountered.;06/25/90 bill Restore normal cursor during break-loop.;06/18/90 bill remove window-ensure-on-screen before printing listener prompt.;07/09/90 alice calls to get-string-from-user supply 2 args;06/14/90 alice #P-reader take 4 as flags - why do we have these here flags?; ------ 2.0d46;06/14/90 bill macroexpand-1 checks for (symbolp (car form)) before looking for;              a macro-function (e.g. ((lambda (x) x) 1));06/12/90 bill make note-function-info do the right thing for (setf foo);              make ::foo read as :foo, not :\:foo;              keyword:<new-symbol> same as keyword::<new-symbol> (used to error);06/08/90 gb   print-unreadable-object: keyword name is :identity, not :id.;06/07/90 bill *read-eval -> *read-eval*;06/05/90 bill ensure listener prompt appears even when *print-level* = 0;06/05/90 gb  $xnopkg restart.  (clear-input *debug-io*) in %break-message, %break-loop.;06/05/90 gb  add storage-condition, stack-overflow-condition.  Start to classify;             errors signalled from kernel.;05/30/90 gb  print-not-readable-error.  Use print-unreadable-object.;05/27/90 gb  macroexpand-1 symbol-macros.;05/22/90 gb  note-variable-info.;05/16/90 gb  compiler-warning-nrefs. *READ-EVAL*.;5/9/90   gb  note & retrieve function information.;5/7/90   gz  New improved file-error condition.;05/05/90 bill new scrap handler.;05/04/90 gb   some more nils in new-{definition,lexical}-environment.;05/02/90 bill prepare-to-quit comes out of line from quit.;04/30/90 gb   reaadtable-case.  Newer condition stuff.  Still need to fix ABORT,;              foo-case macros.  Need also to make primitive errors be of right;              condition class.  Stack-walkers pass fixnums (distance from NIL;              in longwords) around.;04/20/90 gz  Fix in %read-form for the read-delimited-list case.;             Fix in %readtab-fn2spec to deref closure wrappers.;04/02/90 gz  write-a-restart -> print-object;02/14/90 bill in selection-eval: make sure we print in the listener's package,;              or people will get very confused.;2/13/90  gz  in cheap-eval: don't use compile-user-function if it's just;             going to apply the result.;             Flushed *did-startup* and (startup-ccl) in top-level-loop.;02/02/90 gz  Prefetch stream-tyi combined method in %read-form.;01/13/90 gz  Pass idle arg to event-dispatch in toplevel-read.;01/03/89 gz  In %signal-error, look up nilreg cells for $xfunbnd as well.;12/29/89 gz  Made read go through stream-rubout-handler.;             Changed get-[dispatch]-macro-character to treat NIL readtable as;             the initial readtable, as per x3j13/GET-MACRO-CHARACTER-READTABLE.;01/29/90 bill in cheap-eval: compile the lambda expr in ((lambda (...) ...) ...);              Add *break-loop-when-uninterruptable* to break-loop;              Make ESC the preferred name for the Escape character;01/16/90 bill Make quit close windoids and invisible windows.;01/13/90 bill window-ensure-on-screen before printing prompt in listener.;12/30/89 bill Restore *did-startup* and (startup-ccl) to top-level-loop.;12/30/89 gb  cheap eval-when (:execute).;12/28/89 gz  No more catch/throw-error.;12/27/89 gz  Rearrange obsolete #-bccl conditionals.  Bind *compiling-file* to nil;             in break loops.  Don't do startup in toplevel-loop.  Handle setf;             function names in cheap-eval.;12/22/89  gb  slowed down the reader some more (cl:readtable-case nonsense.);11/14/89 gz  Make cheap-eval not use compile-user-function if it's just;             going to funcall the result.;             No more %write.;12-Dec-89 Mly In %read-form, no need to call eofp since stream-tyi returns nil if so;              Moved *name-char-alist* here from l1-io.  I hope this isn't a screw...;              write-a-restart;11/5/89  gz   Do not ignore errors in cleanup functions.;10/13/89 bill funcall *lisp-cleanup-functions* in QUIT before closing windows.;10/13/89 bill Make cheap-eval always use compile-user-function to generate warnings.;09/30/89 gb make selection-eval bind *package*.  I have no idea whether or not;            this is right.;09/17/89 gb flushed a little more of object lisp.;09/16/89 bill Removed the last vestiges of object-lisp windows.;9/14/89 bill Update for CLOS listener: top-level-read, print-listener-prompt;9/13/89  gz in %signal-error, special-case $xvunbnd to allow nilreg offset;            instead of symbol.;8/29/89  gb no more #'function-binding.;4/10/89  gz clos conditions.;04/07/89 gb  $sp8 -> $sp.;3/30/89  gz *inest-ptr* -> *interrupt-level*. %parse-number-token to l1-numbers.;	     $sp-numtkn -> %%numtkn.;3/23/89  gz no more kernel lfuns, no more $sp-findextsym.;03/03/89 gz macro-function to l1-utils.;            made %read-form be object system independent.;2/24/89  gz one-arg %make-uvector -> $sp-allocgv.;2/12/89  gz Added %parse-number-token, new arg to numtkn; 2/13/89 gz read-feature (and ...) fix.; 1/30/89 gb vstack starts at (a5 $vstackbase) vice nilreg.;01/09/89 gz New error system.;01/04/89 gz New read-loop, new eval queue scheme.;01/03/89 gz The reader.; 1/1/89 gb heap, a5, lfuns ...;12/11/88 gz mark-position -> buffer-position;12/2/88 gz partial 1.3 merge:  ;10/19/88 jaj bind and declare special *processing-events* in break-loop  ; 9/28/88 jaj in read-loop don't set - + ++ +++ if source is :eval-queue; 11/27/88 gb forget %toplink, %%next-cfp magic numbers.; 11/23/88 gb %caller here.; 9/11/88  gb stack-walkers changed some.  Error calls break-loop non-continuably.; 9/2/88   gz no more list-nreverse; 9/8/88   gb no cfp. Some stack-walkers changed, others need to.; 9/1/88   gb self-evaluate non-symbol atoms in cheap-eval.; 8/23/88  gz cheap-eval calls compile-user-function for nfunction.; 8/13/88  gb unbound-marker vice int-to-ptr in readloop.; 8/9/88  gb  macro-function (env arg), macroexpand, -1, *hook*.; 7/31/88 gb  Add stack frame accessors, fix %last-fn-on-stack (Right...) Backtrace setup.;             Cheap-eval compiles iff compiler-special-form-p, not function-binding/macro-;             function.; 6/23/88 jaj fixed some catch/throw bugs, toplevel-loop is now a loop; 6/22/88 as  quit doesn't bother to close doc-string file; 6/22/88 jaj throw-error arg is optional; 6/21/88 jaj catch-error returns two values, added catch-error-quietly;             *backtrace-on-errors* -> *backtrace-on-break* ;             changes to read-loop and break-loop, added *listener-break-;             level*, print-listener-prompt prints if neq *break-level*,;             print-compiler-warnings before printing error; 6/20/88 jaj catching abort clears-input. print-listener-prompt prints;             if read-position is zero; 6/10/88 jaj abort throws :abort-break if *in-read-loop*; 6/9/88  jaj quit closes %doc-string-file;             added added [catch/throw]-[toplevel/error/cancel/break];             read-loop cleaned up; 5/8/88  jaj added *save-local-symbols* to cheap-eval; 5/31/88 as  %error -> :error, %toplevel -> :toplevel;             abort does'nt print when *inhibit-error*; 5/23/88 as  error doesn't hang on attempts to print to non-streams; 5/13/88 as  quit closes windows in reverse order; 5/11/88 jaj cheap-eval uses *warn-hook*; 2/27/88 jaj bind *, **, *** etc. in toplevel-loop and break-loop;             instead of read-loop (fixes for evaling from buffer);             added continuablep to break-loop and callers, added;             *continuablep*; 6/5/88  gb  Pass *save-local-symbols* into compile-named-function.; 4/01/88 gz  New macptr scheme.  Flushed pre-1.0 edit history.;10/26/87 jaj abort throws to (or *break-loop-tag* '%toplevel);10/25/87 jaj changed C-/, C-. to Command-/, Command-. (bug report by Ruben);10/23/87 jaj added print-listener-prompt to error;10/21/87 jaj "resume" -> "continue";10/19/87 jaj added abort;10/18/87 jaj removed tyo, added optional force arg to print-listener-prompt;             call it after catching a break.;10/14/87 jaj tyo space to *terminal-io*;10/13/87 jaj added *print-package*, use it in read-loop;10/04/87 gb  tyo a space (to any old stream !?) in abort-break.;9/15/87 jaj  print symbol 'continue using ~s for entering break-loop;             added %real-err-fn-name to skip over event-dispatch;-------------------------------Version 1.0-----------------------------------(eval-when (compile eval)  (defconstant readtable-case-keywords '((:upcase . 1) (:downcase . 2) (:preserve . 0)                                         (:invert . -1) (:studly . -2)))  (defmacro readtable-case-keywords () `',readtable-case-keywords))(defvar *break-on-signals* nil)(defvar *break-on-warnings* nil)(defvar *break-on-errors* t "Not CL.")(defvar *debugger-hook* nil)(defvar *backtrace-on-break* nil)(defvar *** nil)(defvar ** nil)(defvar * nil)(defvar /// nil)(defvar // nil)(defvar / nil)(defvar +++ nil)(defvar ++ nil)(defvar + nil)(defvar - nil)(defvar *continuablep* nil)(defvar *in-read-loop* nil  "Not CL. Is T if waiting for input in the read loop")(defvar *listener-p* nil  "Bound true by READ-LOOP. This is how we tell if a process is a Listener")(defparameter *inhibit-error* nil "If non-nil, ERROR just throws")(defvar *did-startup* nil)(defvar *eval-queue* nil)(defun process-is-listener-p (process)  (symbol-value-in-process '*listener-p* process))(defun process-is-toplevel-listener-p (process)  (and (symbol-value-in-process '*in-read-loop* process)       (eql 0 (symbol-value-in-process '*break-level* process))))(defun startup-finished ()  (setq *event-mask* #$everyEvent))(defun get-next-queued-form ()  (pop *eval-queue*))#|(defmacro without-event-processing (&body body)  `(let-globally ((*processing-events* t))     ,@body))(defmacro with-event-processing-enabled (&body body)  `(let ((*interrupt-level* 0))     (let-globally ((*processing-events* nil))        ,@body)))|#(defmacro catch-cancel (&body body)  `(catch :cancel ,@body))(defmacro throw-cancel (&optional value)  `(throw :cancel ,value))(defun toplevel ()  (let ((p *current-process*))    (if (eq p *initial-process*)      (throw :toplevel nil)      (throw (process-reset-tag p) :toplevel))))#|(defun cancel () (throw :cancel :cancel))|#(defun cancel ()  (if (and *modal-dialog-on-top*           (eq *current-process* *event-processor*)           (let* ((dialog.process (car *modal-dialog-on-top*))                  (dialog (car dialog.process))                  (process (cdr dialog.process)))             (and (typep dialog 'window)                  (wptr dialog)                  (typep process 'process)                  (not (process-exhausted-p process)))))                 (return-from-modal-dialog :cancel)    (throw :cancel :cancel))); It's not clear that this is the right behavior, but aborting CURRENT-PROCESS -; when no one's sure just what CURRENT-PROCESS is - doesn't seem right either.(defun interactive-abort ()  (let* ((w (front-window))         (p (if w (window-process w))))    (setq p (or (if (or (and (eq w (caar *modal-dialog-on-top*))                             (setq p (cdar *modal-dialog-on-top*)))                        (and p (not (option-key-p))                             (or  (eq p *current-process*)                                 (lds                                  (and (not (process-exhausted-p p))                                       (neq 0 (symbol-value-in-process '*break-level* p))                                       )))))                  p)                (process-to-abort "Abort Process")))    ;(dbg p)    (interactive-abort-in-process p)))(defun interactive-abort-in-process (p)  (if p (process-interrupt p                            #'(lambda ()                               (unless *inhibit-abort*                                 (lds (if *in-read-loop*                                         (abort-break)                                        (abort))                                      (abort))                                 ))))); What process-to-abort does now (5/5/95):; - all processes idling: cmd-. & opt-cmd-. abort event-processor; - one process busy: cmd-. aborts the busy process; opt-cmd-. gives dialog; - two or more processes busy: cmd-. & opt-cmd-. gives dialog; (a busy process is a non-idling listener, or any other that's not event-processor)(defun process-to-abort (what)  (let ((l (mapcan #'(lambda (x)                       (unless (or (%stack-group-exhausted-p (process-stack-group x))                                   (not (find-restart-in-process 'abort x))                                   ; idling listeners:                                   #|                                   (and (symbol-value-in-process '*in-read-loop* x)                                        (eq 0 (symbol-value-in-process '*break-level* x)))|#                                   )                         (list x)))                   (reverse *active-processes*))))    (cond      ((null (cdr l)) (car l)) ; *current-process*      ((and (null (cddr l))            (not (option-key-p)))       (if (eq (car l) *event-processor*) (cadr l) (car l)))      (t (let ((p (catch-cancel                    (select-item-from-list l                                           :window-title what                                           :help-spec 15010                                           :list-spec 15011                                           :button-spec 15013))))           (if (neq p :cancel) (car p)))))))(defun find-restart-in-process (name p)  (without-interrupts   (let ((restarts (symbol-value-in-process '%restarts% p)))     (dolist (cluster restarts)       (dolist (restart cluster)         (when (and (or (eq restart name) (eq (restart-name restart) name)))           (return-from find-restart-in-process restart)))))))(defun abort (&optional condition)  (invoke-restart-no-return (find-restart 'abort condition)))(defun continue (&optional condition)  (let ((r (find-restart 'continue condition)))    (if r (invoke-restart r))))(defun muffle-warning (&optional condition)  (invoke-restart-no-return (find-restart 'muffle-warning condition)))(defun abort-break ()  (invoke-restart-no-return 'abort-break))#| Doing it this way prevents abort from clearing input in the listener(defun abort-break ()  (let ((res (find-restart-2 'abort)))    (if  res (invoke-restart-no-return res) (abort)))); find second restart(defun find-restart-2 (name &aux res)  (dolist (cluster %restarts% res)    (dolist (restart cluster)      (when (eq (restart-name restart) name)                 	(if res (return-from find-restart-2 restart)(setq res restart))))))|#(defun quit ()  (let ((listener *top-listener*))    (terminate-standin-event-processor     #'(lambda () (finish-quit listener)))))(defun finish-quit (listener)  (let ((cancelled-p (list nil)))    (declare (type cons cancelled-p))    (process-interrupt *initial-process*                       #'(lambda (cancelled-p)                           (unwind-protect                             (progn                               (prepare-to-quit listener 0)                               (%set-toplevel #'(lambda ()                                                   (%set-toplevel nil)                                                  (ignore-errors (prepare-to-quit nil 1))                                                  (throw :toplevel nil)))                               (throw :toplevel nil))                             (setf (car cancelled-p) t)))                       cancelled-p)    (process-wait "Quit" #'(lambda (cancelled-p) (car cancelled-p)) cancelled-p)    nil)); Kill the standin event processor, then funcall thunk with no args.; Cons up a new process to do this if the current process is the; standin event processor.(defun terminate-standin-event-processor (thunk)  (let ((standin-process *event-processor*))    (unless (eq standin-process *initial-process*)      (if (or (eq *current-process* standin-process)              (eq *current-process* *initial-process*))        (return-from terminate-standin-event-processor          (process-run-function "Standin event processor killer"                                #'(lambda (thunk)                                    (terminate-standin-event-processor thunk))                                thunk))        (progn          (let ((initial-form (process-initial-form standin-process)))            (without-interrupts             (setf (car initial-form) #'process-wait                   (cdr initial-form) (list "Death wait" #'(lambda () nil)))))          (process-reset standin-process)          (process-interrupt *initial-process*                             #'(lambda ()                                 (throw (or *event-processing-loop-tag* :toplevel) nil)))          (process-wait-with-timeout "Standin event processor termination"                                     300                                     #'(lambda ()                                         (eq *event-processor*                                             *initial-process*)))          (unless (eq (setq standin-process *event-processor*)                      *initial-process*)            (setq *event-processor* *initial-process*)            (process-kill-and-wait standin-process))))))  (when thunk (funcall thunk)))(defvar *quitting* nil); Called by quit, save-application & dumplisp(defun prepare-to-quit (&optional listener part)  (without-event-processing ; ((*processing-events* t)        ; just process aborts    (let-globally ((*quitting* (or listener t)))      (when (or (null part) (eql 0 part))        (dolist (f *lisp-cleanup-functions*)          (funcall f))        (let (windows)          (do-all-windows w (push w windows))          (dolist (w windows)            (when (neq w listener)              (window-close-nicely w))))        (when listener          (window-close listener)))      (unless (eql part 0)        (dolist (p (without-interrupts (copy-list *active-processes*)))          (unless (or (eq p *event-processor*) (eq p *initial-process*)                      (without-interrupts (not (memq p *active-processes*))))            (process-reset p :unless-current :shutdown :ask)            (unless (process-wait-with-timeout                     "Shutdown wait"                     300                     #'(lambda (p)                         (or (memq p *shutdown-processes*)                             (not (memq p *all-processes*))))                     p)              (let ((ans (y-or-n-dialog                          (format nil "~s refuses to shut down. Terminate it with extreme prejudice?"                                  p)                          :cancel-text (if *quitting* "Cancel"))))                (if (eq ans nil) (abort)                    (if (neq ans t)(cancel))))              (maybe-finish-process-kill p :kill))))        #+ppc-target        (shutdown-stack-groups)        (while *open-file-streams*          (close (car *open-file-streams*)))        (setq *interrupt-level* -1)       ; can't abort after this        (put-external-scrap)))))(defmethod window-close-nicely ((w window))  (when (and (method-exists-p #'window-needs-saving-p w)             (window-needs-saving-p w))    (ignore-errors (window-select w)))  (multiple-value-bind (res errorp)                       (ignore-errors (values (window-close w)))    (declare (ignore res))    (when errorp      (if (eq t (y-or-n-dialog                  (format nil "Error closing ~s.~%Close it with extreme prejudice?" w)                 :cancel-text (if *quitting* "Cancel")))        (ignore-errors (window-close-internal w))        (cancel)))))(defun whitespacep (char)  (when (fixnump char) (setq char (%code-char char)))  (%str-member char #.wsp&cr));;;***********************************;;; Error System;;;***********************************(defclass condition () ())(defclass warning (condition) ())(defclass serious-condition (condition) ())(defclass error (serious-condition) ())(define-condition simple-condition (condition)  ((format-string :initarg :format-string                  :reader simple-condition-format-string)   (format-arguments :initarg :format-arguments                     :initform nil                     :reader simple-condition-format-arguments))  (:report (lambda (c stream)  ;; If this were a method, slot value might be faster someday.  Accessors always faster ?                               ;; And of course it's terribly important that this be as fast as humanly possible...	    ;Use accessors because they're documented and users can specialize them.            (apply #'format stream (simple-condition-format-string c)                   (simple-condition-format-arguments c)))))(define-condition storage-condition (serious-condition) ())(define-condition simple-storage-condition (simple-error storage-condition) ())(define-condition print-not-readable (error)  ((object :initarg :object :reader print-not-readable-object)   (stream :initarg :stream :reader print-not-readable-stream))  (:report (lambda (c stream)             (let* ((*print-readably* nil))               (format stream "Attempt to print object ~S on stream ~S ."                       (print-not-readable-object c)                       (print-not-readable-stream c))))))(define-condition simple-warning (simple-condition warning))(define-condition compiler-warning (warning)  ((file-name :initarg :file-name :initform nil :accessor compiler-warning-file-name)   (function-name :initarg :function-name :initform nil :accessor compiler-warning-function-name)   (warning-type :initarg :warning-type :reader compiler-warning-warning-type)   (args :initarg :args :reader compiler-warning-args)   (nrefs :initform 1 :accessor compiler-warning-nrefs))  (:report report-compiler-warning))(define-condition style-warning (compiler-warning))(define-condition undefined-function-reference (style-warning))(define-condition macro-used-before-definition (compiler-warning))(define-condition invalid-arguments (style-warning))(define-condition invalid-arguments-global (style-warning))(define-condition simple-error (simple-condition error))(define-condition simple-storage-condition (simple-condition storage-condition))(define-condition stack-overflow-condition (simple-storage-condition))(define-condition type-error (error)  ((datum :initarg :datum)   (expected-type :initarg :expected-type :reader type-error-expected-type)   (format-string :initarg :format-string  :initform (%rsc-string  $xwrongtype) :reader type-error-format-string))  (:report (lambda (c s)             (format s (type-error-format-string c)                     (type-error-datum c)                      (type-error-expected-type c)))))(let* ((magic-token '("Unbound")))  (defmethod type-error-datum ((c type-error))    (let* ((datum-slot (slot-value c 'datum)))      (if (eq magic-token datum-slot)        (%unbound-marker-8)        datum-slot))); do we need this  (defun signal-type-error (datum expected &optional (format-string (%rsc-string  $xwrongtype)))    (let ((error #'error))      (funcall error (make-condition 'type-error                                     :format-string format-string                                     :datum (if (eq datum (%unbound-marker-8)) magic-token datum)                                     :expected-type (%type-error-type expected))))))  (define-condition simple-type-error (simple-condition type-error))(define-condition program-error (error))(define-condition simple-program-error (simple-condition program-error)  ((context :initarg :context :reader simple-program-error-context :initform nil)))(defun signal-program-error (string &rest args)  (error (make-condition 'simple-program-error                         :format-string (if (fixnump string) (%rsc-string string) string)                         :format-arguments args)))(define-condition simple-destructuring-error (simple-program-error))(define-condition compile-time-program-error (simple-program-error)  nil ;((context :initarg :context :reader compile-time-program-error-context))  (:report   (lambda (c s)     (format s "While compiling ~a :~%~a"              (simple-program-error-context c)             (apply #'format nil (simple-condition-format-string c) (simple-condition-format-arguments c))))))(define-condition eval-program-error (simple-program-error)  nil ;((context :initarg :context :reader eval-program-error-context))  (:report   (lambda (c s)     (format s "While preprocessing ~a :~%~a"              (simple-program-error-context c)             (apply #'format nil (simple-condition-format-string c) (simple-condition-format-arguments c)))))); Miscellaneous error during compilation (caused by macroexpansion, transforms, compile-time evaluation, etc.); NOT program-errors.(define-condition compile-time-error (simple-error)  ((context :initarg :context :reader compile-time-error-context))  (:report   (lambda (c s)     (format s "While compiling ~a :~%~a"              (compile-time-error-context c)             (format nil "~a" c)))))(define-condition control-error (error))(define-condition package-error (error)  ((package :initarg :package :reader package-error-package)))(define-condition no-such-package (package-error)  ()  (:report (lambda (c s) (format s (%rsc-string $xnopkg) (package-error-package c)))))(define-condition unintern-conflict-error (package-error)  ((sym-to-unintern :initarg :sym)   (conflicting-syms :initarg :conflicts))  (:report (lambda (c s)             (format s (%rsc-string $xunintc) (slot-value c 'sym-to-unintern) (package-error-package c) (slot-value c 'conflicting-syms)))))(define-condition import-conflict-error (package-error)  ((imported-sym :initarg :imported-sym)   (conflicting-sym :initarg :conflicting-sym)   (conflict-external-p :initarg :conflict-external))  (:report (lambda (c s)             (format s (%rsc-string (if (slot-value c 'conflict-external-p) $ximprtcx $ximprtc))                     (slot-value c 'imported-sym)                     (package-error-package c)                     (slot-value c 'conflicting-sym)))))(define-condition use-package-conflict-error (package-error)  ((package-to-use :initarg :package-to-use)   (conflicts :initarg :conflicts)   (external-p :initarg :external-p))  (:report (lambda (c s)             (format s (%rsc-string (if (slot-value c 'external-p) $xusecX $xusec))                     (slot-value c 'package-to-use)                     (package-error-package c)                     (slot-value c 'conflicts)))))(define-condition export-conflict-error (package-error)  ((conflicts :initarg :conflicts))  (:report    (lambda (c s)     (format s "Name conflict~p detected by ~A :" (length (slot-value c 'conflicts)) 'export)     (let* ((package (package-error-package c)))       (dolist (conflict (slot-value c 'conflicts))         (destructuring-bind (inherited-p sym-to-export using-package conflicting-sym) conflict           (format s "~&~A'ing ~S from ~S would cause a name conflict with ~&~                      the ~a symbol ~S in the package ~s, which uses ~S."                   'export                    sym-to-export                    package                    (if inherited-p "inherited" "present")                   conflicting-sym                   using-package                   package)))))))  (define-condition package-name-conflict-error (package-error simple-error) ())(define-condition stream-error (error)  ((stream :initarg :stream :reader stream-error-stream)))(define-condition end-of-file (stream-error) ()  (:report (lambda (c s)             (format s "Unexpected end of file on ~s" (stream-error-stream c)))))(define-condition modify-read-only-buffer (error) ()  (:report (lambda (c s)             (declare (ignore c))             (format s "Cannot modify a read-only buffer"))))(define-condition file-error (simple-condition error)  ((pathname :initarg :pathname :reader file-error-pathname)   (error-type :initarg :error-type :initform "File error on file ~S"))  (:report (lambda (c s)              (apply #'format s (slot-value c 'error-type)                      (file-error-pathname c)                     (simple-condition-format-arguments c)))))(define-condition cell-error (error)  ((name :initarg :name :reader cell-error-name)   (error-type :initarg :error-type :initform "Cell error" :reader cell-error-type))  (:report (lambda (c s) (format s "~A: ~S" (cell-error-type c) (cell-error-name c)))))(define-condition unbound-variable (cell-error)  ((error-type :initform "Unbound variable")))(define-condition undefined-function (cell-error)  ((error-type :initform "Undefined function")))(define-condition undefined-function-call (control-error undefined-function)  ((function-name :initarg :function-name :reader undefined-function-call-name)   (function-arguments :initarg :function-arguments :reader undefined-function-call-arguments))  (:report (lambda (c s) (format s "Undefined function ~S called with arguments ~:S ."                                 (undefined-function-call-name c)                                 (undefined-function-call-arguments c)))))(define-condition arithmetic-error (simple-error)  ((operation :initform nil :initarg :operation :reader arithmetic-error-operation)   (operands :initform nil :initarg :operands :reader arithmetic-error-operands)))(define-condition division-by-zero (arithmetic-error))(define-condition floating-point-underflow (arithmetic-error))(define-condition floating-point-overflow (arithmetic-error))(defun restartp (thing)   (istruct-typep thing 'restart))(setf (type-predicate 'restart) 'restartp)(defmethod print-object ((restart restart) stream)  (let ((report (%restart-report restart)))    (cond ((or *print-escape* (null report))           (print-unreadable-object (restart stream :identity t)             (format stream "~S ~S"                     'restart (%restart-name restart))))          ((stringp report)           (write-string report stream))          (t           (funcall report stream)))))(defun %make-restart (name action report interactive test)  (%cons-restart name action report interactive test))(defun make-restart (vector name action-function &key report-function interactive-function test-function)  (unless vector (setq vector (%cons-restart nil nil nil nil nil)))  (setf (%restart-name vector) name        (%restart-action vector) (require-type action-function 'function)        (%restart-report vector) (if report-function (require-type report-function 'function))        (%restart-interactive vector) (if interactive-function (require-type interactive-function 'function))        (%restart-test vector) (if test-function (require-type test-function 'function)))  vector)(defun restart-name (restart)  (%restart-name (require-type restart 'restart)))(defun applicable-restart-p (restart condition)  (let* ((pair (assq restart *condition-restarts*))         (test (%restart-test restart)))    (and (or (null pair) (eq (%cdr pair) condition))         (or (null test) (funcall test condition)))))(defun compute-restarts (&optional condition &aux restarts)  (dolist (cluster %restarts% (nreverse restarts))    (if (null condition)      (setq restarts (nreconc (copy-list cluster) restarts))      (dolist (restart cluster)        (when (applicable-restart-p restart condition)          (push restart restarts))))))(defun find-restart (name &optional condition)  (dolist (cluster %restarts%)    (dolist (restart cluster)      (when (and (or (eq restart name) (eq (restart-name restart) name))                 (or (null condition)                     (applicable-restart-p restart condition)))	(return-from find-restart restart)))))(defun %active-restart (name)  (dolist (cluster %restarts%)    (dolist (restart cluster)      (when (or (eq restart name) (eq (%restart-name restart) name))        (return-from %active-restart (values restart cluster)))))  (error "Restart ~S is not active." name))(defun invoke-restart (restart &rest values)  (multiple-value-bind (restart tag) (%active-restart restart)    (let ((fn (%restart-action restart)))      (cond ((null fn)                  ; simple restart             (unless (null values) (%err-disp $xtminps))             (throw tag (values nil T)))            ((fixnump fn)               ; restart case             (throw tag (cons fn values)))            (t (apply fn values))))))   ; restart bind(defun invoke-restart-no-return (restart)  (invoke-restart restart)  (error 'restart-failure :restart restart))(defun invoke-restart-interactively (restart)  (multiple-value-bind (restart tag) (%active-restart restart)    (format *error-output* "~&Invoking restart: ~a~&" restart)    (let* ((argfn (%restart-interactive restart))           (values (when argfn (funcall argfn)))           (fn (%restart-action restart)))      (cond ((null fn)                  ; simple restart             (unless (null values) (%err-disp $xtminps))             (throw tag (values nil T)))            ((fixnump fn)               ; restart case             (throw tag (cons fn values)))            (t (apply fn values))))))   ; restart bind(defun maybe-invoke-restart (restart value condition)  (let ((restart (find-restart restart condition)))    (when restart (invoke-restart restart value))))(defun use-value (value &optional condition)  (maybe-invoke-restart 'use-value value condition))(defun store-value (value &optional condition)  (maybe-invoke-restart 'store-value value condition))(defun condition-arg (thing args type)  (cond ((condition-p thing) (if args (%err-disp $xtminps) thing))        ((symbolp thing) (apply #'make-condition thing args))        (t (make-condition type :format-string thing :format-arguments args))))(defun make-condition (name &rest init-list &aux class)  (declare (dynamic-extent init-list))  (if (and (setq class (find-class name nil))           (condition-p (class-prototype class)))    (apply #'make-instance class init-list)    (error "~S is not a defined condition type name" name)))(defmethod print-object ((c condition) stream)  (if *print-escape*     (call-next-method)    (report-condition c stream)))(defmethod report-condition ((c condition) stream)  (princ (cond ((typep c 'error) "Error ")               ((typep c 'warning) "Warning ")               (t "Condition "))         stream)  ;Here should dump all slots or something.  For now...  (let ((*print-escape* t))    (print-object c stream)))(defun signal-simple-condition (class-name format-string &rest args)  (let ((e #'error))  ; Never-tail-call.    (funcall e (make-condition class-name :format-string format-string :format-arguments args))))(defun signal-simple-program-error (format-string &rest args)  (apply #'signal-simple-condition 'simple-program-error format-string args));;getting the function name for error functions.(defun %last-fn-on-stack (&optional (number 0) (s (%get-frame-ptr)))  (let* ((fn nil)         (sg *current-stack-group*))    (let ((p s))      (tagbody        (dotimes (i number)          (declare (fixnum i))          (unless (setq p (parent-frame p sg))            (go done)))        (if (setq p (parent-frame p sg))          (setq fn (cfp-lfun p sg)))        done))    fn)) (defun %err-fn-name (lfun)  "given an lfun returns the name or the string \"Unknown\""  (if (lfunp lfun) (or (lfun-name lfun) lfun)     (or lfun "Unknown")))(defun %real-err-fn-name (error-pointer)  (let ((name (%err-fn-name (%last-fn-on-stack 0 error-pointer))))    (if (memq name '(event-dispatch call-check-regs))      (%err-fn-name (%last-fn-on-stack 1 error-pointer))      name)));; Some simple restarts for simple error conditions.  Callable from the kernel.(defun %kernel-restart (error-type &rest args)  ;(declare (dynamic-extent args))  (dolist (f *kernel-restarts* (apply #'%err-disp error-type args))    (when (eq (car f) error-type)      (return (apply (cdr f) args)))))(def-kernel-restart $xvunbnd %default-unbound-variable-restarts (cell-name)  (if (fixnump cell-name)    (setq cell-name (nilreg-cell-symbol cell-name)))  (let ((condition (make-condition 'unbound-variable :name cell-name)))    (flet ((new-value ()             (catch-cancel              (return-from new-value                           (list (read-from-string                                   (get-string-from-user                                   (format nil "New value for ~s : " cell-name))))))             (continue condition))) ; force error again if cancelled, var still not set.      (restart-case (%error condition nil (%get-frame-ptr))        (continue ()                  :report (lambda (s) (format s "Retry getting the value of ~S." cell-name))                  (symbol-value cell-name))        (use-value (value)                   :interactive new-value                   :report (lambda (s) (format s "Specify a value of ~S to use this time." cell-name))                   value)        (store-value (value)                     :interactive new-value                     :report (lambda (s) (format s "Specify a value of ~S to store and use." cell-name))                     (setf (symbol-value cell-name) value))))))(def-kernel-restart $xnopkg %default-no-package-restart (package-name)  (or (and *autoload-lisp-package*           (or (string-equal package-name "LISP")                (string-equal package-name "USER"))           (progn             (require "LISP-PACKAGE")             (find-package package-name)))      (let* ((alias (or (%cdr (assoc package-name '(("LISP" . "COMMON-LISP")                                                    ("USER" . "CL-USER"))                                      :test #'string-equal))                        (if (packagep *package*) (package-name *package*))))             (condition (make-condition 'no-such-package :package package-name)))        (flet ((try-again (p)                          (or (find-package p) (%kernel-restart $xnopkg p))))          (restart-case            (restart-case (%error condition nil (%get-frame-ptr))              (continue ()                        :report (lambda (s) (format s "Retry finding package with name ~S." package-name))                        (try-again package-name))              (use-value (value)                         :interactive (lambda () (block nil                                                    (catch-cancel                                                    (return (list (get-string-from-user                                                                   "Find package named : "))))                                                   (continue condition)))                         :report (lambda (s) (format s "Find specified package instead of ~S ." package-name))                         (try-again value))              (make-nickname ()                             :report (lambda (s) (format s "Make ~S be a nickname for package ~S." package-name alias))                             (let ((p (try-again alias)))                               (push package-name (cdr (pkg.names p)))                               p)))            (require-lisp-package ()                                  :test (lambda (c)                                          (and (eq c condition)                                               (or (string-equal package-name "LISP") (string-equal package-name "USER"))))                                  :report (lambda (s)                                             (format s "(require :lisp-package) and retry finding package ~s"                                                    package-name))                                  (require "LISP-PACKAGE")                                  (try-again package-name)))))))(def-kernel-restart $xunintc unintern-conflict-restarts (sym package conflicts)  (let ((condition (make-condition 'unintern-conflict-error :package package :sym sym :conflicts conflicts)))    (restart-case (%error condition nil (%get-frame-ptr))      (continue ()                :report (lambda (s) (format s "Try again to unintern ~s from ~s" sym package))                (unintern sym package))      (do-shadowing-import (ssym)                           :report (lambda (s) (format s "SHADOWING-IMPORT one of ~S in ~S." conflicts package))                           :interactive (lambda ()                                          (block nil                                            (catch-cancel                                             (return (select-item-from-list conflicts                                                                             :window-title                                                                             (format nil "Shadowing-import one of the following in ~s" package)                                                                            :table-print-function #'prin1)))                                            (continue condition)))                           (shadowing-import (list ssym) package)))))(def-kernel-restart $xusec blub (package-to-use using-package conflicts)  (resolve-use-package-conflict-error package-to-use using-package conflicts nil))(def-kernel-restart $xusecX blub (package-to-use using-package conflicts)  (resolve-use-package-conflict-error package-to-use using-package conflicts t))(defun resolve-use-package-conflict-error (package-to-use using-package conflicts external-p)  (let ((condition (make-condition 'use-package-conflict-error                                    :package using-package                                   :package-to-use package-to-use                                   :conflicts conflicts                                   :external-p external-p)))    (flet ((external-test (&rest ignore) (declare (ignore ignore)) external-p)           (present-test (&rest ignore) (declare (ignore ignore)) (not external-p)))      (declare (dynamic-extent #'present-test #'external-test))      (restart-case (%error condition nil (%get-frame-ptr))        (continue ()                  :report (lambda (s) (format s "Try again to use ~s in ~s" package-to-use using-package)))        (resolve-by-shadowing-import (&rest shadowing-imports)                                     :test external-test                                     :interactive (lambda ()                                                    (mapcar #'(lambda (pair)                                                                 (block nil                                                                  (catch-cancel                                                                    (return (car (select-item-from-list pair                                                                                                        :window-title                                                                                                         (format nil "Shadowing-import one of the following in ~s" using-package)                                                                                                        :table-print-function #'prin1))))                                                                  (continue condition)))                                                            conflicts))                                     :report (lambda (s) (format s "SHADOWING-IMPORT one of each pair of conflicting symbols."))                                     (shadowing-import shadowing-imports using-package))        (unintern-all ()                      :test present-test                      :report (lambda (s) (format s "UNINTERN all conflicting symbols from ~S" using-package))                      (dolist (c conflicts)                        (unintern (car c) using-package)))        (shadow-all ()                      :test present-test                      :report (lambda (s) (format s "SHADOW all conflicting symbols in ~S" using-package))                      (dolist (c conflicts)                        (shadow-1 using-package (car c))))        (resolve-by-unintern-or-shadow (&rest dispositions)                                       :test present-test                                       :interactive (lambda ()                                                      (mapcar #'(lambda (pair)                                                                  (let* ((present-sym (car pair)))                                                                    (block nil                                                                      (catch-cancel                                                                        (return (car (select-item-from-list (list 'shadow 'unintern)                                                                                                             :window-title                                                                                                            (format nil "SHADOW ~S in, or UNINTERN ~S from ~S"                                                                                                                     present-sym                                                                                                                     present-sym                                                                                                                    using-package)                                                                                                            :table-print-function #'prin1)))                                                                        (continue condition)))))                                                              conflicts))                                       :report (lambda (s) (format s "SHADOW or UNINTERN the conflicting symbols in ~S." using-package))                                       (dolist (d dispositions)                                         (let* ((sym (car (pop conflicts))))                                           (if (eq d 'shadow)                                             (shadow-1 using-package sym)                                             (unintern sym using-package)))))))))(defun resolve-export-conflicts (conflicts package)  (let* ((first-inherited (caar conflicts))         (all-same (dolist (conflict (cdr conflicts) t)                     (unless (eq (car conflict) first-inherited) (return nil))))         (all-inherited (and all-same first-inherited))         (all-present (and all-same (not first-inherited)))         (condition (make-condition 'export-conflict-error                                    :conflicts conflicts                                    :package package)))    (flet ((check-again ()              (let* ((remaining-conflicts (check-export-conflicts (mapcar #'cadr conflicts) package)))               (if remaining-conflicts (resolve-export-conflicts remaining-conflicts package)))))      (restart-case (%error condition nil (%get-frame-ptr))        (resolve-all-by-shadowing-import-inherited          ()         :test (lambda (&rest ignore) (declare (ignore ignore)) all-inherited)         :report (lambda (s) (format s "SHADOWING-IMPORT all conflicting inherited symbol(s) in using package(s)."))         (dolist (conflict conflicts (check-again))           (destructuring-bind (using-package inherited-sym) (cddr conflict)             (shadowing-import-1 using-package inherited-sym))))        (resolve-all-by-shadowing-import-exported          ()         :test (lambda (&rest ignore) (declare (ignore ignore)) all-inherited)         :report (lambda (s) (format s "SHADOWING-IMPORT all conflicting symbol(s) to be exported in using package(s)."))         (dolist (conflict conflicts (check-again))           (destructuring-bind (exported-sym using-package ignore) (cdr conflict)             (declare (ignore ignore))             (shadowing-import-1 using-package exported-sym))))        (resolve-all-by-uninterning-present          ()         :test (lambda (&rest ignore) (declare (ignore ignore)) all-present)         :report (lambda (s) (format s "UNINTERN all present conflicting symbol(s) in using package(s)."))         (dolist (conflict conflicts (check-again))           (destructuring-bind (using-package inherited-sym) (cddr conflict)             (unintern inherited-sym using-package))))        (resolve-all-by-shadowing-present          ()         :test (lambda (&rest ignore) (declare (ignore ignore)) all-present)         :report (lambda (s) (format s "SHADOW all present conflicting symbol(s) in using package(s)."))         (dolist (conflict conflicts (check-again))           (destructuring-bind (using-package inherited-sym) (cddr conflict)             (shadow-1 using-package inherited-sym))))        (review-and-resolve          (dispositions)         :report (lambda (s) (format s "Review each name conflict and resolve individually."))         :interactive (lambda ()                        (let* ((disp nil))                          (block b                            (catch-cancel                              (dolist (conflict conflicts (return-from b (list disp)))                                (destructuring-bind (inherited-p exported-sym using-package conflicting-sym) conflict                                  (let* ((syms (list exported-sym conflicting-sym)))                                    (if inherited-p                                      (push (list 'shadowing-import                                                  (select-item-from-list syms                                                                              :window-title                                                                               (format nil "Shadowing-import one of the following in ~s" using-package)                                                                              :table-print-function #'prin1)                                                  using-package)                                            disp)                                      (let* ((selection (car (select-item-from-list syms                                                                                    :window-title                                                                                     (format nil "Shadow ~S or unintern ~s in ~s"                                                                                            exported-sym                                                                                             conflicting-sym using-package)                                                                                    :table-print-function #'prin1))))                                        (push (if (eq selection 'exported-sym)                                                (list 'shadow (list exported-sym) using-package)                                                (list 'unintern conflicting-sym using-package))                                              disp)))))))                            nil)))         (dolist (disp dispositions (check-again))           (apply (car disp) (cdr disp))))))))(def-kernel-restart $xwrongtype default-require-type-restarts (value typespec)  (setq typespec (%type-error-type typespec))  (let ((condition (make-condition 'type-error                                    :datum value                                   :expected-type typespec)))    (restart-case (%error condition nil (%get-frame-ptr))      (use-value (newval)                 :report (lambda (s)                           (format s "Use a new value of type ~s instead of ~s." typespec value))                 :interactive (lambda ()                                (format *query-io* "~&New value of type ~S :" typespec)                                (list (read *query-io*)))                 (require-type newval typespec)))))(def-kernel-restart $xudfcall default-undefined-function-call-restarts (function-name args)  (if (fixnump function-name)    (setq function-name (nilreg-cell-symbol function-name)))  (let ((condition (make-condition 'undefined-function-call                                   :function-name function-name                                   :function-arguments args)))    (restart-case (%error condition nil (%get-frame-ptr))      (continue ()                :report (lambda (s) (format s "Retry applying ~S to ~S." function-name args))                (apply function-name args))      (use-value (function)                 :interactive (lambda ()                                (format *query-io* "Function to apply instead of ~s :" function-name)                                (let ((f (read *query-io*)))                                  (unless (symbolp f) (setq f (eval f))) ; almost-the-right-thing (tm)                                  (list (coerce f 'function))))                 :report (lambda (s) (format s "Apply specified function to ~S this time." args))                 (apply function args))      (store-value (function)                   :interactive (lambda ()                                (format *query-io* "Function to apply as new definition of ~s :" function-name)                                (let ((f (read *query-io*)))                                  (unless (symbolp f) (setq f (eval f))) ; almost-the-right-thing (tm)                                  (list (coerce f 'function))))                   :report (lambda (s) (format s "Specify a function to use as the definition of ~S." function-name))                   (apply (setf (symbol-function function-name) function) args))))); This expects to get an argument only when the stack has not already; been extended. In that case, it uses the argument to report how; much has been requested and to extend by at least that amount.; The kernel has extended the max stack size by $default_segment_size so; that this code will have a chance to run. If we throw out, it will; restore it.(def-kernel-restart $xstkover stack-overflow-restarts (&optional bytes-needed-in)  (let* ((sgbuf (sg-buffer *current-stack-group*))         (bytes-needed (or bytes-needed-in (stack-group-size)))         (condition (make-condition 'stack-overflow-condition                                    :format-string "Stack overflow. Min stack size needed (bytes): ~s"                                    :format-arguments (list bytes-needed))))    (restart-case (%error condition nil (%get-frame-ptr))      (continue ()                :report (lambda (s) (format s "make the stack larger."))                (setf (sgbuf.maxsize sgbuf)                      (min (floor most-positive-fixnum 2)                           (+ bytes-needed (floor bytes-needed 4)))))))); This has to be defined fairly early (assuming, of course, that it "has" to be defined at all ...(defun ensure-value-of-type (value typespec placename &optional (typename typespec))  (declare (resident))  (tagbody    again    (unless (typep value typespec)      (let ((condition (make-condition 'type-error                                        :datum value                                       :expected-type typename)))        (restart-case (%error condition nil (%get-frame-ptr))          (store-value (newval)                       :report (lambda (s)                                 (format s "Assign a new value of type ~a to ~s" typespec placename))                       :interactive (lambda ()                                      (format *query-io* "~&New value for ~S :" placename)                                      (list (eval (read))))                       (setq value newval)                       (go again))))))  value);;;The Error Function(defparameter *kernel-simple-error-classes*  (list (cons $xcalltoofew 'simple-destructuring-error)        (cons $xcalltoomany 'simple-destructuring-error)        (cons $xstkover 'stack-overflow-condition)        (cons $xmemfull 'simple-storage-condition)        (cons $xwrongtype 'type-error) ; this one needs 2 args        (cons $xdivzro 'division-by-zero)        (cons $xflovfl 'floating-point-overflow)        (cons $xfunbnd 'undefined-function))); do we like this?(defparameter *simple-error-types*  (%gvector $v_genv nil 'simple-program-error 'file-error))(defconstant $pgm-err #x10000); this is the def of %err-disp(defun %err-disp (err-num &rest errargs)  (declare (fixnum err-num))  (when (and (or (eq err-num $xvunbnd) (eq err-num $xfunbnd))             (null (%cdr errargs))             (fixnump (%car errargs)))    (%rplaca errargs (nilreg-cell-symbol (%car errargs))))  ; The compiler (finally !) won't tail-apply error.  But we kind of  ; expect it to ...  (let* ((err-typ (max (ash err-num -16) 0))         (err-num (%word-to-int err-num))         (format-string (%rsc-string err-num))         (condition-name (or (uvref *simple-error-types* err-typ)                             (%cdr (assq err-num *kernel-simple-error-classes*)))))    (if condition-name            (funcall 'error               (case condition-name                 (type-error (make-condition condition-name                                             :format-string format-string                                             :datum (car errargs)                                             :expected-type (%type-error-type (cadr errargs))))                 (file-error (make-condition condition-name                                             :pathname (car errargs)                                             :error-type format-string                                             :format-arguments (cdr errargs)))                 (undefined-function (make-condition condition-name                                                     :name (car errargs)))                 (t (make-condition condition-name                                     :format-string format-string                                    :format-arguments errargs))))      (apply 'error format-string errargs))))(defparameter %type-error-typespecs%  #(array    bignum    fixnum    character    integer    list    number    sequence    simple-string    simple-vector    string    symbol    macptr    real    cons    unsigned-byte    (integer 2 36)    float))(defun %type-error-type (type)  (if (fixnump type)     (svref %type-error-typespecs% type)    type))(defun %typespec-id (typespec)  (flet ((type-equivalent (t1 t2) (ignore-errors (and (subtypep t1 t2) (subtypep t2 t1)))))    (position typespec %type-error-typespecs% :test #'type-equivalent)))(defun error (condition &rest args)  (%error condition args (%get-frame-ptr)))(defmethod condition-p ((x t)) nil)(defmethod condition-p ((x condition)) t)(defun cerror (cont-string condition &rest args)  (let* ((fp (%get-frame-ptr))         (eval-queue *eval-queue*))    (restart-case (%error condition (if (condition-p condition) nil args) fp)      (continue ()                :report (lambda (stream)                             (apply #'format stream cont-string args))                (setq *eval-queue* eval-queue)                nil))))(let* ((globals ()))  (defun %check-error-globals ()    (let ((vars ())          (valfs ())          (oldvals ()))      (dolist (g globals (values vars valfs oldvals))        (destructuring-bind (sym predicate newvalf) g          (let* ((boundp (boundp sym))                 (oldval (if boundp (symbol-value sym) (%unbound-marker-8))))          (unless (and boundp (funcall predicate oldval))            (push sym vars)            (push oldval oldvals)            (push newvalf valfs)))))))  (defun check-error-global (sym checkfn newvalfn)    (setq sym (require-type sym 'symbol)          checkfn (require-type checkfn 'function)          newvalfn (require-type newvalfn 'function))    (let ((found (assq sym globals)))      (if found        (setf (cadr found) checkfn (caddr found) newvalfn)        (push (list sym checkfn newvalfn) globals))      sym)))(check-error-global '*package* #'packagep #'(lambda () (find-package "CL-USER")))(let* ((terminal-io-test #'(lambda (s) (typep s 'terminal-io)))       (new-terminal-io #'(lambda () (make-instance 'terminal-io))))  (check-error-global '*terminal-io* terminal-io-test new-terminal-io)  (check-error-global '*debug-io* #'streamp new-terminal-io)  (check-error-global '*error-output* #'streamp #'(lambda () (make-instance 'pop-up-terminal-io))))  (defun %error (condition args error-pointer)  (setq condition (condition-arg condition args 'simple-error))  ;(with-pstrs ((str (format nil "error: ~a" condition))) (#_DebugStr str))    (signal condition)  ;(with-pstrs ((str (format nil "error: ~a" condition))) (#_DebugStr str))  (application-error *application* condition error-pointer)  (application-error   *application*   (condition-arg "~s returned. It shouldn't.~%If it returns again, I'll throw to toplevel."                  '(application-error) 'simple-error)   error-pointer)  (toplevel));; Application classes(defconstant default-app-creator :|????|)(defclass application ()  ())(defun eval-enqueue (form)  (application-eval-enqueue *application* form))(defmethod application-eval-enqueue ((app application) form)  (if (functionp form)    (funcall form)    (if (and (consp form)(functionp (car form)))      (apply (car form) (cdr form))      (eval form)))); an example method to base a specialization on(defmethod toplevel-function ((a application) init-file)  (declare (ignore init-file))  (let* ((file-list (finder-parameters))         (spec (cdr file-list)))    (case (car file-list)      (:open        (if spec          (dolist (f spec)            (open-application-document *application* f t))          (open-application a t)))      (:print       (dolist (f spec)         (print-application-document *application* f t))))    (startup-finished)    (catch :toplevel      (loop (event-dispatch))))); specialize this for your application(defmethod print-application-document ((a application) path &optional startup)  (declare (ignore path startup))); specialize this for your application(defmethod open-application ((self application) startup)  (declare (ignore startup))  nil)  ; specialize this for your application(defmethod open-application-document ((a application) path &optional startup)  (declare (ignore path startup)))(defmethod application-file-creator  ((app application)) default-app-creator)(defmethod application-name          ((app application)) nil)(defmethod application-resource-file ((app application)) nil)(defmethod application-sizes         ((app application)) nil)(defmethod application-init-file     ((app application)) nil)(defmethod application-about-view ((app application))  (make-dialog-item 'static-text-dialog-item                    #@(15 20)                    nil                    (application-name app)))(defmethod application-about-dialog ((app application))  (let* ((about-view (application-about-view app))         (view-size (view-size about-view))         (next-y (if view-size                   (+ (point-v (view-position about-view))                      (point-v view-size)                      15)                   50))         (dialog-width  (if view-size                          (max (point-h view-size) 350)                          350))         (dialog-height (if view-size                          (max (+ (point-v view-size) 100) 150)                          150)))    (make-instance 'dialog      :auto-position :centermainscreen      :view-size (make-point dialog-width dialog-height)      :window-type :double-edge-box      :window-show nil      :view-subviews      (list       about-view       (make-dialog-item 'static-text-dialog-item                         (make-point 15 next-y)                         #@(300 60)                         "Written in Macintosh Common Lisp."                         nil                         :view-font '("Geneva" 9))       (make-dialog-item 'default-button-dialog-item                         (make-point (ash (- dialog-width 70) -1)                                     (incf next-y 70))                         #@(70 18)                         "OK"                         #'(lambda (item)                             (declare (ignore item))                             (return-from-modal-dialog t)))))))(defclass lisp-development-system (application)   ())(defmethod toplevel-function ((a lisp-development-system) init-file)  (startup-ccl init-file)  (if *single-process-p*                ; not really right, but ...    (progn      (%set-toplevel #'(lambda ()                          (unless *inhibit-greeting*                             (format t "~&Welcome to ~A ~A!~%"                                    (lisp-implementation-type)                                    (lisp-implementation-version)))                          (toplevel-loop)))      (toplevel))    (make-mcl-listener-process)))(defmethod application-file-creator ((app lisp-development-system))  *ccl-file-creator*)(defmethod application-init-file ((app lisp-development-system))  "init"); redefined by hide-listener-support(defmethod application-error ((a application) condition error-pointer)  (declare (ignore condition error-pointer))  (quit))(defun error-header (kind)  (let ((pname (process-name *current-process*)))    (if (and pname (not (string-equal pname *main-listener-process-name*)))      (format nil "~A in process ~A" kind pname)      (format nil "~A" kind))))(defun signal (condition &rest args)  (setq condition (condition-arg condition args 'simple-condition))  (lds   (when (typep condition *break-on-signals*)     (let ((*break-on-signals* nil))       (cbreak-loop "Signal" "Signal the condition." condition (%get-frame-ptr)))))  (let ((%handlers% %handlers%))    (while %handlers%      (do* ((tag (pop %handlers%)) (handlers tag (cddr handlers)))           ((null handlers))        (when (typep condition (car handlers))          (let ((fn (cadr handlers)))            (cond ((null fn) (throw tag condition))                  ((fixnump fn) (throw tag (cons fn condition)))                  (t (return (funcall fn condition))))))))))(defvar *printing-break-message* nil)(defvar *error-print-circle* nil)   ; reset to T when we actually can print-circle(defun release-locked-windows (&optional (process *current-process*))  (let ((res nil))    (do-all-windows w      (let ((q (window-process-queue w)))        (when (and q (eq process (process-queue-locker q)))          (push q res)          (process-dequeue q process))))    res));;;***********************************;;;Mini-evaluator;;;***********************************(defun new-lexical-environment (&optional parent)  (%istruct 'lexical-environment parent nil nil nil nil nil nil))(defmethod make-load-form ((e lexical-environment))  nil)(defun new-definition-environment (&optional (type 'compile-file))  (%istruct 'definition-environment (list type)  nil nil nil nil nil nil nil nil nil nil nil))(defun definition-environment (env &optional clean-only &aux parent)  (if (and env (not (istruct-typep env 'lexical-environment))) (report-bad-arg env 'lexical-environment))  (do* ()        ((or (null env)             (listp (setq parent (lexenv.parent-env env)))            (and clean-only (or (lexenv.variables env) (lexenv.functions env)))))    (setq env parent))  (if (consp parent)    env))(defvar *macroexpand-hook* 'funcall) ; Should be #'funcall. ;(queue-fixup (setq *macroexpand-hook* #'funcall)) ;  No it shouldn't.(defun macroexpand-1 (form &optional env &aux fn (expansion form) win)  (declare (resident))  (if (and (consp form)           (symbolp (%car form))           (setq fn (macro-function (%car form) env)))    (setq expansion (funcall *macroexpand-hook* fn form env)          win t)    (if (and form env (symbolp form))      (if (istruct-typep env 'lexical-environment)        (do* ((env env (lexenv.parent-env env)))             ((or win (null env) (eq (%svref env 0) 'definition-environment)) (setq win (not (null win))))          (let ((vars (lexenv.variables env)))            (when (consp vars)              (let ((info (dolist (var vars)                            (if (eq (var-name var) form)                              (return var)))))                            (when info                  (when (and (consp (setq info (var-expansion info)))                             (eq (%car info) :symbol-macro))                    (setq win t expansion (%cdr info)))                  (unless win (return)))))))        (report-bad-arg env 'lexical-environment))))   (values expansion win))(defun macroexpand (form &optional env)  (declare (resident))  (multiple-value-bind (new win) (macroexpand-1 form env)    (do* ((won-at-least-once win))         ((null win) (values new won-at-least-once))      (multiple-value-setq (new win) (macroexpand-1 new env)))))(defun %symbol-macroexpand (form env &aux win won)  ; Keep expanding until no longer a symbol-macro or no longer a symbol.  (loop    (unless (and form (symbolp form)) (return))    (multiple-value-setq (form win) (macroexpand-1 form env))    (if win (setq won t) (return)))  (values form won))(defun retain-lambda-expression (name lambda-expression env)  (if (and (let* ((lambda-list (cadr lambda-expression)))             (and (not (memq '&lap lambda-list))                  (not (memq '&method lambda-list))                  (not (memq '&restv lambda-list))))           (nx-declared-inline-p name env)           (not (gethash name *nx1-alphatizers*))           ; A toplevel definition defined inside a (symbol-)macrolet should           ; be inlineable.  It isn't; call DEFINITION-ENVIRONMENT with a           ; "clean-only" argument to ensure that there are no lexically           ; bound macros or symbol-macros.           (definition-environment env t))    lambda-expression)); This is different from AUGMENT-ENVIRONMENT.; If "info" is a lambda expression, then;  record a cons whose CAR is (encoded-lfun-bits . keyvect) and whose cdr;  is the lambda expression iff the function named by "name" is ;  declared/proclaimed INLINE in env(defun note-function-info (name lambda-expression env)  (let ((definition-env (definition-environment env)))    (if definition-env      (let* ((already (assq (setq name (maybe-setf-function-name name))                            (defenv.defined definition-env)))             (info nil))        (when (lambda-expression-p lambda-expression)          (multiple-value-bind (lfbits keyvect) (encode-lambda-list lambda-expression t)            (setq info (cons (cons lfbits keyvect)                              (retain-lambda-expression name lambda-expression env)))))          (if already            (if info (%rplacd already info))            (push (cons name info) (defenv.defined definition-env)))))    name)); And this is different from FUNCTION-INFORMATION.(defun retrieve-environment-function-info (name env) (let ((defenv (definition-environment env)))   (if defenv (assq (maybe-setf-function-name name) (defenv.defined defenv)))))(defun maybe-setf-function-name (name)  (if (and (consp name) (eq (car name) 'setf))    (setf-function-name (cadr name))    name)); Must differ from -something-, but not sure what ... (defun note-variable-info (name info env)  (let ((definition-env (definition-environment env)))    (if definition-env (push (cons name info) (defenv.specials definition-env)))    name))(defun compile-file-environment-p (env)  (let ((defenv (definition-environment env)))    (and defenv (eq 'compile-file (car (defenv.type defenv))))))(defun cheap-eval (form)  (cheap-eval-in-environment form nil)); used by nfcomp too; Should preserve order of decl-specs; it sometimes matters.(defun decl-specs-from-declarations (declarations)  (let ((decl-specs nil))    (dolist (declaration declarations decl-specs)      ;(unless (eq (car declaration) 'declare) (say "what"))      (dolist (decl-spec (cdr declaration))        (setq decl-specs (nconc decl-specs (list decl-spec)))))))(defun cheap-eval-in-environment (form env &aux sym)  (declare (resident))  (flet ((progn-in-env (body&decls parse-env base-env)           (multiple-value-bind (body decls) (parse-body body&decls parse-env)             (setq base-env (augment-environment base-env :declare (decl-specs-from-declarations decls)))             (while (cdr body)               (cheap-eval-in-environment (pop body) base-env))             (cheap-eval-in-environment (car body) base-env))))    (if form      (cond ((symbolp form)              (multiple-value-bind (expansion win) (macroexpand-1 form env)               (if win                  (cheap-eval-in-environment expansion env)                  (let* ((defenv (definition-environment env))                        (constant (if defenv (assq form (defenv.constants defenv))))                        (constval (%cdr constant)))                   (if constant                     (if (neq (%unbound-marker-8) constval)                       constval                       (error "Can't determine value of constant symbol ~s" form))                      (symbol-value form))))))            ((atom form) form)            ((eq (setq sym (%car form)) 'quote)             (verify-arg-count form 1 1)             (%cadr form))            ((eq sym 'function)             (verify-arg-count form 1 1)             (cond ((symbolp (setq sym (%cadr form)))                    (%function sym))                   ((and (consp sym) (eq (%car sym) 'setf) (consp (%cdr sym)) (null (%cddr sym)))                    (%function (setf-function-name (%cadr sym))))                   (t (%make-function nil sym env))))            ((eq sym 'nfunction)             (verify-arg-count form 2 2)             (%make-function (%cadr form) (%caddr form) env))            ((eq sym 'progn) (progn-in-env (%cdr form) env env))            ((eq sym 'setq)             (if (not (%ilogbitp 0 (list-length form)))               (verify-arg-count form 0 0)) ;Invoke a "Too many args" error.             (let* ((sym nil)                    (val nil))               (while (setq form (%cdr form))                 (setq sym (require-type (pop form) 'symbol))                 (multiple-value-bind (expansion expanded)                                      (macroexpand-1 sym env)                   (if expanded                     (setq val (cheap-eval-in-environment `(setf ,expansion ,(%car form)) env))                     (set sym (setq val (cheap-eval-in-environment (%car form) env))))))               val))            ((eq sym 'eval-when)             (destructuring-bind (when . body) (%cdr form)               (when (or (memq 'eval when) (memq :execute when)) (progn-in-env body env env))))            ((eq sym 'if)             (destructuring-bind (test true &optional false) (%cdr form)               (cheap-eval-in-environment (if (cheap-eval-in-environment test env) true false) env)))            ((eq sym 'locally) (progn-in-env (%cdr form) env env))            ((eq sym 'symbol-macrolet)             (progn-in-env (cddr form) env (augment-environment env :symbol-macro (cadr form))))            ((eq sym 'macrolet)             (let ((temp-env (augment-environment env                                                  :macro                                                   (mapcar #'(lambda (m)                                                              (destructuring-bind (name arglist &body body) m                                                                (list name (enclose (parse-macro name arglist body env)                                                                                    env))))                                                          (cadr form)))))               (progn-in-env (cddr form) temp-env temp-env)))            ((and (symbolp sym)                   (compiler-special-form-p sym)                  (not (functionp (fboundp sym))))             (if (eq sym 'unwind-protect)               (destructuring-bind (protected-form . cleanup-forms) (cdr form)                 (unwind-protect                   (cheap-eval-in-environment protected-form env)                   (progn-in-env cleanup-forms env env)))               (funcall (%make-function nil `(lambda () (progn ,form)) env))))            ((and (symbolp sym) (macro-function sym env))             (if (eq sym 'step)               (let ((*compile-definitions* nil))                     (cheap-eval-in-environment (macroexpand-1 form env) env))               (cheap-eval-in-environment (macroexpand-1 form env) env)))            ((or (symbolp sym)                 (and (consp sym) (eq (%car sym) 'lambda)))             (let ((args nil))               (dolist (elt (%cdr form)) (push (cheap-eval-in-environment elt env) args))               (apply #'call-check-regs (if (symbolp sym) sym (%make-function nil sym env))                      (nreverse args))))            (t (signal-simple-condition 'simple-program-error "Car of ~S is not a function name or lambda-expression." form))))))(%fhave 'eval #'cheap-eval)#+ppc-target(defppclapfunction get-saved-register-values ()  (vpush save0)  (vpush save1)  (vpush save2)  (vpush save3)  (vpush save4)  (vpush save5)  (vpush save6)  (vpush save7)  (la temp0 32 vsp)  (set-nargs 8)  (ba .SPvalues))#+ppc-target(defun call-check-regs (fn &rest args)  (declare (dynamic-extent args)           (optimize (debug 3)))        ; don't use any saved registers  (let ((old-regs (multiple-value-list (get-saved-register-values))))    (declare (dynamic-extent old-regs))    (multiple-value-prog1 (apply fn args)      (let* ((new-regs (multiple-value-list (get-saved-register-values)))             (new-regs-tail new-regs))        (declare (dynamic-extent new-regs))        (unless (dolist (old-reg old-regs t)                  (unless (eq old-reg (car new-regs-tail))                    (return nil))                  (pop new-regs-tail))          (apply 'error "Registers clobbered applying ~s to ~s~%~@{~a sb: ~s, Was: ~s~%~}"                 fn args                 (mapcan 'list                         (let ((res nil))                           (dotimes (i (length old-regs))                             (push (format nil "save~d" i) res))                           (nreverse res))                         old-regs                         new-regs)))))))#-ppc-target(defun call-check-regs (fn &rest args)  (declare (dynamic-extent args))  (declare (optimize (debug 3))) ; no register allocation  (let* ((dsave0 (lap-inline () (move.l dsave0 acc)))         (dsave1 (lap-inline () (move.l dsave1 acc)))         (dsave2 (lap-inline () (move.l dsave2 acc)))         (asave0 (lap-inline () (move.l asave0 acc)))         (asave1 (lap-inline () (move.l asave1 acc))))    (multiple-value-prog1 (apply fn args)      (let* ((ndsave0 (lap-inline () (move.l dsave0 acc)))             (ndsave1 (lap-inline () (move.l dsave1 acc)))             (ndsave2 (lap-inline () (move.l dsave2 acc)))             (nasave0 (lap-inline () (move.l asave0 acc)))             (nasave1 (lap-inline () (move.l asave1 acc))))        (unless (and (eq dsave0 ndsave0)                     (eq dsave1 ndsave1)                     (eq dsave2 ndsave2)                     (eq asave0 nasave0)                     (eq asave1 nasave1))          (error "Registers clobbered applying ~S to ~S~%~@{~s SB: ~s, Was: ~s~%~}"                 fn args                 'dsave0 dsave0 ndsave0                 'dsave1 dsave1 ndsave1                 'dsave2 dsave2 ndsave2                 'asave0 asave0 nasave0                 'asave1 asave1 nasave1))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Stack frame accessors.(eval-when (compile eval)  (require 'lap)  (require 'lapmacros));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *name-char-alist*  '(("Null" . #\000) ("Nul" . #\000)    ("Home" . #\001)    ("Enter" . #\003)    ("End" . #\004)    ("Help" . #\005)    ("Bell"  . #\007) ; ^G , used by Franz    ("Delete" . #\010) ("Backspace" . #\010)("BS" . #\010)    ("Tab" . #\011)    ("Linefeed" . #\012) ("LF" . #\012)    ("PageUp" . #\013)    ("Page" . #\014)("PageDown" . #\014)("Formfeed" . #\014) ("FF" . #\014)    ("Newline" . #\015) ("Return" . #\015) ("CR" . #\015)    ("CommandMark" . #\021)    ("CheckMark" . #\022)    ("DiamondMark" . #\023)    ("AppleMark" . #\024)    ("ESC" .  #\033) ("Escape" . #\033) ("Clear" .  #\033)       ("Altmode" .  #\033) ("ALT" .  #\033)    ("BackArrow" . #\034) ("Backward-arrow" . #\034)    ("ForwardArrow" . #\035) ("Forward-arrow" . #\035)    ("UpArrow" . #\036) ("Up-arrow" . #\036)    ("DownArrow" . #\037) ("Down-arrow" . #\037)    ("Space" . #\040)    ("Dot" . #\245)    ("altCheckMark" . #\303)    ("DEL" . #\177)("ForwardDelete" . #\177) ("Rubout" . #\177)    )); Character names are stored in *NAME-CHAR-ALIST* which consists of; (name . char) where name must be a simple string and char must be; a character.;(NAME-CHAR name);If name has an entry in the *NAME-CHAR-ALIST*, return first such entry.;Otherwise, if it consists of one char, return it.;Otherwise, if it consists of two chars, the first of which  is ^,; return %code-char(c xor 64), where c is the uppercased second char.;Otherwise, if it consists of octal digits, the digits are; interpreted as the (mod 256) ascii code of a character.;Otherwise return NIL.(defun name-char (char)  (lap-inline ()    (:variable char)   (if# (ne (cmp.b ($ $t_imm_char) arg_z))     (jsr #'%%deref-sym-or-string)     (lea (atemp0 acc.l $v_data) atemp0)     (move.l arg_y acc)    else#     (lea (varg char $char.code) atemp0)  ; what's that?     (move.l ($ 1) acc))   (jsr #'%%name-char)));atemp0/acc = name(defun %%name-char (&lap 0)  (old-lap   (preserve_regs #(asave0 asave1 dsave2))   (move.l (special *name-char-alist*) dsave2)   @next   (bif (or (eq nilreg dsave2) (ne (ttagp ($ $t_cons) dsave2 da))) @noname)   (move.l dsave2 atemp1)   (car atemp1 asave0)                  ; asave0 = (name . char)   (cdr atemp1 dsave2)   (bif (ne (ttagp ($ $t_cons) asave0 da)) @next)   (car asave0 atemp1)                  ; atemp1 = name   (bif (ne (ttagp ($ $t_vector) atemp1 da)) @next)   (getvect atemp1 arg_y)   (move.l atemp0 asave1)   (cmp.l acc arg_y)   (bra @nextch)   @cmp   (move.b (@+ asave1) da)   (if# (and (ge (cmp.b ($ #\a) da)) (le (cmp.b ($ #\z) da)))     (sub.b ($ 32) da))   (move.b (@+ atemp1) db)   (if# (and (ge (cmp.b ($ #\a) db)) (le (cmp.b ($ #\z) db)))     (sub.b ($ 32) db))   (cmp.b da db)   @nextch   (bne @next)   (sub.l ($ 1) arg_y)   (bpl @cmp)   (cdr asave0 acc)   (unuse_regs)   (rts)   @noname   (restore_regs)   (if# (eq (sub.l ($ 1) acc))     ;(move.l ($ 0) acc)     (move.b (atemp0) acc)                ;"A" -> #\A     (swap acc)     (move.b ($ $t_imm_char) acc)     (rts))   (if# (and (eq (sub.l ($ 1) acc)) (eq (cmp.b ($ #\^) (atemp0))))     (move.b (atemp0 1) da)     (if# (and (ge (cmp.b ($ #\a) da)) (le (cmp.b ($ #\z) da)))       (sub.b ($ 32) da))     (eor ($ #x40) da)                    ;"^A" -> #\^A     ; (move.l ($ 0) acc)     (move.b da acc)     (swap acc)     (move.b ($ $t_imm_char) acc)     (rts))   (add.l ($ 2) acc)   (move.l ($ 0) da)   (prog#    (move.b (@+ atemp0) arg_y)    (sub.b ($ #\0) arg_y)    (cmp.b ($ 8) arg_y)    (bgeu @nil)    (lsl.w ($ 3) da)  ;<<                     ;"112" -> #\112    (add.b arg_y da)    (until# (eq (sub.l ($ 1) acc))))   ; (move.l ($ 0) acc)   (move.w da acc)    ;<<   (swap acc)   (move.b ($ $t_imm_char) acc)   (rts)   @nil   (move.l nilreg acc)   (rts)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			Readtables					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Readtable = istructure with data [1] type-table and [2] macro-char-alist; Type-table is a 256 byte ivector with a type byte for each char.; macro-char-alist is a list of (char . defn).  The defn is either; a fixnum (built-in), or a cons of (initial-char . macro-char-alist) for; dispatch macros, or it is a function or a symbol to call for user macros.(defun readtablep (object) (istruct-typep object 'readtable))(defun readtable-arg (object)  (if (null object) (setq object *readtable*))  (unless (istruct-typep object 'readtable)    (report-bad-arg object 'readtable))  object)(defvar %initial-readtable%  (let* ((ttab (%make-uvector 256 $v_sbytev))         (wspc '(#\Null #\Tab #\Linefeed #\Page #\Return #\Space #\312)) ;$CA=non-break space         (macs `((#\( . 4)                 (#\; . 3)                 (#\' . 2)                 (#\" . 1)                 (#\# . (#\#                         (#\' . 13) (#\X . 12) (#\O . 11) (#\B . 10) (#\R . 9)                         (#\\ . 8)  (#\| . 7) (#\. . 6)                         (#\, . 5) (#\: . 4) (#\( . 3) (#\< . 2) (#\) . 1)                         ,@(mapcar #'(lambda (ch) (cons ch 0)) wspc)))                 (#\) . 0)))         (case (cdr (assq :upcase (readtable-case-keywords)))))    (dotimes (i 256) (declare (fixnum i))(uvset ttab i $cht_cnst))    (dolist (ch wspc) (uvset ttab (%char-code ch) $cht_wsp))    (uvset ttab (char-code #\\) $cht_sesc)    (uvset ttab (char-code #\|) $cht_mesc)    (dolist (def macs)      (uvset ttab (%char-code (%car def))              (if (eq (%car def) #\#) $cht_ntmac $cht_tmac)))    (%gvector $v_istruct 'readtable ttab macs case)))(defparameter *readtable* %initial-readtable%)(queue-fixup (setq %initial-readtable% (copy-readtable *readtable*)))(defun copy-readtable (&optional (from *readtable*) to)  (setq from (readtable-arg (or from %initial-readtable%)))  (lap-inline ((readtable-arg (or to (%gvector $v_istruct 'readtable (%make-uvector 256 $v_sbytev) nil (rdtab.case from))))               (copy-tree (rdtab.alist from)))    (:variable from)    (move.l arg_y atemp0)    (move.l (svref atemp0 rdtab.ttab) atemp1)    (move.l acc (svref atemp0 rdtab.alist))    (move.l (varg from) atemp0)    (move.l (svref atemp0 rdtab.ttab) atemp0)    (add.w ($ $v_data) atemp0)    (add.w ($ $v_data) atemp1)    (move.l ($ (1- 64)) da)    (prog# (move.l (@+ atemp0) (@+ atemp1)) (dbf da (top#)))    (move.l arg_y acc)));Entry: atemp0=readtable, acc=char arg;Type-checks and preserves acc.  Returns da=type and:;          MI if not a macro char;	   GT if 'normal' macro char, dy=def;	   Z  if dispatching macro char, dy=atemp0=def (dispatch table)(defun %%get-readtab-char (&lap 0)  (old-lap   (if# (ne (cmp.b ($ $t_imm_char) acc)) (twtaerr acc 'character))   (move.l (svref atemp0 rdtab.ttab) atemp1)   (swap acc)   (move.b (atemp1 acc.w $v_data) da)   (swap acc)   (if# (eq (btst ($ $cht_macbit) da))     (move.l ($ -1) dy)     (rts))   (move.l (svref atemp0 rdtab.alist) atemp0)   (prog#    (car atemp0 atemp1)    (cdr atemp0 atemp0)    (until# (eq (car atemp1) acc)))   (cdr atemp1 dy)                      ;Macro defn   (if# (or (ne (ttagp ($ $t_cons) dy db))            (ne (progn (move.l dy atemp0)                       (cmp.b ($ $t_imm_char) (atemp0 (+ $_car $char.type))))))     (move.l ($ 1) db))			;clear Z, MI   (rts)));Entry: atemp0=readtable data, acc=char, dy=subchar;Returns with dy=Disp tab cons, acc=subchar, and;	Z set if subchar not defined;       Z clear if subchar defined,;	  atemp1=defn cons, atemp0=defn's alist loc: (cadr atemp0) = atemp1(defun %%get-readtab-subchar (&lap 0)  (old-lap   (vpush dy)   (if# (ne (jsr #'%%get-readtab-char))     (ccall error '"~S is not a dispatching macro character." acc))   (vpop acc)   (if# (ne (cmp.b ($ $t_imm_char) acc))     (twtaerr acc 'character))   (swap acc)   (if# (ge (cmp.b ($ #\0) acc))     (if# (le (cmp.b ($ #\9) acc))       (swap acc)       (twtaerr acc '(not (satisfies digit-char-p))))     (if# (and (ge (cmp.b ($ #\a) acc)) (le (cmp.b ($ #\z) acc)))       (sub.b ($ 32) acc)))   (swap acc)   ;dy=atemp0=dispatch table, da=type, acc=subchar   (prog#    (move.l atemp0 da)    (cdr atemp0 atemp0)    (while# (ne atemp0 nilreg))    (car atemp0 atemp1)    (until# (eq (car atemp1) acc))    (move.l da atemp0)    (move.l ($ 1) da))   (rts))); read table only has base chars;da=New type, dy=New defn, atemp0=Readtable, acc=char arg(defun %%set-readtab-char (&lap 0)  (old-lap   (if# (ne (cmp.b ($ $t_imm_char) acc))                 (twtaerr acc 'base-character))   (move.l (svref atemp0 rdtab.ttab) atemp1)   ; type table   (vpush atemp1)                              ;save it   (swap acc)   (if# (eq (btst ($ $cht_macbit) (atemp1 acc.w $v_data)))   ;Is it a macro?     (bif (eq (btst ($ $cht_macbit) da)) @set)   ; No, making it one now?     (swap acc)                                ; Yes, so make a slot for it     (mkint da)     (movem.l #(acc da atemp0) (-@ vsp))     (vpush (svref atemp0 rdtab.alist))     (exg arg_y arg_z)     (jsr_subprim $sp-consyz)     (move.l acc arg_y)     (vpop arg_z)     (jsr_subprim $sp-consyz)     (move.l acc db)     (movem.l (@+ vsp) #(acc da atemp0))     (move.l db (svref atemp0 rdtab.alist))     (getint da)     (swap acc)     (bra @set))   (swap acc)			; Was a macro char, get old def   (lea (svref atemp0 rdtab.alist (- $_cdr)) atemp0)   (prog#    (move.l atemp0 db)    (cdr atemp0 atemp0)    (car atemp0 atemp1)    (until# (eq (car atemp1) acc)))   (swap acc)   (if# (ne (btst ($ $cht_macbit) da))         ; Is new a macro char as well?     (rplacd atemp1 dy)                        ; Yea, just replace the def    else#     (move.l db atemp1)     (rplacd atemp1 (cdr atemp0)))              ; Nope, splice it out.   @set   (vpop atemp1)   (move.b da (atemp1 acc.w $v_data))   (rts)))(defun set-syntax-from-char (to-char from-char &optional to-readtable from-readtable)  (require-type to-char 'base-character)  (require-type from-char 'base-character)  (old-lap-inline ((readtable-arg to-readtable)               (readtable-arg (or from-readtable %initial-readtable%)))    (vpush arg_y)    (move.l acc atemp0)    (move.l (varg from-char 4) acc)    (jsr #'%%get-readtab-char)                 ; da <- type, dy <- defn    (if# eq                                    ; Dispatch macro, copy it (?)      (pea (@ 1))      (move.w da (sp))      (ccall copy-tree dy)      (move.l acc dy)      (move.w (@+ sp) da)      (add.w ($ 2) sp))    (vpop atemp0)				;TO readtable data    (move.l (varg to-char) acc)    (jsr #'%%set-readtab-char))  T)(defun get-macro-character (char &optional (readtable *readtable*))  (require-type char 'base-character)  (setq readtable (readtable-arg (or readtable %initial-readtable%)))  (old-lap   (move.l acc atemp0)   (move.l (varg char) acc)   (vpush nilreg)                            ; Assume not a macro char.   (vpush nilreg)   (jsr #'%%get-readtab-char)   (if# pl     (setpred eq db)                    ; acc <- dispatching-macro-p     (cmp.b ($ $cht_ntmac) da)     (if# eq (add.l ($ $t_val) (vsp)))     (ccall %readtab-spec2fn dy acc)     (move.l acc (vsp 4)))   (set_nargs 2)   (jmp_subprim $sp-nvalret)))(defun set-macro-character (char fn &optional non-terminating-p readtable)  (require-type char 'base-character)  (setq readtable (readtable-arg readtable))  (old-lap-inline ((if (symbolp fn) fn (%readtab-fn2spec fn)))    (move.l acc dy)    (move.l (varg readtable) atemp0)    (move.l ($ $cht_tmac) da)              ;da= type    (if# (ne (varg non-terminating-p) nilreg)      (move.l ($ $cht_ntmac) da))    (move.l (varg char) acc)    (jsr #'%%set-readtab-char))  T)(defun readtable-case (readtable)  (%car (rassoc (rdtab.case (readtable-arg readtable)) (readtable-case-keywords) :test #'eq)))(defun %set-readtable-case (readtable case)  (let ((val (assq case readtable-case-keywords)))    (unless val      (report-bad-arg case '(member :upcase :downcase :preserve :invert :studly)))    (setf (rdtab.case (readtable-arg readtable)) (%cdr val)))  case)  (defsetf readtable-case %set-readtable-case)(defun %readtab-spec2fn (spec dispatch-p)  (if dispatch-p    #'(lambda (stream char)        (declare (ignore stream char))        ;Reader function called outside reader context        (%err-disp $xrmactx (%car SPEC)))    (let ((val (assq spec '((0 . #\)) (1 . #\") (2 . #\') (3 . #\;) (4 . #\()))))      (if val        #'(lambda (stream char)            (declare (ignore stream char))            (%err-disp $xrmactx (%cdr VAL)))        spec))))(defun %readtab-fn2spec (fn)  (setq fn (require-type fn 'function))  (if (eq (%type-of fn) 'compiled-lexical-closure)    (let ((subfn (%nth-immediate (%lfun-vector fn t) 0)))      (cond ((eq subfn '#,(%nth-immediate (%lfun-vector (%readtab-spec2fn 0 nil) t) 0))             (let ((value (%nth-immediate (%lfun-vector fn t) 1)))               (car (if (closed-over-value-p value) (%cdr value) value))))            ((eq subfn '#,(%nth-immediate (%lfun-vector (%readtab-spec2fn nil t) t) 0))             (let ((value (%nth-immediate (%lfun-vector fn t) 1)))               (if (closed-over-value-p value) (%cdr value) value)))            (t fn)))    fn))(defun make-dispatch-macro-character (char &optional non-terminating-p readtable)  (setq readtable (readtable-arg readtable))  (require-type char 'base-character)  (old-lap-inline ()    (move.l (varg char) arg_z)    (jsr_subprim $sp-consznil)    (move.l acc dy)    (move.l (varg readtable) atemp0)    (move.l (varg char) acc)    (move.l ($ $cht_tmac) da)    (if# (ne (varg non-terminating-p) nilreg) (move.l ($ $cht_ntmac) da))    (jsr #'%%set-readtab-char))  T)(defun get-dispatch-macro-character (disp-ch sub-ch &optional (readtable *readtable*))  (setq readtable (readtable-arg (or readtable %initial-readtable%)))  (require-type disp-ch 'base-character)  (require-type sub-ch 'base-character)  (old-lap-inline ()    (move.l (varg readtable) atemp0)    (move.l (varg sub-ch) arg_y)    (move.l (varg disp-ch) acc)    (jsr #'%%get-readtab-subchar)    (if# ne      (ccall %readtab-spec2subfn (cdr atemp1))     else#      (move.l nilreg acc))))(defun set-dispatch-macro-character (disp-ch sub-ch fn &optional readtable)  (setq readtable (readtable-arg readtable))  (require-type disp-ch 'base-character)  (require-type sub-ch 'base-character)  (old-lap-inline ((if (symbolp fn) fn (%readtab-subfn2spec fn)))    (preserve_regs dsave0)    (move.l acc dsave0)    (move.l (varg readtable 4) atemp0)    (move.l (varg disp-ch 4) acc)    (move.l (varg sub-ch 4) dy)    (jsr #'%%get-readtab-subchar)    (if# ne      (rplacd atemp1 dsave0)                   ; Found, put in new def      (bif (ne dsave0 nilreg) @ret)      (cdr atemp0 atemp1)                      ;Oops, making it undefined,      (rplacd atemp0 (cdr atemp1))             ; splice it out instead.     else#                                     ;Else push a new entry in dispatch table.      (bif (eq dsave0 nilreg) @ret)            ;Unless just making it undefined...      (vpush dy)      (move.l acc arg_y)      (move.l dsave0 arg_z)      (jsr_subprim $sp-consyz)      (move.l acc arg_y)      (move.l (vsp) atemp0)      (cdr atemp0 arg_z)      (jsr_subprim $sp-consyz)      (vpop atemp0)      (rplacd atemp0 acc))    @ret    (restore_regs))  T)(defun %readtab-spec2subfn (spec)  (let ((val (assq spec '((0 . #\space) (1 . #\)) (2 . #\<) (3 . #\() (4 . #\:)                          (5 . #\,) (6 . #\.) (7 . #\|) (8 . #\\) (9 . #\R)                          (10 . #\B) (11 . #\O) (12 . #\X) (13 . #\')))))    (if val      #'(lambda (stream char arg)          (declare (ignore stream char arg))          (%err-disp $xrmactx (%cdr VAL)))      spec)))(defun %readtab-subfn2spec (fn)  (setq fn (require-type fn 'function))  (if (and (eq (%type-of fn) 'compiled-lexical-closure)           (eq (%nth-immediate (%lfun-vector fn t) 0)               '#,(%nth-immediate (%lfun-vector (%readtab-spec2subfn 0) t) 0)))    (car (%nth-immediate (%lfun-vector fn t) 1))    fn));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				Reader					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defvar *read-eval* t "When nil, #. signals an error.")(defvar %read-objects% nil)(defvar %keep-whitespace% nil)(defglobal %parse-string% (make-string 255 :element-type 'base-character))(defun input-stream-arg (stream)  (cond ((null stream) *standard-input*)        ((eq stream t) *terminal-io*)        ;Otherwise, let ASK complain...        (t stream)));Since some built-in read macros really want to use internal reader entry points;for efficiency, we can't reliably offer a protocol for stream-dependent;recursive reading.  So recursive reads always get done via tyi's, and streams;only get to intercept toplevel reads.(defun read (&optional stream (eof-error-p t) eof-value recursive-p)  (declare (resident))  (setq stream (input-stream-arg stream))  (if recursive-p    (%read-form stream 0 nil)    (let* ((temp #'(lambda (stream)                     (let ((%read-objects% nil) (%keep-whitespace% nil))                       (stream-read stream eof-error-p eof-value)))))      (declare (dynamic-extent temp))    (stream-rubout-handler stream temp))))(defun read-preserving-whitespace (&optional stream (eof-error-p t) eof-value recursive-p)  (setq stream (input-stream-arg stream))  (if recursive-p    (%read-form stream 0 nil)    (let ((%read-objects% nil) (%keep-whitespace% t))      (stream-read stream eof-error-p eof-value))))(defmethod stream-read ((stream stream) eof-error-p eof-val)  (%read-form stream (if eof-error-p 0) eof-val))(defun read-delimited-list (char &optional stream recursive-p)  (setq char (require-type char 'character))  (setq stream (input-stream-arg stream))  (let ((%keep-whitespace% nil))    (if recursive-p      (%read-form stream char nil)      (let ((%read-objects% nil))        (%read-form stream char nil)))))(defun read-conditional (stream subchar int)  (declare (ignore int))  (cond (*read-suppress* (read stream t nil t) (values))        ((eq subchar (read-feature stream)) (read stream t nil t))        (t (let* ((*read-suppress* t))             (read stream t nil t)             (values)))))(defun read-feature (stream)  (let* ((f (let* ((*package* *keyword-package*))                 (read stream t nil t))))    (labels ((eval-feature (form)               (cond ((atom form)                       (member form *features*))                     ((eq (car form) :not)                       (not (eval-feature (cadr form))))                     ((eq (car form) :and)                       (dolist (subform (cdr form) t)                        (unless (eval-feature subform) (return))))                     ((eq (car form) :or)                       (dolist (subform (cdr form) nil)                        (when (eval-feature subform) (return t))))                     (t (%err-disp $XRDFEATURE form)))))      (if (eval-feature f) #\+ #\-))))(set-dispatch-macro-character #\# #\+ #'read-conditional)(set-dispatch-macro-character #\# #\- #'read-conditional)(defresource *parse-string-resource*  :constructor (make-string 255 :element-type 'base-character));arg=0 : read form, error if eof;arg=nil : read form, eof-val if eof.;arg=char : read delimited list(defun %read-form (stream arg eof-val)  (declare (resident))  (check-type *readtable* readtable)  (check-type *package* package)  (let ((parse-string %parse-string%))    (if parse-string      (unwind-protect        (progn          (setq %parse-string% nil)          (%read-form-internal stream arg eof-val parse-string))        (setq %parse-string% parse-string))      (using-resource (parse-string *parse-string-resource*)        (%read-form-internal stream arg eof-val parse-string)))))(defun %read-form-internal (stream arg eof-val parse-string)  (old-lap   (preserve_regs #(asave0 asave1 dsave0))   (move.l (varg stream 12) dsave0)   (move.l (varg arg 12) asave0)   (move.l (varg eof-val 12)  asave1)   (vpush dsave0)                       ; stream   (move.l dsave0 arg_z)   (set_nargs 1)   (lea #'safe-stream-reader atemp0)   (jsr_subprim $sp-mvpass)             ; returns two values: function & arg   (move.l ($ 8) da)   (jsr_subprim $sp-fitvals)   (clr.l -@vsp)                        ; untyi_char   (move.l (special *readtable*) atemp0)   (vpush (svref atemp0 rdtab.case)) ; case flag   (vpush atemp0)                    ; rdtab   (vpush nilreg)                    ; radix   (vpush nilreg)                    ; xparstr   (clr.l -@vsp)                     ; strlen   (if# (eq (vsp) nilreg)     (move.l ($ 255) acc)     (jsr_subprim $sp-makestr)     (move.l acc (vsp)))   (equate RD.strlen 0 RD.strlenw 0 RD.strlenb 1           RD.xparstr 4           RD.radix 8           RD.rdtab 12           RD.case 16           RD.untyi_char 20           RD.tyi_arg 24           RD.tyi_function 28           RD.stream 32           RD_count 36           RD.parstr (+ RD_count 12))   (move.l asave0 acc)   (move.l vsp asave0)   (if# (eq (tst.l acc))                ; read, eof-error-p = t     (bsr RdExpNoDotNoEof)    elseif# (eq acc nilreg)             ; read, eof-error-p = nil     (prog#      (if# (eq (bsr getnwsp))        (move.l asave1 acc)        (bra (exit#)))      (until# (ne (bsr parse-exp-no-dot))))    else#                               ; read-delimited-list, acc=char     (vpush acc)                        ; The char     (vpush nilreg)                     ; the list     (lea (vsp (- $_cdr)) asave1)     (bra @read-delimited-next)     (prog#      (if# (ne (bsr parse-exp-no-dot))        (jsr_subprim $sp-consznil)        (rplacd asave1 acc)        (move.l acc asave1))      @read-delimited-next      (bsr getnwspnoeof)      (until# (eq (cmp.w (vsp 4) acc))))     (vpop acc)     (add.w ($ 4) vsp))   (move.l acc asave1)   (if# (ne (move.l (asave0 RD.untyi_char) arg_y))     (ccall untyi arg_y (asave0 RD.stream)))   (lea (vsp RD_count) vsp)   (move.l asave1 acc)   (restore_regs)   (lfret)   ;Read an expression or right paren. db=DotOkp.   ; Returns with MI flag set if dot, else Z flag if paren, else acc=expr.   RdLstExpNoDot   (move.l ($ 0) db)   RdLstExp   ;(move.l nilreg (special %keep-whitespace%))   (spush db)                               ; 0 or 1   (prog#    (bsr getnwspnoeof)    (while# (ne (cmp.w ($ #\)) acc)))    (move.l (sp) db)    (bsr parse-exp)    (until# (or mi ne)))   (add.w ($ 4) sp)		;(Doesn't affect flags)   (rts)   RdExpNoDotnoeof   (prog#    (bsr getnwspnoeof)    (bsr parse-exp-no-dot)    (until# ne))   (rts)   ;ParsExp(acc=next char (swapped), da.b=acc's type, db=1 if dot ok, else 0)   ;Char must not be whitespace.  Returns with:   ;     MI flag set if "." and DB non-zero, else   ;     Z flag set if splicing macro, else   ;     lisp object in acc.   ;Obeys *read-suppress*, *read-base*, and %keep-whitespace%   parse-exp-no-dot   (move.l ($ 0) db)   parse-exp   (cmp.b ($ $cht_ill) da)   (beq IllChrErr)   (btst ($ $cht_macbit) da)   (beq parse-token)   (swap acc)                           ;acc = macro char, as a lisp char   (move.l (asave0 RD.rdtab) atemp0)   (move.l (svref atemp0 rdtab.alist) atemp0)   ; macro-char-alist   (prog#                               ; search it    (car atemp0 atemp1)    (cdr atemp0 atemp0)    (until# (eq (car atemp1) acc)))   (cdr atemp1 atemp0)                  ; atemp0 = definition   (if# (eq (ttag atemp0 db))           ; Fixnum => builtin     (move.l atemp0 db)     (vscale.l db)     (jmp (pc db.l 2))                  ; %readtab-spec2fn knows these values     (jmp (^ |)-macro|))                ; 0     (jmp (^ |"-macro|))                ; 1     (jmp (^ |'-macro|))                ; 2     (jmp (^ |;-macro|))                ; 3     (jmp (^ |(-macro|)))               ; 4   (if# (or (ne (sub.w ($ $t_cons) db))            (ne (cmp.b ($ $t_imm_char) (atemp0 (+ $_car $char.type)))))     (move.l (asave0 RD.stream) arg_y)   ;random user function     (set_nargs 2)     (jsr_subprim $sp-mvfpass)           ; funcall atemp0 leaving values on stack     (add.w nargs vsp)                    ; Flush 'em (acc always has first)     (tst.w nargs)                        ; flags as per any-values-p     (rts))   ;(char . ...) means dispatch macro   (vpush acc)                          ; The dispatch char   (vpush atemp0)                       ; its dispatch table   (bsr use-parse-string)               ;String in use.   (loop#                               ; Collect argument    (bsr tyinoeof)    (swap acc)    (while# (and (ge (cmp.w ($ #\0) acc)) (le (cmp.w ($ #\9) acc))))    (bsr addchr))   (swap acc)   (vpush acc)   (bsr get-string)   ;(move.l ($ 10) db)   ;(move.l ($ 0) dy)   ;(jsr #'%%numtkn)   (ext.l da)   (mkint da)   (ccall new-numtoken atemp0  '0 da '10); acc <- numarg   (bsr release-parse-string)   (vpop arg_y)                         ; arg_y <- the subchar   (vpop atemp0)                        ; dispatch table   (vpop da)                            ; original char, in case of error   (swap arg_y)   (if# (and (geu (cmp.w ($ #\a) arg_y)) (leu (cmp.w ($ #\z) arg_y)))     (sub.b ($ 32) arg_y))   (swap arg_y)   (prog#    (cdr atemp0 atemp0)    (while# (ne atemp0 nilreg))    (car atemp0 atemp1)    (until# (eq (car atemp1) arg_y))    (cdr atemp1 atemp0)                  ; atemp0 = definition    (if# (eq (ttag atemp0 db))           ; Fixnum => builtin      (move.l atemp0 db)      (vscale.l db)      (jmp (pc db.l 2))                 ; %readtab-spec2subfn knows these values      (jmp (^ |# -macro|))                  ; 0      (jmp (^ |#)-macro|))                  ; 1      (jmp (^ |#<-macro|))                  ; 2      (jmp (^ |#(-macro|))                  ; 3      (jmp (^ |#:-macro|))                  ; 4      (jmp (^ |#,-macro|))                  ; 5      (jmp (^ |#.-macro|))                  ; 6      (jmp (^ |#\|-macro|))                 ; 7      (jmp (^ |#\\-macro|))                 ; 8      (jmp (^ |#R-macro|))                  ; 9      (jmp (^ |#B-macro|))                  ; 10      (jmp (^ |#O-macro|))                  ; 11      (jmp (^ |#X-macro|))                  ; 12      (jmp (^ |#'-macro|)))                 ; 13    (move.l (asave0 RD.stream) arg_x)    (set_nargs 3)    (jsr_subprim $sp-mvfpass)    (add.w nargs vsp)    (tst.w nargs)    (rts))   (if# (ne (special *read-suppress*) nilreg)     (set_nargs 0)                      ; Ignore totally     (rts))   ;Reader error: undefined character ^0 in ^1 dispatch macro   (signal_error (fixnum $XNORDISP) arg_y da)   use-parse-string   (move.l nilreg (asave0 RD.xparstr))   ;No overflow.   (clr.l (asave0 RD.strlen))           ; 0 chars   (rts)   ;parse-token(acc=char (swapped), da.b=type, db=1 if dot ok, else 0)   ;Char must be a constituent or a single or multiple escape   ;Obeys *read-suppress*, *read-base*, and cKeepWsp(a5)   ;Returns with MI set if "." and DB non-zero,   ; otherwise acc=parsed expression and Z flag clear.   parse-token   (progn     (spush db)                           ; 0 or 1     (bsr collect-token)     (spop db)     (if# (ne (special *read-suppress*) nilreg)       (move.l nilreg acc)       (bra release-parse-string))     (if# (eq (tst.w acc))                ; Any non-dots?       ;Note that string can't be empty (the only way to have an empty pname       ;is to have escapes or a package, both of which set the non-dots flag)       (sub.w ($ 1) da)                   ;Just one dot?       (bne BadSymErr)			;Nope, bad token all around       (tst.w db)                         ;Dot ok?       (beq DotErr)                       ;No, Dot context error.       (bsr release-parse-string)                ;Standard exit actions       (move.l ($ -1) acc)                ;Special case.       (rts))     (preserve_regs dsave0)     (move.l dy dsave0)                   ; dsave0 = package     (if# (eq (tst.b acc))                ; Any escapes?       (bif (eq (tst.l da)) BadSymErr)    ;Empty string and no escapes (possible if pkg)?       (vpush acc)                        ; acc.b = 0 => looks like a fixnum...       (bsr GetRadix)                     ;preserves atemp0/da       ;(move.l ($ 0) dy)       ;(jsr #'%%numtkn)       (ext.l da)       (mkint da)       (ext.l db)       (mkint db)       (ccall new-numtoken atemp0 '0 da db)       (if# (ne acc nilreg)         (add.w ($ 4) vsp)                     ; Looks like a number         (bif (ne dsave0 nilreg) BadSymErr) ;Had a package? Definite loser.         (bra @parse-token-done))         ;Else got us a genuine number and done.       (bsr get-string)                   ;Not a number, fetch atemp0/da again.       (vpop acc))                        ;and get back flags     (if# (eq dsave0 nilreg)              ;No package is like "<current-pkg>::"       (move.l ($ -1) acc)       (move.l (special *package*) dsave0))     (if# (or (mi (tst.l acc))          ; pkg::symbol              (eq (progn (move.l dsave0 acc)                          (cmp.l (special *keyword-package*) acc))))       (move.l dsave0 acc)       ; findsym expects length in bytes       (if# (eq (vsubtypep ($ $v_xstr) atemp0 dx))         (asl.l da))       (jsr #'%%findsym)       (bne @parse-token-done)       (vunscale.l db) (vpush db)       (vunscale.l dy) (vpush dy)       (bsr copy-parse-string)       (vpop dy) (vscale.l dy)       (vpop db) (vscale.l db)       (move.l dsave0 atemp0)       (jsr #'%%addsym)      else#                                ; pkg:symbol       (move.l dsave0 atemp1)       (move.l (svref atemp1 pkg.etab) acc)       (jsr #'%%GetSym)       (if# eq         (if# (eq (a5 $nilsym) acc) (move.l nilreg acc))         (bra @parse-token-done))       (bsr copy-parse-string)       (move.l acc arg_y)       (move.l dsave0 arg_z)       (bsr ExtSymError))			;Could be continuable...     @parse-token-done     (restore_regs)     release-parse-string     (move.l nilreg (asave0 RD.xparstr))   ;Let this get gc'd.     (set_nargs 1)                         ;Clear MI and Z flags     (rts))   ;collect-token(acc=char (swapped), da.b=type)   ;Char must be a constituent or a single or multiple escape   ;Returns with dy/package,   ;	      rh(acc)/0 if read nothing but dots, else FFFF if had escapes in   ;		    in pname string, else FF00.   ;             lh(acc)/FF00 if package specified via ::,   ;		     FFFE if package is keyword because of initial :   ;	             0000 if no package or pkg:name syntax.   ;	      atemp0/string (in RD.parstr or RD.xparstr0), da/ length.   ;Caller should restore cParStr when done with it.   collect-token   (progn     (bsr use-parse-string)     (vpush nilreg)		  ; 4(vsp) = escaped chars kludge thing (used only by :invert)     (vpush nilreg)             ; (vsp) = package     ;(sp)=non-dots-p, 1(sp)=escapes-p 2(sp)= got pkg::  3(sp)=got initial :     (pea (@ 1))                          ; keep it odd...     @collect-token-loop     (if# (eq (cmp.b ($ $CHT_MESC) da))       (move.w ($ -1) (sp))               ;Collect multiple escape       (prog#        (bsr nextchr)        (bif (eq (cmp.b ($ $CHT_MESC) da)) @collect-token-next)        (if# (eq (cmp.b ($ $CHT_SESC) da)) (bsr nextchr))        (if# (ne (tst.l (asave0 RD.case)))          (swap acc)          (vpush acc)          (move.l (vsp (+ 4 4)) arg_z)          (move.l (asave0 RD.strlen) arg_y)                    ;(dc.w #_debugger)          (jsr_subprim $sp-consYZ)          (move.l acc (vsp (+ 4 4)))          (vpop acc)          (swap acc))        (bsr addchr)        (bra (top#))))     (if# (eq (cmp.b ($ $CHT_SESC) da))       (move.w ($ -1) (sp)) 		;Collect single escape       (bsr nextchr)       (if# (ne (tst.l (asave0 RD.case)))          (swap acc)          (vpush acc)          (move.l (vsp (+ 4 4)) arg_z)          (move.l (asave0 RD.strlen) arg_y)          ;(dc.w #_debugger)          (jsr_subprim $sp-consYZ)          (move.l acc (vsp (+ 4 4)))          (vpop acc)          (swap acc))       (bra @collect-token-add))     (bif (eq (cmp.w ($ #\.) acc)) @collect-token-add)     (st (sp))                            ; Have a non-dot     (if# (eq (cmp.w ($ #\:) acc))       (bif (ne (special *read-suppress*) nilreg) @collect-token-add)   ; Don't care about details       (if# (ne (vsp) nilreg)               ;Already have package?         (move.w (sp 2) da)                 ;Yes, anything since then?         (sub.w ($ 1) da)         (or.b (sp 1) da)         (or.w (asave0 RD.strlenw) da)         (bne @collect-token-add)           ; Yup, nothing special about this :         (st (sp 2))                        ;Else remember double dots         (bra @collect-token-next))       (if# (and (eq (tst.w (asave0 RD.strlenw)))   ;No package yet, do we have a name?                 (eq (tst.b (sp 1))))       ;Even just ||?         (move.l (special *keyword-package*) (vsp))   ;Nope, means keyword pkg         (move.w ($ -1) (sp 2))             ;Remember that's how we got it.         (bsr tyinoeof)         (if# (ne (cmp.l '#\: acc))           (move.l acc (asave0 RD.untyi_char)))         (bra @collect-token-next))       (bsr get-string)                   ;atemp0/da <- package name              (if# (ne (tst.l (asave0 RD.case)))   ; invert or studly or upcase or downcase         (ext.l da)         (mkint da)         (vpush da)         ;(dc.w #_debugger)         (ccall %read-casify atemp0 da (vsp (+ 4 4)))         (move.l acc atemp0)         (vpop da)         (getint da))             ;(add.w ($ $v_data) atemp0)       (jsr #'%%find-pkg)         ;Find the package       ;(mkint da)       ;(ccall %find-package atemp0 ($ 0) da) ; maybe??       (if# (eq acc nilreg)         (bsr copy-parse-string)         (bsr NoPkgError))                ;No such package.       (move.l acc (vsp))       (bsr use-parse-string)             ;Re-init       ;(move.l '(nil -1) atemp1)       ;(move.l atemp1 (vsp 4))       ;(clr.l -@atemp1)       (move.l nilreg (vsp 4))       (sf (sp 1))			;No escapes in string itself       (bra @collect-token-next))          #|     (if# (ne (move.l (asave0 RD.case) da)) ; :UPCASE, :DOWNCASE, or :INVERT       (move.l (vsp 4) atemp1)       (if# (eq '-2 da)         (add.b acc (atemp1 -3))         else#         (if# (and (geu (cmp.w ($ #\a) acc)) (leu (cmp.w ($ #\z) acc)))                      (if# (eq '1 da)             (sub.b ($ 32) acc))           elseif# (and (geu (cmp.w ($ #\A) acc)) (leu (cmp.w ($ #\Z) acc)))                      (if# (eq '2 da)             (add.b ($ 32) acc)))))   |#     @collect-token-add     (bsr addchr)     @collect-token-next                            ; Check out next char     (bif (eq (bsr tyi)) @collect-token-done)     (bsr getchrtype)     (beq IllChrErr)     (if# (ne (cmp.b ($ $cht_tmac) da))       (bif (ne (cmp.b ($ $cht_wsp) da)) @collect-token-loop)       (bif (eq (special %keep-whitespace%) nilreg) @collect-token-done))     (swap acc)     (move.l acc (asave0 RD.untyi_char))     @collect-token-done     (bsr get-string)                     ;whole string to xparstr or parstr, atemp0/da     (if# (NE (tst.l (asave0 RD.case)))   ; invert or studly or upcase or downcase       (ext.l da)       (mkint da)       (vpush da)       ;(dc.w #_debugger)       (ccall %read-casify atemp0 da (vsp (+ 4 4)))       (move.l acc atemp0)       (vpop da)       (getint da))     (vpop dy)                            ; Package     (vpop atemp1)                        ; indices of escaped chars          (spop acc)                           ; Flags     (sub.b ($ 1) acc)     (swap acc)     (rts))   RadixArgp                            ; Preserves atemp0/da   (progn     (if# (and (eq (ttagp ($ $t_fixnum) db dy))               (ge (progn (getint db) (move.l ($ 2) dy) (cmp.l dy db)))               (le (progn (move.l ($ 36) dy) (cmp.l dy db))))       (move.l ($ 1) dy)       (rts))     (move.l ($ 0) dy)     (rts))   GetRadix                             ;preserves atemp0/da   (progn     (move.l (asave0 RD.radix) db)     (if# (ne db nilreg) (getint db) (rts))     @get-radix     (move.l (special *read-base*) db)     (move.l db (asave0 RD.radix))     (if# (eq (bsr RadixArgp))       ;****==> Should be continuable...       (move.l (fixnum 10) (special *read-base*))       (signal_error (fixnum $XBADRDX) (asave0 RD.radix))   ; Illegal *read-base*       (bra @get-radix))     (rts))   BadSymErr                            ; E.g. symbol consisting of dots only   (move.w ($ $XBADSYM) acc)   (bra ReadError)   DotErr   (move.w ($ $XDOTERR) acc)   (bra ReadError)   ;Add swapped char in acc to RD.parstr.   ; --> This code ASSUMES that length(RD.parstr) = 255.   addchr   (progn     (move.l (asave0 RD.parstr) atemp0)     (if# (and (gtu (cmp.w ($ #xff) acc))               (ne (vsubtypep ($ $v_xstr) atemp0 da)))       (swap acc)       (vpush acc)       (ccall thin-to-fat-string (asave0 RD.parstr))       (move.l acc (asave0 RD.parstr))       (vpop acc)       (swap acc)       (bra addchr))     (if# (ne (add.b ($ 1) (asave0 RD.strlenb)))       (move.l (asave0 RD.parstr) atemp0)              (move.w (asave0 RD.strlenw) da)       (if# (eq (vsubtypep ($ $v_sstr) atemp0 db))         (move.b acc (atemp0 da.w (1- $v_data)))         else#         (add.w da da)         (move.w acc (atemp0 da.w (- $v_data 2))))       (rts))     (bif (ne (special *read-suppress*) nilreg) addchr)     (swap acc)     (vpush acc)     ; if xparstr is  nil make a new one len = 255     ; copy parstr into it     ; if xparstr is not nil make a new on len + 255 len xparstr     ; copy xparstr and parstr into it     (ccall %read-extend-str (asave0 RD.parstr)(asave0 RD.xparstr))     (move.l acc (asave0 RD.xparstr))     (vpop acc)     (swap acc)     (bra addchr))   ;Set atemp0/da = string, consing up a full-length xparstr if necessary   get-string   (progn     (move.l (asave0 RD.xparstr) acc)     (if# (eq acc nilreg)       ; if xparstr is nil return parstr and strlen       (move.l (asave0 RD.parstr) atemp0)       (move.w (asave0 RD.strlenw) da)       (ext.l da)       (rts))     (move.l acc atemp0) ; xparstr     (if# (ne (move.w (asave0 RD.strlenw) da))   ; First time...       ; if strlen not 0 xparstr gets strcat of parstr and xparstr       (ext.l da)       (mkint da)       (ccall %read-extend-str (asave0 RD.parstr) atemp0 da)       (move.l acc (asave0 RD.xparstr))       (move.l acc atemp0)       (clr.w (asave0 RD.strlenw)))          ; Remember did this            (vsize atemp0 da) ; this is bytes - I think we want chars!     (if# (eq (vsubtypep ($ $v_xstr) atemp0 acc))       (asr.l ($ 1) da))     (rts))   copy-parse-string   (progn     (move.l (asave0 RD.xparstr) acc)     ; if xparstr is nil make a new string len = strlen     ; copy contents of str into it     ; put it in xparstr and clear strlen     ; if xparstr is not nil - do nothing?     (if# (eq acc nilreg)       (move.l ($ 0) acc)       (move.w (asave0 RD.strlenw) acc)       (ext.l acc)       (mkint acc)       (ccall %read-extend-str (asave0 RD.parstr) (asave0 RD.xparstr) acc)       (move.l acc (asave0 RD.xparstr))       (clr.w (asave0 RD.strlenw)))     (rts))      |(-macro|   (progn     (preserve_regs asave1)     (vpush NILREG)                  ;The list     (lea (vsp (- $_cdr)) asave1)    ;tail pointer     (prog#      (move.l ($ -1) db)             ; Dot ok.      (bsr RdLstExp)      (bmi @lparen-dot)              ; dot      (beq @lparen-done)             ; right paren      (jsr_subprim $sp-consznil)     ;Else add expression.      (rplacd asave1 acc)      (move.l acc asave1)      (bra (top#)))     @lparen-dot     (bif (or (eq (vsp) nilreg) ;must be something before dot              (eq (bsr RdLstExpNoDot)) ;and after dot              (ne (progn (rplacd asave1 acc) (bsr RdLstExpNoDot)))) ;Just one          DotErr)     @lparen-done     (vpop acc)     (restore_regs)     (set_nargs 1)		;Have a value     (rts))   |'-macro|   (progn     (vpush 'quote)    SQuotMacArg     (bsr RdExpNoDotnoeof)     (vpush acc)     (set_nargs 2)     (jsr_subprim $sp-conslist)     (set_nargs 1)		;Have a value     (rts))   |#'-macro|   (progn     (bsr NoNumArg)     (vpush 'function)     (bra SQuotMacArg))   |;-macro|   (progn     ;(if# (eq (cmp.l 't (special *fmh*)))     ;  (dc.w #_Debugger))     (prog#      (while# (ne (bsr tyi)))      (swap acc)      (until# (eq (cmp.w ($ #\Newline) acc))))     (rts))                                 ;Z set (no value)   |"-macro|   (progn     (vpush acc)     (bsr use-parse-string)                 ;String in use.     (bra @dquote-next)     (prog#      (if# (eq (sub.b ($ $CHT_SESC) da)) (bsr nextchr))      (bsr addchr)      @dquote-next      (bsr nextchr)      (until# (eq (cmp.w (vsp) acc))))     (add.w ($ 4) vsp)     (bsr get-string)     (bsr copy-parse-string)         ;Copy and return the string.     (bra release-parse-string))   |)-macro|   (move.w ($ $XUMRPR) acc)   (bra ReadError)   NoNumArg   (progn     (bif (and (ne acc nilreg) (eq (special *read-suppress*) nilreg)) NumArgErr)     (rts))   NumArgErr   (signal_error (fixnum $XRDNOARG) arg_y)   NeedNumArg   (progn     (bif (and (eq acc nilreg) (eq (special *read-suppress*) nilreg)) NoNumArgErr)     (rts))   NoNumArgErr   (signal_error (fixnum $XRDNDARG) arg_y)   |#\\-macro|   (progn     (if# (and (ne nilreg acc)               (ne (tst.l acc))               (eq (special *read-suppress*) nilreg))       (signal_error (fixnum $XRDFONT)))     (move.l ($ $CHT_SESC) da)     (bsr collect-token)     (if# (eq (special *read-suppress*) nilreg)       (move.l da dtemp0)       (add.w ($ $v_data) atemp0)       (jsr #'%%name-char)       (bif (ne acc nilreg) release-parse-string)       (bsr copy-parse-string)       (signal_error (fixnum $XRDNAME) acc))     (move.l nilreg acc)     (bra release-parse-string))   |#(-macro|   (progn     (if# (ne acc nilreg)       (vscale.l acc)       (jsr_subprim $sp-allocgv)       (preserve_regs #(dsave0 dsave1 asave1 acc))       (move.l acc asave1)       (vsize asave1 dsave1)       (vunscale.l dsave1)       (move.l (fixnum 0) dsave0)       (bra @sharp-lparen-next)       (prog#        (if# (cc (cmp.l dsave1 dsave0)) (signal_error (fixnum $XARROOB) dsave0 asave1))        (vscale.l dsave0)        (move.l acc (asave1 dsave0.l $v_data))        (vunscale.l dsave0)        (add.l (fixnum 1) dsave0)        @sharp-lparen-next        (bsr RdLstExpNoDot)        (until# eq))       (if# (ne (sub.l dsave0 dsave1))         (if# (mi (sub.l (fixnum 1) dsave0))           (signal_error (fixnum $XARROOB) dsave0 asave1))         (vscale.l dsave0)         (lea (asave1 dsave0.l $v_data) atemp0)         ;vunscale.l dsave0         (move.l (@+ atemp0) acc)         (prog#          (move.l acc (@+ atemp0))          (until# (eq (sub.l (fixnum 1) dsave1)))))       (restore_regs)      else#       (preserve_regs #(dsave0 asave1))       (move.l nilreg asave1)       (move.l (fixnum 0) dsave0)       (bra @sharp-lparen-anext)       (prog#        (add.l (fixnum 1) dsave0)        (move.l acc arg_y)        (move.l asave1 arg_z)        (jsr_subprim $sp-consyz)        (move.l acc asave1)        @sharp-lparen-anext        (bsr RdLstExpNoDot)        (until# eq))       (move.l dsave0 acc)       (vscale.l acc)       (jsr_subprim $sp-allocgv)       (vsize atemp0 da)       (lea (atemp0 da.l $v_data) atemp0)       (bra @sharp-lparen-lnext)       (prog#        (car asave1 (-@ atemp0))        (cdr asave1 asave1)        @sharp-lparen-lnext        (until# (eq asave1 nilreg)))       (restore_regs))     (set_nargs 1)     (rts))   |#.-macro|   (progn     (bsr NoNumArg)     (if# (eq (special *read-eval*) nilreg)       (ccall error '"#. reader macro invoked when ~S is false ." '*read-eval*)       else#       (bsr RdExpNoDotnoeof)       (if# (ne (special *read-suppress*) nilreg)         (move.l nilreg acc)         else#         (ccall eval acc)))     (set_nargs 1)     (rts))   |#,-macro|   (progn     (bif (or (ne (special *read-suppress*) nilreg)              (eq (special *compiling-file*) nilreg)              (eq (progn (move.l (special *reading-for-cfasl*) da) (cmp.l da nilreg))))          |#.-macro|)     (vpush da)     (bsr NoNumArg)     (bra SQuotMacArg))   |#\|-macro|   (progn     (bsr NoNumArg)     (move.l (fixnum 1) da)     (vpush da)                             ; (vsp) = nexting level     (prog#      (bsr tyinoeof)      (swap acc)      (prog#       (bif (ne (cmp.w ($ #\#) acc)) @sharp-vbar-endp)       (bsr tyinoeof)       (swap acc)       (until# (eq (cmp.w ($ #\|) acc))))      (add.l (fixnum 1) (vsp))      (bra (top#))      @sharp-vbar-endp      (bif (ne (cmp.w ($ #\|) acc)) (top#))      (bsr tyinoeof)      (swap acc)      (bif (ne (cmp.w ($ #\#) acc)) @sharp-vbar-endp)      (until# (eq (sub.l (fixnum 1) (vsp)))))     (add.w ($ 4) vsp)     (rts))                                 ; Z flag set, no values   |#:-macro|   (progn     (bsr NoNumArg)     (if# (eq (special *read-suppress*) nilreg)       (bsr getnwspnoeof)       (bif (eq (cmp.b ($ $CHT_ILL) da)) IllChrErr)       (if# (or (ne (btst ($ $cht_macbit) da))                (eq (progn (bsr collect-token) (tst.w acc)))                (ne (cmp.l dy nilreg))                (and (eq (tst.b acc))                     (ne (progn (bsr GetRadix)		     	        ;(move.l ($ 0) dy)                                ;(jsr #'%%numtkn)                                (ext.l da)                                (mkint da)                                (ext.l db)                                (mkint db)                                (ccall new-numtoken atemp0 '0 da db)                                (cmp.l acc nilreg)))))         (bsr release-parse-string)         (bra BadSymErr))       (bsr copy-parse-string)       (bsr release-parse-string)       (jsr_subprim $sp-makesym)      else#       (bsr RdExpNoDotnoeof)       (move.l nilreg acc))     (set_nargs 1)     (rts))   |#X-macro|   (move.l ($ 16) db)   (bra sharp-num-mac)   |#B-macro|   (move.l ($ 2) db)   (bra sharp-num-mac)   |#O-macro|   (move.l ($ 8) db)   sharp-num-mac   (bsr NoNumArg)   (bra RdNumber)   |#R-macro|   (bif (ne (special *read-suppress*) nilreg) RdNumber)   (bif (eq acc nilreg) NoNumArgErr)   (move.l acc db)   (bif (ne (bsr radixargp)) RdNumber)   (move.w ($ $XMACRDX) acc)   (bra ReadError)   ;Read a rational number in base in db, for #b/#o/#x/#r   RdNumber   (progn    (spush db)                              ; Radix, between 2 and 36.    (bsr getnwspnoeof)    (bif (eq (cmp.b ($ $cht_ill) da)) IllChrErr)    (if# (ne (btst ($ $cht_macbit) da))      (add.w ($ 4) sp)     else#      (bsr collect-token)      (spop db)      (if# (ne (special *read-suppress*) nilreg)        (move.l nilreg acc)        (bra release-parse-string))      (bif (and (eq dy nilreg)                (eq (tst.b acc))                ;(ne (cmp.w ($ #\.) (atemp0 da.l (1- $v_data)))) ;So #b111. loses!                (ne (progn ;(move.l ($ 0) dy)                           ;(jsr #'%%numtkn)                           (ext.l da)                           (mkint da)                           (ext.l db)                           (mkint db)                           (ccall new-numtoken atemp0 '0 da db)                           (cmp.l acc nilreg)))                (eq (dtagp acc $t_dfloat $t_sfloat)))           release-parse-string))    (move.w ($ $XBADNUM) acc)    (bra ReadError))   |#<-macro|   (move.l '"#<" acc)   (bra sharp-unread)   |#)-macro|   (move.l '"#)" acc)   (bra sharp-unread)   |# -macro|   (move.l '"#<whitespace>" acc)   sharp-unread   (signal_error (fixnum $XUNREAD) acc)      IllChrErr   (signal_error (fixnum $XILLCHR) acc)   ReadError   (bsr release-parse-string)               ;Minimize consing inside debuggers...   (ext.l acc)   (mkint acc)   (signal_error acc)   ;This error is continuable.  It returns with a package in acc.   NoPkgError   (Tsignal_restart (fixnum $XNOPKG) acc)	;There's no package named ^0   ;This error could be continuable. It should return with a symbol in acc   ExtSymError   (signal_error (fixnum $XNOESYM) arg_y arg_z)   ;Read next non-whitespace char.  Z flag set if EOF.   getnwsp   (prog#    (while# (ne (bsr tyi)))    (bsr getchrtype)    (until# (ne (cmp.b ($ $CHT_WSP) da))))   (rts)   getnwspnoeof   (prog#    (bsr tyinoeof)    (bsr getchrtype)    (until# (ne (cmp.b ($ $CHT_WSP) da))))   (rts)   ;Read next char.   ;Returns with acc=char (swapped), DA.b=char type, flags set as per DA.   nextchr   (bsr tyinoeof)   getchrtype   (move.l (asave0 RD.rdtab) atemp0)   (move.l (svref atemp0 rdtab.ttab) atemp0)   (swap acc)   ;Shouldn't be necessary, but...   (if# (gtu (cmp.w ($ #xff) acc))      (move.b ($ $cht_cnst) da)  ; ??      else#      (move.b (atemp0 acc.w $v_data) da))       ;Should be non-negative byte   (rts)   ;Returns NIL if eof.  Flags set as per nil-p.   tyi   (if# (ne (move.l (asave0 RD.untyi_char) acc))     (clr.l (asave0 RD.untyi_char))     (move.l ($ 1) da)     (rts))   ;(ccall stream-tyi (asave0 RD.stream))   (move.l (asave0 RD.tyi_arg) arg_z)   (set_nargs 1)   (lfjsr (asave0 RD.tyi_function))   (bif (ne nilreg acc) tyi_chr)   (rts)   ;;I/O.  Note that the only way an eof error is signaled is if TYI   ;;returns NIL - we never do EOFP and then signal an error.  This is so   ;;TYI has a chance to intercept the error before it happens.   ;;The listener uses this.   tyinoeof   (if# (ne (move.l (asave0 RD.untyi_char) acc))     (clr.l (asave0 RD.untyi_char))     (move.l ($ 1) da)     (rts))   ;(ccall stream-tyi (asave0 RD.stream))   (move.l (asave0 RD.tyi_arg) arg_z)   (set_nargs 1)   (lfjsr (asave0 RD.tyi_function))   (if# (eq nilreg acc)     (bsr release-parse-string)     (ccall error 'end-of-file ':stream (asave0 RD.stream)))   tyi_chr   (if# (ne (cmp.b ($ $t_imm_char) acc))     (move.l acc atemp0)     (jsr_subprim $sp-chararg-atemp0))   (move.l ($ 1) da)   (rts)   ))(defun thin-to-fat-string (string)  (let* ((len (length string))         (new (make-string len :element-type 'extended-character)))    (move-string-bytes string new 0 0 len)    new))(defun %read-extend-str (str xstr &optional len)  (when (not len)(setq len (length str)))  (let* ((type (array-element-type str)))    (if  (not xstr)      (progn (setq xstr (make-string len :element-type type))             (move-string-bytes str xstr 0 0 len)             xstr)      (%str-cat xstr (if (eq len (length str)) str (%substr str 0 len)))))); readtable-case is invert or studly; escaped appears to be a cons whose car is nil and cdr is 0; I think that invert is broken in 2.0 (crashing when mixed case)? so this can't be very crucial#|(defun %read-idiocy (str len escaped)  ;(declare (ignore escaped))  (case (readtable-case *readtable*)    ; This wont work with fat strings today. Let them report it.    (:studly (nstring-studlify str :end len))    (:invert ; if all same case switch em else do nothing??     (let ((which nil))       (dotimes (i len)         (when (or (not escaped) (not (memq (ash i 13) escaped)))           (let ((c (%schar str i)))             (if (alpha-char-p c)               (if (upper-case-p c)                 (progn                   (when (eq which :lower)(return-from %read-idiocy str))                   (setq which :upper))                 (progn                   (when (eq which :upper)(return-from %read-idiocy str))                   (setq which :lower)))))))       (when which         (dotimes (i len)           (when (or (not escaped) (not (memq (ash i 13) escaped)))             (let ((c (%schar str i)))               (case which                 (:lower (setf (%schar str i)(char-upcase c)))                 (:upper (setf (%schar str i)(char-downcase c))))))))       str))))|#(defun %read-casify (str len escaped)  (case (readtable-case *readtable*)    (:downcase     (dotimes (i len)       (when (or (not escaped)(not (memq (ash i 13) escaped)))         (let ((c (%schar str i)))           (if (alpha-char-p c)             (setf (%schar str i)(char-downcase c)))))))    (:upcase     (dotimes (i len)       (when (or (not escaped)(not (memq (ash i 13) escaped)))         (let ((c (%schar str i)))           (if (alpha-char-p c)             (setf (%schar str i)(char-upcase c)))))))         ; This wont work with fat strings today. Let them report it.    (:studly (nstring-studlify str :end len))    (:invert ; if all same case switch em else do nothing??     (let ((which nil))       (dotimes (i len)         (when (or (not escaped) (not (memq (ash i 13) escaped)))           (let ((c (%schar str i)))             (if (alpha-char-p c)               (if (upper-case-p c)                 (progn                   (when (eq which :lower)(return-from %read-casify str))                   (setq which :upper))                 (progn                   (when (eq which :upper)(return-from %read-casify str))                   (setq which :lower)))))))       (when which         (dotimes (i len)           (when (or (not escaped) (not (memq (ash i 13) escaped)))             (let ((c (%schar str i)))               (case which                 (:lower (setf (%schar str i)(char-upcase c)))                 (:upper (setf (%schar str i)(char-downcase c)))))))))))       str);Until load backquote...(set-macro-character #\`  #'(lambda (stream char) (declare (ignore stream)) (%err-disp $xbadmac char)))(set-macro-character #\, (get-macro-character #\`));for reading #@(h v) as points(set-dispatch-macro-character #\# #\@    (qlfun |#@-reader| (stream char arg)      (require-no-numarg char arg)      (let ((list (read stream t nil t)))        (unless *read-suppress*          (let ((point (apply #'make-big-point list)))            (if (consp point)              `(make-big-point ,(%car point) ,(%cdr point))              point))))))(defun require-no-numarg (subchar numarg)  (if (and numarg (not *read-suppress*))      (error "Spurious numeric argument in #~D~A reader macro ." numarg subchar)))(set-dispatch-macro-character #\# #\P (qlfun |#P-reader| (stream char flags &aux path (invalid-string "Invalid flags (~S) for pathname ~S"))   (declare (ignore char))   (when (null flags) (setq flags 0))   (unless (memq flags '(0 1 2 3 4))     (unless *read-suppress* (report-bad-arg flags '(integer 0 4))))   (setq path (read stream t nil t))   (unless *read-suppress*     (unless (stringp path) (report-bad-arg path 'string))     (setq path (pathname path))     (when (%ilogbitp 0 flags)       (when (%pathname-type path) (error invalid-string flags path))       (setf (%pathname-type path) :unspecific))     (when (%ilogbitp 1 flags)       (when (%pathname-name path) (error invalid-string flags path))       (setf (%pathname-name path) ""))     path)))(set-dispatch-macro-character #\# #\_  (qlfun |#_-reader| (stream char arg)    (declare (special *traps-package*))    (when arg (unless *read-suppress* (%err-disp $xrdnoarg char)))    (unless *read-suppress*      (require :defrecord)      (require :deftrap))    (stream-untyi stream #\_)    (let* ((sym (let ((*package* *traps-package*)) (read stream t nil t))))      (unless *read-suppress*        (unless (and sym (symbolp sym)) (report-bad-arg sym 'symbol))        (load-trap sym stream)))))(set-dispatch-macro-character  #\# #\$ (qlfun |#$-reader| (stream char arg)   (declare (special *traps-package*))   (declare (ignore char))   (unless *read-suppress*     (require :defrecord)     (require :deftrap))   (stream-untyi stream #\$)   (let* ((sym (let ((*package* *traps-package*)) (read stream t nil t))))     (unless *read-suppress*       (unless arg (setq arg 0))       (ecase arg         (0          (unless (boundp sym)            (load-trap-constant sym stream)))         (1 (makunbound sym) (load-trap-constant sym stream)))       sym))))#|(set-dispatch-macro-character #\# #\" #'(lambda (stream char arg)     (declare (ignore arg))     (unless *read-suppress*       (let ((pos0 (stream-position stream)))       (stream-untyi stream char)       (let* ((string (read stream t nil t))              (scriptruns (stream-script-runs stream pos0 (1- (stream-position stream)))))         (if scriptruns           (make-instance 'scripted-string string scriptruns)           string)))))); if we do this need a print-object - define stream-script-runs for input-script-file-stream; buffer-stream and what else? can a scripted string be used for an output-string-stream; Need to be able to pass these things to buffer-insert; stream-write-string????? - doesn't fit very well - would be fine if unicode files existed; Seems like styled-string would be the natural next request #S"asdf" ?; from buffers - buffer-substring generalizes to buffer-scripted-substring and buffer-styled-substring; from fred-dialog-items ditto - just a delegation - use for searches?; Use styled string where we now use a cons of string and style.(defmethod stream-script-runs (stream bpos epos)  (declare (ignore stream bpos epos)))|#;end of L1-readloop.lisp#|	Change History (most recent last):	2	12/27/94	akh	merge with d13	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)