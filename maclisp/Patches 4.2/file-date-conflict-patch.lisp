; -*- Mode: Lisp; Package: CCL; -*-(in-package :ccl);;; move buffer-save-conflict  to window-save remove from %buffer-write-file(eval-when (:compile-toplevel :execute)(require "FREDENV")(def-accessors %svref  bfc.prev  bfc.next  bfc.string)(def-accessors %svref  nil  markl.gclink  markl.data)#-ppc-target(deflapgen chunk_ptr (asrc adest)  (lap-instr `(progn (move.l (svref ,asrc bfc.string) ,adest)                     (add.w ($ $v_data) ,adest))))(defmacro inline-check-mark (thing)  (if (ppc-target-p)    #+ppc-clos    (let ((thing-sym (gensym)))      `(let ((,thing-sym ,thing))         (unless (eq (ppc-typecode ,thing-sym) ppc::subtag-mark)           (%badarg ,thing-sym 'buffer-mark))))    #-ppc-clos (error "uh")    `(lap-inline (,thing)       (move.l acc atemp0)       (if# (or (ne (ttagp ($ $t_vector) acc da))                (ne (vsubtypep ($ $v_mark) atemp0 da))                (ne (progn                      (move.l (svref atemp0 mark.buffer) atemp0)                      (vsubtypep ($ $v_istruct) atemp0 da))))         (ccall %badarg acc 'buffer-mark)))))(defmacro set-fontruns-font (array idx value)  (if (ppc-target-p)    (let ((arr (gensym)))      `(the fixnum         (let ((,arr ,array))           (declare (optimize (speed 3)(safety 0)))           (declare (type (simple-array (unsigned-byte 8) (*)) ,arr)) ; lie           (setf (aref ,arr (%ilsl 2 ,idx)) ,value))))    `(lap-inline (,array ,idx ,value)       (asr.l ($ (- $fixnumshift 2)) arg_y) ; idx       (move.l arg_x atemp0)  ; array       (getint acc)  ; value       (move.b acc (atemp0 arg_y.l $v_data))       (mkint acc))))     (defmacro set-fontruns-pos (array idx pos)  (if (ppc-target-p)    (let* ((arr (gensym))           (iv (gensym))           (pv (gensym)))      `(let ((,arr ,array)             (,iv (%ilsl 1 ,idx)) ; this sucks             (,pv ,pos))                  (declare (optimize (speed 3)(safety 0)))         (locally (declare (type (simple-array (unsigned-byte 8)(*)) ,arr))           (setf (aref ,arr (%i+ 1 (%ilsl 1 ,iv))) (%ilsr 16 ,pv)))         (locally (declare (type (simple-array (unsigned-byte 16) (*)) ,arr)) ; lie           (setf (aref ,arr (%i+ 1 ,iv)) ,pv))))  `(lap-inline (,array ,idx ,pos)     (asr.l ($ (- $fixnumshift 2)) arg_y) ; idx     (getint arg_z)  ; pos     (move.l arg_x atemp0)      (clr.l arg_x)     (move.b (atemp0 arg_y.l $v_data) arg_x)     (ror.l ($ 8) arg_x)     (or.l arg_x arg_z)     (move.l arg_z (atemp0 arg_y.l $v_data))     (move.l nilreg acc))))(defmacro set-fontruns (array idx font pos)  (if (ppc-target-p)    (let* ((arr (gensym))           (iv (gensym))           (pv (gensym)))      `(let ((,arr ,array)             (,pv ,pos)             (,iv (%ilsl 1 ,idx))) ; this sucks         (declare (optimize (speed 3)(safety 0)))         (locally (declare (type (simple-array (unsigned-byte 16) (*)) ,arr)) ; lie           (setf (aref ,arr ,iv) (%ilogior (%ilsl 8 ,font)(%ilsr 16 ,pv)))           (setf (aref ,arr (%i+ 1 ,iv)) ,pv))))  ; this leaves trash in arg_x and arg_y  - does it matter  ;  assume array is a variable  `(lap-inline (,idx ,font ,pos)     (:variable ,array)     (asr.l ($ (- $fixnumshift 2)) arg_x) ; idx     (move.l (varg ,array) atemp0)     (getint arg_y)  ; font     (ror.l ($ 8) arg_y)          (getint arg_z)     (or.l arg_y arg_z)     (move.l arg_z (atemp0 arg_x.l $v_data))     (move.l nilreg acc))))(defmacro move-fontrun (array from to)  (if (ppc-target-p)    (let* ((arr (gensym))           (fromv (gensym))           (tov (gensym)))                        `(let ((,arr ,array)             (,fromv (%ilsl 1 ,from))             (,tov (%ilsl 1 ,to)))        (declare (optimize (speed 3)(safety 0)))        (declare (type (simple-array (unsigned-byte 16) (*)) ,arr)) ; lie        (setf (aref ,arr ,tov)(aref ,arr ,fromv))        (setf (aref ,arr (%i+ 1 ,tov))(aref ,arr (%i+ 1 ,fromv)))))      `(lap-inline (,array ,from ,to)     (asr.l ($ (- $fixnumshift 2)) arg_y)  ; from     (asr.l ($ (- $fixnumshift 2)) arg_z)   ; to     (move.l arg_x atemp0)     (move.l (atemp0 arg_y.l $v_data) (atemp0 arg_z.l $v_data))     (move.l nilreg acc)))); allow more than 2 args; Handy.  Good thing it's (eval-when (:compile-toplevel)); in l1-edbuf.(defmacro %i++ (a b &rest args)  (if args `(%i+ ,a (%i++ ,b ,@args))      `(%i+ ,a ,b)))           ; not unary(defmacro %i-- (arg1 arg2 &rest args)  (if args `(%i- ,arg1 (%i++ ,arg2 ,@args))      `(%i- ,arg1 ,arg2))))(let ((*warn-if-redefine* nil)      (*warn-if-redefine-kernel* nil))(defmethod window-save ((w fred-mixin))  (let ((my-file-name (window-filename w)))    (if (null my-file-name)      (window-save-as w)      (progn        (let ((last-written (mac-file-write-date my-file-name))              (my-write-date (buffer-file-write-date (fred-buffer w))))          (when (and my-write-date (not (eql last-written my-write-date)))            (handle-buffer-save-conflict my-file-name)))         (window-save-1 w my-file-name :overwrite)        (setf (buffer-file-write-date (fred-buffer w))(mac-file-write-date my-file-name))                                  (ed-history-add w :saved nil)        ))))(defun %buffer-write-file (buffer name)  (let* ((buf (mark-buffer buffer))         (bufsiz (bf.bufsiz buf))         (chunksz (bf.chunksz buf))         (gappos (bf.gappos buf))         (gapend  (bf.gapend buf))         (chunk (bf.gapchunk buf))         (pos 0)         ;(old-date (buffer-file-write-date buffer))         ;new-date         chunk-buffer         (tem-string nil)         (tem chunk)         vrefnum)        (when tem      (while (setq tem (bfc.prev tem))        (setq chunk tem)))       (%stack-iopb (pb np)      (%path-to-iopb name pb :errchk)      (setq vrefnum (%get-signed-word pb $iovrefnum))      ;(setq new-date (%get-unsigned-long pb $ioflmddat))      (setq name (%path-from-iopb pb)))    (with-pstrs ((pname (mac-namestring name)))      (%stack-block ((pb 52 :clear t))        (setf (rref pb :hparamblockrec.ioNamePtr) pname              (rref pb :hparamblockrec.ioVrefNum) vrefnum              (rref pb :hparamblockrec.ioversnum) 0              (rref pb :hparamblockrec.ioPermssn) $fswrperm              (rref pb :hparamblockrec.ioMisc) (%null-ptr))        (unwind-protect          (let ((io-buf-ptr))            (setq chunk-buffer (get-chunk-buffer (if (eq 'base-character (bf-chartype buf))                                                   chunksz                                                   (* 2 chunksz)))                  io-buf-ptr (car chunk-buffer))                     (errchk (#_PBOpenSync pb))            (setf (rref pb :hparamblockrec.iomisc) (%int-to-ptr 0))            #|            (when (and old-date (not (eql new-date old-date)))              (handle-buffer-save-conflict name))            |#            (errchk (#_PBSetEOFSync pb))                        (while (<  pos  gappos)              (let* ((n (min chunksz (- gappos pos)))                     (nbytes n))                (when (not chunk)(error "phooey"))                (without-interrupts                 (let ((str (bfc.string chunk)))                   (cond                     ((extended-string-p str)                     (when (not tem-string)                         (setq tem-string (make-string (* 2 chunksz) :element-type 'base-character)))                     (setq nbytes (squeeze-string-bytes str tem-string 0 0 n))                     (x%put-my-string pb tem-string $iobuffer io-buf-ptr 0 nbytes))                    (t (x%put-my-ptr pb chunk $iobuffer io-buf-ptr 0 nbytes))))                 (%put-long pb nbytes $ioreqcount)                 (errchk (#_PBWriteSync pb)))                (setq pos (+ pos n))                (unless (= pos gappos)(setq chunk (bfc.next chunk)))))            (while (>= gapend chunksz)              (setq gapend (- gapend chunksz))              (setq chunk (bfc.next chunk)))                  (when (not (zerop gapend))  ; write tail of last chunk in gap              (let* ((n (- chunksz gapend))                     (nbytes n))                (when (not chunk) (error "phooey"))                (without-interrupts                 (let ((str (bfc.string chunk)))                   (cond                    ((extended-string-p str)                     (when (not tem-string)                       (setq tem-string (make-string (* 2 chunksz) :element-type 'base-character)))                     (setq nbytes (squeeze-string-bytes str tem-string gapend 0 n))                     (x%put-my-string pb tem-string $iobuffer io-buf-ptr 0 nbytes))                    (t (x%put-my-ptr pb chunk  $iobuffer io-buf-ptr gapend nbytes))))                 (%put-long pb nbytes $ioreqcount)                 (errchk (#_PBWriteSync pb)))                (setq chunk (bfc.next chunk))                (setq pos (+ pos n))))            (while (< pos  bufsiz)              (when (not chunk) (error "phooey"))              (without-interrupts               (let* ((str (bfc.string chunk))                      (n (min chunksz (- bufsiz pos)))                      (nbytes n))                 (cond                  ((extended-string-p str)                   (when (not tem-string)                     (setq tem-string (make-string (* 2 chunksz) :element-type 'base-character)))                   (setq nbytes (squeeze-string-bytes str tem-string 0 0 n))                   (x%put-my-string pb tem-string $iobuffer io-buf-ptr 0 nbytes))                  (t (x%put-my-ptr pb chunk $iobuffer io-buf-ptr 0 nbytes)))                 (%put-long pb nbytes $ioreqcount))               (errchk (#_PBWriteSync pb)))              (setq chunk (bfc.next chunk))              (setq pos (+ pos chunksz))))          (when chunk-buffer (free-chunk-buffer chunk-buffer))          (unless (eq 0 (%get-word pb $ioRefNum))            (errchk (#_PBCloseSync pb))))))    name)))