;;;-*- Mode: Lisp; Package: CCL -*-;;	Change History (most recent first):;;  3 4/24/96  akh  from mcl 3.0;;  3 6/26/95  akh  fix redefmethod to account for some compiler changes;;  (do not edit before this line!!);;; patchenv.lisp;;; Copyright 1992-1994 Apple Computer, Inc.;;; Copyright 1995 Digitool, Inc.;;; require this file for compiling a patch file:#|(eval-when (:compile-toplevel :execute)  (require "PATCHENV"))|#;; The run-time code for this is part of patch 1 for MCL 2.0.;; For MCL 2.1, the run-time is at the end of "ccl:lib;pathnames.lisp";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Modification History;;;;;;  6/29/95 slh  redefmethod walks compiler-let forms;;; 04/13/93 bill p%nx1-operator works in 2.0 & 2.1;;;               record-source-file;;; 12/27/93 bill %nx1-operator no longer evals its arg;;; 10/09/92 bill redefnx2;;;(in-package "CCL")(defmacro redefine-function (access-form fn &optional                                          setf-access-form                                         (record-source-file-name access-form)                                         (record-source-file-type 'function))  (let* ((old (gensym))         (function (gensym)))    `(let* ((,old (,@access-form))            (,function ,fn))       (if (%swappable-function-p ,old)         (%set-xtab-lfun ,old ,function)         (let* ((*warn-if-redefine-kernel* nil)                (*warn-if-redefine* nil))           ,@(when record-source-file-name              `((record-source-file ',record-source-file-name ',record-source-file-type)))           (setf (,@(or setf-access-form access-form)) ,function))))))(defmacro redefun (name args &body body &environment env)  (setq name (require-type name 'symbol))       ;  should handle (SETF name): see DEFUN  (multiple-value-bind (forms decls) (parse-body body env t)    (let ((lambda-expr `(lambda ,args                           (declare (global-function-name ,name))                          ,@decls                           (block ,name ,@forms ))))      `(progn         (eval-when (:compile-toplevel)           (note-function-info            ',name ',lambda-expr ,env))         (redefine-function (fboundp ',name)                            (nfunction ,name                                        ,lambda-expr)                            (symbol-function ',name)                            ,name)))))(defun create-macro-function (name arglist body env &optional (inner-name name))  `(nfunction ,name ,(parse-macro-1 inner-name arglist body env)))(defmacro redefmacro (name arglist &body body &environment env)  (let ((macro-function-form (create-macro-function name arglist body env)))    `(progn       (eval-when (:compile-toplevel)         (define-compile-time-macro ',name ',(third macro-function-form) ',env))       (eval-when (:load-toplevel :execute)         (redefine-function (macro-function ',name) ,macro-function-form nil ,name)))))(defmacro redefine-compiler-macro (name arglist &body body &environment env)  `(eval-when (:compile-toplevel :load-toplevel :execute)     (redefine-function (compiler-macro-function ',name)                         ,(create-macro-function                          `(compiler-macro-function ,name) arglist body env name)                        nil                        nil)))(defmacro redefmethod (&whole call name &rest args &environment env)  (declare (ignore name args))  (let ((expansion (macroexpand `(defmethod ,@(cdr call)) env)))    (labels ((check-forms (forms)               (dolist (form forms)                 (when (consp form)                   (case (car form)                     (%defmethod                      (setf (car form) '%redefmethod)                      (return-from redefmethod (values expansion t)))                     (compiler-let                       (check-forms (cddr form))))))))      (check-forms expansion)      (error "Didn't find %defmethod in ~S" expansion))))(defmacro redefine-setf-method (access-fn lambda-list &body body)  "Syntax like DEFMACRO, but creates a Setf-Method generator.  The body  must be a form that returns the five magical values."  (unless (symbolp access-fn)    (signal-program-error $xnotsym access-fn))  (multiple-value-bind (lambda-form doc)                       (parse-macro-1 access-fn lambda-list body)    `(eval-when (load compile eval)       (re-store-setf-method ',access-fn                          (nfunction ,access-fn ,lambda-form)                          ,@(when doc (list doc))))))(defmacro redefnx1 (name sym arglist &body forms)  (let ((fn `(nfunction ,name ,(parse-macro name arglist forms)))        (theprogn ())        (ysym (gensym))        (re-sethash (gensym)))                        `(let ((,ysym ,fn))       (flet ((,re-sethash (key hash fn)                (let ((old-fn (gethash key hash)))                  (if (and old-fn (%swappable-function-p old-fn))                    (%set-xtab-lfun old-fn fn)                    (setf (gethash key hash) fn)))                fn))         ,(if (symbolp sym)            `(progn               (,re-sethash ',sym *nx1-alphatizers* ,ysym)               (proclaim '(inline ,sym))               (pushnew ',sym *nx1-compiler-special-forms*))            (dolist (x sym `(progn ,@(nreverse theprogn)))              (if (consp x)                (setq x (%car x))                (push `(pushnew ',x *nx1-compiler-special-forms*) theprogn))              (push `(proclaim '(inline ,x)) theprogn)              (push `(,re-sethash ',x *nx1-alphatizers* ,ysym) theprogn)))         (record-source-file ',name 'function)         ,ysym))))(defmacro p%nx1-operator (locative)  (if #.(fboundp 'make-process)    `(%nx1-operator ,locative)    `(%nx1-operator ',locative)))(defmacro redefnx2 (name locative arglist &body forms)  (multiple-value-bind (body decls)                       (parse-body forms nil t)    (let ((fn `(nfunction ,name (lambda ,arglist ,@decls (block ,name .,body))))          (re-svset (gensym)))    `(flet ((,re-svset (index fn)              (let* ((old-fn (svref *nx2-specials* index)))                (if (and old-fn (%swappable-function-p old-fn))                  (%set-xtab-lfun old-fn fn)                  (setf (svref *nx2-specials* index) fn)))))       (record-source-file ',name 'function)       (,re-svset (%ilogand operator-id-mask (p%nx1-operator ,locative)) ,fn)))))    (provide "PATCHENV")