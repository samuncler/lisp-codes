;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  3 8/25/97  akh  add finder comment stuff;;  17 9/13/96 akh  fix physical-pathname-p for nwo;;  16 9/4/96  akh  dont remember;;  13 7/30/96 akh  fix find-pstr-pattern - dont run off the end;;  12 7/26/96 akh  fix %path-pstr*=;;  10 5/20/96 akh  path-pstr*= fix for false alarm on match with *;;  7 1/28/96  akh  back-translate-pathname takes optional allowable hosts arg;;  3 11/17/95 akh  #_hxx => #_PBHxx;;  2 10/11/95 akh  no lap if ppc;;  7 9/14/95  akh  path-pstr*=  - firstbyte => singlebyte;;  6 7/27/95  akh  merge patches - set-xtab-lfun and redefmethod;;  5 6/8/95   slh  make load-all-patches really do that;;  2 4/28/95  akh  fix path-pstr*= - aref char-byte-table (not svref);;  3 3/2/95   akh  say element-type 'base-character;;  (do not edit before this line!!);;pathnames.lisp Pathnames for Coral Common LISP;; Copyright 1987-1988 Coral Software Corp.;; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.(in-package "CCL"); Modification History:;; akh - bill's set/get finder-comment with shannon spire's fix - added finder-comment-p arg to copy-file; akh fix physical-pathname-p for nwo; 08/05/96 bill (errchk (#_NewHandle ...)) => (#_NewHandle :errchk ...) in new-version-resource & patch-resource;  7/31/96 slh  cond. out def-logical-directory (see comment); 04/25/96 bill load-patches says (make-pathname :name :wild :defaults *.fasl-pathname*);               instead of "*.fasl".; 04/25/96 bill flush-volume resolves aliases.; akh path-pstr*= fix for false alarm on match with *; ------------- MCL-PPC 3.9; 03/26/96  gb  lowmem accessors.; 02/26/96 gb    #-ppc-target functions-match-p; 12/05/95 slh   update trap names (a few more); 11/29/95 bill  New trap names to avoid emulator.;                (#_PBxxx :errchk ...) -> (errchk (#_PBxxx ...)); 11/30/95 slh   no patch-subprim for PPC; 10/06/93 bill  register-patch, list-patches; 10/04/93 bill  patch-resource can now lengthen the resource; -------------- 3.0d13; 07/13/93 alice rename-file, create-directory load-patches call full-pathname with no-error nil; 06/16/93 alice fs-cons-pathname is no more, %dir-sub-file uses %std-name-and-type; 06/12/93 alice %path-pstr*= deals with fat strings and assumes pstr is in system script.; 04/13/93 bill  record-source-file in %redefmethod; 02/09/93 bill  #_allocate -> #_SetEof. This makes Harold Haig's file server happy.; 12/09/92 bill  #_allocate returns to %copy-fork; 11/25/92 bill  patch-resource, patch-subprim; 08/25/92 bill  in %copy-fork: use autoloaded records & constants, not sysequ.lisp constants; 07/09/92 bill  added run-time for "ccl:lib;patchenv"; 11/05/92 alice once again %directory, %one-wild, %all-directories - avoid indirect alias circles;		while not avoiding good stuff (patch 2); 08/27/92 alice bigger block size in copy-file; 04/29/92 alice %one-wild - dont resolve alias unless it matches;		directory, %directory, %all-directories avoid indirect circles when resolving aliases; 04/23/92 alice directory - fix (directory "*:abcd:" :directories t); 04/16/92 alice %file*= - ALWAYS put the length back (fixes a crock in directory); 02/28/92 alice directory dtrt when no directory provided; 02/07/92 alice volume-number does something useful with 0;--------------- 2.0; 01/12/92 alice copy-file revert; 12/16/91 alice eject-disk and friends allow volume-number too; 12/12/91 gb    %err-disp -> signal-file-error, with fixnum args.; 12/12/91 bill  #_LoadResource after #_Get1Resource;--------------- 2.0b4; 11/04/91 alice fs-cons-pathname quotes dots iff could be construed as having a version .0 or .newest; 11/01/91 alice undo 09/12/91 - it is WRONG; 10/10/91 alice rename-file use gen-file-name; 10/21/91 gb    no more #_PB; 09/24/91 alice fix load-logical-pathname-translations a) dont if already defined b) return T if loaded; 09/20/91 alice another fix to rename-file ; 09/12/91 alice files-in-directory if :directories t, also include dir if name is "*" - NO; 09/12/91 alice create-directory failed to create intermediate dirs (result of alias mods); 09/11/91 alice copy-file obey :if-exists nil, rename-file was ill, create-directory recurse FULL PHYSICAL dir;--------------- 2.0b3; 08/29/91 alice %files-in-directory and %all-directories with no name or type heed directories argument; 08/26/91 bill  copy-file reported some errors on wrong pathname; 08/22/91 alice %copy-fork had another typo; 08/21/91 bill  %copy-fork had a typo; 08/21/91 alice forgot to pass along resolve-aliases in a few places.; 08/01/91 alice adapt for aliases (to do:  rename-file, copy-file); 07/29/91 alice do dirids as 1 long; 07/21/91 gb    use :clear option in %stack-block.  Use _Allocate when copying forks.; 07/12/91 alice directory escape dots in name (so dont lose .0 etc); 07/09/91 alice simpler back-translate-pathname; 07/03/91 alice fix bogosity in back-translate-pathname; 06/28/91 alice make backtranslate-pathname do the old style logical dirs too.; 06/10/91 alice backtranslate-pathname deal with :wild in directory list; 06/07/91 alice new-version-resource read 'vers' from curaprefnum.;------------ 2.0b2; 06/04/91 alice add some more vars to load-patches; 05/20/91 bill translate-logical-pathname in dirpath-to-filepath; 05/16/91 bill add a :fork keyword to copy-file.; 05/15/91 bill copy-file does _FlushVol.  %copy-fork clears the ioMisc field before open.; 04/02/91 alice drive-name takes neg num to serve as volume-name; 03/28/91 alice put load-patches here for lack of a better place; 03/08/91 alice rename-file do directories too, deal with catmove + rename.; 02/26/91 alice copy-file - dont create new before know old exists!; 02/22/91 alice %err-disp => file-error; 02/08/91 alice added back-translate-pathname; 02/07/91 alice moved some stuff to l1-pathnames; 02/06/91 alice %pathname-match-dir1 - logical match physical?;---------- 2.0b1; 02/06/91 alice load-logical-pathname-translations; 01/30/91 alice dir etal don't call dir-path-from-iopb because GatorShare the Caymen/NFS thing doesnt;          work right for protected dirs (can _getcatinfo via iofdirindex but not by ioDirID); 01/28/91 alice directory and friends use #files instead of waiting for fnferr; 01/25/91 alice directory and friends - if unexpected error just quit/continue, dont error; 01/25/91 alice set-logical-pathname-translations - fix so call to parse-namestring wont error;----------------- 2.0a5; 01/06/90 alice directory - do error if called upon undefined (ccl) logical directory; 01/03/90 alice translate-component and %split-component; 01/01/91 alice %component-match-p nothing matches **, %pathname-match-directory (abs vs. relative?); 01/01/90        translate-directory relative=>absolute is relative (??); 12/20/90 alice change call to %directory-list-namestring; 12/13/90 alice fix %all-directories when ** matches nothing; 12/11/90 alice change %some-specific; 12/10/90 alice fix %logical-directory-component (then nuke it);   flush-volume and some others like eject-disk call make-pathname with host nil (or defaults nil);   verify-logical-host-name - check for defined logical host;   deal with $afpAccessDenied errors in directory and friends;--------------- 2.0a4; 11/06/90 alice %pathname-match-dir0 fix to fix of 10/18/90 (so hd: matches hd:**:); 10/25/90 alice directory just call full-pathname instead of doing the same thing in line; 10/23/90 alice create-directory just thought it was doing translate-logical-pathname; 10/19/90 alice fix translate-directory for null source, %pathname-match-directory;                let nil match **; 10/18/90 alice %pathname-match-directory - dont match if one is longer - from alanr; 10/16/90 gb   no more %str-length.; 08/20/90 bill %%path*= per GZ; 07/25/90 alice directory work for relative pathnames too; 07/18/90 alice let create-directory create multiple sub-directories; ---------- 2.0d48; 07/12/90 alice make copy-file preserve creation and modification date; 07/06/90 alice create-directory and directory call translate-logical-pathname; 07/06/90 alice add eject&unmount-disk (name?? - useful ??); 07/01/90 alice The definitive and final version of directory; 06/29/90 alice added volume-number; 06/28/90 alice ever more fixes to directory; 06/22/90 bill found the ugly bug in copy-file; 06/21/90 alice fix directory **; 06/19/90 alice make copy-file lots faster; 06/11/90 alice pathname-match-p check logical host too; 06/01/90 alice add translate-pathname (yuck) and logical-pathname; 05/29/90 add pathname-match-p - fix kludge in file*=;05/25/90 alice Added %all-directories - kludged a fix in %file*= for *.*;05/21/90 bill Gails fix to %path-pstr*=;5/7/90   gz  Logical pathnames, modulo a parser.  %path*= -> %path-pstr*=, add;             %path-str*= for matching strings.;04/14/90 gz  %substr now takes start/end args.;             Logical-pathname -> logical-directory.;             Structured directories.;02/13/90 gz  Fix in rename-file:  _CatMove wants ioNewName null, not "".;09/30/89 bill Fixed cache clearing in %one-directory;09/27/89 gb simple-string -> ensure-simple-string.;09/25/89 bill Added mode line.  Add use-cache-p arg to %path-from-iopb calls in;              %one-directory.  Clear the cache at the beginning.;01/05/89 gz Don't pass empty strings to traps.;10/24/88 gz added def-logical-pathname, formerly in record-source(??);9/23/88 gb %path-[to,from]-pb -> %path-[to,from]-iopb.;9/01/88 gz directory done except for "**" matching.;8/30/88 gz new regime.  Directory not done yet.;8/16/88 gz $ioNamePtr -> $ioFileName. %str= -> string=.;9/29/87 jaj moved %do-files-in-directory and do-files-in-directory to l1-files;------------------------------------Version 1.0-----------------------------;8/21/87 gz  Made do-devices et. al. not expand into trap macros, so alltraps;            isn't needed to use them.;7/27/87 gz  Made file-locked-p return nil if file is not locked...;7/26/87 am  lock-file unlock-file locked-filep now return their args.;7/26/87 am  fixed directory to merge with *default-pathname-defaults*, and;            use the mac-default directory if there is still no dir specified.;7/24/87 gz  moved merge-pathnames and support to l1-files.; 7/24/87 am pathnamep -> lisp-pathnamep;7/22/87 am  modified pathname string-parsing per gz. made modules follow.;            the global vars like *default-pathname-defaults* start with nil;             made (pathname "foo") have nil directory component.;             twidled some arguments to %filename-matcher and %str*=; 7/18/87  gz try not to leave symbolic $constants in macroexpansions.; 7/11/87  gz added find-module-pathnames (which is called by require),;             *module-search-path*.;             Made user-homedir-pathname return the "home;" dir, rather than;             *working-directory*.; 7/ 6/87  am user-home-dir-pathname return *working-directory* + tiny changes:;             like hfs-volume-p -> %hfs-volume-p.;             with-pstrs -> with-returned-pstrs in files/directories-in-directory; 6/30/87  gz added some bccl conditionalizations.; 06/21/87 am changed file immensely for new file-system. put file in lib.; 06/21/87 gb moved pathmnamep, mac-pathnamep to l1-utils.  Made %pr-pathname;             call CCL printer.; 06/12/87 gb moved *pathname-escape-character* to level-2.  aux vars in;             directory, %filename-matcher.; 06/04/87 gb fixed pathnamep and mac-pathnamep when passed random uvectors.; 87 05 24 cfry fixed pathnamep and mac-pathnamep when passed "";;87 05 16 am made directory-list look for ESCAPED semicolons.;;87 05 06 am Made all components be strings, made pathnames be implemented as;             structures. Moved %str-mem-bak %str-member-i ;             toggle-case %str*= %str*=-aux %str-mem-esc %rem-unnecess-esc;             %ins-esc to level-2. %parse-filename-str now returns multiple-values;             instead of a list. + added many functions prefixed by mac- and %mac-;             mac-to-lisp-namestring -> %mac-to-lisp-namestring;;87 04 29 gb lexical variable name conflict in namestring.;;87 04 27 am added %str-member-i and toggle-case. made %str*=-aux use them.;;87 04 07 am fixed make-pathname and directory-namestring .; 4/5/87   gz string-to-simple-string* -> simple-string. %member -> memq.;;87 03 20 am expand-logical-pathnames -> expand-logical-namestring;;87 03 17 am file-streamp -> stream-has-file-p;;87 03 17 am string-to-simple-string* -> simple-string  #\¶ -> *pathname-escape-character*;             %str-length -> length;  added file-streamp. Hacked truename again.;;87 03 02 am Added a correct truename %truename defvared *working-directory*;;87 02 26 am added printing and reading, escape-chars; changed merging and;             expanding; no more downcasing.;;87 02 25 am (based on gz's changes of 1/30/87) %str-char ->schar,;             return -> return-from in %str*=,%str*=-aux,file-namestring,proper-dir-nam;             truename -> %truename, %i-path-string-truename -> %truename,;             am:truename -> truename.;87 02 24 am changed much to make work in code-0. removed #'directory!;87 02 23 am changed names for files-in-directory and directories-in-directory,;            put in a differeent user-home-dir function and changed #'devices;87 02 06 am added the fboundp cluase in the clause that defines truename.(eval-when (eval compile)  (require 'level-2)  (require 'backquote)  (require 'sysequ));(defconstant $accessDenied -5000) ; put this with other errnos(defconstant $afpAccessDenied -5000) ; which name to use?#+no ; it's in a compatibility file now(defun def-logical-directory (logical-name physical-pathname &aux pair len old)   "Physical-pathname may be NIL to remove the definition.    Returns old definition"   (setq logical-name (string-arg logical-name)) ;coerces to simple-string   (when (and (not (eql (setq len (length logical-name)) 0))              (eq (schar logical-name (setq len (%i- len 1))) #\;)              (not (%path-quoted-p logical-name len 0)))     (setq logical-name (%substr logical-name 0 len)))   (when physical-pathname     (when (non-nil-symbol-p physical-pathname)       (setq physical-pathname (symbol-name physical-pathname)))     (if (stringp physical-pathname)       (progn         (setq physical-pathname (ensure-simple-string physical-pathname))         (unless (or (eql (setq len (length physical-pathname)) 0)                     (and (%str-member (schar physical-pathname (%i- len 1)) ":;")                          (not (%path-quoted-p physical-pathname (%i- len 1) 0))))           (setq physical-pathname (%str-cat physical-pathname ":"))))       (setq physical-pathname (directory-namestring physical-pathname))))   (setq pair (%str-assoc logical-name *logical-directory-alist*))   (setq old (cdr pair))   (if (null physical-pathname) ;remove     (if pair (setq *logical-directory-alist*                    (remove-from-alist (%car pair) *logical-directory-alist*)))     (if pair (progn (%rplaca pair logical-name) ;In case new casification                     (%rplacd pair physical-pathname))         (push (cons logical-name physical-pathname)               *logical-directory-alist*)))   old);-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_;ANSI CL logical pathnames#|(defun %logical-directory-component (dir)  (cond ((null dir) nil)        ((eq dir ':wild) '(:absolute "**"))        ((stringp dir) (%directory-string-list dir 0))        ((listp dir)         (unless (or (eq (%car dir) ':absolute) (eq (%car dir) ':relative))           (report-bad-arg dir))         (unless (and (eq (%car dir) ':relative) (null (%cdr dir)))           (cons (%car dir)                 (mapcar #'(lambda (name)                             (cond ((eq name ':wild) "*")                                   ((eq name ':wild-inferiors) "**")                                   ((stringp name) (%verify-logical-component name "directory"))                                   ((consp name)                                    (list :logical (%verify-logical-component (cadr name) "directory")))                                                                       (t (report-bad-arg name))))                         (%cdr dir)))))        (t (report-bad-arg dir))))(defun %logical-name-component (name type)  (cond ((null name) nil)        ((eq name ':wild) "*")        ((stringp name)         (setq name (%verify-logical-component name type))         (when (%path-mem "." name)           (error "Illegal character in logical name component ~S" name))         name)        (t (report-bad-arg name))))|#(defvar *pathname-translations-pathname*  (make-pathname :host "ccl" :type "pathname-translations"))(defun load-logical-pathname-translations (host)  ;(setq host (verify-logical-host-name host))  (when (not (%str-assoc host %logical-host-translations%))    (setf (logical-pathname-translations host)          (with-open-file (file (merge-pathnames (make-pathname :name host :defaults nil)                                                 *pathname-translations-pathname*)                                :element-type 'base-character)            (read file)))    T))(defun back-translate-pathname (path &optional hosts)  (let ((newpath (back-translate-pathname-1 path hosts)))    (cond ((equalp path newpath)           (fcomp-standard-source path))          (t newpath)))); our old friend returns for awhile(defun fcomp-standard-source (name)  (if (pathnamep name)(setq name (namestring name)))  (let  ((len (length name)) str slen)    (dolist (log.phys *logical-directory-alist*)      (setq str (cdr log.phys) slen (length str))      (when (and (%i<= slen len) (string-equal str name :end2 slen))        (return-from fcomp-standard-source          (%str-cat (car log.phys)                    ";"                    (%substr name slen len)))))    name))#|; this only works for simple stuff!! wildcards at end only(defun back-translate-pathname-1 (path)  (dolist (host %logical-host-translations%)    (dolist (trans (cdr host))      (when (pathname-match-p path (cadr trans))        (let* ((rhs (cadr trans))               (path-dir (pathname-directory path))               (lhs-dir (pathname-directory (car trans)))               lhs-part               newpath)          (cond            ((and nil (logical-pathname-p path) ; this is may be totally bogus                 (logical-pathname-p (cadr trans)))            (setq newpath (translate-pathname path (cadr trans) (car trans) :reversible t)))           (t   ; should probably skip translations containing e.g. foo*bar                            (dolist (foo (cdr lhs-dir))              (when (if (stringp foo)                      (or (string= foo "**")                          (string= foo "*"))                      (memq  foo '(:wild-inferiors :wild)))                (return))              (push foo lhs-part))            (setq lhs-part (nreverse lhs-part))                        (when rhs              (let ((rhs-dir (pathname-directory rhs))                    (n 0))                (dolist (foo (cdr rhs-dir))                  (when (if (stringp foo)                          (or (string= foo "**")                              (string= foo "*"))                          (memq  foo '(:wild-inferiors :wild)))                    (return))                  (setq n (+ n 1)))                (setq newpath                      (make-pathname :host (car host)                                     :directory (cons (car path-dir)                                                      (nconc lhs-part                                                             (nthcdr n (cdr path-dir))))                                     :name (pathname-name path)                                     :type (pathname-type path)))))))          (return-from back-translate-pathname-1             (if  (equalp path newpath) path (back-translate-pathname-1 newpath)))))))  path)|#(defun back-translate-pathname-1 (path &optional hosts)  (dolist (host %logical-host-translations%)    (when (or (null hosts) (member (car host) hosts :test 'string-equal))      (dolist (trans (cdr host))        (when (pathname-match-p path (cadr trans))          (let* (newpath)                      (setq newpath (translate-pathname path (cadr trans) (car trans) :reversible t))            (return-from back-translate-pathname-1               (if  (equalp path newpath) path (back-translate-pathname-1 newpath hosts))))))))  path); must be after back-translate-pathname(defun physical-pathname-p (path)  (let* ((path (pathname path))         (dir (pathname-directory path)))    (and dir         (or (not (logical-pathname-p path))             (not (null (memq (pathname-host path) '(nil :unspecific))))))));-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_;File or directory Manipulations;This does a rename or a move as appropriate.  Doesn't handle a combination;of the two, though it should.; this can nuke a directory (should it?)(defun rename-file (old-path new-path &key (if-exists :error)                             &aux old-true-path new-true-path orig-new-path errno dirp)  (setq dirp (directory-pathname-p old-path))  (setq orig-new-path (setq new-path (merge-pathnames new-path old-path)))  (when dirp    (setq old-path (dirpath-to-filepath old-path))    (when (not (directory-pathname-p new-path))      (signal-file-error $xrenamedir new-path))    (setq new-path (dirpath-to-filepath orig-new-path)))  (%stack-iopb (npb nnp)    (%stack-iopb (opb onp)      (%path-to-iopb old-path opb :errchk)      (when (neq (%ilogbitp $ioDirFlg (%get-byte opb $ioFlAttrib)) dirp)        (signal-file-error $xdirnotfile old-path))      ;(%put-word opb 0 $ioFDirIndex)      ;(file-errchk (#_PBGetCatInfoSync old-path :a0 opb))      (%put-long opb (%get-long opb $ioFlParID) $ioDirID)      (setq old-true-path (%path-from-iopb opb :errchk))      (when dirp (setq old-true-path (filepath-to-dirpath old-true-path)))      (prog ()        new-path         (%path-to-iopb new-path npb :errchk nil t) ; Bug was here        (unless (eq (%get-word opb $ioVRefNum)(%get-word npb $ioVRefNum))          (error "Cannot rename across volumes"))        (if (and (eql (%get-long opb $ioDirID) (%get-long npb $ioDirID)))          (progn            (%put-ptr opb nnp $ioNewName)            (setq errno (#_PBHRenameSync opb))            (when (eq errno $dupFNErr)              (unless (eq if-exists :supersede)                (unless (setq new-path (if-exists if-exists (%path-from-iopb npb)))                  (return-from rename-file nil))                (setq if-exists :supersede)                (go new-path))              (setq errno (#_PBHDeleteSync npb))              (when (zerop errno)                (setq errno (#_PBHRenameSync opb)))              (unless (zerop errno)                (signal-file-error errno npb))))          (let ((tem-path (probe-file new-path)))            (when tem-path              (cond                ((neq if-exists :supersede)                (unless (setq new-path (if-exists if-exists tem-path))                  (return-from rename-file nil))                (setq if-exists :supersede)                (go new-path))               (t (file-errchk (#_PBHDeleteSync npb) new-path))))            (%put-long opb (%get-long npb $ioDirID) $ioNewDirID)            (%put-ptr opb (%null-ptr) $ioNewName)            (setq errno (#_PBCatMoveSync opb))            (cond              ((eq errno $dupFNErr) ; this happens if old name exists in new dir              (setq tem-path (gen-file-name old-true-path))              (rename-file old-true-path tem-path) ;give it a funny name in current dir              (setq new-true-path (nth-value 2 (rename-file tem-path new-path)))              (return))             ((not (%izerop errno)) (signal-file-error errno new-path)))            (when (not (string-equal (%get-string onp)(%get-string nnp)))              (setq new-true-path                    (nth-value 2 (rename-file (make-pathname                                                :directory (pathname-directory (full-pathname new-path :no-error nil))                                               :name (pathname-name old-true-path)                                               :type (pathname-type old-true-path)                                               :defaults nil)                                              new-path)))              (return))))        (%put-ptr npb nnp $ioFileName)        (setq new-true-path (%path-from-iopb npb)))      (when dirp (setq new-true-path (filepath-to-dirpath new-true-path)))      (values orig-new-path old-true-path new-true-path))))(defun copy-file (old-path new-path &key (if-exists :error) fork (blocksz 8192)                           finder-comment-p                           &aux true-new-path dfp rfp srcvol dstvol                            both-forks-p finder-info-p)  (unless fork (setq fork :both))  (unless (memq fork '(:both :data :resource))    (report-bad-arg fork '(member :both :data :resource)))  (setq both-forks-p (eq fork :both))  (when (directory-pathname-p old-path)    (signal-file-error $xnocopydir old-path))  (setq new-path (merge-pathnames new-path old-path))  (%stack-iopb (opb onp)    (%stack-iopb (npb nnp)      (%path-to-iopb old-path opb :errchk)      (setq old-path (%path-from-iopb opb))   ; truename       (%put-word opb 0 $ioFDirIndex)      (file-errchk (#_PBHGetFInfoSync opb) old-path)      (setq dfp (not (%null-ptr-p (%get-ptr opb $ioFlPyLen))))      (setq rfp (not (%null-ptr-p (%get-ptr opb $ioFlRPyLen))))      (setq true-new-path             (or (and (not both-forks-p)                     (probe-file new-path))                (progn                  (setq finder-info-p t)                  (create-file new-path :if-exists if-exists))))      (when (not true-new-path) (return-from copy-file nil))      (%path-to-iopb true-new-path npb :errchk)      (setq srcvol (%get-word opb $iovrefnum))      (setq dstvol (%get-word npb $ioVRefNum))      (%put-word opb dstvol $ioVRefNum)      (%put-long opb (%get-long npb $ioDirID) $ioDirID)      (%put-ptr opb (%get-ptr npb $ioFileName) $ioFileName)            (when finder-info-p        (file-errchk (#_PBHSetFInfoSync opb) new-path)) ; set most file info of new to be same as old       (with-pstrs ((srcname (mac-namestring old-path))                   (dstname (mac-namestring true-new-path)))        (%stack-block ((srcpb $iopbsize :clear t)                       (dstpb $iopbsize :clear t)                       (buf blocksz))          (%put-word srcpb srcvol $iovrefnum)          (%put-word dstpb dstvol $iovrefnum)          (%put-ptr srcpb srcname $iofilename)          (%put-ptr dstpb dstname $iofilename)          (%put-ptr srcpb buf $iobuffer)          (%put-ptr dstpb buf $iobuffer)          (when (and dfp (memq fork '(:data :both)))      ;data fork            (%copy-fork srcpb dstpb nil blocksz))          (when (and rfp (memq fork '(:resource :both)))  ; resource fork            (%copy-fork srcpb dstpb t blocksz))          (when finder-info-p            (file-errchk (#_PBHSetFInfoSync opb) new-path)) ; to get the dates right          (%put-ptr dstpb (%null-ptr) $iofilename)          (%put-word dstpb -1 $iovolindex)          (#_PBFlushVolSync :errchk dstpb)))      (when finder-comment-p        (set-finder-comment new-path (get-finder-comment old-path)))      (values new-path old-path true-new-path))))(defun %copy-fork (srcpb dstpb resource-p blocksz)  (unwind-protect    (progn      (setf (pref srcpb :HParamBlockRec.iopermssn) #$fsRdPerm)      (setf (pref dstpb :HParamBlockRec.iopermssn) #$fsWrPerm)      ; buffer address for _Open & _OpenRf      (setf (pref srcpb :HParamBlockRec.ioMisc) (%null-ptr))      (if resource-p         (errchk (#_PBOpenRFSync dstpb))        (errchk (#_PBOpenSync dstpb)))      (if resource-p        (errchk (#_PBOpenRFSync srcpb))        (errchk (#_PBOpenSync srcpb)))      (errchk (#_PBGetEOFSync srcpb))      (let ((reslen (%get-long srcpb $ioLEOF)))        (%put-long dstpb reslen $ioLEOF)        (errchk (#_PBSetEofSync dstpb))        (setf (pref srcpb :HParamBlockRec.ioPosMode) #$fsFromStart)        (setf (pref dstpb :HParamBlockRec.ioPosMode) #$fsFromStart)        (setf (pref srcpb :HParamBlockRec.ioReqCount) blocksz)        (setf (pref dstpb :HParamBlockRec.ioReqCount) blocksz)        (setf (pref srcpb :HParamBlockRec.ioPosOffset) 0)        (setf (pref dstpb :HParamBlockRec.ioPosOffset) 0)        (while (%i> reslen blocksz)          (errchk (#_PBReadSync srcpb))          (errchk (#_PBWriteSync dstpb))          (setq reslen (%i- reslen blocksz)))        (unless (%izerop reslen)          (setf (pref srcpb :HParamBlockRec.ioReqCount) reslen)          (setf (pref dstpb :HParamBlockRec.ioReqCount) reslen)          (errchk (#_PBReadSync srcpb))          (errchk (#_PBWriteSync dstpb)))))    (errchk (#_PBCloseSync dstpb))    (errchk (#_PBCloseSync srcpb)))); Return the Finder comment of a file or NIL if it doesn't have one.(defun get-finder-comment (path)  (%stack-iopb (pb np)    (when (zerop (%path-to-iopb path pb))      (let ((vrefnum (pref pb :CInfoPBRec.ioVRefNum))            (dirid (pref pb :CInfoPBRec.ioDirID)))        (rlet ((dtpb :DTPBRec                     :ioNamePtr (%null-ptr)                     :ioVRefnum vrefnum))          (%stack-block ((comment 200))            (when (eql 0 (#_PBDTGetPath dtpb))              (setf (pref dtpb :DTPBRec.ioNamePtr) np                    (pref dtpb :DTPBRec.ioDirID) dirid                    (pref dtpb :DTPBRec.ioDTBuffer) comment                    (pref dtpb :DTPBRec.ioDTReqCount) 200) ; SVS. Gotta do this.)              (when (eql 0 (#_PBDTGetComment dtpb))                (%str-from-ptr comment (pref dtpb :DTPBRec.ioDTActCount)))))))))); Set the finder comment of a file.; If comment is NIL, remove the finder comment(defun set-finder-comment (path comment)  (%stack-iopb (pb np)    (when (zerop (%path-to-iopb path pb))      (let ((vrefnum (pref pb :CInfoPBRec.ioVRefNum))            (dirid (pref pb :CInfoPBRec.ioDirID)))        (rlet ((dtpb :DTPBRec                     :ioNamePtr (%null-ptr)                     :ioVRefnum vrefnum))          (when (eql 0 (#_PBDTGetPath dtpb))            (setf (pref dtpb :DTPBRec.ioNamePtr) np                  (pref dtpb :DTPBRec.ioDirID) dirid)            (if comment              (with-cstrs ((comment-ptr comment))                (setf (pref dtpb :DTPBRec.ioDTBuffer) comment-ptr                      (pref dtpb :DTPBRec.ioDTReqCount) (length comment))                (when (eql 0 (#_PBDTSetComment dtpb))                  comment))              (eql 0 (#_PBDTRemoveComment dtpb)))))))))  (defun lock-file (path)  "Accepts files only"  (when (directory-pathname-p path) (signal-file-error $err-no-file path)) ; not really  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (file-errchk (#_PBHSetFLockSync pb) path)    (%path-from-iopb pb)))(defun unlock-file (path)  "Accepts files only"  (when (directory-pathname-p path) (signal-file-error $err-no-file path)) ; not really  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (file-errchk (#_PBHRstFLockSync pb) path)    (%path-from-iopb pb)))(defun create-directory (path &key (if-exists :error) &aux errno full-path)   (when (directory-pathname-p path) ; and translate-logical?    (setq path (dirpath-to-filepath path)))   (setq full-path (full-pathname path :no-error nil))  (%stack-iopb (pb np)    (setq errno (%path-to-iopb full-path pb nil nil T))    (when (or (eq errno $fnfErr) (eq errno $nsvErr)              (eq errno $dirNFErr)(eq errno $paramERR)) ; Aufs again      (create-directory (make-pathname :directory (pathname-directory full-path) :defaults nil)                        :if-exists if-exists)      (setq errno (%path-to-iopb full-path pb :errchk nil T)))    (if (null (%izerop errno))(signal-file-error errno path))    (setq errno (#_PBDirCreateSync pb))    (when (eq errno $dupFNErr)      (or (setq path (if-exists if-exists (%path-from-iopb pb) "CreateÉ"))          (return-from create-directory nil))      (%path-to-iopb path pb :errchk)      (file-errchk (#_PBHDeleteSync pb) path)      (setq errno (#_PBDirCreateSync pb)))    (%dir-path-from-iopb pb)))(defun dirpath-to-filepath (path)  (setq path (translate-logical-pathname path))  (let* ((dir (pathname-directory path))         (super (butlast dir))         (name (car (last dir))))      ;Gotta pick the dir name out of the path, e.g. "hd:ccl:new:" ->      ;"hd:ccl:new".  Problem is e.g. if it ends in "::"... Can't use      ;traps since the darn thing doesn't exist yet, so just punt on      ;the dubious cases...      (when (or (null super)            ; ":"                (eq name ':up)        ; "....::"                (and (eq (car super) ':absolute) (null (%cdr super))))  ; "hd:"        (signal-file-error $xnocreate path))      (setq path (make-pathname :directory super :name name :defaults nil))))(defun filepath-to-dirpath (path)  (let* ((dir (pathname-directory path))                  (rest (file-namestring path)))    (make-pathname :directory (append dir (list rest)) :defaults nil)))  ;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_;Volume manipulation;Actually, puts dir name, unless too long.(defun %put-volume-name (ptr path)  (setq path (mac-directory-namestring path))  (when (%i> (length path) 255)    (setq path (%substr path 0 (1+ (%str-member #\: path))))    (when (%i> (length path) 255) (signal-file-error $nsvErr path)))    (%put-string ptr path))(defun hfs-volume-p (path)  (%stack-iopb (pb np)    (%put-volume-name np path)    (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)    (%put-word pb 0 $ioVRefNum)    (file-errchk (#_PBHGetVInfoSync pb) path)    (eq (%get-word pb $ioVSigWord) #x4244)))(defun drive-number (path)  (%stack-iopb (pb np)    (%put-volume-name np path)    (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)    (%put-word pb 0 $ioVRefNum)    (file-errchk (#_PBHGetVInfoSync pb) path)    (%get-signed-word pb $ioVDrvInfo)))(defun volume-number (path-or-num)    (%stack-iopb (pb np)    (etypecase path-or-num      ((or pathname string)       (when (directory-pathname-p path-or-num)         (%put-volume-name np path-or-num)         (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)         (%put-word pb 0 $ioVRefNum)         (file-errchk (#_PBHGetVInfoSync pb) path-or-num)         (%get-signed-word pb $ioVRefNum)))      (fixnum       (%put-word pb 0 $ioVolIndex)       (%put-word pb path-or-num $ioVRefNum)       (let ((errno (#_PBGetVInfoSync pb)))         (if (%izerop errno) path-or-num nil)))))); allow negative numbers and this serves for volume-name as well(defun drive-name (number)  (setq number (require-type number '(integer #x-8000 #x7fff)))  (%stack-iopb (pb np)    (%put-word pb 0 $ioVolIndex)    (%put-word pb number $ioVRefNum)    (errchk (#_PBHGetVInfoSync pb))    (make-pathname :directory (%get-string np) :defaults nil)))(defun eject-disk (path-or-drive)  (%stack-iopb (pb np)    (if (integerp path-or-drive)      (progn                (%put-word pb 0 $ioVolIndex)        (%put-word pb path-or-drive $ioVRefNum))      (progn        (%put-volume-name np path-or-drive)        (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)        (%put-word pb 0 $ioVRefNum)))    (errchk (#_PBHGetVInfoSync pb))     ; Just so we can report the truename...    (errchk (#_PBEject pb))    (make-pathname :directory (%get-string np) :defaults nil)))(defun disk-ejected-p (path-or-drive)  (%stack-iopb (pb np)    (if (integerp path-or-drive)      (progn        ;(unless (< 0 path-or-drive #x8000) (report-bad-arg path-or-drive '(integer 1 #x7fff)))        (%put-word pb 0 $ioVolIndex)        (%put-word pb path-or-drive $ioVRefNum))      (progn        (%put-volume-name np path-or-drive)        (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)        (%put-word pb 0 $ioVRefNum)))    (errchk (#_PBHGetVInfoSync pb))    (and (%izerop (%get-word pb $ioVDrvInfo))         (%i< 0 (%get-signed-word pb $ioVDRefNum)))))(defun eject&unmount-disk (path-or-drive)  (%stack-iopb (pb np)    (if (integerp path-or-drive)      (progn        ;(unless (< 0 path-or-drive #x8000) (report-bad-arg path-or-drive '(integer 1 #x7fff)))        (%put-word pb 0 $ioVolIndex)        (%put-word pb path-or-drive $ioVRefNum))      (progn        (%put-volume-name np path-or-drive)        (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)        (%put-word pb 0 $ioVRefNum)))    (errchk (#_PBGetVInfoSync pb))      ; Just so we can report the truename...    (prog1 (make-pathname  :directory (%get-string np) :defaults nil)      (errchk (#_PBEject pb))      (errchk (#_PBUnmountVol pb)))))(defun flush-volume (path)  (%stack-iopb (pb np)    (%put-volume-name np (truename path))       ; truename resolves aliases    (%put-word pb (if (%izerop (%get-byte np)) 0 -1) $ioVolIndex)    (%put-word pb 0 $ioVRefNum)    (errchk (#_PBHGetVInfoSync pb))     ; Just so we can report the truename...    (errchk (#_PBFlushVolSync pb))    (%put-byte np (%i+ (%get-byte np) 1))   ; avoid a %str-cat later...    (%put-byte np (%char-code #\:) (%get-byte np))    (make-pathname :defaults  nil :directory (%get-string np))    )) #|(defun devices ()  (%stack-iopb (pb np)    (do ((index 1 (1+ index)) (result ()) errno)        ((not (%izerop (setq errno (progn (%put-word pb index $ioVolIndex)                                          (#_PBGetVInfoSync pb)))))         (if (eq errno $nsvErr) (nreverse result) (%err-disp errno)))      (%put-byte np (%i+ (%get-byte np) 1))   ; avoid a %str-cat later...      (%put-byte np (%char-code #\:) (%get-byte np))      (push (make-pathname :directory (%get-string np)) result))))|#;Takes a pathname, returns the truename of the directory if the pathname;names a directory, NIL if it names an ordinary file, error otherwise.;E.g. (directoryp "ccl;:foo:baz") might return #P"hd:mumble:foo:baz:" if baz;is a dir. - should we doc this - its exported?(defun directoryp (path)  (%stack-iopb (pb np)    (%path-to-iopb path pb nil)    (and (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))         (%dir-path-from-iopb pb))));-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_;Wildcards(defun wild-pathname-p (pathname &optional field-key)  (flet ((wild-p (name) (or (eq name :wild)                            (eq name :wild-inferiors)                            (and (stringp name) (%path-mem "*" name)))))    (case field-key      ((nil)       (or (some #'wild-p (pathname-directory pathname))           (wild-p (pathname-name pathname))           (wild-p (pathname-type pathname))           (wild-p (pathname-version pathname))))      (:host nil)      (:device nil)      (:directory (some #'wild-p (pathname-directory pathname)))      (:name (wild-p (pathname-name pathname)))      (:type (wild-p (pathname-type pathname)))      (:version (wild-p (pathname-version pathname)))      (t (wild-pathname-p pathname                          (require-type field-key                                         '(member nil :host :device                                           :directory :name :type :version))))))) ;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_;Directory Traversing;Make a list of all files matching the pattern and satisfying the restrictions;specified by the keyword args.  The :TEST arg is only called if all the;other conditions are satisfied (so the more of these special keywords we;have that can be detected from raw data, the fewer pathnames we have to cons;up).; known bug (directory "samson:" :directory-pathnames nil) gives; (#1P"Samson:samson") - should probably be "samson:" - let them report it.#| find other dirs in translations that match wild for e.g.      (setf (logical-pathname-translations "barf")            `(("barf:alice;**;*.*" "alice:**:*.*")             ("barf:**;*.*" "zoe:**:*.*")))|# #|; big pile of horse doo doo(defun other-wild-dirs (wild)  (let* ((host (pathname-host wild)))    (when (and host (neq host :unspecific))      (let* ((trans (logical-pathname-translations host))            (wilder (make-pathname :host host :directory (pathname-directory wild)                                   :name :wild :type :wild))            (full-wild (full-pathname wilder))            res)        (dolist (x trans res)          (when (pathname-match-p (print (make-pathname :host host :directory (pathname-directory (car x))                                                 :name :wild :type :wild))                                  wilder)            ; isnt right *.* doesn't match *.lisp            ; now **; doesn't match nothing            (print (list 3 (car x)))            (when (not (pathname-match-p (full-pathname (cadr x)) full-wild))              (push (cadr x) res))))))))(defun other-wild-dirs (wild)  (let* ((host (pathname-host wild)))    (when (and host (neq host :unspecific))      (let* ((trans (logical-pathname-translations host))                        (full-wild (full-pathname wild))            res)        (dolist (x trans res)          (when (pathname-match-p wild (car x))            ; isnt right *.* doesn't match *.lisp            ; now **; doesn't match nothing            ;(print (list 3 (car x)))            (when (not (pathname-match-p (full-pathname (cadr x)) full-wild))              (push (cadr x) res))))))))|#(defun other-wild-dirs (wild)  (declare (ignore wild)))(defun directory (path &key (directories nil)                       (files t)                       (directory-pathnames t)                       test resolve-aliases                       &aux dir wild rest errno)  (let* ((other-dirs (other-wild-dirs path))             (more (when other-dirs (mapcan #'(lambda (dir)                                            (directory dir :directories directories :files files                                                       :directory-pathnames directory-pathnames                                                       :test test :resolve-aliases resolve-aliases))                                        other-dirs)))         (path (full-pathname path :no-error nil))         (*directories-done* nil)         (dirlist (pathname-directory  path))); save parsing the string a million times    (declare (special *directories-done* nil))    (setq dir (if (null dirlist) ":"                  (%directory-list-namestring dirlist)))    ;dir is guaranteed to end in a ":".    #-bccl (unless (eq (schar dir (1- (length dir))) #\:)             (error "Bad dir format in ~S" path))    (multiple-value-setq (dir wild rest) (%split-dir dir))    (append     (%stack-iopb (pb np)       (nreverse        (if dir          (if (%izerop (setq errno (%path-GetDirInfo dir pb nil t)))                       (let ((so-far (nreverse (cdr (pathname-directory (%path-from-iopb pb)))))) ; <<              (cond (wild                     (cond ((string= wild "**")                            (%all-directories pb rest path directories files                                              directory-pathnames test so-far resolve-aliases))                           (t (%one-wild pb wild rest path directories files                                         directory-pathnames test so-far resolve-aliases))))                    (t (%directory pb rest path directories files                                   directory-pathnames test so-far resolve-aliases))))            (when nil              (unless (or (eq errno $fnfErr) (eq errno $nsvErr)(eq errno $afpAccessDenied)                          (eq errno $dirNFErr)(eq errno $paramERR)) ; Aufs again                (%err-disp errno))))          (let ((vol wild) more-p)                ; wild volume!             (if (string= vol "**")              (setq vol "*"  wild "**")              (multiple-value-setq (dir wild rest) (%split-dir rest))              )            (setq more-p (or (pathname-name path)(pathname-type path)))            (do ((index 1 (1+ index)) (result ()))                ((not (%izerop (setq errno (progn (%put-word pb index $ioVolIndex)                                                  (#_PBGetVInfoSync pb)))))                 (if (eq errno $nsvErr) result (signal-file-error errno path)))              (%put-long pb 2 $ioDirID) ; i dont get this? - dir of volume              (when (%path-pstr*= vol np)                (let ((so-far (list (%get-std-string np))))                  (declare (dynamic-extent so-far))                  (%put-word pb -1 $iofdirIndex)                  (file-errchk (#_PBGetCatInfoSync pb) path) ; to get # files                   ;(print (list so-far more-p dir wild rest))                  (setq result                        (nconc                         (cond (wild                                (cond ((string= wild "**")                                       (%all-directories pb rest path directories files                                                         directory-pathnames test so-far resolve-aliases))                                      (t (%one-wild pb wild rest path directories files                                                    directory-pathnames test so-far resolve-aliases))))                                                             ((and dir (not (string= dir ":")))                                (%some-specific pb dir wild rest path directories                                                files directory-pathnames test so-far resolve-aliases))                               ((or more-p (and rest (not (string= rest ":"))))                                (%directory pb rest path directories files                                            directory-pathnames test so-far resolve-aliases))                               (t ; ignore directory-pathnames option here - let them report the bug                                (let ((sub (%cons-pathname (cons :absolute (copy-list so-far)) nil nil)))                                  (when (and sub (or (null test)(funcall test sub)))                                    (list sub)))))                         result)))))))))     more)))(defun %directory (pb rest path directories files directory-pathnames test &optional so-far resolve-aliases)  ;(print (%dir-path-from-iopb pb))  (declare (special *directories-done*))  (when resolve-aliases          (push so-far *directories-done*))  (if (or (null rest)(string= rest ":"))    (%files-in-directory pb path directories files directory-pathnames test so-far resolve-aliases)    (multiple-value-bind (dir wild rest)(%split-dir rest)      (if (or (null dir)(string= dir ":"))         (cond (wild                (cond                 ((string= wild "**")                 (%all-directories pb rest path                                   directories files                                    directory-pathnames test so-far resolve-aliases))                (t (%one-wild pb wild rest path                              directories files directory-pathnames test so-far resolve-aliases))))               (t (if (and rest (not (string= rest ":")))(error "Shouldnt"))                  (%files-in-directory pb path                                       directories files                                       directory-pathnames test so-far resolve-aliases)))        (%some-specific pb dir wild rest path directories files directory-pathnames test so-far resolve-aliases))))); for a specific sub directory or directories(defun %some-specific (pb dir wild rest path directories files directory-pathnames test &optional so-far resolve-aliases)  ;(setq %saved-ioVRefNum% nil)     ; clear cache for %path-from-iopb  (when (%subdir-info dir pb resolve-aliases)    (setq so-far (nconc (nreverse (cdr (%directory-string-list dir 0))) so-far))    (cond (wild           (cond ((string= wild "**")                  (%all-directories pb rest path directories files                                    directory-pathnames test so-far resolve-aliases))                 (t (%one-wild pb wild rest path directories files                               directory-pathnames test so-far resolve-aliases))))          ((and rest (not (string= rest ":")))           ; does this ever happen?           (%some-specific rest nil nil path                           directories files directory-pathnames test so-far resolve-aliases))          (t (%directory pb rest path directories files directory-pathnames test so-far resolve-aliases))))); for a * or *x*y(defun %one-wild (pb wild rest path directories files directory-pathnames test &optional so-far resolve-aliases)  ;(setq %saved-ioVRefNum% nil)     ; clear cache for %path-from-iopb  (declare (special *directories-done*))  (with-macptrs ((np (%get-ptr pb $ioFileName)))    (let ((nfiles (%get-word pb $ioDrNmFls)))      (do ((index 1 (1+ index))           (dirid (%get-long pb $ioDirID))           (vrefnum (%get-word pb $iovrefnum))           (is-alias nil nil)           (so-far-alias nil nil)           (orig nil nil)           (result ()))          ((> index nfiles) (when result (delete-duplicates result :test #'equal)))        (when (%izerop (progn (%put-word pb index $ioFDirIndex)                              (#_PBGetCatInfoSync pb)))                    (when (and resolve-aliases (pb-alias-p pb)(%path-pstr*= wild np))            (setq orig (%get-std-string np))            (%put-long pb dirid $ioDirID)            (setq is-alias t)            (pb-resolve-alias pb)            (when (neq resolve-aliases :show-alias)              (setq so-far-alias (nreverse (cdr (pathname-directory (%x-path-from-iopb pb)))))))          (if (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))            (when (or orig  (%path-pstr*= wild np)) ; are we consistent or what              ; either show unresolved name which matches, or resolved name that doesnt              (let ((so-far                      (if (and orig (eq resolve-aliases :show-alias))                       (cons orig so-far)                       (or so-far-alias (cons (%get-std-string np) so-far)))))                (declare (dynamic-extent so-far))                (when (not (and is-alias (member so-far *directories-done* :test #'equal)))                  (setq result                        (nconc (%directory pb rest path directories files                                          directory-pathnames test so-far resolve-aliases)                             result)))))))        (%put-word pb vrefnum $iovrefnum)        (%put-long pb dirid $ioDirID))))); now for samson:**:*c*:**: we get samson:ccl:crap:barf: twice because; it matches in two ways; 1) **=ccl *c*=crap **=barf; 2) **= nothing *c*=ccl **=crap:barf; called to match a **(defun %all-directories (pb rest path directories files directory-pathnames test &optional so-far resolve-aliases)  (declare (special *directories-done*))  (when resolve-aliases      (push so-far *directories-done*))      (let ((do-files nil)        (do-dirs nil)        (result nil)        (name (pathname-name path))        (type (pathname-type path))        (nfiles (%get-word pb $ioDrNmFls))        sub dir)    (multiple-value-bind (next-dir next-wild next-rest)                         (%split-dir rest)      (when (and (or (null next-dir)(string= next-dir ":"))                 next-wild                 (string= next-wild "**")) ; i.e. some dummy said :**:**: which = :**:        (setq rest next-rest)        (multiple-value-setq (next-dir next-wild next-rest)                             (%split-dir next-rest)))      (cond ((or (null rest)(string= rest ":"))             (cond ((or name type)                    (when files (setq do-files t))                    (when directories (setq do-dirs t)))                   (t (when (null dir)                        (setq dir (cons :absolute (nreverse (copy-list so-far)))))                      (when directories                        (setq sub (if directory-pathnames                                    (%cons-pathname dir nil nil)                                    (%cons-pathname (butlast dir)(car (last dir)) nil)))                        (when (and sub (or (null test)(funcall test sub)))                          (setq result (list sub)))))))            (t ; first deal with ** matching nothing             (let ((dirid (%get-long pb $ioDirID))                   (vrefnum (%get-word pb $iovrefnum))) ; in case changed by alias             (setq result                                      (cond                     ((and next-dir (not (string= next-dir ":")))                      (%some-specific pb next-dir next-wild next-rest path                                     directories files directory-pathnames                                     test so-far resolve-aliases))                    (next-wild                     (%one-wild pb next-wild next-rest path                                directories files directory-pathnames test so-far resolve-aliases))                    (t (error "Shouldnt"))))             ; back up to starting point             (%put-word pb vrefnum $iovrefnum)             (%put-long pb dirid $ioDirID)))))                   ; now descend doing %all-dirs on dirs and collecting files & dirs if do-x is t    (with-macptrs ((np (%get-ptr pb $ioFileName)))           (do ((index 1 (1+ index))           (dirid (%get-long pb $ioDirID))           (vrefnum (%get-word pb $iovrefnum))           (is-alias nil nil)           errno)          ((> index nfiles)(when result (delete-duplicates result :test #'equal)))       (let (orig resolved)        (setq errno (progn (%put-word pb index $ioFDirIndex)                           (#_PBGetCatInfoSync pb)))        (when (%izerop errno)          (when (and resolve-aliases (pb-alias-p pb))            (setq orig (%get-std-string np))            (%put-long pb dirid $ioDirID)            (pb-resolve-alias pb)            (setq is-alias t)            (when (neq resolve-aliases :show-alias)              (setq resolved (%x-path-from-iopb pb))))          (let ()            (if (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))              (progn                                (when (and do-dirs (if orig                                     (%path-str*= orig (file-namestring path))                                     (%file*= name type np)))                  (when (null dir)                    (setq dir (cons :absolute (nreverse (copy-list so-far)))))                  (setq sub (%dir-sub-dir np orig dir resolved directory-pathnames))                  (when (and sub (or (null test)(funcall test sub)))                    (push sub result)))                                (let ((so-far                        (if (and orig (eq resolve-aliases :show-alias))                         (cons orig so-far)                         (if resolved                            (nreverse (cdr (pathname-directory resolved)))                           (cons (%get-std-string np) so-far)))))                  (declare (dynamic-extent so-far))                  (when (not (and is-alias (member so-far *directories-done* :test #'equal)))                    (setq result                          (nconc (%all-directories pb rest path directories files                                                   directory-pathnames test so-far resolve-aliases)                                 result)))))              (when (and do-files (if orig (%path-str*= orig (file-namestring path))(%file*= name type np)))                                  (when (null dir)                    (setq dir (cons :absolute (nreverse (copy-list so-far)))))                  (setq sub (%dir-sub-file np orig dir resolved))                  (when (and sub (or (null test) (funcall test sub)))                    (push sub result))))))        (%put-word pb vrefnum $iovrefnum)                (%put-long pb dirid $ioDirID))))))(defun %x-path-from-iopb (pb)  (if (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))    (%dir-path-from-iopb pb)    (%path-from-iopb pb)))(defun %dir-sub-dir (np orig dir resolved directory-pathnames)    (cond    (resolved (if directory-pathnames               resolved               (let ((dir (pathname-directory resolved)))                 (%cons-pathname (butlast dir) (car (last dir)) nil))))   (t    (let ((part (if orig  orig (%get-std-string np))))      (if directory-pathnames        (%cons-pathname (append dir (list part)) nil nil)        (%cons-pathname dir part nil)))))) (defun %dir-sub-file (np orig dir resolved)  (if resolved resolved    (let ((part (if orig  orig (%get-string np))))      (multiple-value-bind (name type) (%std-name-and-type part)      (%cons-pathname dir name type)))))  (defun %files-in-directory (pb path directories files directory-pathnames test                               &optional so-far resolve-aliases)  (let ((name (pathname-name path))        (type (pathname-type path))        (result ())        (nfiles (%get-word pb $ioDrNmFls))        sub dir)    (when (and directories (not type) (null name)) ;(string= name "*")(string= name "**")))      (setq dir (cons :absolute                       (nreverse (copy-list so-far))))      (setq sub (if directory-pathnames                  (%cons-pathname dir nil nil)                  (%cons-pathname (butlast dir)(car (last dir)) nil)))      (when (and sub (or (null test)(funcall test sub)))        (setq result (list sub))))    (if (not (or name type))      result      (with-macptrs ((np (%get-ptr pb $ioFileName)))        (do ((index 1 (1+ index))             (dirid (%get-long pb $ioDirID))             (vrefnum (%get-word pb $iovrefnum))             (orig nil nil)             (resolved nil nil)             errno)            ((> index nfiles) result)          (setq errno                (progn (%put-word pb index $ioFDirIndex)                       (#_PBGetCatInfoSync pb)))          (when (%izerop errno)            (when (and (pb-alias-p pb) resolve-aliases)              (when (eq resolve-aliases :show-alias)                (setq orig (%get-std-string np)))              (%put-long pb dirid $iodirid)              (pb-resolve-alias pb)              (when (neq resolve-aliases :show-alias)                (setq resolved (%x-path-from-iopb pb))))            (when (%file*= name type np)              (if (not dir)                (setq dir (cons :absolute (nreverse (copy-list so-far)))))              (let ((sub nil))                (if (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib))                  (when directories                    (setq sub (%dir-sub-dir np orig dir resolved directory-pathnames)))                  (when  files                    (setq sub (%dir-sub-file np orig dir resolved))))                (when (and sub (or (null test) (funcall test sub)))                  (pushnew sub result :test #'equal)))))          (%put-word pb vrefnum $iovrefnum)          (%put-long pb dirid $ioDirID))))))(defun %get-std-string (np)  (with-macptrs ((pp (%inc-ptr np 1)))      (%path-std-quotes (%str-from-ptr-in-script pp (%get-byte pp -1)) nil ":;*")))#|(defun print-pb (pb &optional foo)  (format t "~%~S vrefnum ~x fdiridx  ~x vidx ~x dirid ~x ~S"          (let ((np (%get-ptr pb $iofilename)))            (when (not (eql np (%null-ptr)))(%get-string (%get-ptr pb $iofilename))))          (%get-signed-word pb $iovrefnum)          (%get-word pb $iofdirindex)          (%get-signed-word pb $iovolindex)          (%get-long pb $iodirid)          foo))|#(defun %split-dir (dir &aux pos)                 ; dir ends in a ":".  ;"foo:bar::x*y:baz::z*t:"  ->  "foo:bar::" "x*y" ":baz::z*t:"  (if (null (setq pos (%path-mem "*" dir)))    (values dir nil nil)    (let (epos (len (length dir)))      (setq pos (if (setq pos (%path-mem-last ":" dir 0 pos)) (%i+ pos 1) 0)            epos (%path-mem ":" dir pos len))      (values (unless (%izerop pos) (%path-mac-namestring (%substr dir 0 pos)))              (%substr dir pos epos)              (%substr dir epos len))))); true if macdir is a possibly multi component subdir of thing in pb; oh foo - if multi component need to deal with aliases (will be slow)(defun %subdir-info (macdir pb resolve-aliases &aux errno dirid)  (declare (ignore-if-unused errno))    ; refs to errno depessimized out.  (or (string= macdir ":")      (with-macptrs (np)        (%setf-macptr np (%get-ptr pb $ioFileName))        (%put-string np macdir)        (%put-word pb 0 $ioFDirIndex)  ; means heed the name        (setq dirid (%get-long pb $iodirid))        (if (%izerop (setq errno (#_PBGetCatInfoSync pb)))          (progn (when (and resolve-aliases (pb-alias-p pb))                   (%put-long pb dirid $iodirid)                   (pb-resolve-alias pb))                 (%ilogbitp $ioDirFlg (%get-byte pb $ioFlAttrib)))          (when nil ;(print errno)            (unless (or (eq errno $fnfErr)                        (eq errno $paramErr) ; AUFS returns this sometimes                        (eq errno $nsvErr)                        (eq errno $dirNFErr)                        (eq errno $afpAccessDenied))            (%err-disp errno))))))); experimental and wrong.#+gonzo(defun %path-pstr*= (pattern pstr &optional (pos 1))  (cond    (#-PPC-target    (and (eq (default-script #$smSystemScript) #$smRoman)(simple-base-string-p pattern))    #+PPC-target nil    (%%path-pstr*= pattern pstr pos))   (t    (require-type pstr 'macptr)    (require-type pattern 'simple-string)    (let ((p-start 0)          (p-end (length pattern))          (s-start pos)          (s-end (+ (%get-byte pstr 0) 1))          (p*pos)          (s*pos)          (esc (char-code *pathname-escape-character*))          (table (get-char-byte-table nil)))      (declare (optimize (speed 3)(safety 0)))      (declare (fixnum p-start p-end s-start s-end))      (loop                (when (eq p-start p-end)          (when (eq s-start s-end)(return-from %path-pstr*= t))          ; maybe * includes more          (when (null p*pos) (return nil))          (setq p-start p*pos)          (setq s-start s*pos)          (when (eq s-start s-end)(return-from %path-pstr*= nil)))        (let ((p (%scharcode pattern p-start)))          (cond            ((eq p (char-code #\*))            (setq p*pos p-start)            (loop                        (setq p-start (%i+ 1 p-start))              (when (eq p-start p-end)(return-from %path-pstr*= t))              (unless (eq (setq p (%scharcode pattern p-start)) (char-code #\*))                (return)))            (loop ; looking for the char after *              (when (eq s-start s-end)(return-from %path-pstr*= nil))              (let ((s (%get-byte pstr s-start)))                (when (and table (eq (aref table s) 1))                  (setq s-start (1+ s-start))                  (when (eq s-start s-end)(return-from %path-pstr*= nil)) ; shouldnt happen                  (setq s (%ilogior (%ilsl 8 s)(%get-byte pstr s-start))))                (setq s-start (%i+ 1 s-start))                (when (or (eq p s)                          (and (eq p (%ilogxor s 32))                               (progn (setq s (%ilogior s 32))                                      (>= s (char-code #\a)))                               (%i<= s (char-code #\z))))                  (setq p-start (%i+ 1 p-start))                  (setq s*pos s-start)                  (return)))))           (t            (when (eq p esc)              (setq p (%scharcode pattern (setq p-start (1+ p-start)))))            (when (eq s-start s-end)(return-from %path-pstr*= nil))            (let ((s (%get-byte pstr s-start)))              (when (and table (eq (aref table s) 1))                (setq s-start (1+ s-start))                (when (eq s-start s-end)(return-from %path-pstr*= nil)) ; shouldnt happen                (setq s (%ilogior (%ilsl 8 s)(%get-byte pstr s-start))))                        (when (not (or (eq p s)                             (and (eq (%ilogxor p 32) s)                                  (progn (setq p (%ilogior p 32))                                         (>= p (char-code #\a)))                                  (%i<= p (char-code #\z)))))                (when (or (null p*pos)                          (eq (1+ s-start) s-end))                  (return-from %path-pstr*= nil))))            (setq p-start (1+ p-start))            (setq s-start (1+ s-start))))))))))(defun %path-pstr*= (pattern pstr &optional (pos 1))  (cond    (#-PPC-target    (and (eq (default-script #$smSystemScript) #$smRoman)(simple-base-string-p pattern))    #+PPC-target nil    (%%path-pstr*= pattern pstr pos))   (t    (require-type pstr 'macptr)    (require-type pattern 'simple-string)    (let* ((p-end (length pattern))           (s-end (+ (%get-byte pstr 0) 1))           (table (get-char-byte-table nil)))      (declare (optimize (speed 3)(safety 0)))      (declare (fixnum p-start p-end s-start s-end))      (path-pstr-sub pattern pstr 0 pos p-end s-end table)))))(defun path-pstr-match-p (pattern pstr p-start s-start p-end s-end table)  (declare (fixnum p-start s-start p-end s-end))  (declare (optimize (speed 3)(safety 0)))  ;; does pattern match pstr between p-start p-end  ;(when (or (>= p-start p-end)(>= s-start s-end)) (error "a"))  (let ((esc (char-code *pathname-escape-character*)))    (loop            (when (eq p-start p-end)        (return (eq s-start s-end)))      (WHEN (>= S-START S-END)(RETURN NIL))      (let ((p (%scharcode pattern p-start)))        (when (eq p esc)          (setq p (%scharcode pattern (setq p-start (1+ p-start)))))        ;(when (eq p #\*)(return p-start))        (when (eq p-start p-end)          (return T))        (let ((s (%get-byte pstr s-start)))          (when (and table (eq (aref table s) 1))            (setq s-start (1+ s-start))            (when (eq s-start s-end)(return-from path-pstr-match-p nil)) ; shouldnt happen            (setq s (%ilogior (%ilsl 8 s)(%get-byte pstr s-start))))          (when (not (or (eq p s)                         (and (eq (%ilogxor p 32) s)                              (progn (setq p (%ilogior p 32))                                     (%i>= p (char-code #\a)))                              (%i<= p (char-code #\z)))))            (return nil))          (setq p-start (1+ p-start))          (setq s-start (1+ s-start))))))); find match of pattern between start and end in pstr ; rets one past end of pattern in pstr or nil(defun find-pstr-pattern (pattern pstr p-start s-start p-end s-end table)  (declare (fixnum p-start s-start p-end s-end))  (declare (optimize (speed 3)(safety 0)))  ;(when (or (>= p-start p-end)(>= s-start s-end)) (error "a"))  (let* ((first-p (%scharcode pattern p-start))         (esc (char-code *pathname-escape-character*)))    (when (eq  first-p esc)      (setq first-p (%scharcode pattern (setq p-start (1+ p-start)))))    (do* ((i s-start (1+ i))          (last-i (%i- s-end (%i- p-end p-start))))         ((> i last-i) nil)      (declare (fixnum i))      (let ((s (%get-byte pstr i)))        (when (and table (eq (aref table s) 1))          (setq I (1+ I))          (when (eq i s-end)(return-from find-pstr-pattern nil)) ; shouldnt happen          (setq s (%ilogior (%ilsl 8 s)(%get-byte pstr i))))        (when (or (eq first-p s)                  (and (eq first-p (%ilogxor s 32))                       (progn (setq s (%ilogior s 32))                                (%i>= s (char-code #\a)))                         (%i<= s (char-code #\z))))          (do* ((j (1+ i) (1+ j))                (k (1+ p-start)(1+ k)))               ((>= k p-end) (progn (return-from find-pstr-pattern j)))            (declare (fixnum j k))            (let* ((p (%scharcode pattern k))                   (s (%get-byte pstr j)))              (when (and table (eq (aref table s) 1))                (setq j (1+ j))                (when (eq j s-end)(return-from find-pstr-pattern nil)) ; shouldnt happen                (setq s (%ilogior (%ilsl 8 s)(%get-byte pstr i))))              (when (eq  p esc)                (setq p (%scharcode pattern (setq k (1+ k)))))              (when (not (or (eq p s)                             (and (eq (%ilogxor p 32) s)                                  (progn (setq p (%ilogior p 32))                                         (%i>= p (char-code #\a)))                                  (%i<= p (char-code #\z)))))                (return))))))))); does pattern match pstr between start and end(defun path-pstr-sub (pattern pstr p-start s-start p-end s-end table)  (declare (fixnum p-start s-start p-end s-end))  (declare (optimize (speed 3)(safety 0)))  ;(when (or (>= p-start p-end)(> s-start s-end)) (error "a"))  ;(print (list p-start p-end s-start s-end))  (let ((p (%scharcode pattern p-start))        (esc (char-code *pathname-escape-character*)))        (cond      ((eq p (char-code #\*))      ; starts with a * find what we looking for unless * is last in which case done      (loop ; lots of *'s same as one        (when (eq (%i+ 1 p-start)  p-end)          (return-from path-pstr-sub t))        (if (eq (%schar pattern (%i+ 1 p-start)) #\*)          (setq p-start (1+ p-start))          (return)))      (let* ((next* (%path-mem "*" pattern (%i+ 1 p-start)))             (len (- (or next* p-end) (%i+ 1 p-start))))                (loop          (when (> (+ s-start len) s-end)(return nil))          (let ((res (find-pstr-pattern pattern pstr (%i+ 1 p-start) s-start (or next* p-end) s-end table)))             (if (null res)              (return nil)              (if (null next*)                (if (eq res s-end)                  (return t))                                  (return (path-pstr-sub pattern pstr next* (+ s-start len) p-end s-end table)))))          (setq s-start (1+ s-start)))))     (t (when (eq p esc)          (setq p-start (1+ p-start))          (setq p (%scharcode pattern p-start)))        (let* ((next* (%path-mem "*" pattern (if (eq p (char-code #\*))(%i+ 1 p-start) p-start)))               (this-s-end (if next* (+ s-start (- next* p-start)) s-end)))          (if (> this-s-end s-end)            nil            (if  (path-pstr-match-p pattern pstr p-start s-start (or next* p-end) this-s-end table)              (if (null next*)                t                                  (path-pstr-sub pattern pstr next* this-s-end p-end s-end table)))))))))#-PPC-target(defun %%path-pstr*= (pattern pstr &optional (pos 1))  ;(format t "~&(%path-pstr*= ~S ~S ~S)" pattern (%get-string pstr)  pos)  (if (null pattern)    t    (lap-inline ()      (:variable pstr pattern pos)      (move.l (varg pstr) atemp0)      (jsr_subprim $sp-macptrptr)         ; typecheck      (move.l (varg pattern) atemp0)      (jsr_subprim $sp-check-string-atemp0)      (getvect atemp0 arg_z)      (move.l (varg pstr) atemp1)      (move.l (atemp1 $macptr.ptr) atemp1)      (moveq 0 arg_y)      (move.b (atemp1) arg_y)      (add.w ($ 1) arg_y)      (move.l (varg pos) da)      (getint da)      (add.l da atemp1)      (sub.l da arg_y)      (moveq 0 arg_x)      (jsr #'%%path*=))))(defun %file*= (name type pstr)  ;(format t "~&(%file*= ~S ~S ~S)" name type (%get-string pstr))  (when (and (null name) (null type))    (return-from %file*= T))  (let* ((len (%get-byte pstr)) (m len) val)    (until (or (%izerop m) (eq (%get-byte pstr m) (%char-code #\.)))      (setq m (%i- m 1)))    (unless (%izerop m) (%put-byte pstr (%i- m 1)))    (and (%path-pstr*= name pstr)         (setq val                (cond ((eq type :unspecific)                      (%izerop m))                     ((null type)                      T)                     (T                      (%put-byte pstr (if (%izerop m) 0 len))                      (%path-pstr*= type pstr (%i+ m 1))))))    (when t ;val      (%put-byte pstr len)      ;(format t "~%   ~S" (%get-string pstr))      )    val))#|(defun %probe-all-directories (vrefnum dirid name &aux results)  (setq results (%directory vrefnum dirid name))  (%do-directories-in-directory (pb vrefnum dirid "" results)  ;    (pdb (%get-long pb $ioDirId) name)     (setq results           (nconc (%probe-all-directories vrefnum (%get-long pb $ioDirId) name)                  results))))|#;;;;;;;;;;;;;;;;;;; Patch loader (defvar patch-directory-prefix "Patches ")   ; Patch dir name is "Patches 2.0a5"(defvar lisp-version-prefix "Version ")      ; version string is "Version 2.0a5"(defvar *new-lisp-patch-version* nil)        ; a number; i.e. 6(defun lisp-patch-version-number ()  (or (patch-file-version (lisp-implementation-short-version))   -1)); i.e. "2.0b1p6"(defun lisp-implementation-short-version ()  ; actually returns a string with  (let ((vers (lisp-implementation-version)))    (%substr vers (length lisp-version-prefix) (length vers)))); i.e. "2.0b1"(defun lisp-implementation-version-less-patch ()  (nth-value 2 (patch-file-version (lisp-implementation-short-version))))(defun new-version-resource ()  (let* ((newv *new-lisp-patch-version*)(oldv (lisp-patch-version-number)))    (when (and newv (neq newv oldv))      (let ((resh (%null-ptr))            (curfile (#_CurResFile))            oldsize)        (unwind-protect          (progn             (#_UseResFile (#_LMGetCurApRefNum))            (%setf-macptr resh (#_Get1Resource :|vers| 1))            (unless (%null-ptr-p resh)	      (#_LoadResource resh)              (setq oldsize (#_GetHandleSize resh))                            (with-dereferenced-handles ((r resh))                (let* ((len1 (%get-byte r 6))                       (str1 (%str-cat (lisp-implementation-version-less-patch) "p" (format nil "~A" newv)))                       (str2 (%get-string r (+ 7 len1)))                       (delta (- (length str1)(length (lisp-implementation-short-version)))))                  (setq str2 (%str-cat str1 (%substr str2 len1 (length str2))))                  (let ((newres (errchk (#_NewHandle (+ oldsize delta delta)))))                    (with-dereferenced-handles ((p newres))                      (dotimes (i 3)                        (declare (fixnum i))                        (%put-word p (%get-word r (+ i i)) (+ i i)))                      (%put-string p str1  6)                      (%put-string p str2 (+ 7 (length str1))))                    (list newres :|vers| 1))))))          (#_UseResFile curfile)))))); load all fasl's in the patch dir whatever they are named     (defun load-all-patches (&optional (source-dir (full-pathname "ccl:" :no-error nil)))  (load-patches source-dir t)  (setq *new-lisp-patch-version* nil)); some startup procedure should always do this - perhaps with a query; the ALL option loads every fasl in patch directory - does not set patch-version(defun load-patches (&optional (source-dir (full-pathname "ccl:" :no-error nil)) all)  (let ((patch-vers (lisp-patch-version-number))        patch-dir        patch-files        newpv)    ;  "Version xxxx" -> "patches xxxx:"    (setq patch-dir (%str-cat ":"                              patch-directory-prefix                               (lisp-implementation-version-less-patch)                              ":"))    ; require that the dir name containing patches match    ; implementation version - should the patch files themselves contain version?    (setq patch-dir (merge-pathnames patch-dir source-dir))     (when (probe-file patch-dir)      (setq patch-files (directory (merge-pathnames patch-dir #.(make-pathname :name :wild                                                                               :defaults *.fasl-pathname*))))      (dolist (file patch-files)        (multiple-value-bind (patch-n)                             (patch-file-version (pathname-name file))          (when all (setq patch-n (1+ patch-vers)))          (when (and (numberp patch-n)(> patch-n patch-vers))            (when (null newpv)(setq newpv -1))            (when (> patch-n newpv)              (setq newpv patch-n))            (let ((*load-verbose* t)                  (*record-source-file* nil)                  (*warn-if-redefine* nil) ; - & various  other load vars                  (*warn-if-redefine-kernel* nil))              (load file)))))      (when (and (null all) newpv) (setq *new-lisp-patch-version* newpv)))))(defun patch-file-version (name)    ; look backwards for digits preceded by p    ; return number, "pN" and  eg. "2.0b1"    (let ((n (1- (length name)))          dot)      (when (>= n 1)        (loop          (let ((char (%schar name n)))            (cond ((eq char #\.)  ; allow dots for eg p1.1 ??                   (if dot (return) (setq dot t)))                  ((digit-char-p char))                  (t (return))))          (if (= n 0) (return))          (setq n (1- n)))        (if (and (< n (1- (length name)))(>= n 0))          (let ((char (%schar name n)))             (if (or (eq #\P char)(eq #\p char))              (values (read-from-string name nil nil :start (1+ n))                      (%substr name n (length name))                      (%substr name 0 n))              (values nil name name)))          (values nil name name)))))#|; put on the front of a patch file(eval-when (load)  (when (or *warn-if-redefine* *warn-if-redefine-kernel*)    (error "Use the function LOAD-PATCHES to load patches"))); or(eval-when (load)  (when (or *warn-if-redefine* *warn-if-redefine-kernel* *record-source-file*)    (let ((file *load-truename*)           (dir (car (last (pathname-directory file))))          (patch-dir (%str-cat                               patch-directory-prefix                               (lisp-implementation-version-less-patch))))      (cond ((string= dir patch-dir)             (close file)             (load-patches (make-pathname :directory (but-last (pathname-directory file)) :defaults nil))             (throw ??))            (t (error "~%Put this file in a directory named ~A and use the function LOAD-PATCHES~%or if you really want to just load it without updating the patch version bind~%*warn-if-redefine*, *warn-if-redefine-kernel* and *record-source-file* to NIL" patch-dir)))))); or(eval-when (load eval)  (when (or *warn-if-redefine* *warn-if-redefine-kernel* *record-source-file*)    (let* ((file *load-truename*)            (dir (car (last (pathname-directory file))))           (patch-dir (%str-cat                               patch-directory-prefix                               (lisp-implementation-version-less-patch))))      (cond ((string= dir patch-dir)             (error "Use the function LOAD-PATCHES to load this file.If you really want to load it without updating the patchversion bind *warn-if-redefine*, *warn-if-redefine-kernel* and*record-source-file* to NIL"))            (t (error "Put this file in a directory named ~S and use thefunction LOAD-PATCHES. If you really want to load it without updatingthe patch version bind *warn-if-redefine*, *warn-if-redefine-kernel*and *record-source-file* to NIL" (%str-cat "ccl:" patch-dir ";"))))))  (let ((who "2.0§3") (me (lisp-implementation-version-less-patch)))    (when (not (string= (lisp-implementation-version-less-patch) who))      (cerror "Patch will be loaded anyway."               (make-condition 'simple-condition                              :format-string "This patch file is for MCL ~A. This is MCL ~A."                              :format-arguments (list who me))))))|#; A very simple patch registry(defvar *loaded-patches* nil)(defun register-patch (name)  (push name *loaded-patches*))(defun list-patches ()  (dolist (name (reverse *loaded-patches*))    (format t "~&~a~%" name)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; This is the run-time required for "ccl:lib;patchenv";;;(defloadvar *patched-slfunvs* nil)(defloadvar *unswappable-patches* nil)#-PPC-target(progn(defun swappable-immediate-p (imm offset)  (lap-inline ((or offset 0) imm nil)    (getint arg_x)    (add.l arg_x arg_y)    (move.l (a5 $Pstatic_cons_area) da)    (if# ne      (move.l da atemp0)      (if# (or (and (cc (atemp0 $cons-area.gspace-start) arg_y)                    (cs (atemp0 $cons-area.ispace-end) arg_y))               (and (cc (a5 $vcells_start) arg_y)                    (cs (a5 $slfuns_end) arg_y)))        (add.w ($ $t_val) acc)))))(defun could-be-slfun (lfun &optional old-lfun)  (let ((lfunv (%lfun-vector lfun))        (unswappable-imms nil)        (could-be-slfun 0))             ; index of last used sub-function    (declare (special could-be-slfun))          ; ugly, but saves a symbol    (dotimes (i (%count-immrefs lfunv))      (multiple-value-bind (imm offset) (%nth-immediate lfunv i)        (unless (swappable-immediate-p imm offset)          (multiple-value-bind (old-imm found?)                               (find-swappable-imm imm offset old-lfun)            (if found?              (let ((imm-offset (%immediate-offset lfunv i)))                (lap-inline (old-imm (or offset 0) imm-offset)                  (:variable lfunv)                  (move.l (varg lfunv) atemp0)                  (lea (atemp0 $lfv_lfun) atemp0)                  (getint arg_z)        ; imm-offset                  (getint arg_y)        ; offset                  (add.l arg_y arg_x)   ; (+ old-imm offset)                  (move.l arg_x (atemp0 arg_z))))              (push imm unswappable-imms))))))    (if unswappable-imms      (progn        (when *unswappable-patches*          (push (cons lfun unswappable-imms) *unswappable-patches*))        nil)      t))); Might want to make this look for a compatible lfun or list.; Right now it just considers simple strings.; Assumes that could-be-slfun is special-bound to an integer (as done by could-be-slfun above)(defun find-swappable-imm (imm offset lfun)  (declare (special could-be-slfun))  (when lfun    (let ((matcher (cond ((simple-string-p imm)                          #'(lambda (imm lfun-imm)                              (and (simple-string-p lfun-imm)                                   (string= imm lfun-imm))))                         ((listp imm) 'lists-matchp)                         ((simple-vector-p imm)                          ; This catches keyword vectors                          #'(lambda (imm lfun-imm)                              (and (simple-vector-p lfun-imm)                                   (eql (length imm) (length lfun-imm))                                   (dotimes (i (length imm) t)                                     (unless (eq (svref imm i)                                                 (svref lfun-imm i))                                       (return nil))))))                         ((functionp imm)                           #'(lambda (new-f old-f)                              (when (and (%swappable-function-p old-f)                                         (logbitp $lfatr-slfunv-bit (lfun-attributes old-f))                                         (not (memq (%lfun-vector old-f) *patched-slfunvs*)))                                (%set-xtab-lfun old-f new-f)                                t))))))      (when matcher        (let ((lfunv (%lfun-vector lfun)))          (dotimes (i (%count-immrefs lfunv))            (let ((lfun-imm (%nth-immediate lfunv i)))              (when (and (swappable-immediate-p lfun-imm offset)                         (or (not (functionp lfun-imm))                             (>= i could-be-slfun))                         (funcall matcher imm lfun-imm))                (if (functionp lfun-imm) (setq could-be-slfun i))                (return (values lfun-imm t)))))))))))  ; end #-PPC#+PPC-target(defun could-be-slfun (lfun &optional old-lfun)  (declare (ignore lfun old-lfun))  nil)(defun lists-matchp (l1 l2)  (or (eq l1 l2)      (and (listp l1)           (listp l2)           (eql (list-length-and-final-cdr l1) (list-length-and-final-cdr l2))           (labels ((match (l1 l2 hash skip-list-length?)                      (cond ((listp l1)                             (and (listp l2)                                  (or skip-list-length?                                      (eql (list-length-and-final-cdr l1)                                           (list-length-and-final-cdr l2)))                                  (or (eq l1 l2)                                      (eq (gethash l1 hash t) l2)                                      (progn                                        (setf (gethash l1 hash) l2)                                        (and (match (car l1) (car l2) hash nil)                                             (match (cdr l1) (cdr l2) hash t))))))                            ((listp l2) nil)                            ((simple-string-p l1)                             (and (simple-string-p l2)                                  (string= l1 l2)))                            (t (eq l1 l2)))))             (match l1 l2 (make-hash-table :test 'eq) t)))))#-ppc-target(defun functions-matchp (new-f old-f)  (when (and (functionp new-f) (%swappable-function-p old-f)             (logbitp $lfatr-slfunv-bit (lfun-attributes old-f))             (not (memq (%lfun-vector old-f) *patched-slfunvs*)))    (%set-xtab-lfun old-f new-f)    (logbitp $lfatr-slfunv-bit (lfun-attributes old-f)))); slfun -must- be a swappable function jump-table entry.; resident-lfun should be a non-swappable function with a compatible; "signature".#+PPC-target(defun %set-xtab-lfun (slfun resident-lfun)  (declare (ignore slfun resident-lfun)))           #-PPC-target(defun %set-xtab-lfun (slfun resident-lfun)  (cond ((could-be-slfun resident-lfun slfun)	 (without-interrupts           (let* ((lfunv (%lfun-vector resident-lfun))                  (len (uvsize lfunv))                  (new (%make-uvector (+ len 2) $v_nlfunv)))             (dotimes (i len) (setf (uvref new i) (uvref lfunv i)))             (setf (uvref new len) 0) ; for disk address             (setf (uvref new (1+ len)) 0) ; for disk address             (setf (uvref new 0)  ; attributes moved from 2 to 0                    (%ilogior (ash 1 $lfatr-slfunv-bit) (uvref new 0)))             (push new *patched-slfunvs*)             (lap-inline (slfun new)               (add.l ($ $lfv_lfun) arg_z)               (move.l arg_y atemp0)   ; slfun                (move.w ($ #x4ef9) atemp0@+) ; jmp or something               (move.l arg_z @atemp0)  ;                (jsr_subprim $sp-clrcache)))))        (t (lap-inline (slfun resident-lfun)             (move.l arg_y atemp0)             (move.w ($ #x4ef9) atemp0@+)             (move.l arg_z atemp0@+)             (move.w ($ (ash 1 $lfatr-nopurge-bit)) @atemp0)  ; ??             (jsr_subprim $sp-clrcache))))  slfun)#+PPC-target(defun %swappable-function-p (f)  (declare (ignore f))  nil)#-PPC-target(defun %swappable-function-p (f)  (and (functionp f)       (lap-inline (f nil)         (if# (and (cc (a5 $slfuns_start) arg_y)                            (cs (a5 $slfuns_end) arg_y))                    (add.w ($ $t_val) acc)))))(defun %redefmethod (function specializers qualifiers &optional method-class documentation)    (let* ((real-specializers (mapcar #'(lambda (x)                                        (if (symbolp x)                                          (find-class x nil)                                          x))                                    specializers))         (name (function-name function))         (gf (fboundp name))         (old-method (and (typep gf 'generic-function)                          (find-method gf qualifiers real-specializers nil)))         (old-function (and old-method (%method-function old-method)))         (*warn-if-redefine-kernel* nil)         (*warn-if-redefine* nil)         (specs-exist (dolist (spec real-specializers t)                        (if (null spec)(return nil)))))    (when (and old-function specs-exist)            (if  (%swappable-function-p old-function)        (let* ((new-method (copy-uvector old-method))               (gf (%method-gf new-method)))          (setf (%method-gf new-method) nil)          (lfun-name function new-method)          (%set-xtab-lfun old-function function)          (%add-method new-method gf)          (record-source-file new-method 'method)          new-method)        (%defmethod function specializers qualifiers method-class documentation)))))(defun re-store-setf-method (name fn &optional doc)  (let ((old-fn (gethash name %setf-methods%)))    (when (and old-fn (%swappable-function-p old-fn))      (%set-xtab-lfun old-fn fn)      (setq fn old-fn))    (store-setf-method name fn doc))); A couple of functions to help with kernel patches.(defun patch-resource (type id offset old new &optional (patch-doc-string "patch"))  (flet ((reserror ()           (let ((code (#_ResError)))             (unless (eql code 0)               (%err-disp code)))))    (declare (inline reserror))    (let* ((copy (car (find-if #'(lambda (x)                                   (and (equal (second x) type)                                        (eql (third x) id)))                               *patched-resources*)))           (old-length (length old))           (min-size (+ offset (* 2 (max old-length (length new)))))           resource           (already-patched? t))      (macrolet ((not-patching-message (reason)                   `(format t "~&Not adding ~a to resource '~a' ~s ~a.~%"                            patch-doc-string type id ,reason)))        (if copy          (unless (>= (#_getHandleSize copy) min-size)            (#_SetHandleSIze copy min-size)            (unless (eql (#_GetHandleSize copy) min-size)              (not-patching-message "because its size could not be increased.")              (return-from patch-resource nil)))          (progn            (setq already-patched? nil)            (setq resource (prog1 (#_GetResource type id) (reserror)))            (when (%null-ptr-p resource)              (error "There is no resource with type='a' and id=~s" type id))            (when (%null-ptr-p (%get-ptr resource))              (#_LoadResource resource))            (let* ((size (#_getHandleSize resource)))              (unless (>= size (min (+ offset old-length) min-size))                (not-patching-message "because it is too short")                (return-from patch-resource nil))              (setq copy (#_NewHandle :errchk min-size))              (when (%null-ptr-p (%get-ptr resource))                (#_LoadResource resource))              (#_BlockMove (%get-ptr resource) (%get-ptr copy) size))))        (let ((offs offset))          (dolist (word old)            (unless (or (eql word (%hget-signed-word copy offs))                        (eql word (%hget-unsigned-word copy offs)))              (unless already-patched?                (#_DisposeHandle copy))              (not-patching-message "due to data mismatch")              (return-from patch-resource nil))            (incf offs 2))          (setq offs offset)          (dolist (word new)            (when word              (setf (%hget-word copy offs) word))            (incf offs 2)))        (unless already-patched?          (push (list copy type id) *patched-resources*))        copy))))#-ppc-target(defun patch-subprim (a5-offset offset old new)  (let ((p (%incf-ptr (%currenta5) a5-offset)))    (when (eql #x4efa                   ; jmp pc-relative, 16-bit offset               (%get-unsigned-word p))      (%incf-ptr p (+ 2 (%get-signed-word p 2))))    (let ((offs offset))      (dolist (word old)        (unless (or (eql word (%get-signed-word p offs))                    (eql word (%get-unsigned-word p offs)))          (format t "~&Not patching subprim ~s due to data mismatch.~%"                  (let ((pair (find a5-offset *subprims8-alist* :key 'cadr)))                    (if pair (car pair) a5-offset)))          (return-from patch-subprim nil))        (incf offs 2))      (setq offs offset)      (dolist (word new)        (when word (setf (%get-word p offs) word))        (incf offs 2)))    p))(provide "PATHNAMES")#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)