; -*- Mode: Lisp; Package: CCL -*-;; chars.lisp;;	Change History (most recent first):;;  2 10/5/97  akh  see below;;  10 1/22/97 akh  optimizations for string and char comparisons;;                  char< and friends back to just code compare;;  8 6/7/96   akh  use scharcode in string-cmp;;  7 3/27/96  akh  fix itlb resource things;;  6 2/19/96  akh  fix char/=;;  4 12/22/95 gb   Bill's fixes to %strup/%strdown;;  3 10/17/95 akh  merge patches;;  2 10/12/95 akh  no mo lap;;  3 5/10/95  akh  tiny change in string-compare;;  2 4/28/95  akh  fix string-compare for extended strings;;  3 3/2/95   akh  say element-type 'base-character;;  2 2/9/95   slh  new char-not-equal;;  5 2/3/95   akh  merge leibniz patches;;  4 2/2/95   akh  merge with leibniz patches for defstruct;;  (do not edit before this line!!); Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!(in-package :ccl);; Modification History;;09/02/97 akh char-name of code < space returns the ^ str;01/30/96 bill  wtf is char-int? Common Lisp, that's wtf.; 3/05/95 slh   char-not-equal fix;02/09/95 slh   new char-not-equal;------------- 3.0d17;07/12/93 alice we forgot char-not-lessp/greaterp/equal;07/09/03 alice string-upcase/downcase and char-equal/greaterp/lessp char>/</<=/>= use 	*string-compare-script*;		(1500+ bytes bite the dust). ;07/07/93 alice alpha-char-p and alphanumericp ok but slow if non roman;07/01/93 alice string comparisons all use *string-compare-script*, as do lower-case-p and upper-case-p;05/26/93 alice changed %strup, %strdown and %strcap - but they only make sense if roman;05/17/03 alice added base-character-p and extended-character-p then moved them to l1-aprims;05/16/93 alice char-name and character deal with extended characters, some cmp.b to cmp.w - not done yet;		what about alpha-char-p etal for extended chars. alpha sorting is really another issue entirely;05/04/93 alice copy-string-arg knows about extended-character; ??      alice char> fix parens;01/03/93 alice char< do unsigned compare please;10/14/92 alice get rid of some lap;11/20/92 gb   fix flaw in CHARACTER.;------------- 2.0;01/06/91 alice fix nstring-capitalize, string-capitalize;01/02/91 gb  Graphic-char-p looks more aesthetic without #_Debugger.;12/06/91 alphanumericp, upper-case-p and lower-case-p ‡ˆ‰ŠŒŽ‘’“”•–—˜™š›œžŸ €‚ƒ„…† and ËÌÍ;	  also %%strup %%strdown, and string-capitalize. graphic-char-p from 128 to 255 (itsa Macintosh);------------- 2.0b4;07/21/91 gb %badarg fixes, digit-char returns NIL for bad radices, &lap arglists.;02/18/91 gb code-char, char-code eval-redef'ed elsewhere.;05/13/91 bill string-lessp -> l1-aprims for bootstrapping l1-windows.;09/03/90 gb  call %%deref-sym-char-or-string where appropriate.;06/28/90 bill cs -> le in char<;06/25/90 gb   alpha-char-p, lower-case-p to l1-aprims.;06/23/90  gb  forget about $symbol-header.; ----- 2.0a1;06/07/90 bill %noforcestk doesn't work with &optional args in digit-char.;06/02/90 gb  code-char error message.;05/22/90 gb  no more symtagp.;04/17/90 gb   char-lessp : LS vice CS (CS considered harmful); exorcise ghosts.;04/14/90  gz  [n]string-studlify.;01/14/89 Bill char-not-greaterp tested with HI instead of CS;12-Nov-89 Mly graphic-char-p, not graphics-char-p;04/07/89 gb  $sp8 -> $sp.;3/16/89  gz mkchar no longer does a getint.;03/13/89 gb digit-char-p: cmp -> sub.;02/15/89 gb alpanumericp -> alphanumericp; char>= was missing.;            So much for string-diag.lisp.;11/19/88 gb passes string-diag.lisp .;10/25/88 gb new file.(defloadvar *itl2-resources* nil)(defun get-itl2-resource (script)  (let* ((elt (assq script *itl2-resources*))         (res (cdr elt)))    (or (and res (not (%null-ptr-p res)) res)        (let ((id (cond ((eq script #$smRoman) 0)                        (t (with-macptrs ((bhdl (#_getresource :|itlb| script)))                             (cond ((%null-ptr-p bhdl)(error "Can't find :|itlb| ~D resource." script ))                                   (t (#_loadresource bhdl)))                             (href bhdl itlbrecord.itlbsort))))))                (let ((ihdl (#_getresource :|itl2| id)))            (cond ((%null-ptr-p ihdl)(error "Can't find :|itl2| ~D resource." id ))                  (t (#_loadresource ihdl)                     (#_HNoPurge ihdl)))            (if elt (rplacd elt ihdl) (push (cons script ihdl) *itl2-resources*))            ihdl)))))        ; If object is a character, it is returned.  If it is an integer, its INT-CHAR; is returned. If it is a string of length 1, then the sole element of the; string is returned.  If it is a symbol whose pname is of length 1, then; the sole element of the pname is returned. Else error.(defun character (arg)  (if (typep arg 'character)    arg    (if (typep arg 'fixnum)      (code-char arg)      (if (and (typep arg 'string)               (= (the fixnum (length arg)) 1))        (char arg 0)        (let* ((pname (if (typep arg 'symbol) (symbol-name arg))))          (if (and pname (= (the fixnum (length pname)) 1))            (char pname 0)            (%err-disp $xcoerce arg 'character)))))))(defun digit-char (weight &optional radix)  (let* ((r (if radix (require-type radix 'integer) 10)))    (if (and (typep (require-type weight 'integer) 'fixnum)             (>= r 2)             (<= r 36)             (>= weight 0)             (< weight r))      (locally (declare (fixnum weight))        (if (< weight 10)          (code-char (the fixnum (+ weight (char-code #\0))))          (code-char (the fixnum (+ weight (- (char-code #\A) 10)))))))));True for ascii codes 32-126 inclusive.; and for guys >= 128. Its really a function of the font of the moment.(defun graphic-char-p (c)  (let* ((code (char-code c)))    (unless (eq c #\rubout)      (>= code (char-code #\space)))));True for ascii codes 13 and 32-126 inclusive.(defun standard-char-p (c)  (let* ((code (char-code c)))    (or (eq c #\newline)        (and          (>= code (char-code #\space))         (< code (char-code #\rubout)))))); if no table - then what?(defun upper-case-p (c)    (let* ((code (char-code c))           (script (string-compare-script)))      (declare (optimize (speed 3)(safety 0)))      (if (and (%i< code 128)               (or (eq script #$smroman)                   (eq script #$smJapanese)))        (and (%i>= code (char-code #\A))(%i<= code (char-code #\Z)))        (let ((tbl (get-char-up-table script)))          (cond (tbl             (locally (declare (type (simple-array (unsigned-byte 8) (*)) tbl))               (if (%i< code #x100)  (neq code (aref tbl code)) nil)))            (t (neq c (char-downcase c))))))));True for a-z and ‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ(defun lower-case-p (c)    (let* ((code (char-code c))           (script (string-compare-script)))      (declare (optimize (speed 3)(safety 0)))      (if (and (%i< code 128)               (or (eq script #$smroman)                   (eq script #$smJapanese)))        (and (%i>= code (char-code #\a))(%i<= code (char-code #\z)))        (let ((tbl (get-char-up-table script)))          (cond (tbl             (locally (declare (type (simple-array (unsigned-byte 8) (*)) tbl))               (if (%i< code #x100)  (neq code (aref tbl code)) nil)))            (t (neq c (char-downcase c)))))))); I assume nobody cares that this be blindingly fast(defun both-case-p (c)  (or (neq c (char-upcase c))(neq c (char-downcase c))))  (defun alphanumericp (c)    (let ((script (string-compare-script)))      (cond       ((OR (eq script #$smRoman)(and (eq script #$smJapanese)(< (char-code c) 128)))        #-PPC-target        (lap-inline (c)          (jsr_subprim $sp-char_argZ)          (if#             (or                   (and (geu (cmp.w ($ #\0) arg_z))                  (leu (cmp.w ($ #\9) arg_z)))             (and (geu (cmp.w ($ #\a) arg_z))                  (leu (cmp.w ($ #\z) arg_z)))             (and (geu (cmp.w ($ #\A) arg_z))                  (leu (cmp.w ($ #\Z) arg_z)))             (and (geu (cmp.w ($ #\200) arg_z))                  (leu (cmp.w ($ #\237) arg_z)))             (and (geu (cmp.w ($ #\313) arg_z))                  (leu (cmp.w ($ #\315) arg_z)))             (and (geu (cmp.w ($ #\345) arg_z))                  (leu (cmp.w ($ #\364) arg_z))                  (ne (cmp.w ($ #\360) arg_z))))            (move_t acc)            else#            (move.l nilreg acc)))        #+PPC-target        (let ((code (char-code c)))          (declare (fixnum code))          (or           (and (>= code (char-code #\0))                (<= code (char-code #\9)))           (and (>= code (char-code #\a))                (<= code (char-code #\z)))           (and (>= code (char-code #\A))                (<= code (char-code #\Z)))           (and (>= code (char-code #\200))                (or                 (<= code (char-code #\237))                 (and (>= code (char-code #\313))                      (or                       (<= code (char-code #\315))                       (and (>= code (char-code #\345))                            (<= code (char-code #\364))                            (neq code (char-code #\360))))))))))       (t (xalphanumericp c script)))))(defun char= (ch &rest others)  (declare (dynamic-extent others))  (unless (typep ch 'character)    (setq ch (require-type ch 'character)))  (dolist (other others t)    (unless (eq other ch)      (unless (typep other 'character)        (setq other (require-type other 'character)))      (return))))(defun char/= (ch &rest others)  (declare (dynamic-extent others))  (unless (typep ch 'character)    (setq ch (require-type ch 'character)))  (do* ((rest others (cdr rest)))       ((null rest) t)    (let ((other (car rest)))      (if (eq other ch) (return))      (unless (typep other 'character)        (setq other (require-type other 'character)))      (dolist (o2 (cdr rest))        (if (eq o2 other)(return-from char/= nil))))))(defun char-equal (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ((script (string-compare-script))           (table (get-char-equal-sort-table script)))               (cond (table             (setq char (char-code char))             (when (%i< char #x100)(setq char (aref table char)))             (dolist (c others t)               (let ((code (char-code c)))                 (when (not (eq char                                (setq char (if (%i> code #xff) code (aref table code)))))                   (return)))))            (t (dolist (c others t)                 (when (not (eql c char))                   (when (neq 0 (char-compare char c script))                     (return))))))))); Compares each char against all following chars, not just next one. Tries; to be fast for one or two args.(defun char-not-equal (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3) (safety 0)))    (let* ((script (string-compare-script))           (table  (get-char-equal-sort-table script))           (rest   (cdr others)))      (cond (table             (flet ((cmp-code (char)                      (if (%i< (setq char (char-code char)) #x100)                        (aref table char)                        char)))               (declare (dynamic-extent cmp-code))               (cond (rest              ; more than 2 args, have table                      ; first convert all chars to codes                      (setq char (cmp-code char))                      (do ((list others (cdr list)))                          ((null list))                        (rplaca list (cmp-code (car list))))                      ; compare each code with those that follow                      (while others                        (when (memq char others)                          (return-from char-not-equal nil))                        (setq char   (car others)                              others rest                              rest   (cdr others)))                      t)                     (others            ; 2 args, have table                      (not (eq (cmp-code char)                               (cmp-code (car others)))))                     (t t))))            (rest                       ; more than 2 args, no table             (while others               (when (member char others                             :test #'(lambda (c1 c2)                                       (eq 0 (char-compare c1 c2 script))))                 (return-from char-not-equal nil)))             t)            (others                     ;  2 args, no table             (not (eq 0 (char-compare char (car others) script))))            (t t)))))#| Old version. CLtL2 p. 378 says char comparisons are analogous to numeric comparisons;   p. 293 says /= is true for "all different"; the following compares adjacent pairs only.(defun char-not-equal (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ((script (string-compare-script))           (table (get-char-equal-sort-table script)))               (cond (table             (setq char (char-code char))             (when (%i< char #x100)(setq char (aref table char)))             (dolist (c others t)               (let ((code (char-code c)))                 (when (eq char                           (setq char (if (%i> code #xff) code (aref table code))))                   (return)))))            (t (dolist (c others t)                 (when (eq 0 (char-compare char (setq char c) script)) (return))))))))|#(defun char-lessp (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ((script (string-compare-script))           (table (get-char-equal-sort-table script)))      (cond (table             (setq char (char-code char))             (when (%i< char #x100)(setq char (aref table char)))             (dolist (c others t)               (let ((code (char-code c)))                 (when (not (%i< char                                 (setq char (if (%i> code #xff) code (aref table code)))))                   (return)))))            (t (dolist (c others t)                 (when (neq -1 (char-compare char (setq char c) script)) (return))))))))(defun char-not-lessp (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ((script (string-compare-script))           (table (get-char-equal-sort-table script)))      (cond (table             (setq char (char-code char))             (when (%i< char #x100)(setq char (aref table char)))             (dolist (c others t)               (let ((code (char-code c)))                 (when (%i< char                            (setq char (if (%i> code #xff) code (aref table code))))                   (return)))))            (t (dolist (c others t)                 (when (eq -1 (char-compare char (setq char c) script)) (return))))))))(defun char-greaterp (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ((script (string-compare-script))           (table (get-char-equal-sort-table script)))      (cond (table             (setq char (char-code char))             (when (%i< char #x100)(setq char (aref table char)))             (dolist (c others t)               (let ((code (char-code c)))                 (when (not (%i> char                                 (setq char (if (%i> code #xff) code (aref table code)))))                   (return)))))            (t (dolist (c others t)                 (when (neq 1 (char-compare char (setq char c) script)) (return))))))))(defun char-not-greaterp (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ((script (string-compare-script))           (table (get-char-equal-sort-table script)))      (cond (table             (setq char (char-code char))             (when (%i< char #x100)(setq char (aref table char)))             (dolist (c others t)               (let ((code (char-code c)))                 (when (%i> char                            (setq char (if (%i> code #xff) code (aref table code))))                   (return)))))            (t (dolist (c others t)                 (when (eq 1 (char-compare char (setq char c) script)) (return))))))))(defun char> (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ()            (setq char (char-code char))      (dolist (c others t)        (let ((code (char-code c)))          (when (not (%i> char (setq char code)))            (return)))))))(defun char>= (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ()            (setq char (char-code char))      (dolist (c others t)        (let ((code (char-code c)))          (when (not (%i>= char (setq char code)))            (return)))))))(defun char< (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ()            (setq char (char-code char))      (dolist (c others t)        (let ((code (char-code c)))          (when (not (%i< char (setq char code)))            (return)))))))(defun char<= (char &rest others)  (declare (dynamic-extent others))  (locally (declare (optimize (speed 3)(safety 0)))    (let* ()            (setq char (char-code char))      (dolist (c others t)        (let ((code (char-code c)))          (when (not (%i<= char (setq char code)))            (return))))))); This is Common Lisp(defun char-int (c)  (char-code c));If char has an entry in the *NAME-CHAR-ALIST*, return first such entry.;Otherwise, if char is a graphics character, return NIL;Otherwise, if char code is < 128, return "^C", otherwise "1nn"(defun char-name (c)    (dolist (e *name-char-alist*)    (declare (list e))        (when (eq c (cdr e))(return-from char-name (car e))))  (let ((code (char-code c)))    (declare (fixnum code))    (cond ((< code #x7f)           (when (< code (char-code #\space))             (let ((str (make-string 2 :element-type 'base-character)))               (declare (simple-base-string str))               (setf (schar str 0) #\^)               (setf (schar str 1)(code-char (%ilogxor code #x40)))               str)))          ((and (< code #x100)(graphic-char-p c)) nil)          (t (let* ((n (if (< code #o1000)                                       3                                       (if (< code #o10000)                                         4                                         (if (< code #o100000) 5 6))))                    (str (make-string n :element-type 'base-character)))               (declare (fixnum n)(simple-base-string str))               (do ((i (1- n)(1- i)))                   ((< i 0))                 (declare (fixnum i))                 (setf (schar str i)                       (code-char (+ (char-code #\0)(%ilogand code 7))))                 (setq code (lsh code -3)))               str)))))                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Given arglist of (string &key :start :end), dereferenced string in atemp0,; displacement offset in dtemp0, length in dtemp1,;return with pointer to/length of string in atemp0,dtemp0#| ; called by %%strstud which should be history(defun %%getstronearg (&lap 0)  (old-lap   (equate _end 4)   (equate _start 12)   (equate _str 16)   (move.l (vsp _start) da)   (if# (ne nilreg da)     (bif (ne (ttagp ($ $t_fixnum) da db)) @bads)     (getint da)     (bmi @badd2idx)     (sub.l da dtemp1)     (blt @badd2idx)     (add.l da dtemp0)     else#     (move.l '0 da))   (move.l (vsp _end) db)   (if# (ne db nilreg)     (bif (ne (ttagp ($ $t_fixnum) db dx)) @bade)     (getint db)     (sub.l da db)     (bif (gtu dtemp1 db) @badd3idx)     (move.l db dtemp1))   (lea (atemp0 dtemp0.l $v_data) atemp0)   (move.l dtemp1 dtemp0)   (rts)@badd3idx   (add.l db da)@badd2idx   (mkint da)   (Tsignal_error (fixnum $xarroob) da (vsp _str))@bade   (twtaerr (vsp _end) 'fixnum)@bads   (twtaerr (vsp _start) 'fixnum)))(defun %%copystrarg (&lap 0)  (old-lap   (vpush atemp0)   (spush dtemp1)   (spush dtemp0)   (move.l dtemp1 arg_z)   (jsr_subprim $sp-makestr)   (move.l atemp0 da)   (vpop atemp0)   (add.w ($ $v_data) atemp0)   (add.l sp@+ atemp0)   (spop dtemp1)   (move.l dtemp1 dtemp0)   (bra @1)@0 (move.b atemp0@+ atemp1@+)@1 (dbfl dtemp0 @0)   (move.l ($ 0) dtemp0)   (move.l da atemp0)   (move.l atemp0 atemp1)   (rts)))|#; lfunlks for its caller !#+Gonzo(defun %%strstud (&lap 0)  (old-lap    (jsr (function %%getstronearg))    (vpush atemp1)    (move.l atemp0 atemp1)    (move.l acc da)    (moveq 0 dx)    (dbfloop.l da (add.b (@+ atemp1) dx))    (move.b ($ (- (%char-code #\a) (%char-code #\A))) dy)    (dbfloop.l acc      (move.b (@+ atemp0) da)      (if# (lt (progn                 (move.b da db)                 (add.b dx db)                 (and.b ($ #xF) db)                 (cmp.b ($ 6) db)))        (if# (and (geu (cmp.b ($ #\a) da)) (leu (cmp.b ($ #\z) da)))          (sub.b dy (atemp0 -1))         elseif# (and (geu (cmp.b ($ #\A) da)) (leu (cmp.b ($ #\Z) da)))          (add.b dy (atemp0 -1)))))    (vpop acc)    (lfret)))(defun string-downcase (string &key start end)  (setq string (copy-string-arg string))  (if (not start) (setq start 0)(require-type start 'fixnum))  (if (not end)(setq end (length string))(require-type end 'fixnum))  (%strdown string start end))(defun %ascii-string-down (string start end)    (declare (fixnum start end))    (loop       (when (>= start end)(return t))      (let ((code (%scharcode string start)))        (when (> code 127)(return nil))        (when (and (%i>= code (char-code #\A))(%i<= code (char-code #\Z)))          (setq code (%i+ code #.(- (char-code #\a)(char-code #\A))))          (setf (%scharcode string start) code))        (setq start (%i+ 1 start)))))(defun %strdown (string start end)    (declare (fixnum start end))    (let* ((script (string-compare-script)))      (when (eq script #$smjapanese)        (when (%ascii-string-down string start end)          (return-from %strdown string)))            (let ((downstring (get-char-down-table script)))        (cond          (downstring (locally                       (declare (type (simple-array (unsigned-byte 8)(*)) downstring)                                (optimize (speed 3) (safety 0)))                       (while (< start end)                         (let ((code (%scharcode string start)))                           (when (%i< code #x100)                             (setf (%scharcode string start)(aref downstring code))))                         (setq start (1+ start)))))         (t (%strup-or-down string start end script t))))      string)); will die if called with 8 bit script - sez who(defun %strup-or-down (string start end script &optional down-p)  (let ((bytes (byte-length string script start end))        (font (#_getscript script #$smScriptAppFond)))    (%stack-block ((p bytes))      (%put-string-segment-contents p string start end bytes script)      (with-font font        (if down-p          (#_lowertext p bytes)          (#_uppertext p bytes)))  ; I guess the length has to be the same      (pointer-to-string-in-script p string bytes script start))))(defun copy-string-arg (string &aux (org 0) len)  (etypecase string    (string     (setq len (length string))     (multiple-value-setq (string org)(array-data-and-offset string)))    (symbol     (setq string (symbol-name string))     (setq len (length string)))    (character     (return-from copy-string-arg                    (make-string 1 :initial-element string :element-type (type-of string)))))  (%substr string org (+ len org)))     (defun string-upcase (string &key start end)  (setq string (copy-string-arg string))  (if (not start) (setq start 0)(require-type start 'fixnum))  (if (not end)(setq end (length string))(require-type end 'fixnum))  (%strup string start end))(defun %ascii-string-up (string start end)    (declare (fixnum start end))    (loop       (when (>= start end)(return t))      (let ((code (%scharcode string start)))        (when (> code 127)(return nil))        (when (and (%i>= code (char-code #\a))(%i<= code (char-code #\z)))          (setq code (%i- code #.(- (char-code #\a)(char-code #\A))))          (setf (%scharcode string start) code))        (setq start (%i+ 1 start)))))(defun %strup (string start end)    (declare (fixnum start end))    (let* ((script (string-compare-script)))      (when (eq script #$smjapanese)        (if (%ascii-string-up string start end)          (return-from %strup string)))      (let* ((upstring (get-char-up-table script)))          (cond           (upstring (locally                        (declare (type (simple-array (unsigned-byte 8) (*)) upstring)                                (optimize (speed 3) (safety 0)))                       (while (< start end)                         (let ((code (%scharcode string start)))                           (when (%i< code #x100)                             ; we could use a setf %scharcode too.                             (setf (%scharcode string start) (aref upstring code))))                         (setq start (1+ start)))))           (t (%strup-or-down string start end script))))      string))(defun string-capitalize (string &key start end)  (setq string (copy-string-arg string))  (if (not start) (setq start 0)(require-type start 'fixnum))  (if (not end)(setq end (length string))(require-type end 'fixnum))  (%strcap string start end))(defun %strcap (string start end)    (declare (fixnum start end))    (let ((state :up)          (i start)          (script (string-compare-script)))      (declare (fixnum i))      (if (and (eq script #$smJapanese)(ascii-string-p string start end))        (setq script #$smRoman))      (let* ((upstring (get-char-up-table script))             (downstring (get-char-down-table script)))        (cond          (upstring          (while (< i end)            (let* ((c (%schar string i))                   (alphap (alphanumericp c))) ; makes no sense              (if alphap                (progn                  (setf (%schar string i)                        (case state                          (:up (%schar upstring (%char-code c)))                          (t (%schar downstring (%char-code c)))))                  (setq state :down))                (setq state :up)))            (setq i (1+ i))))         (t (while (< i end)              (let* ((c (%schar string i))                     (alphap (alphanumericp c))) ; makes no sense                (if alphap                  (progn                    (setf (%schar string i)                          (case state                            (:up (char-upcase c))                            (t (char-downcase c))))                    (setq state :down))                  (setq state :up)))              (setq i (1+ i))))))      string))#|(defun string-studlify (string &key start end)  (old-lap   (move.l (varg string) acc)   (jsr (function %%deref-sym-char-or-string))   (jsr (function %%copystrarg))   (jmp (function %%strstud))))|#(defun string-studlify (string &key start end)  (declare (ignore start end))  string)(defun nstring-downcase (string &key start end)  (etypecase string    (string     (if (not start) (setq start 0)(require-type start 'fixnum))     (if (not end)(setq end (length string))(require-type end 'fixnum))     (multiple-value-bind (sstring org) (array-data-and-offset string)       (%strdown sstring (+ start org)(+ end org)))     string)))(defun nstring-upcase (string &key start end)  (etypecase string    (string     (if (not start) (setq start 0)(require-type start 'fixnum))     (if (not end)(setq end (length string))(require-type end 'fixnum))     (multiple-value-bind (sstring org) (array-data-and-offset string)       (%strup sstring (+ start org)(+ end org)))     string)))(defun nstring-capitalize (string &key start end)  (etypecase string    (string     (if (not start) (setq start 0)(require-type start 'fixnum))     (if (not end)(setq end (length string))(require-type end 'fixnum))     (multiple-value-bind (sstring org) (array-data-and-offset string)       (%strcap sstring (+ start org)(+ end org)))     string)))#|(defun nstring-studlify (string &key start end)  (old-lap   (move.l (varg string) acc)   (jsr (function %%derefstring))   (move.l (varg string) atemp1)   (jmp (function %%strstud))))|#(defun nstring-studlify (string &key start end)  (declare (ignore start end))  string); only call for fat scripts  - LOOK OUT - from patch 3(defun char-compare (char1 char2 script)    (let ((code1 (char-code char1))          (code2 (char-code char2)))      (declare (fixnum code1 code1))      (if (eql code1 code2)        0        (if (and (eq script #$smJapanese)(< code1 128)(< code2 128))          (let ((table (get-char-equal-sort-table #$smroman)))            (declare (optimize (speed 3)(safety 0)))                       (let ((c1 (aref table code1))                  (c2 (aref table code2)))              (declare (fixnum c1 c2))              (if (eql c1 c2) 0 (if (< c1 c2) -1 1))))          (char-code-compare-hairy code1 code2 script t)))));; its 18 times faster when no upcase(defun char-code-compare-hairy (code1 code2 script upcase-them)  (%stack-block ((p1 2)                 (p2 2))    (let* ((len1 (if (%i> code1 #xff) 2 1))           (len2 (if (%i> code2 #xff) 2 1)))      (let ((ihdl (get-itl2-resource script)))        (if (eq len1 1)(%put-byte p1 code1)(%put-word p1 code1))        (if (eq len2 1)(%put-byte p2 code2)(%put-word p2 code2))        (when upcase-them          (let ((font (#_getscript script #$smScriptAppFond)))                          (with-FONT font              (#_uppertext p1 len1)              (#_uppertext p2 len2))))        (#_iumagpstring p1 p2 len1 len2 ihdl)))))(defun char-cmp (char1 char2 script)  (declare (ignore script))  (let ((code1 (char-code char1))        (code2 (char-code char2)))    (declare (fixnum code1 code1))    (if (eql code1 code2)      0      (if (< code1 code2) -1 1))))(defun ascii-string-p (str start end)    (declare (fixnum start end))    (dotimes (i (the fixnum (- end start)) t)      (when (%i> (%scharcode str (%i+ start i)) 127)(return nil))))(eval-when (:compile-toplevel :execute)  (declaim (inline ascii-string-compare)))    ;; returns nil when non = and non ascii, else keeps chugging(defun ascii-string-compare (str1 start1 end1 str2 start2 end2)    (let* ((len1 (- end1 start1))           (len2 (- end2 start2)))      (declare (fixnum len1 len2))      (dotimes (i (the fixnum (min len1 len2)) (if (eq len1 len2)                                                 (values t len1)                                                 (values (if (< len1 len2) -1 1)                                                         (min len1 len2))))        (let* ((c1 (%scharcode str1 (%i+ start1 i)))               (c2 (%scharcode str2 (%i+ start2 i))))          (declare (fixnum c1 c2))          (unless (eq c1 c2)            (when (or (> c1 127)(> c2 127))(return (values nil i)))            (if (and (>= c1 (char-code #\a))(<= c1 (char-code #\z)))              (setq c1 (- c1 #.(- (char-code #\a)(char-code #\A)))))            (if (and (>= c2 (char-code #\a))(<= c2 (char-code #\z)))              (setq c2 (- c2 #.(- (char-code #\a)(char-code #\A)))))            (unless (eq c1 c2)              (return (values (if (> c1 c2) 1 -1) i)))))))); returns 2 values -1 less, t eq, 1 greater;  and pos of wherever we gave up; also think about case in eg buffer-substring-p etal  (defun string-compare (string1 start1 end1 string2 start2 end2 &optional for-equal)  (let ((istart1 (or start1 0)))    (if (and (simple-string-p string1)(null start1)(null end1))      (setq start1 0 end1 (length string1))      (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1)))    (if (and (simple-string-p string2)(null start2)(null end2))      (setq start2 0 end2 (length string2))      (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2)))    (let* ((len1 (%i- end1 start1))           (len2 (%i- end2 start2)))      (declare (fixnum len1 len2))      (when (or (not for-equal)(eql len1 len2))        (let* ((script (string-compare-script))               (pos 0)               val)          (when (or (eql script #$smjapanese)(eq script #$smRoman))            (multiple-value-setq (val pos)              (ascii-string-compare string1 start1 end1 string2 start2 end2))            (when val (return-from string-compare (values val (%i+ pos istart1)))))          (let ((sort-table (get-char-equal-sort-table script)))            (if (eq script #$smRoman) ; finish from pos to end                        (let ()                (locally (declare (type (simple-array (unsigned-byte 8) (*)) sort-table))                                  (dotimes (i (the fixnum (- (min len1 len2) pos)) (if (eq len1 len2)                                                                     (setq val t pos len1)                                                                     (setq val (if (< len1 len2) -1 1)                                                                           pos  (min len1 len2))))                    (let* ((c1 (%scharcode string1 (%i+ start1 pos i)))                           (c2 (%scharcode string2 (%i+ start2 pos i))))                      (declare (fixnum c1 c2))                      (unless (eq c1 c2)                        (if (or (> c1 127)(> c2 127))                          (progn                            (if (<= c1 #xff)(setq c1 (aref sort-table c1)))                            (if (<= c2 #xff)(setq c2 (aref sort-table c2))))                          (progn                            (if (and (>= c1 (char-code #\a))(<= c1 (char-code #\z)))                              (setq c1 (- c1 #.(- (char-code #\a)(char-code #\A)))))                            (if (and (>= c2 (char-code #\a))(<= c2 (char-code #\z)))                              (setq c2 (- c2 #.(- (char-code #\a)(char-code #\A)))))))                        (unless (eq c1 c2)                          (setq val (if (> c1 c2) 1 -1)                                 pos  (+ pos i))                          (return))))))                (values val (%i+  pos istart1)))              (cond               (sort-table                (locally (declare (type (simple-array (unsigned-byte 8) (*)) sort-table))                  (dotimes (i (the fixnum (min len1 len2)) (if (eq len1 len2)                                                             (setq val t pos len1)                                                             (setq val (if (< len1 len2) -1 1)                                                                   pos  (min len1 len2))))                    (let* ((c1 (%scharcode string1 (%i+ start1 i)))                           (c2 (%scharcode string2 (%i+ start2 i))))                      (declare (fixnum c1 c2))                      (unless (eq c1 c2)                        (if (<= c1 #xff)(setq c1 (aref sort-table c1)))                        (if (<= c2 #xff)(setq c2 (aref sort-table c2)))                        (unless (eq c1 c2)                          (setq val (if (> c1 c2) 1 -1) pos  (+ pos i))                          (return)))))                  (values val (%i+ pos istart1))))               (t (let ((blen1 (byte-length string1 script start1 end1))                        (blen2 (byte-length string2 script start2 end2)))                    ; dont hold your breath - this is really steenking slow                    (%stack-block ((p1 blen1)                                   (p2 blen2))                      (%put-string-segment-contents p1 string1 start1 end1)                      (%put-string-segment-contents p2 string2 start2 end2)                      (let ((font (#_getscript script #$smScriptAppFond)))                        (with-FONT font                          (#_uppertext p1 blen1)                          (#_uppertext p2 blen2)))                      (multiple-value-bind (val pos) (char-compare-at-mismatch p1 p2 blen1 blen2 script for-equal)                        (values val (+ pos istart1)))))))))))))); find pos of mismatch if any and char-compare that. Wins big if no mismatch or for-equal.; Saves groveling over strings twice in any case.(defun char-compare-at-mismatch (p1 p2 blen1 blen2 script for-equal)  (let ((table (get-char-byte-table script)))    (multiple-value-bind (charpos bytepos)                         (do* ((bytecount 0 (1+ bytecount))                               (charcount 0 (1+ charcount)))                              ((or (eq bytecount blen1)(eq bytecount blen2))(values charcount bytecount))                           (let ((b1 (%get-byte p1 bytecount))                                 (b2 (%get-byte p2 bytecount)))                             (if (neq b1 b2)                               (return (values charcount bytecount)))                             (when (eq 1 (aref table b1))                               (setq bytecount (1+ bytecount))                               (setq b1 (%get-byte p1 bytecount))                               (setq b2 (%get-byte p2 bytecount))                               (if (neq b1 b2)(return (values charcount (1- bytecount)))))))      (if (or (eq bytepos blen1)(eq bytepos blen2))        (values (if (eq blen1 blen2) t (if (< blen1 blen2) -1 1)) charpos)        (if for-equal          (values nil charpos)          (let ((code1 (%get-byte p1 bytepos))                (code2 (%get-byte p2 bytepos)))            (when (eq 1 (aref table code1))              (setq code1 (logior (ash code1 8)(%get-byte p1 (1+ bytepos)))))            (when (eq 1 (aref table code2))              (setq code2 (logior (ash code2 8)(%get-byte p2 (1+ bytepos)))))            (let ((val (char-code-compare-hairy code1 code2 script nil)))              (if (eq val 0)(values t charpos) ; shouldnt happen                  (values val charpos)))))))))(defun string-greaterp (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)    (if (eq result 1) pos nil)))(defun string-not-greaterp (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)    (if (eq result 1) nil pos)))(defun string-not-equal (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)    (if (eq result t) nil pos)))(defun string-not-lessp (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)    (if (eq result -1) nil pos)))(defun string-equal (string1 string2 &key start1 end1 start2 end2)  (eq t (string-compare string1 start1 end1 string2 start2 end2 t)))(defun string-lessp (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos)(string-compare string1 start1 end1 string2 start2 end2)    (if (eq result -1) pos nil))); forget script-manager - just do codes(defun string-cmp (string1 start1 end1 string2 start2 end2)  (let ((istart1 (or start1 0)))    (if (and (typep string1 'simple-string)(null start1)(null end1))      (setq start1 0 end1 (length string1))      (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1)))    (if (and (typep string2 'simple-string)(null start2)(null end2))      (setq start2 0 end2 (length string2))      (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2)))    (setq istart1 (%i- start1 istart1))            (let* ((val t))      (declare (optimize (speed 3)(safety 0)))      (do* ((i start1 (%i+ 1 i))            (j start2 (%i+ 1 j)))           ()        (when (eq i end1)          (when (neq j end2)(setq val -1))          (return))        (when (eq j end2)          (setq end1 i)          (setq val 1)(return))        (let ((code1 (%scharcode string1 i))              (code2 (%scharcode string2 j)))          (declare (fixnum code1 code2))          (unless (= code1 code2)                        (setq val (if (%i< code1 code2) -1 1))            (setq end1 i)            (return))))      (values val (%i- end1 istart1)))))(defun string> (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)    (if (eq result 1) pos nil)))(defun string>= (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)    (if (eq result -1) nil pos)))(defun string< (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)    (if (eq result -1) pos nil)))(defun string<= (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)    (if (eq result 1) nil pos))); this need not be so fancy?(defun string/= (string1 string2 &key start1 end1 start2 end2)  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)    (if (eq result t) nil pos)))(provide 'chars)