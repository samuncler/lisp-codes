; -*- Mode:lisp; Package:CCL; -*-;;	Change History (most recent first):;;  3 10/17/95 akh  no more advise restore-lisp-pointers;;  2 5/18/95  slh  find-ff-trap and add-ff-trap dont die if *ff-traps* is nil;;  (do not edit before this line!!);; new-traps.lisp - non-level-1 trap & interface functions; Copyright 1995 Digitool, Inc.; Modification History;; 05/02/96 bill  expand-ff-trap expands the old way if its string arg is NIL.; -------------  MCL-PPC 3.9; 03/11/96 bill  expand-ff-trap uses *memerror-traps* & *reserror-traps* to determine what code to;                generate for error checking.;                It also takes a new library arg specifying the shared library to look in for the trap.;                deftrap-inline respects the new syntax for specifying shared library names.;                It passes the shared library and the macro environment to expand-ff-trap.; 03/06/96 bill  Get rid of misplaced bold fonts.;                expand-ff-trap signals an error for too few as well as too many args,;                and the error message is more informative.;                Type check trap args. To do this, expand-ff-trap takes a new environment arg.; 03/01/96 bill  expand-ff-trap generates (ff-call-slep ...) instead of (ppc-ff-call ...); 12/27/95 gb    inline-trap stuff #-ppc-target.; 11/31/95 bill  expand-ff-trap no longer wraps VALUES around the generated code.;                Doing so prevented the compiler from realizing that it could;                stack cons pointer return values.; 11/30/95 slh   recognize :check-error too; 11/13/95 bill  expand-ff-trap no longer complains about "no implementation" for the ppc target.; 11/09/95 gb    expand-ff-trap: _MemError returns an OSErr; 11/08/95 bill  (require-trap #_memerror); 11/02/95 bill  expand-ff-trap generates (ppc-ff-call ...) if (ppc-target-p) is true.;                It also converts args & results slightly differently for that case.;                Change = to EQL in a few places so that it will inline.;  6/09/05 slh   clear trap array after using it; no ime lap!;  5/25/95 slh   new interfaces-2 mods.;  5/16/95 slh   find-ff-trap, add-ff-trap, convert-ff-traps;  5/10/95 slh   created from a file by Alan Ruttenberg & Mike Travers(in-package :ccl)(declaim (special *ff-trap-pointer* *ff-trap-pointer-size*))(defvar *ff-trap-save-pointer-array* nil  "If we do a save-world, this gets the contents of the trap pointer to be restored in the next launch")(defvar *variable-names-macro-arglists-shouldnt-use* '(t))(defun bad-variable-name-replacement (name)  (intern (format nil "VARIABLE-NAMED-~A" (string name)) 'traps))(defun make-ff-trapwords (words)  "This gets stored in the fasl file, as part of the load-time-value form. We add a couple of words per   discussion with gb, so that the return address of the jsr doesn't pollute our argument stack."  (let ((words `(10271 ; spop d4                 ,@words                 12036 20085))) ; spush d4 / rts    (make-array (length words) :element-type '(unsigned-byte 16) :initial-contents words)));; calculate the pointer we are going to give to ff-call(defmacro inline-trap-offset (name trapwords)  `(%inc-ptr *ff-trap-pointer* (the fixnum (%car (load-time-value (register-fftrap ',name ,trapwords))))))(defparameter *memerror-traps*  (mapcar #'(lambda (x) (intern (string-upcase x) 'traps))          '("_NewEmptyHandle" "_NewEmptyHandleSys" "_HLock" "_HUnlock" "_HPurge" "_HNoPurge"            "_HLockHI" "_ReserveMem" "_ReserveMemSys"            "_SetApplLimit"            "_NewHandle" "_NewHandleSys" "_NewHandleClear" "_NewHandleSysClear"            "_HandleZone""_RecoverHandle" "_RecoverHandleSys"            "_NewPtr" "_NewPtrSys" "_NewPtrClear" "_NewPtrSysClear"            "_PtrZone"            "_MoveHHi" "_DisposePtr" "_SetPtrSize" "_DisposeHandle" "_SetHandleSize" "_ReallocateHandle"            "_EmptyHandle" "_HSetRBit" "_HClrRBit" "_MoreMasters")))(defparameter *reserror-traps*  (mapcar #'(lambda (x) (intern (string-upcase x) 'traps))          '("_RsrcZoneInit" "_CloseResFile" "_CreateResFile" "_OpenResFile" "_UseResFile"            "_CountTypes" "_Count1Types" "_GetIndType" "_Get1IndType"            "_CountResources" "_Count1Resources" "_GetIndResource" "_Get1IndResource"            "_GetResource" "_Get1Resource" "_GetNamedResource" "_Get1NamedResource"            "_LoadResource" "_ReleaseResource" "_DetachResource"            "_UniqueID" "_Unique1ID" "_GetResAttrs"            "_GetResInfo" "_SetResInfo" "_AddResource" "_GetResourceSizeOnDisk" "_GetMaxResourceSize"            "_RsrcMapEntry" "_SetResAttrs" "_ChangedResource" "_RemoveResource" "_UpdateResFile"            "_WriteResource" "_SetResPurge" "_GetResFileAttrs" "_SetResFileAttrs"            "_OpenRFPerm" "_RGetResource" "_HOpenResFile" "_HOpenResFile" "_HCreateResFile" "_HCreateResFile"            "_FSpOpenResFile" "_FSpCreateResFile"            "_ReadPartialResource" "_WritePartialResource"            "_SetResourceSize" "_SizeResource" "_MaxSizeRsrc" "_RmveResource")));this function does the expansion of a trap call inside code.(defun expand-ff-trap (name passed-args inlines inline-args return-type &optional can-errcheck? string library env &aux c? do-memerr?)  "To summarize, we add the ff-traps pointer with with the car of the ff-trap entry (so   that we can update it at load time). Then call the trap.   Args come in in the form which the pascal reader gives them to us, i.e. as pairs of    name and mactype. Return-type is a mactype as well."    (when (eq (car inlines) :c) (setq c? t inlines (cdr inlines)))      (let* ((ppc-target-p (ppc-target-p))         (c-type-coercion? (if ppc-target-p t c?)))        (when (and (null inlines) (not ppc-target-p))      (format t "~&;; Warning: Trap ~a has no defined implementation~&" name)      (return-from expand-ff-trap `(error "Trap ~a has no defined-implementation" ',name)))        (when (member :no-errchk passed-args)      (setq passed-args (remove :no-errchk passed-args)))    (when (member-if #'(lambda (arg)                         (memq arg *error-check-keywords*))                     passed-args)      (setq passed-args (remove-if #'(lambda (arg) (memq arg *error-check-keywords*)) passed-args))      (setq do-memerr? t))    (when (and (not can-errcheck?) do-memerr?)      (format t "~&;; :errchk keyword wrongly found in ~a. Ignoring.~&" name))        (let ((passed-length (length passed-args))          (inline-length (length inline-args)))      (declare (fixnum passed-length inline-length))      (when (> passed-length inline-length)        (error "Too many args in trap call:~%~a" `(,name ,@passed-args)))      (when (< passed-length inline-length)        (error "Too few args in trap call:~%~a" `(,name ,@passed-args))))    (let* ((constants-checked            (mapcar #'(lambda (arg trap-arg &aux ct-check)                        (if (and (constantp arg)                                 (setq ct-check                                       (mactype-ct-type-check                                         (find-arg-mactype (cadr trap-arg)))))                          (if (funcall ct-check (eval arg))                            t                            (error "Argument ~s (~s) to trap ~a is not of type ~s"                                   arg (car trap-arg) name (cadr trap-arg)))                          nil))                    passed-args inline-args))           (arg-vars (mapcar #'(lambda (x) (declare (ignore x)) (gensym)) passed-args))           (rt-type-check-code (expand-trap-rt-type-check constants-checked                                                          (mapcar #'(lambda (var trap-arg)                                                                      (cons var (cadr trap-arg)))                                                                  arg-vars inline-args)                                                          env))           (inside-args (if rt-type-check-code arg-vars passed-args))           (type-coerced-args (ff-type-coerced-args inside-args inline-args c-type-coercion?))           (form (if (and ppc-target-p string)                   `(ff-call-slep ,(get-shared-library-entry-point string library)                                  ,@(ppc-ff-keywordized-arglist type-coerced-args inline-args)                                  ,(if return-type                                      (mactype=>ppc-ff-call-type (find-mactype return-type))                                     :void))                   (let ((trapwords (make-ff-trapwords inlines)))                     `(ff-call (inline-trap-offset ,name ,trapwords)                               ,@(ff-keywordized-arglist type-coerced-args inline-args c?)                               ,(if return-type (if c? :d0 (mactype-ff-type (find-mactype return-type))) :novalue)                               )))))      (when return-type        (setq form              (if c-type-coercion?                 (coerced-c-result form return-type ppc-target-p)                (coerced-pascal-result form return-type))))      (when rt-type-check-code        (setq form `(let ,(mapcar 'list arg-vars passed-args)                      (declare (dynamic-extent ,@arg-vars))                      ,@rt-type-check-code ,form)))      (if do-memerr?        (cond ((memq name *memerror-traps*)               `(memerror-check ,form))              ((memq name *reserror-traps*)               `(reserror-check ,form))              (t `(errchk ,form)))        form))))  ; Uh, A) this is undoubtedly defined elsewhere and B) isn't reentrant.(defvar *ff-ostype-string* (make-string 4 :element-type 'base-character))(defun ff-long-to-ostype (long)  (let ((string *ff-ostype-string*))    (setf (aref string 0) (%code-char (ldb (byte 8 24) long)))    (let ((rest (logand long #xffffff)))      (declare (fixnum rest))      (declare (optimize (speed 3) (safety 0)))      (setf (aref string 1) (%code-char (ldb (byte 8 16) rest)))      (setf (aref string 2) (%code-char (ldb (byte 8 8) rest)))      (setf (aref string 3) (%code-char (ldb (byte 8 0) rest))))    (intern string :keyword)))         ;; in C, everything is returned in d0. I assume that shorter elements will be returned ;; intact by ff-call. I need only to worry about pointer and character types.(defun coerced-c-result (return-arg return-type &optional dont-convert-pointers)  (let ((it-be (case (mactype-name (find-mactype return-type))                 ((:ptr :pointer) (if dont-convert-pointers return-arg `(%int-to-ptr ,return-arg)))                 (:character `(code-char ,return-arg))                 (:boolean `(not (eql ,return-arg 0)))                 (:ostype `(ff-long-to-ostype ,return-arg))                 (otherwise return-arg))))    (assert it-be () "Didn't find a ff-type for ~a" return-type)    it-be));; In pascal, I need to worry about functions which return 8 bit values,;; since the 8 bits will be in the top word of the (defun coerced-pascal-result (return-arg return-type)  (case (mactype-name (find-mactype return-type))    (:character `(code-char (ash ,return-arg -8)))    (:boolean `(not (eql (ash ,return-arg -8) 0)))    (:unsigned-byte `(ldb (byte 8 8) ,return-arg))    (:signed-byte (let ((temp (gensym)))                    `(let ((,temp (ldb (byte 8 8) ,return-arg)))                       (if (> ,temp 128) (- ,temp 256) ,temp))))    (otherwise return-arg)))(defun ff-keywordized-arglist (passed-args inline-args c?)  (loop for (nil type) in (if c? (reverse inline-args) inline-args)        for passed in (if c? (reverse passed-args) passed-args)        for ff-argtype = (or (mactype-ff-type (find-mactype type)) :ptr)        ; slh added (or .. ptr)        do (when (and c? (unless (eq ff-argtype :ptr) (setq ff-argtype :long))))        collect ff-argtype collect passed))(defun ppc-ff-keywordized-arglist (passed-args inline-args)  (loop for (nil type) in inline-args        for passed in passed-args        for ff-argtype = (mactype=>ppc-ff-call-type (find-mactype type))        collect ff-argtype collect passed))(defun ff-type-coerced-args (args inline-args c?)  (loop for arg in args        for (nil rawtype) in inline-args        for type = (find-mactype rawtype)        collect         (if (and (eql (mactype-record-size type) 1))          (case (mactype-name type)            (:unsigned-byte (if c? arg `(ash (logand #xff ,arg) 8)))            (:boolean `(if ,arg -1 0))          ; #$true #$false            (:signed-byte (if c? arg                              (let ((temp (gensym)))                                `(let ((,temp (ldb (byte 8 0) ,arg)))                                   (if (> ,temp 128)                                      (- (ash ,temp 8) #xffff)                                     (ash ,temp 8))))))            (:character (if c? `(char-code ,arg) `(ash (char-code ,arg) 8)))            (otherwise arg))          arg)))(defun can-do-errcheck-keyword? (name args return-type inlines)  (declare (ignore name args return-type))  (or (null inlines) (not (eq (car inlines) :c))));; The source is translated into this macro unless there is an aptimized translator;; added extra argument errchk(defmacro deftrap-inline (name args return-type inlines &key allow-errchk?)  (multiple-value-bind (name string-spec) (make-trap-symbol name)    (multiple-value-bind (string library) (trap-string-and-library string-spec t)      (loop for argspec in args            do             (when (memq (car argspec) *variable-names-macro-arglists-shouldnt-use*)              (setf (car argspec) (bad-variable-name-replacement (car argspec)))))      (let ((env-var (gensym)))        `(progn           (setf (gethash ',name %trap-strings%) ',string-spec)           (defmacro ,name (&environment ,env-var ,@(mapcar 'car args) ,@(if allow-errchk? '(&optional (errchk? :no-errchk)) nil))             (declare (ignore-if-unused errchk?))             (expand-ff-trap ',name (list ,@(if allow-errchk? (list 'errchk?) nil) ,@(mapcar 'car args))                             ',inlines ',args ',return-type ,allow-errchk? ,string ,library ,env-var)))))));;****************************************************************;; Save and load world...;; The strategy is to save the pointer to an array when save-world, and restore the pointer ;; from the array when we restart a world. I was going to use a resource, except I didn't know;; how to add the resource to only the newly saved word.;;;; we have a timing issue here here. If system code uses traps stored in the ff-pointer;; during the restart sequence then we have to make it an early priority to set this up.;; I'm not sure how to make this happen early enough.; now called from kill-lisp-pointers on 68K; not used at all on PPC.#-ppc-target(progn(defun save-trap-pointer-to-array ()  (let* ((nwords (/ *ff-trap-pointer-size* 2))         (array (make-array nwords :element-type '(unsigned-byte 16))))    (setq *ff-trap-save-pointer-array* array)    (dotimes (i nwords)      (setf (aref array i) (%get-word *ff-trap-pointer* (* i 2))))))(defun restore-trap-pointer-from-array ()  (let* ((nwords (/ *ff-trap-pointer-size* 2))         (array *ff-trap-save-pointer-array*))    (when array      (dotimes (i nwords)        (setf (%get-word *ff-trap-pointer* (* i 2)) (aref array i)))      (setq *ff-trap-save-pointer-array* nil))))(defun initialize-ff-traps-pointer ()  (setq *ff-trap-pointer* (%register-trap 41246 384 *ff-trap-pointer-size*))    ; (#_newptr *ff-trap-pointer-size*)  (when *ff-trap-save-pointer-array*    (restore-trap-pointer-from-array))); redefines definition in l1-traps.lisp(defun find-ff-trap (name)  (and *ff-traps*        (gethash name *ff-traps*))); redefines definition in l1-traps.lisp(defun add-ff-trap (name offset trap-words)  (when (not *ff-traps*) (setq *ff-traps* (make-hash-table :test 'eq)))  (let ((pair (cons offset trap-words)))    (puthash name *ff-traps* pair)    pair))(defun convert-ff-traps ()  (let ((ff-traps *ff-traps*))    (setq *ff-traps* (make-hash-table :test 'eq))    (while ff-traps      (let ((acons (pop ff-traps)))        (puthash (car acons) *ff-traps* (cdr acons))))))    (unless *ff-trap-pointer*  (initialize-ff-traps-pointer))(when (consp *ff-traps*)  (convert-ff-traps)))#|(advise restore-lisp-pointers (initialize-ff-traps-pointer)        :when :before); Do this in save-application, it's not necessary for just quitting;(pushnew 'save-trap-pointer-to-array *lisp-cleanup-functions*)(advise record-descriptor-storage        (when (eq (car values) :handle)          (warn "Relying on ~A records to have a default storage type of :handle is not recommended." (record-descriptor-name (car arglist))))        :when :after        :name :interfaces-2)|#; End of new-traps.lisp