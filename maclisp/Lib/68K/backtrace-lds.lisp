;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  3 4/24/95  akh  support for restart-frame and return-from-frame;;  (do not edit before this line!!); backtrace-lds.lisp; low-level support for stack-backtrace dialog (Lisp Development System); Copyright 1987-1988, Coral Software Corp.; Copyright 1989-1994, Apple Computer, Inc.; Copyright 1995, Digitool, Inc.(in-package :ccl);; Modification History;; 06/12/97 slh  %stack< -> backtrace.lisp (for MCL-AppGen);  3/30/95 slh  merge in base-app changes;-------------- 3.0d18;04/13/93 bill set-nth-value-in-frame works again.;------------- 2.1d5;03/16/93 bill return-from-frame works in the new order.;03/12/93 bill frame-vsp updated for segmented stacks.;03/01/93 bill teach last-frame-ptr about segmented stacks;11/20/92 gb   pass stack-group around; needs to work with discontiguous stacks.;------------- 2.0;11/11/91 gb   use "safe-cell-value" to lie about nilreg v,fcells.;------------- 2.0b3;07/21/91 gb   Declaim, %badarg.;06/13/91 bill "saved ~s" -> "saved ~a";------------- 2.0b2;05/06/91 bill set-saved-register, set-register-value;              find-local-name returns "saved xSAVEn" vice xSAVEn for argtype;05/03/91 bill set-nth-value-in-frame;05/20/91 gb   FUNCTION-ARGS groks &restv.;05/01/91 alice nth-value-in-frame - as gary suggests don't _debugger, make range check work;03/04/91 alice report-bad-arg gets 2 args;02/18/91 gb   %uvsize -> uvsize.;02/07/91 alice ccl; => ccl:;-------------- 2.0b1;11/21/90 gb   slight mods to (select-)backtrace.;10/23/90 akh  gary's fix to show nilreg-relative specials in nth-value-in-frame;10/16/90 bill frame-supplied-args, *proto-return* interracts correctly with PROGV.;10/11/90 bill Remove old backtrace window;10/10/90 bill add identification of saved registers to find-local-name;10/09/90 bill parent-frame-saved-vars, saved-register-values;10/05/90 bill make *proto-return*'s agree with last-catch-since (unsigned compare).;              Also pop CSAREA to below target SP.;09/14/90 bill *use-new-backtrace* in select-backtrace.;09/06/90 bill Invalidate the backtrace-dialog after set-view-size;08/30/90 bill add PC to print-call-history;08/24/90 bill frame-lfun;08/02/90 bill Fix drawing in set-view-size;07/26/90 bill function-args returns NIL for NKEYS if &key not mentioned.;07/13/90 alice put find-local-name from patch-2.0a1 (correct??);07/05/90 bill  Fix some sizes to prevent overlapping.;07/04/90 bill  bug in find-local-name when lfun arg was nil.;06/25/90 bill  :table-width & :table-height -> :table-dimensions.;06/22/90 bill  :window-font -> :view-font;06/13/90 bill  resize the backtrace-dialog.;06/12/90 gb    FIND-LOCAL-NAME counts nkeys twice (for key-supplied-p stuff.);06/04/90 gb     return-from-frame rides again.;05/27/90 gb     move trace etc. to encapsulate.lisp.;05/24/90 bill  :window-size -> :view-size;04/30/90 gb    new stack walkers.  apply-in-frame still broken.;01/17/90  gz   pass $lfatr-noname-bit to %make-lfun.;02/10/90 bill  without-dialog-drawing => with-quieted-view;12/29/89 bill  Remove (method window-deativate-event-handler :after (backtrace-dialog));               The dialog does this automagically.;12/27/89  gz   Use defsetf to def a setf.; 10/24/89 gb   trace-global-def makes a closure.  What a concept.; 9/27/89 gb    defvar -> proclaim of *backtrace-dialogs*.; 9/17/89 gb    removed ASKs from trace functions.; 9/17/89  gz   $lfatr-regs-mask in registers-used-by.; 9/16/89 bill  Left a couple of ASK's in trace functions.; 9/10/89  gz   use first-selected-cell.;               (%cdr (%sym-fn-loc x)) -> (fboundp x); 09/09/89 bill $catchtop => $ccatchtop in last-catch-since; 09/07/89 bill add without-dialog-item-drawing-if to ;               backtrace-frame-table-update to prevent double drawing; 09/06/89 bill CLOSify the dialog;               apply-in-frame: imms returned from decompose-fn was assumed;               to be a simple-vector: (svset ...) => (setf (aref ...));08/24/89 gb  gratuitous fascist global name changes.; 07/28/89 bill "dialog" => "dialog-object";5/8/89   gz  %make-compiled-function -> %make-lfun (new regime);04/27/89 gb  backtrace-frame-table-update : set instance variables before calling SCROLL-TO-CELL;             and/or SET-TABLE-DIMENSIONS.  Btw, why all the update events all of a sudden?;04/07/89 gb  $sp8 -> $sp.; 03/18/89 gz  window-foo -> window-object-foo.; 7-apr-89 as  %str-cat takes rest arg; 03/04/89 gz  put trace/untrace here.  New %make-compiled-function args,;              symbolic names for lfun bits.; 02/23/89 gb  shared-macptr bug in cell-sp.; 12/01/88 gz  use defobject.; 9/11/88 gb   life after cfp; make local, setf-local work.; 8/23/88 gz   declarations; 8/17/88 gb   sp-lfun -> cfp-lfun.; 6/22/88 as   saved-specials always described in backtrace; 6/21/88 as   (setf (local . . .));              inspect function-object, not symbol; 6/20/88 as   add 10 to pc when displaying it (but not when storing it); 6/16/88 as   new features; 6/10/88 jaj  added closed-over-value-p and use it; 6/7/88  gb   put in local name stuff; 6/01/88 as   catch :truncate; 5/13/88 jaj  made room for package of *debug-value*;10/28/87 gb   require traps.;10/15/87 jaj  *d* renamed to *debug-value* %lfun-name-string only has offsets;              if above A5.; 9/15/87 jaj    print *d* using ~s, don't print hex addresses in block-compiled;                version.  new function %lfun-name-string, other changes.;---------------------------------Version 1.0----------------------------------; 8/01/87  gb    made backtrace-frame-table-update scroll to cell 0.  made;                frame-title's size a little shorter to reduce update glitches.; 7/28/87  as    changed wording of dialog message; 7/28/87  gz    draw to self in draw-cell-contents, per gb.; 7/24/87  as    single click displays frame values.;                new text item tells about *d*;                made de-activation more visually informative; 7/23/87  gb    changed position, size of static-text-item, made it;                print frame address in hex.; 7/21/87  gz    select-backtrace does a modeless backtrace,;                backtrace does a modal one.;                Fencepost in backtrace-table-update.; 7/19/87 as/gb  switched font to monaco 9;                binds *d* to selected value in selected frame.; 7/17/87 jaj    up to window spec; 7/14/87  gb    require defrecord, provide backtrace.; 7/13/87 jaj    init-lists use keywords; 7/11/87  as    backtrace uses table-double-click-p; 7/6/87   gz    new EXIST arg scheme; 7/02/87  gb    don't compile dialog-item-action every time. Fencepost;                in count-values-in-frame.  Set flags in table handles to allow;                at most one cell to be selected.  Deselect old cell when;                selecting new frames.; 6/30/87  gz    bind *print-length* and *print-level* when drawing frames.; 6/25/87  gz    put 'version, autoload dialogs.; 6/24/87  gb    re-worked.; 6/22/87  gb    still modeless but finds functions better.; 6/19/87  gb    %have -> have.; 6/18/87  jaj   New file.(eval-when (eval compile #-bccl load)  (require 'streams))(eval-when (eval compile)  (require 'toolequ)  (require 'sysequ)  (require 'lispequ)  (require 'subprims8 "ccl:compiler;subprims8")  (require 'backquote))#|;(defun child-frame (p sg)  (require-type sg 'stack-group)  (lap-inline (p sg)    ;(debug "child-frame")    (with-preserved-registers #(dsave0 dsave1 dsave2 asave0)      (move.l arg_z dsave2)      (move.l arg_y dsave0)      (move.l nilreg dsave1)      (address->index sp arg_z)      (if# (eq (special *current-stack-group*) dsave2)        (address->index (a5 $csarea) arg_y)        else#        ;(debug "Other stack group")        (move.l dsave2 atemp0)        (move.l (atemp0 4) atemp0)        (move.l (svref atemp0 sgbuf.csbuf) atemp0)        (move.l (atemp0 $stackseg.first) atemp0)        (move.l (atemp0 $catch.cs_area) arg_y))      (lea #'%next-cfp asave0)@again      (move.l dsave2 arg_x)      (set_nargs 3)      (move.l asave0 atemp0)      (jsr_subprim $sp-mvpass)      (vpop arg_y)      (vpop acc)      (if# (ne nilreg acc)        (if# (eq dsave0 acc)          (if# (ne dsave1 nilreg)            (move.l dsave1 acc)            else#            (move.l nilreg acc))          else#          (move.l acc dsave1)          (bra @again))))))|#            #|(defun count-stack-frames (&optional (s (%get-frame-ptr)) (e (last-frame-ptr)) (sg *current-stack-group*))  (lap-inline () (debug "Count stack frames"))  (let ((n 1))    (let ((endptr (stack-area-endptr s sg)))      (if endptr        (loop          (if (multiple-value-setq (s endptr) (%next-cfp sg endptr s))            (setq n (%i+ n 1)))          (when (or (null s) (eq s e)) (return)))))    n))|##| unused(defun saved-specials-between (sg istart xend)  sg istart xend)|#; Act as if VSTACK-INDEX points somewhere where DATA could go & put it there.(defun set-lisp-data (vstack-index data)  (let* ((old (%access-lisp-data vstack-index)))    (if (closed-over-value-p old)      (set-car old data)      (lap-inline (vstack-index data)        (index->address arg_y atemp0)        (move.l arg_z @atemp0)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;extensions to let user access and modify values(defun set-nth-value-in-frame (sp n sg new-value &optional child-frame &aux                               (i -1)                              special)  (declare (ignore child-frame))  (let* ((curvsp (frame-vsp sp)))    (loop      (setq special (saved-binding-p sg curvsp)             i (%i+ i 1))      (when (eq n i)        (set-lisp-data curvsp new-value)        (return new-value))      (setq curvsp (%i- curvsp (if special 3 1)))))); Returns five values: (ARGS TYPES NAMES COUNT NCLOSED); ARGS is a list of the args supplied to the function; TYPES is a list of the types of the args.; NAMES is a list of the names of the args.;       TYPES & NAMES will hae entries only for closed-over, required, & optional args.; COUNT is the number of known-correct elements of ARGS, or T if they're all correct.;       ARGS will be filled with NIL up to the number of required args to lfun; NCLOSED is the number of closed-over values that are in the prefix of ARGS;       If COUNT < NCLOSED, it is not safe to restart the function.(defun frame-supplied-args (frame lfun pc child sg)  (multiple-value-bind (req opt restp keys allow-other-keys optinit lexprp ncells nclosed)                       (function-args lfun)    (declare (ignore allow-other-keys lexprp ncells))    (let* ((vsp (frame-vsp frame))           (child-vsp (frame-vsp child vsp sg))           (frame-size (- vsp child-vsp))           (res nil)           (types nil)           (names nil))      (flet ((push-type&name (cellno)               (multiple-value-bind (type name) (find-local-name cellno lfun pc)                 (push type types)                 (push name names))))        (declare (dynamic-extent #'push-type&name))        (if (or (logbitp ccl::$lfatr-novpushed-args-bit (ccl::lfun-attributes lfun))                (<= frame-size 0))          ; Can't parse the frame, but all but the last 3 args are on the stack          (let* ((nargs (+ nclosed req))                 (vstack-args (max 0 (min frame-size (- nargs 3)))))            (dotimes (i vstack-args)              (declare (fixnum i))              (push (access-lisp-data vsp) res)              (push-type&name i)              (decf vsp))            (values (nreconc res (make-list (- nargs vstack-args)))                    (nreverse types)                    (nreverse names)                    vstack-args                    nclosed))          ; All args were vpushed.          (let* ((might-be-rest (> frame-size (+ req opt)))                 (rest (and restp might-be-rest (access-lisp-data (- vsp req opt))))                 (cellno -1))            (declare (fixnum cellno))            (when (and keys might-be-rest (null rest))              (let ((vsp (- vsp req opt))                    (keyvect (lfun-keyvect lfun))                    (res nil))                (dotimes (i keys)                  (declare (fixnum i))                  (when (access-lisp-data (1- vsp))   ; key-supplied-p                    (push (aref keyvect i) res)                    (push (access-lisp-data vsp) res))                  (decf vsp 2))                (setq rest (nreverse res))))            (dotimes (i nclosed)              (declare (fixnum i))              (when (<= vsp child-vsp) (return))              (push (access-lisp-data vsp) res)              (push-type&name (incf cellno))              (decf vsp))            (dotimes (i req)              (declare (fixnum i))              (when (<= vsp child-vsp) (return))              (push (access-lisp-data vsp) res)              (push-type&name (incf cellno))              (decf vsp))            (if rest              (dotimes (i opt)              ; all optionals were specified                (declare (fixnum i))                (when (<= vsp child-vsp) (return))                (push (access-lisp-data vsp) res)                (push-type&name (incf cellno))                (decf vsp))              (let ((offset (+ opt (if restp 1 0) (if keys (+ keys keys) 0)))                    (optionals nil))                (dotimes (i opt)            ; some optionals may have been omitted                  (declare (fixnum i))                  (when (<= vsp child-vsp) (return))                  (let ((value (access-lisp-data vsp)))                    (if optinit                      (if (access-lisp-data (- vsp offset))                        (progn                          (push value optionals)                          (push-type&name (incf cellno))                          (return)))                      (progn (push value optionals)                             (push-type&name (incf cellno))))                    (decf vsp)))                (unless optinit                  ; assume that null optionals were not passed.                  (while (and optionals (null (car optionals)))                    (pop optionals)                    (pop types)                    (pop names)))                (setq rest (nreconc optionals rest))))            (values (nreconc res rest) (nreverse types) (nreverse names)                    t nclosed))))))); nth-frame-info, set-nth-frame-info, & frame-lfun are in "inspector;new-backtrace"(defun frame-name-number (symbol)  "given a name, returns index of slot in frame."  (let* ((names (names-in-frame))         (tail (memq symbol names)))    (if tail      (if (memq symbol (cdr tail))        (error "~s is bound more than once in the current frame.~        ~%Please refer to it by number." symbol)        (- (list-length names)           (list-length tail)))      (error "~s is not bound in the current frame." symbol))))(defmacro local (indicator)  (if (symbolp indicator)    `(values (nth-frame-info (frame-name-number ',indicator)))    (progn      (unless (fixnump indicator)        (report-bad-arg indicator '(or symbol (integer 0 #.call-arguments-limit))))      `(values (nth-frame-info ,indicator)))))(defmacro set-local (indicator new-value)  (if (symbolp indicator)    `(set-nth-frame-value (frame-name-number ',indicator) ,new-value)    (progn      (unless (fixnump indicator)        (report-bad-arg indicator '(or symbol (integer 0 #.most-positive-fixnum))))      `(set-nth-frame-value ,indicator ,new-value))))(defsetf local set-local); Returns the segment containing index, or NIL if it's not in the stack; actually returns index or nil - or something -  ok its just a predicate(defun %stack-member (index stackseg)  (lap-inline (index stackseg)    (move.l arg_z atemp0)    (index->address arg_y arg_y) ; index as address    (move.l atemp0 atemp1)  ; stackseg    (prog#     (if# (cc (atemp1 $stackseg.first) arg_y)       (if# (cs (atemp1 $stackseg.last) arg_y)         (address->index arg_y acc)  ; address as index - i.e. original index         (bra (exit#))))     (move.l (atemp1 $stackseg.older) da)     (move.l da atemp1)     (bne (top#))     (move.l nilreg acc))))         #| ; there are two of these functions; Since stacks are segmented, there isn't necessarily any ordering between catch frames.; So ...; This is still broken!!!; make this pos comprehensible(defun last-catch-since (sp sg)   (declare (%noforcestk))  (old-lap-inline ()   (index->address arg_y db)  ; so sp is an index   (move.l arg_z atemp0)   (move.l (atemp0 $sg.sgbuf) atemp0)   (move.l (svref atemp0 sgbuf.csbuf) atemp0)   (if# (ne (special *current-stack-group*) arg_z)     (move.l (atemp0 $stackseg.first) atemp1)    else#     (move.l sp (atemp0 $stackseg.first))     (move.l (a5 $ccatchtop) atemp1))   (prog#    (if# (cc (atemp0 $stackseg.first) db)      (bif (cs (atemp0 $stackseg.last) db) (exit#)))    (move.l (atemp0 $stackseg.older) da)    (move.l da atemp0)    (bne (top#))    (ccall error '"Can't find stack segment"))   ; db = sp arg as an address   ; atemp0 = stack seg containing sp   ; atemp1 = first catch frame   (moveq 0 dtemp1)   (bra @test)   (prog#    (move.l atemp1 dtemp1)    (move.l (atemp1 $catch.link) atemp1)    @test    (bif (eq (move.l atemp1 da)) (exit#))    (if# (and (cc (atemp0 $stackseg.first) atemp1)              (cs (atemp0 $stackseg.last) atemp1))      (bif (cc atemp1 db) (top#))      (bra (exit#)))    (spush atemp0)    (bra @nextseg)    (prog#     (bif (and (cc (atemp0 $stackseg.first) atemp1)               (cs (atemp0 $stackseg.last) atemp1))          (exit#))     @nextseg     (move.l (atemp0 $stackseg.older) acc)     (move.l acc atemp0)     (bif ne (top#)))    (spop atemp0)    (bif eq (top#)))   (move.l nilreg acc)   (if# (ne (tst.l dtemp1))     (add.l ($ $catch.pc) dtemp1)     (address->index dtemp1 acc))))|#(defun last-catch-since (sp sg)   ;(declare (%noforcestk))  (lap-inline ()(:variable sp sg)   (index->address arg_y db)  ; so sp is an index   (move.l arg_z atemp0)   (move.l (atemp0 $sg.sgbuf) atemp0)   (move.l (svref atemp0 sgbuf.csbuf) atemp0)  ; some side effect I dont understand   (if# (ne (special *current-stack-group*) arg_z)     (move.l (atemp0 $stackseg.first) atemp1)    else#     (move.l sp (atemp0 $stackseg.first))     (move.l (a5 $ccatchtop) atemp1))   (prog#    (if# (cc (atemp0 $stackseg.first) db)      (bif (cs (atemp0 $stackseg.last) db) (exit#)))    (move.l (atemp0 $stackseg.older) da)    (move.l da atemp0)    (bne (top#))    (ccall error '"Can't find stack segment"))   ; db = sp arg as an address   ; atemp0 = stack seg containing sp   ; atemp1 = first catch frame   (moveq 0 dtemp1)   (bra @test)   (prog#    (move.l atemp1 dtemp1)    (move.l (atemp1 $catch.link) atemp1)    @test    (bif (eq (move.l atemp1 da)) (exit#))    (if# (and (cc (atemp0 $stackseg.first) atemp1)              (cs (atemp0 $stackseg.last) atemp1))      (bif (cc atemp1 db) (top#))      (bra (exit#)))    (spush atemp0)    (bra @nextseg)    (prog#     (bif (and (cc (atemp0 $stackseg.first) atemp1)               (cs (atemp0 $stackseg.last) atemp1))          (exit#))     @nextseg     (move.l (atemp0 $stackseg.older) acc)     (move.l acc atemp0)     (bif ne (top#)))    (spop atemp0)    (bif eq (top#)))   (move.l nilreg acc)   (if# (ne (tst.l dtemp1))     (add.l ($ $catch.pc) dtemp1)     (address->index dtemp1 acc)))); This isn't quite right - has to look at all functions on stack, not just those that saved VSPs.(defun frame-restartable-p (target &optional (sg *current-stack-group*))  (let ((values (make-list (1+ 5))))    (declare (dynamic-extent values)) ; time for dynamic-extent make-array .    (let* ((catch (last-catch-since target sg))           lfun           pc           (unresolved 0)           (frame (parent-frame catch sg))           (child (child-frame frame sg)))      #-bccl (unless frame (break "bug: null frame"))      (loop        (unless (multiple-value-setq (lfun pc) (cfp-lfun frame sg child)) (return nil))        (multiple-value-bind (mask where) (registers-used-by lfun pc)          (when mask            (if (not where)               (setq unresolved (%ilogior unresolved mask))              (let ((vsp (- (frame-vsp frame) where (1- (logcount mask))))                    (j 5))                (dotimes (i j)                  (declare (fixnum i))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setf (nth (1+ i) values) vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1))))))))))        (when (eq target frame)          (return (setf (car values) (if (eql unresolved 0) target))))        (setq child frame)        (unless (setq frame (parent-frame frame sg))          (return))))    ;(break "target = ~s ~s ~x" target (index->address target) (index->address target))    (values-list values)))(defun next-catch (catch)  (lap-inline (catch)    (index->address arg_z atemp0)    (move.l nilreg acc)    (if# (ne (move.l (atemp0 (- $catch.link $catch.pc)) da))      (add.l ($ $catch.pc) da)      (address->index da acc)))); get the saved register addresses for this frame; still need to worry about this unresolved business; could share some code with parent-frame-saved-vars(defun my-saved-vars (sg frame)  (let ((unresolved 0)        dsave0 dsave1 dsave2 asave0 asave1)    (multiple-value-bind (lfun pc) (cfp-lfun frame sg)        (if lfun          (multiple-value-bind (mask where) (registers-used-by lfun pc)            (when mask              (if (not where)                 (setq unresolved (%ilogior unresolved mask))                (let ((vsp (- (frame-vsp frame) where (1- (logcount mask))))                      (j 5))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq dsave0 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq dsave1 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq dsave2 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq asave0 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq asave1 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))))))          (setq unresolved #x1f)))    (values unresolved dsave0 dsave1 dsave2 asave0 asave1)))        (defun parent-frame-saved-vars        (sg frame last-catch unresolved dsave0 dsave1 dsave2 asave0 asave1)  (let ((parent (and frame (parent-frame frame sg))))    ;(print  (list frame parent last-catch))    (when parent      (loop (let ((next-catch (and last-catch (next-catch last-catch))))              ;(declare (ignore next-catch))              (if (and next-catch (> next-catch parent))  ; this looks wrong to me                (progn ;(print 'ccl::weird)                (setq last-catch next-catch                      unresolved 0                      dsave0 nil                      dsave1 nil                      dsave2 nil                      asave0 nil                      asave1 nil))                (return))))      (multiple-value-bind (lfun pc) (cfp-lfun parent sg frame)        (if lfun          (multiple-value-bind (mask where) (registers-used-by lfun pc)            (when mask              (if (not where)                 (setq unresolved (%ilogior unresolved mask))                (let ((vsp (- (frame-vsp parent) where (1- (logcount mask))))                      (j 5))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq dsave0 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq dsave1 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq dsave2 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq asave0 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))                  (when (%ilogbitp (setq j (%i- j 1)) mask)                    (setq asave1 vsp                          vsp (1+ vsp)                          unresolved (%ilogand unresolved (%ilognot (%ilsl j 1)))))))))          (setq unresolved #x1f                dsave0 nil                dsave1 nil                dsave2 nil                asave0 nil                asave1 nil)))      (values parent last-catch unresolved dsave0 dsave1 dsave2 asave0 asave1)))); initialization for looping on parent-frame-saved-vars(defun last-catch-since-saved-vars (frame sg)  (let ((last-catch (last-catch-since frame sg)))    (values (parent-frame last-catch sg) last-catch 0 nil nil nil nil nil))); Returns 6 values:; mask dsave0 dsave1 dsave2 asave0 asave1; The mask says which registers are used at PC in LFUN.; The other five are the values of those registers.; registers whose bits are not set in MASK or set in UNRESOLVED will; be returned as NIL.(defun saved-register-values        (lfun pc child last-catch unresolved dsave0 dsave1 dsave2 asave0 asave1)  (declare (ignore child))  (let ((mask (or (registers-used-by lfun pc) 0))        (j 5))    (setq dsave0          (and (%ilogbitp (setq j (%i- j 1)) mask)               (not (%ilogbitp j unresolved))               (safe-cell-value (get-register-value dsave0 last-catch j))))    (setq dsave1          (and (%ilogbitp (setq j (%i- j 1)) mask)               (not (%ilogbitp j unresolved))               (safe-cell-value (get-register-value dsave1 last-catch j))))    (setq dsave2          (and (%ilogbitp (setq j (%i- j 1)) mask)               (not (%ilogbitp j unresolved))               (safe-cell-value (get-register-value dsave2 last-catch j))))    (setq asave0          (and (%ilogbitp (setq j (%i- j 1)) mask)               (not (%ilogbitp j unresolved))               (safe-cell-value (get-register-value asave0 last-catch j))))    (setq asave1          (and (%ilogbitp (setq j (%i- j 1)) mask)               (not (%ilogbitp j unresolved))               (safe-cell-value (get-register-value asave1 last-catch j))))    (values mask dsave0 dsave1 dsave2 asave0 asave1))) ; Set the nth saved register to value.(defun set-saved-register       (value n lfun pc child last-catch unresolved &rest saved-register-addresses)  (declare (ignore lfun pc child) (dynamic-extent saved-register-values))  (let ((j (- 4 n))        (addr (nth n saved-register-addresses)))    (when (logbitp j unresolved)      (error "Can't set register ~S to ~S" n value))    (set-register-value value addr last-catch j))  value); Index is bit number in register mask:; 4=dsave0, 3=dsave1, 2=dsave2, 1=asave0, 0=asave1(defun get-register-value (address last-catch index)  (declare (%noforcestk))  (lap-inline (address last-catch index)    (if# (ne (cmp.l arg_x nilreg))      ; address      (index->address arg_x atemp0)      (move.l @atemp0 acc)     else#      (index->address arg_y atemp0)     ; last-catch      (vscale.l arg_z)                  ; index      (neg.l arg_z)      (move.l (atemp0 arg_z (- (+ $catch.regs (* 4 4)) $catch.pc)) acc)))); Inverse of get-register-value(defun set-register-value (value address last-catch index)  (declare (%noforcestk))  (lap-inline (value address last-catch index)    (if# (ne (cmp.l arg_x nilreg))      ; address      (index->address arg_x atemp0)      (move.l @vsp @atemp0)     else#      (index->address arg_y atemp0)     ; last-catch      (vscale.l arg_z)                  ; index      (neg.l arg_z)      (move.l @vsp (atemp0 arg_z (- (+ $catch.regs (* 4 4)) $catch.pc))))))(defun return-from-nth-frame (n &rest values)  (apply-in-nth-frame n #'values values))(defun apply-in-nth-frame (n fn arglist)  (let* ((bt-info (car *backtrace-dialogs*)))    (and bt-info         (let* ((frame (nth-frame nil (bt.youngest bt-info) n)))           (and frame (apply-in-frame frame fn arglist)))))  (format t "Can't return to frame ~d ." n)); This method is shadowed by one for the backtrace window.(defmethod nth-frame (w target n &aux (sg *current-stack-group*))  (declare (ignore w))  (and target (dotimes (i n target)                (declare (fixnum i))                (unless (setq target (parent-frame target sg)) (return nil))))); If this returns at all, it's because the frame wasn't restartable.(defun apply-in-frame (frame fn arglist &optional (sg *current-stack-group*))  (multiple-value-bind (target-sp dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc)                       (frame-restartable-p frame sg)    (if target-sp      (apply-in-frame-internal       sg frame fn arglist dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc))))(defun apply-in-frame-internal (sg frame fn arglist dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc)  (if (eq sg *current-stack-group*)    (%apply-in-frame frame fn arglist dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc)    (let ((process (stack-group-process sg)))      (if process        (process-interrupt         process         #'%apply-in-frame         frame fn arglist dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc)        (error "Can't find active process for ~s" sg)))))(defun %apply-in-frame       (frame fn arglist dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc)  (unless (and fn               (or (symbolp fn)                   (functionp fn)))    (report-bad-arg fn '(or function symbol)))  (let* ((catch (last-catch-since  frame *current-stack-group*))         #|           ; this sort of works & they are = but if we just do my-last-catch-since it crashes           (cadr (list nil ;(last-catch-since  frame *current-stack-group*)                              (my-last-catch-since  frame *current-stack-group*)))) |#         (sgbuf (sg-buffer *current-stack-group*))         (csbuf (sgbuf.csbuf sgbuf))         (vsbuf (sgbuf.vsbuf sgbuf))         (vsp (lap-inline (frame)                (index->address arg_z atemp0)                (address->index @atemp0 acc)))         (dblink (let ((link (lap-inline ()                               (move.l (a5 $db_link) acc)                               (address->index acc acc))))                   (lap-inline (csbuf vsbuf)                     (index->address arg_z atemp0)  ; arg_y arg_z backwards?                     (move.l vsp (atemp0 $stackseg.first))                     (index->address arg_y atemp0)                     (move.l sp (atemp0 $stackseg.first)))  ; WHAT Again                   (loop                     (when (or (eql 0 link)                               (and (%stack-member link vsbuf)                                    (or (eql link vsp)                                        (%stack< vsp link vsbuf)))                               (and (%stack-member link csbuf)                                    (%stack< frame link csbuf)))                       (return))                     (setq link (lap-inline (link)                                  (index->address arg_z atemp0)                                  (move.l @atemp0 acc)                                  (address->index acc acc))))   ; assumes 0 -> 0                   link))         (csarea (let ((csarea (lap-inline ()                                 (move.l (a5 $csarea) acc)                                 (address->index acc acc))))    ; assumes 0 -> 0                   (loop                     (when (or (eql 0 csarea)                               (%stack< frame csarea csbuf))                       (return))                     (setq csarea (lap-inline (csarea)                                    (index->address arg_z atemp0)                                    (move.l @atemp0 acc)                                    (address->index acc acc))))         ; assumes 0 -> 0                   csarea))         (v (vector catch dblink csarea frame fn arglist                    dsave0-loc dsave1-loc dsave2-loc asave0-loc asave1-loc)))    (lap-inline (v)      (movereg arg_z acc)      (move.l acc atemp0)      (move.l (svref atemp0 0) da)      ; catch      (if# ne        (index->address da da)        (sub.l ($ $catch.pc) da)        (address->index da da)        (move.l da (svref atemp0 0)))      (loop#       (move.l acc atemp0)       (move.l (svref atemp0 0) da)       (index->address da da)           ; assumes that 0 -> 0       (if# (eq (move.l (a5 $ccatchtop) db))         ; Can't get to the end as *%dynvfp%* & *%dynvlimit%* are always bound         (ccall error '"End of catch chain. This shouldn't ever happen"))       (bif (eq db da) (exit#))       (jsr_subprim $sp-nthrow1v1))      (if# (ne (tst.l (a5 $ccatchtop)))  ; then throw one more - odd        (jsr_subprim $sp-nthrow1v1))      (move.l acc atemp0)      (move.l (svref atemp0 1) da)      ; dblink      (index->address da da)      (loop#       (move.l (a5 $db_link) db)       (bif (eq db da) (exit#))       (if# (eq (tst.l db))         (ccall error '"End of dynamic binding chain. This should never happen."))       (jsr_subprim $sp-payback))       ; assumes $sp-payback preserves acc & da      (vpush acc)      (move.l acc atemp0)      (move.l (svref atemp0 2) acc)     ; csarea      (loop#       (move.l acc da)       (index->address da da)           ; assumes 0 -> 0       (move.l (a5 $csarea) db)       (bif (eq db da) (exit#))       (if# (eq (tst.l db))         (ccall error '"End of csarea chain. This shouldn't happen."))       (jsr_subprim $sp-popnlisparea))      (vpop acc)      (move.l acc atemp0)      (lea (svref atemp0 6) atemp0)     ; dsave0-loc      (move.l atemp0@+ da)      (if# (ne da nilreg)        (index->address da atemp1)        (move.l @atemp1 dsave0))      (move.l atemp0@+ da)      (if# (ne da nilreg)        (index->address da atemp1)        (move.l @atemp1 dsave1))      (move.l atemp0@+ da)      (if# (ne da nilreg)        (index->address da atemp1)        (move.l @atemp1 dsave2))      (move.l atemp0@+ da)      (if# (ne da nilreg)        (index->address da atemp1)        (move.l @atemp1 asave0))      (move.l atemp0@+ da)      (if# (ne da nilreg)        (index->address da atemp1)        (move.l @atemp1 asave1))      (move.l acc atemp0)      (move.l (svref atemp0 3) da)      ; frame      (index->address da sp)      (move.l @sp vsp)      (move.l (svref atemp0 5) arg_z)   ; arglist      (move.l (svref atemp0 4) atemp0)          ; fn      (set_nargs 0)      (jsr_subprim $sp-spreadargz-vextend-save-atemp0)      (jmp_subprim $sp-tfuncallgen-vchunkpop))))#|(setq *save-local-symbols* t)(defun test (flip flop &optional bar)  (let ((another-one t)        (bar 'quux))    (break)))(test '(a b c d) #\a)(defun closure-test (flim flam)  (labels ((inner (x)              (let ((ret (list x flam)))                (break))))    (inner flim)    (break)))(closure-test '(a b c) 'quux)(defun set-test (a b)  (break)  (+ a b))(set-test 1 'a)|#(provide 'backtrace); End of backtrace-lds.lisp