;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  8 9/27/96  akh  no warnings;;  7 9/3/96   akh  revert expt;;  2 4/6/95   akh  Use Kalman's rationalize;;  (do not edit before this line!!); Lisp arithmetic code.;; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.; Edit history; 01/12/93 bill Bob Cassel's patch to sqrt: move complex test earlier so;               the minusp doesn't error.; ------------- 3.0d13;07/07/93 bill  random-state stuff except for the print-object method moves to l1-numbers;-------------- 3.0d11;06/25/93 alice float reader (try-harder) - error before trying to compute (expt 5 100000).;05/28/93 bill  a random-state can no longer get "stuck" at 0.;-------------- 3.0d8;04/20/93 alice messed with short float reader some more; 04/19/93 alice fix short float reader (finally) so fix below is not necessary; 04/19/93 alice float-5-to-e don't die if e > 23; 08/10/92 alice sqrt - check for floatp early - twice as fast if true.; 07/13/92 alice float - faster, shorter, fceiling, fround, ftruncate, ffloor;01/13/93 bill  ldb, dpb, & friends move to l1-numbers;11/20/92 gb    new temp-float-consing syntax.  Not sure about mods to ffloor, etc.;07/13/92 bill  (ffloor 3) no longer signals an error (neither do fceiling, fround, or ftruncate);-------------- 2.0;02/22/92 (alice from "post 2.0f2c5:default-float-patch") don't rts from MAKE-SHORT-FLOAT-FROM-FIXNUMS;;               dtrt with *read-default-float-format* in PARSE-FLOAT;;               do short floats the sloppy way - instead of totally broken - in FIDE.;-------------- 2.0f2c5;11/25/91 alice #\f and #\F are also exponent markers;-------------- 2.0b4;11/21/91 alice allow a dude to types 200 digits and e-500;11/18/91 alice new float reader - hope we dont need to read floats sooner;09/08/91 alice log of bignum or big ratio doesnt try to float it, sqrt fancier for bignum & ratio;------------- 2.0b3;08/31/91 gb    fix complex/short-float stuff.;08/24/91 gb    use new trap syntax; don't _Debugger in %%decode-sfloat.;07/21/91 gb    &lap arglists, error checking & signalling.  Naive ATAN still loses, place;               blame elsewhere.;06/07/91 bill  isqrt type-checks its argument.;-------------- 2.0b2;05/30/91 gb    Do assume FMOVE.L emulated.;05/30/91 gb    Don't assume FMOVE.L emulated.;05/23/91 bill  gb's fixes for acos, asin, & %fatan2;05/20/91 gb    Short-floats more-or-less work, modulo some "complex" cases.;01/15/91 alice add fixnum-decode-float and make-float-from-fixnums;---------------- 2.0a5 d83;11/28/90 alice byte-position allow 0 size;09/27/90 bill  Akira KURIHARA's (Newton's) isqrt;04/02/90  gz   write-a-random-state -> print-object.;03/20/90  gz   Change %fatan2 and atan as per X3J13/IEEE-ATAN-BRANCH-CUT:SPLIT.  Make;               it cons less while at it.;               atemp0 -> atemp1 in ABS.;03/01/90  gz   Split off %%scale-float, so don't have to cons a float just to;               scale it.;12-Nov-89 Mly  Important optimisation: speed up /= by 40%.  Use *write-istruct-alist*;10/30/89 bill  Rename pr-%print-random-state to write-a-random-state and add;               stream arg;10/03/89  gz   Remove assumption that bignums are less than 32k.;05/07/89 gb    allocvect,reservevect calls pass subtype in arg_y.;04/19/89 gz    Coerce to complex fns.;04/07/89 gb  $sp8 -> $sp.;4/4/89    gz   $narithtemps -> $xfp0. Moved lap macros to lapmacros.;03/08/89  gz   [integer]-decode-float, float-precision, scale-float, random,;               gcd, abs, boole et. al.;               No more %fexpt. Moved store_float to lapmacros.;03/03/89  gz   Bytefield functions. Made byte not cons for fixnum fields.;02/12/89  gz   Added %copy-float, float, complex, float-sign, random-state-p, make-random-state.;               Flushed real-arg.  Do float stuff inline.;01/03/89  gz   #C;11/18/88  gz   Lapified LCM, made (LCM) => 1 instead of error.; 9/02/88  gz   Added number-arg, real-arg, logcount;               dynamic extent &rest in /=.; 8/27/88  gz   random state printing.  No more hitypes!; 8/15/88  gz   added float-digits, float-radix.; 7/30/87  gb   sneak /= past defun.; 7/24/87  gz   fix in complex sqrt.; 7/12/87  gb   Provide thyself; some stuff to sysutils.; 6/17/87  gb   1+, 1- : moved to level-2.; 5/17/87  gz   removed defconstants (in kernel now). Fix in %fatanh.; 3/27/87  gz   avoid recursive &rest arg consing in min, max, /=.; 03/02/87 gz   Use defconstant for constants, compute values at compile time,;               move to top so can use them within.  Added real rationalize.; 01/18/87 gz   Added byte-field fns. %apply -> apply. Added fake;               ffloor, fceiling, ftruncate, fround, rational, rationalize.; 01/29/87 gz   %put -> put; GZ, 27-Jan-87 Removed uses of type-of; GZ, 4-Jan-87  Removed fixnump, integerp, numberp, floatp, complex.;               Made half-pi compile-time only.; GZ, 1-Sep-86  Added LCM, made stuff use ash now that it works for bignums,;               use define-constant for constants.; GZ, 27-Jul-86	Added transcendental fns, pi (Chapter 12.5 of CLtL).;               Made type predicates return t/nil.;               changed defconstants to home-baked defconst to get around;               cfasl limitation.; GZ, 29-May-86 Removed stuff in kernel now.; GZ, 26-May-86 Added %put of version so can tell if loaded; GZ, 3-May-86  New for lisp 4.16; GZ, 27-Mar-86 New(in-package :ccl)(eval-when (:execute :compile-toplevel)  (require "SANETRAPS")  (require 'lapmacros)  #| ; in lispequ  (defconstant $Num1Dfloat 0)  (defconstant $Num1Int 2)  (defconstant $Num1Sfloat 4)  (defconstant $Num1Ratio 6)  (defconstant $Num1CR 8)  (defconstant $Num1CF 10)  (defconstant $Num1CS 12) |#  (declaim (inline %temp-float-binop %temp-float %temp-float-one-arg))  (defun %temp-float-binop (address tempfloat  arg_y arg_z)    (%primitive $sp-tempFPbinaryop :atemp0 address :arg_x tempfloat :arg_y arg_y :arg_z arg_z :acc))    (defmacro %temp-float-binop-subprim (sp tempfloat arg_y arg_z)    `(lap-inline (,tempfloat ,arg_y ,arg_z)       (lea (a5 ,sp) atemp0)       (jsr_subprim $sp-tempFPbinaryop)))  (defun %temp-float-one-arg (address tempfloat arg)    (%primitive $sp-tempFPunaryop :atemp0 address :arg_y tempfloat :arg_z arg :acc))  (defmacro %temp-dfloat-result-p ()     ; Will return NIL unless called magically enough.    `(%primitive $sp-tempdfloatresultp :acc)) ; Coerce arg to type float, using "temp" if a double-float needs to be consed.  (declaim (inline %temp-float))  (defun %temp-float (temp arg)    (%primitive $sp-tempfloat :arg_y temp :arg_z arg :acc)))(defun parse-float (str len off)  ; we cant assume this really is a float but dont call with eg s1 or e1  (let ((integer 0)(expt 0)(sign 0)(done 0)(digits 0) point-pos type)     (setq integer          (do ((n off (1+ n))               (first t nil)               (maxn  (+ off len)))              ((>= n maxn) integer)            (let ((c (%schar str n)))              (cond ((eq c #\.)                     (setq point-pos digits))                    ((and first (eq c #\+)))                    ((and first (eq c #\-))                     (setq sign -1))                    ((memq c '(#\s #\S))                     (setq type 'short-float)                     (return integer))                    ((memq c '(#\d #\f #\l  #\D #\F #\L))                     (setq type 'double-float)                     (return integer))                    ((memq c '(#\e #\E))                     (return integer))                    ((setq c (digit-char-p c))                     (setq digits (1+ digits))                     (setq integer (+ c (* 10 integer))))                                      (t (return-from parse-float nil)))              (setq done (1+ done)))))    (when point-pos      (setq expt  (- point-pos digits)))    (when (null type)      (setq type *read-default-float-format*))    (when (> len done)      (let ((eexp nil) (esign 1) c)        (do ((n (+ off done 1) (1+ n))             (first t nil))            ((>= n (+ off len)))          (setq c (%schar str n))          (cond ((and first (or (eq c #\+)(eq c #\-)))                 (when (eq c #\-)(setq esign -1)))                ((setq c (digit-char-p c))                 (setq eexp (+ c (* (or eexp 0) 10))))                (t (return-from parse-float nil))))        (when (not eexp)(return-from parse-float nil))        (setq expt (+ expt (* esign eexp)))))    (fide sign integer expt (eq type 'short-float))));; an interesting test case: 1.448997445238699;; The correct result is 6525704354437805 x 2^-52;; Incorrect is          6525704354437806 x 2^-52;; (from Will Clinger, "How to Read Floating Point Numbers Accurately",;;  ACM SIGPLAN'90 Conference on Programming Language Design and Implementation");; Doug Curries numbers 214748.3646, 1073741823/5000;; Sane read losers;; 15871904747836473438871.0e-8;; 3123927307537977993905.0-13;; 17209940865514936528.0e-6;; "13.60447536e132" => adds some gratuitous drech;; "94824331561426550.889e182";; "1166694.64175277e-150" => 1.1666946417527701E-144;; "3109973217844.55680988601e-173";; "817332.e-184" => 8.173320000000001E-179;; "2695.13e-180" => 2.6951300000000002E-177;; "89.85345789e-183" => 8.985345789000001E-182;; "0864813880.29e140" => 8.648138802899999E+148;; "5221.e-193" => 5.2209999999999995E-190;; "7.15628e-175" => 7.156280000000001E-175(defparameter float-powers-of-5  nil)(defparameter integer-powers-of-5 nil)(defun 5-to-e (e)  (declare (fixnum e)(optimize (speed 3)(safety 0)))  (if (> e 335)    (* (5-to-e 335)(5-to-e (- e 335))) ; for the dude who types 200 digits and e-500    (if (< e 12)      (svref integer-powers-of-5 e)      (multiple-value-bind (q r) (truncate e 12) ; was floor        (declare (fixnum q r))                (if (eql r 0)          (svref integer-powers-of-5 (%i+ q 11))          (* (svref integer-powers-of-5 r)             (svref integer-powers-of-5 (%i+ q 11))))))))(defun float-5-to-e (e)  (if (> e 22)  ; shouldnt happen    (expt 5.0 e)    (svref float-powers-of-5 e)))(defparameter a-short-float nil)(defun fide #|float-integer-with-decimal-exponent|# (sign integer power-of-10 &optional short)  ;; take care of the zero case  (when (zerop integer)    (return-from fide ;float-integer-with-decimal-exponent      (if short        (if (minusp sign) -0.0s0 0.0s0)        (if (minusp sign) -0.0 0.0))))  (let ((abs-power (abs power-of-10))        (integer-length (integer-length integer)))    ;; this doesn't work for the above example, so arithmetic must be done wrong    ;; This does work if set FPCR precision to double    ;; now see if the conversion can be done simply:    ;; if both the integer and the power of 10 can be floated exactly, then    ;; correct rounding can be done by the multiply or divide    (when (or;short           (and (<= integer-length  (if short 17 53))   ; if short it should be floatable                ;; (integer-length (expt 5 23)) => 52                (< abs-power  (if short 5 23)))) ; we mean < 23 not <=      ;; if you care about consing, this could be done in assembly language or whatever,      ;; since all integers fit in 53 bits      (return-from fide ;float-integer-with-decimal-exponent        (let* ((signed-integer (prog1 (if (minusp sign) (- integer) integer)))               (float (float signed-integer (if short 0.0s0 0.0)))               (10-to-power (scale-float (float-5-to-e abs-power) abs-power)))          ; coerce to short-float does not whine about undeflow, but does re overflow          (when short (setq 10-to-power (coerce 10-to-power 'short-float)))          (if (zerop abs-power)            float            (if (minusp power-of-10)              (/ float  10-to-power)              (* float  10-to-power))))))    (try-harder sign integer power-of-10 short)))(defun try-harder (sign integer power-of-10 short)  (flet ((ovf (&optional under)           (if under             (cerror "Use float 0 instead." "Exponent underflow.")             (cerror "Use largest value instead." "Exponent overflow."))           (return-from try-harder             (if under               (if (minusp sign)                 (if short -0.0s0 -0.0d0)                 (if short 0.0s0 0.0d0))               (if (minusp sign)                 (if short most-negative-short-float most-negative-double-float)                 (if short most-positive-short-float most-positive-double-float))))))  (let* ((integer-length (integer-length integer)) new-int power-of-2)    (if (minusp power-of-10)      (progn         ; avoid creating enormous integers with 5-to-e only to error later        (when (< power-of-10 -335)          (let ((poo (+ (round integer-length 3.2) power-of-10)))            ; overestimate digits in integer            (when (< poo -335) (ovf t))            ; this case occurs if 600+ digits             (when (> poo 335)(ovf))))        (let* ((divisor (5-to-e (- power-of-10)))               ;; make sure we will have enough bits in the quotient               ;; (and a couple extra for rounding)               (shift-factor (+ (- (integer-length divisor) integer-length)                                (if short 28 60)))               (scaled-integer integer))          (if (plusp shift-factor)            (setq scaled-integer (ash integer shift-factor))            (setq divisor (ash divisor (- shift-factor))))          (multiple-value-bind (quotient remainder)(floor scaled-integer divisor)            (unless (zerop remainder) ; whats this - tells us there's junk below              (setq quotient (logior quotient 1)))            (setq new-int quotient)            (setq power-of-2  (- power-of-10 shift-factor)))))      (progn        (when (> power-of-10 335)(ovf))        (setq new-int (* integer (5-to-e power-of-10)))        (setq power-of-2 power-of-10)))    (float-and-scale-and-round sign new-int power-of-2 short))))(defun float-and-scale-and-round (sign integer power-of-2 short)  (let ((length (integer-length integer))        (lowbits 0)        (prec (if short 24 53))        (ep (if short 28 60)))    (when (<= length prec)      ;; float can be done exactly, so do it the easy way      (return-from float-and-scale-and-round        (scale-float (float (if (minusp sign) (- integer) integer) (if short a-short-float))                     power-of-2)))        (let* ((exponent (+ length power-of-2))           ; short float biased by 30 rather than 14 for reasons too complicated           ; to explain having to do with the format allowing easy conversion to IEEE single float           (biased-exponent (+ exponent (if short 30 1022)))           (sticky-residue nil))      (cond        ((and short (< biased-exponent 16))        ; there is one number that becomes zero without telling you.        ; Although we are friendly here, we can over/underflow above without friendliness        (cerror         "Use short float 0 instead" "Exponent under flow")        (return-from float-and-scale-and-round (if (zerop sign) 0.0s0 -0.0s0)))       ((<= biased-exponent 0)        ;; denormalize the number        (setf sticky-residue (not (zerop (ldb integer (byte (- 1 biased-exponent) 0)))))        (setf integer (ash integer (- biased-exponent 1)))        (setf biased-exponent 0)))      (let ((lowest (min ep length)))        (when (and (> length ep)(not (zerop (ldb (byte (- length ep) 0) integer))))          (setq integer (logior integer (ash 1 (- length ep)))))        ; somewhere between 1 and (- ep prec) bits        (setq lowbits (ash (ldb (byte (- lowest prec) (- length lowest)) integer) (- ep lowest))))      (let* ((significand (ldb (byte (1- prec) (- length prec)) integer)))        ;(break)        (when (and (not (zerop (ldb (byte 1 (- length (1+ prec))) integer)))   ; round bit                   (or sticky-residue (oddp significand)                       (not (zerop (ldb (byte (- ep prec 1) 0) lowbits)))))          ;; round up          (setf significand (ldb (byte (1- prec) 0) (+ significand 1)))          (when (zerop significand)            (incf biased-exponent)))        (cond ((and (zerop biased-exponent)                    (zerop significand))               (cerror "Use a zero result" "Complete loss of significance in floating point read"))              ((>= biased-exponent (if short (+ 30 18) 2047))               (cond (short                      (cerror "Use largest magnitude short float" "Exponent overflow")                      (return-from float-and-scale-and-round                        (if (zerop sign) most-positive-short-float                            most-negative-short-float)))                     (t                      (cerror "Use a floating infinity result" "Exponent overflow")                      (setf significand 0)                      (setq biased-exponent 2047)))))        (values         (if short            (make-short-float-from-fixnums (ldb (byte 23 0) significand)                                          biased-exponent                                          sign)           (make-float-from-fixnums (ldb (byte 24 28) significand)                                    (ldb (byte 28 0) significand)                                    biased-exponent                                    sign))         lowbits))))); exp is biased by 30 so must be masked ; format is; eeeeemmmmmmmmmmmmmmmmmmmmmmmsttt(defun make-short-float-from-fixnums (sig exp sign)  (setq sig (require-type sig 'fixnum))  (setq exp (require-type exp 'fixnum))  (setq sign (require-type sign 'fixnum))  (lap-inline ()    (:variable sig exp sign)    (move.l ($ $t_sfloat) acc)    (move.l (varg sign) dtemp2)    (bge @foo)    (or.l ($ #x8)  acc)  ; sign    @foo    ;(dc.w #_debugger)    (move.l (varg exp) dtemp2)    ;(sub.l ($ #x10) dtemp2)    (and.l ($ #xf8) dtemp2)  ; keep 5 bits    (ror.l 8 dtemp2)  ; left 24 = right 8    ;(ror.l 1 dtemp2)    (or.l dtemp2 acc)    (move.l (varg sig) dtemp2)    (and.l ($ #x3fffff8) dtemp2)  ; keep 23 bits    (rol.l 1 dtemp2)    (or.l dtemp2 acc)))(defparameter a-short-float 1.0s0)(defmethod print-object ((rs random-state) stream)  ;;Besides #.grossness, this is buggy because cl:random-state  ;;is not allowed to have a function definition...  (format stream "#.(~S ~S ~S)"   ;>> #.GAG!!!          'random-state          (%ilsr (%i- 16 $fixnumshift) (%svref rs 1))          (%ilsr (%i- 16 $fixnumshift) (%svref rs 2))))(defun float (number &optional other)  (let (type)    (if (or (null other)(progn (setq type (%type-of other)) (eq type 'double-float)))      (%primitive $sp-DFloatZ :arg_z number :arg_z)      (case type        (short-float         (%primitive $sp-SFloatZ :arg_z number :arg_z))        (t (float number (require-type other 'float)))))))(defun complex (realpart &optional imagpart)  (lap-inline ()    (:variable realpart imagpart)    (preserve_regs dsave0)    (move.l arg_z dsave0)    (move.l arg_y acc)    (jsr_subprim $sp-real1chk)    (exg acc dsave0)                    ; dsave0 = realpart da=numtype, acc = imagpart    (if# (eq nilreg acc) (move.l '0 acc))    (if# (eq (tst.w da))      (jsr_subprim $sp-dfloatZ)      elseif# (eq (jsr_subprim $sp-real1chk))      (exg dsave0 acc)      (jsr_subprim $sp-dfloatZ)      (exg dsave0 acc)      elseif# (eq (cmp.b ($ $Num1Sfloat) da))      (exg dsave0 acc)      (jsr_subprim $sp-sfloatZ)      (exg dsave0 acc))    (move.l dsave0 arg_y)    (restore_regs)    (if# (eq (tst.l arg_z))      (move.l arg_y acc)     else#      (jsr_subprim $sp-MakeComplex))));(coerce num 'complex).(defun coerce-to-complex (num)  ;(if (complexp num) num (complex num))  (lap-inline (num)    (if# (eq (jsr_subprim $sp-Num1Chk))      (move.l acc arg_y)      (move.l '0.0 acc)      (jsr_subprim $sp-MakeComplex)      elseif# (eq (cmp.b ($ $num1sfloat) da))      (move.l acc arg_y)      (move.l '0.0s0 arg_z)      (jsr_subprim $sp-MakeComplex))));(coerce num '(complex float))(defun coerce-to-complex-float (tags num)  (lap-inline ()    (:variable num tags)    (jsr_subprim $sp-Num1Chk)    (move.l (varg tags) db)    (getint db)    (cmp.w ($ $Num1CR) da)    (if# ne      (if# (eq (cmp.b ($ (ash 1 $t_sfloat)) db))        (cmp.b ($ $Num1CF) da)        elseif# (eq (cmp.b ($ (ash 1 $t_dfloat)) db))        (cmp.b ($ $Num1CS) da)))    (if# eq                           ; (complex rational) or (complex wrong-float-type)      (preserve_regs dsave0)      (move.l acc atemp0)      (add.w ($ $v_data) atemp0)      (move.l (@+ atemp0) acc)      (move.l (atemp0) dsave0)      (if# (eq (cmp.b ($ (logior (ash 1 $t_sfloat) (ash 1 $t_dfloat))) db))        (jsr_subprim $sp-floatz)        (exg dsave0 acc)        (jsr_subprim $sp-floatz)        elseif# (eq (cmp.b ($ (ash 1 $t_dfloat)) db))        (jsr_subprim $sp-dfloatZ)        (exg dsave0 acc)        (jsr_subprim $sp-dfloatZ)        else#        (jsr_subprim $sp-sfloatZ)        (exg dsave0 acc)        (jsr_subprim $sp-sfloatZ))      (move.l dsave0 arg_y)      (restore_regs)      (jsr_subprim $sp-makeComplex)      elseif# (le (cmp.w ($ $Num1CR) da))                      ; real      (if# (eq (cmp.b ($ (logior (ash 1 $t_sfloat) (ash 1 $t_dfloat))) db))        (jsr_subprim $sp-floatz)        elseif# (eq (cmp.b ($ (ash 1 $t_dfloat)) db))        (jsr_subprim $sp-dfloatZ)        else# (jsr_subprim $sp-sfloatZ))      (move.l acc arg_y)      (if# (ne (dtagp acc $t_sfloat))        (move.l '0.0s0 acc)        else#        (move.l '0.0 acc))    (jsr_subprim $sp-makecomplex))));(coerce num '(complex <type>))(defun coerce-to-complex-type (num type)  (if (complexp num)    (if (and (typep (complex.real num) type) (typep (complex.imag num) type))      num      (complex (coerce (complex.real num) type)               (coerce (complex.imag num) type)))    (complex (coerce num type))))(defun %copy-float (float)  ;Returns a freshly consed float.  float can also be a macptr.  (lap-inline ()    (:variable float)    (move.l arg_z atemp0)    (if# (ne (ttagp ($ $t_dfloat) arg_z da))      (jsr_subprim $sp-macptrptr)      else#      (sub.w ($ $t_dfloat) atemp0))    (move.l (@+ atemp0) arg_y)    (move.l (atemp0) arg_z)    (jsr_subprim $sp-makefloat)))(defun float-radix (float)  (require-type float 'float)  2)(defun float-digits (float)  (if (typep (require-type float 'float) 'short-float)    24    53))  (defun float-sign (float1 &optional float2)  (lap-inline ()    (:variable float1 float2)    (if# (eq (dtagp arg_y $t_dfloat $t_sfloat)) (wtaerr arg_y 'float))    (dtagp arg_y $t_sfloat)    (sne da)    (move.l arg_y atemp1)    (move.l arg_z atemp0)    (cmp.l nilreg arg_z)    (sne dx)    (if# ne      (if# (eq (dtagp arg_z $t_dfloat $t_sfloat)) (wtaerr arg_y 'float))      (dtagp arg_z $t_sfloat)      (sne db)      (if# eq        (getflt atemp0 arg_y arg_z))    ; Else arg_z = float2.0s0      else#      (if# (eq (move.b da db))        (move.l ($ #x3FF00000) arg_y)        (move.l ($ 0) arg_z)        else#        (move.l '1.0s0 arg_z)))    (if# (eq (tst.b da))                ; float1 is a double      (if# (mi (tst.w (atemp1 $floathi)))        @mi        (tst.b db)        (if# eq                         ; then float2 is a double          (bset ($ 31) arg_y)          (bne @same)          @cons          (jsr_subprim $sp-makefloat)          (bra @exit)          else#          (bset ($ 3) arg_z))        else#                           ; float1 a non-negative double        @pl        (tst.b db)        (if# eq          (bclr ($ 31) arg_y)          (bne @cons)          @same          (if# (eq atemp0 nilreg)            (move.l ($ 0) arg_z)            (bra @cons))          (move.l atemp0 acc)))      else#      (bif (ne (progn (move.l atemp1 da) (btst ($ 3) da))) @mi)      (bra @pl))    @exit))(defun scale-float (float integer)  (lap-inline ((%temp-dfloat-result-p) (require-type float 'float) integer)    (if# (or (ne (ttagp ($ $t_fixnum) arg_z da))   ;Strictly speaking bignums should signal             (ne (progn (move.l arg_z da)          ; over/underflow, not wta, but...                        (getint da)                        (move.w da db)                        (ext.l db)                        (cmp.l da db))))      (wtaerr arg_z '(signed-byte 16)))    (if# (eq (dtagp arg_y $t_sfloat))      (move.l arg_y atemp0)      (store_float atemp0 fp1)      (jsr #'%%scale-float)      (move.l arg_x arg_z)      (jsr_subprim $sp-cstoreFP1D)      else#      (move.l arg_y arg_z)      (jsr_subprim $sp-SFloatFP1)      (jsr #'%%scale-float)      (jsr_subprim $sp-FP1SFloat))));FP1 = the float, da.w = scale amount;Returns with FP1 = answer.  Preserves atemp0, arg regs..(defun %%scale-float (&lap 0)  (lap-inline ()    (if# (ne (tst.b (a5 $fp68881flag)))      (FSCALE.W da fp1)      else#      (spush atemp0)      (move.l ($ 20) acc)      (jsr_subprim $sp-mknlisparea)      (lea (sp 14) atemp1)      (move.w da (atemp1))      (move.l atemp1 (-@ atemp1))      (lea (a5 (+ $xfp0 10)) atemp0)      (move.l atemp0 (-@ atemp1))      (move.w ($ _fscalbx) (-@ atemp1))      (jsr_subprim $sp-strap)      (dc.w #xa9eb)      (spop atemp0))))(defun integer-decode-float (float)  (setq float (require-type float 'float))  (let ((significand nil)        (exponent nil)        (sign  1))     (lap-inline (float)      (:variable significand exponent sign)      (if# (ne (dtagp arg_z $t_sfloat))        (if# (ne (btst ($ 3) arg_z))          (move.l '-1 (varg sign)))        (jsr #'%%decode-sfloat)        (if# ne          (sub db da)          (bset ($ 23) arg_y)          (if# (ne (cmp.w ($ 24) db))            (move.l arg_z arg_y)            (and.l ($ (1- (ash 1 23))) arg_y)))        (ext.l da)        (mkint da)        (move.l da (varg exponent))        (mkint arg_y)        (move.l arg_y (varg significand))        else#        (move.l arg_z atemp0)        (if# (mi (tst.w (atemp0 $floathi))) (move.l '-1 (varg sign)))        (jsr #'%%decode-dfloat)        (if# ne          (sub db da)          (bset ($ 20) arg_y)          (if# (ne (cmp.w ($ 53) db))            (getflt atemp0 arg_y arg_z)            (and.l ($ #xFFFFF) arg_y)))        (ext.l da)        (mkint da)        (move.l da (varg Exponent))        (begin_csarea)        (movem.l #(arg_y arg_z) -@sp)        (begin_csarea)        (move.l ($ 8) dtemp0)        (move.l ($ $v_bignum) arg_y)        (jsr_subprim $sp-reservevect)        (spop_csarea)        (movem.l sp@+ #(arg_y arg_z))        (spop_csarea)        (lea (atemp0 (+ $v_data 8)) atemp0)        (move.l arg_z (-@ atemp0))        (move.l arg_y (-@ atemp0))        (move.l ($ (1- 4)) acc)        (prog#         (tst.w (@+ atemp0))         (dbne acc (top#)))        (sub.w ($ 2) atemp0)        (if# mi          (clr.w (-@ atemp0))          (add.w ($ 1) acc))        (add.w ($ 1) acc)        (jsr_subprim $sp-mkpermint)        (move.l acc (varg Significand))))        (values significand exponent sign))); decompose a double-float into fixnum size pieces; returns 4 values; hi is high 24 bits of mantissa (with the implied 1 in bit 25 if appropriate); lo is low 28 bits of mantissa  (hi and lo are both right justified); exp is 11 bit exponent (the bits as they are - not unbiased; i.e. exp is >= 0); sign is 1 or -1 (defun fixnum-decode-float (float)  (setq float (require-type float 'double-float))  (let (hi lo exp (sign 1))    (lap-inline ()      (:variable float hi lo exp sign)      (move.l (varg float) atemp0)      (sub.l ($ $t_dfloat) atemp0)      (move.l (atemp0) dtemp1)      (bge @foo)      (move.l '-1 (varg sign))      @foo      (rol.l ($ 8) dtemp1)      (rol.l ($ 7) dtemp1) ; right 20 -3 is 17 - or rotate left 15      (and.l ($ #x3ff8) dtemp1)  ; 11 bits      (move.l dtemp1 (varg exp))      (move.l atemp0@+ dtemp1)   ; want 20 lo bits + implied 1      ;(or.l ($ #x100000) dtemp1)      (and.l ($ #xfffff) dtemp1)      (lsl.l ($ 7) dtemp1)   ; 4 + fixnum      (move.l (atemp0) dtemp2)  ; want his hi 4 bits      (rol.l 7 dtemp2)       ; right 28 - fixnum = 25  or rotate left 7      (and.l ($ #x78) dtemp2)      (or.l dtemp2 dtemp1)      (move.l dtemp1 (varg hi))      (move.l (atemp0) dtemp1)      (lsl.l 3 dtemp1)      (and.l ($ #x7ffffff8) dtemp1) ; lo 28 bits      (move.l dtemp1 (varg lo)))    (values (if (eq 0 exp) hi (logior hi #x1000000))            lo exp sign))); make a float from hi - high 24 bits mantissa (ignore implied higher bit);                   lo -  low 28 bits mantissa;                   exp  - take low 11 bits;                   sign - sign(sign) => result; hi result - 1 bit sign: 11 bits exp: 20 hi bits of hi arg; lo result - 4 lo bits of hi arg: 28 lo bits of lo arg; no error checks, no tweaks, no nuthin(defun make-float-from-fixnums (hi lo exp sign)  (setq hi (require-type hi 'fixnum))  (setq lo (require-type lo 'fixnum))  (setq exp (require-type exp 'fixnum))  (setq sign (require-type sign 'fixnum))  (lap-inline ()    (:variable hi lo exp sign)    (move.l ($ 0) arg_y)    (move.l (varg sign) dtemp2)    (bge @foo)    (move.l ($ #x80000000) arg_y)  ; sign    @foo    (move.l (varg exp) dtemp2)    (and.l ($ #x3ff8) dtemp2)  ; keep 11 bits    (ror.l 8 dtemp2)    (ror.l 7 dtemp2) ; left 20 - fixnum = 17; or right 15    (or.l dtemp2 arg_y)    (move.l (varg hi) dtemp2)    (lsr.l 7 dtemp2)    (and.l ($ #xfffff) dtemp2)    (or.l dtemp2 arg_y)  ; first part done    (move.l (varg hi) arg_z)    (and.l ($ #x78) arg_z)    (ror.l 7 arg_z)      ; left 28 - fixnum = 25; or right 7        (move.l (varg lo) dtemp2)    (lsr.l 3 dtemp2)    (and.l ($ #xfffffff) dtemp2)    (or.l dtemp2 arg_z)    (jsr_subprim $sp-makefloat)))(defun decode-float (float)  (setq float (require-type float 'float))  (let ((significand nil)        (exponent nil)        (sign nil))    (lap-inline (float)      (:variable significand exponent sign)      (if# (ne (dtagp arg_z $t_sfloat))        (if# (ne (btst ($ 3) arg_z))          (move.l '-1.0s0 (varg sign))          else#          (move.l '1.0s0 (varg sign)))        (jsr #'%%decode-sfloat)         (if# ne (lsl.l ($ 4) arg_y) (or.l '0.5s0 arg_y) else# (move.l '0.0s0 arg_y))        (move.l arg_y (varg significand))        (ext.l da)        (mkint da)        (move.l da (varg exponent))        else#        (move.l arg_z atemp0)        (move.l '1.0 (varg sign))        (if# (mi (tst.w (atemp0 $floathi))) (move.l '-1.0 (varg sign)))        (jsr #'%%decode-dfloat)        (if# ne (or.l ($ #x3FE00000) arg_y))   ;Scale significand if non-zero        (ext.l da)        (mkint da)        (move.l da (varg exponent))        (jsr_subprim $sp-makefloat)        (move.l acc (varg Significand))))    (values significand exponent sign)))(defun float-precision (float)  (lap-inline ((require-type float 'float))    (if# (ne (dtagp arg_z $t_sfloat))      (jsr #'%%decode-sfloat)      else#      (move.l acc atemp0)      (jsr #'%%decode-dfloat))    (move.l db acc)    (mkint acc)));Take double float in atemp0 and return with:;arg_y/arg_z=normalized significand,da=exponent,db=precision;Z flag set if ±0.0(defun %%decode-dfloat (&lap 0)  (old-lap   (move.l ($ (1- 53)) db)   (getflt atemp0 arg_y arg_z)   (swap arg_y)   (move.w arg_y da)   (and.w ($ #xF) arg_y)   (swap arg_y)   (and.w ($ #x7FF0) da)   (lsr.w 4 da)   (if# eq     (sub.w ($ 1) db)     (prog#      (lsl.l ($ 1) arg_z)      (roxl.l ($ 1) arg_y)      (bclr ($ 20) arg_y)      (dbne db (top#)))     (move.l ($ -51) da)     (add.w db da))   (sub.w ($ #x3FE) da)   (add.w ($ 1) db)   (if# eq (moveq 0 da))   (rts))); Take short float in arg_z and return with; arg_y = normalized significand,da=exponent,db=precision, arg_z = unboxed "single" float.; Z flag set if ± 0(defun %%decode-sfloat (&lap 0)  (old-lap;   (spush '"%%decode-sfloat");   (add.l ($ (1- $v_data)) @sp);   (dc.w _DebugStr)   (jsr_subprim $sp-unboxSF)            ; preserves all but acc   (move.l ($ (1- 24)) db)   (moveq 0 da)   (move.l arg_z arg_y)   (swap arg_y)   (move.w arg_y da)   (and.w ($ #x7f) arg_y)   (swap arg_y)   (lsr.w ($ 7) da)   (and.w ($ #xff) da)   (if# eq     (sub.w ($ 1) db)     (prog#      (add.l arg_y arg_y)      (bclr ($ 23) arg_y)      (dbne db (top#)))     (move.l ($ -22) da)     (add.w db da))   (sub.w ($ #x7e) da)   (add.w ($ 1) db)   (if# eq (moveq 0 da))   (rts)))(defun number-arg (arg)  (if (numberp arg) arg (%badarg arg 'number)))(set-dispatch-macro-character #\# #\C  #'(lambda (stream char arg &aux form)      (when arg (unless *read-suppress* (%err-disp $xrdnoarg char)))      (setq form (read stream t nil t))      (unless *read-suppress* (apply #'complex form))))(defun conjugate (number)   (if (complexp number)      (complex (%svref number 0) (- (%svref number 1)))     (if (numberp number) number         (report-bad-arg number 'number))))(defun numerator (rational)  (if (ratiop rational) (%svref rational 0)    (if (integerp rational) rational      (report-bad-arg rational 'rational))))(defun denominator (rational)  (if (ratiop rational) (%svref rational 1)    (if (integerp rational) 1      (report-bad-arg rational 'rational))))(defun abs (number)  (old-lap    (lfunlk)    abs1    (if# (eq (ttag acc da))      (if# (mi (tst.l acc))        (if# (vs (neg.l acc)) (jmp_subprim $sp-xfxovf1)))      @handy-rts (rts))    (if# (eq (cmp.b ($ $t_sfloat) da))      (bclr ($ 3) acc)      (rts))    (move.l acc atemp0)    (if# (eq (sub.w ($ $t_dfloat) da))      (sub.w ($ $t_dfloat) atemp0)      (bif (pl (move.l (@+ atemp0) arg_y)) @handy-rts)      (bclr 31 arg_y)      (spush @atemp0)      (spush arg_y)      (fmove.d @sp fp1)      (add.w ($ 8) sp)      (jmp_subprim $sp-FP1DFloat))    (if# (eq (sub.w ($ (- $t_vector $t_dfloat)) da))      (vsubtype atemp0 da)      (if# (eq (cmp.b ($ $v_bignum) da))        (bif (pl (tst.w (atemp0 $v_data))) @handy-rts)        (jmp_subprim $sp-negBg))      (if# (eq (cmp.b ($ $v_ratio) da))        (move.l (svref atemp0 ratio.num) acc)        (vpush atemp0)        (bsr abs1)        (vpop atemp0)        (if# (ne (svref atemp0 ratio.num) acc)          (move.l acc arg_y)          (move.l (svref atemp0 ratio.den) arg_z)          (jmp_subprim $sp-MakeRatio))        (move.l atemp0 acc)        (rts))      (if# (eq (cmp.b ($ $v_complex) da))        (add.w ($ $v_data) atemp0)        (move.l (@+ atemp0) arg_z)        (if# (eq (ttagp ($ $t_dfloat) arg_z da))          (move.l arg_z atemp1)          (store_float atemp1 FP1)          (move.l (atemp0) atemp1)          (store_float atemp1 FP3)          (FMUL.x FP1 FP1)          (FMUL.x FP3 FP3)          (FADD.x FP3 FP1)         else#          (vpush (atemp0))          (move.l arg_z arg_y)          (jsr_subprim $sp-times2)          (vpop arg_y)          (vpush arg_z)          (move.l arg_y arg_z)          (jsr_subprim $sp-times2)          (vpop arg_y)          (jsr_subprim $sp-add2acc)          (jsr_subprim $sp-rat2xf))        (FSQRT.x FP1)        (jmp_subprim $sp-FP1DFloat)))    (spush vsp)                         ; for backtrace    (wtaerr acc 'number)))(%fhave '/= (qlfun /= (number &rest more-numbers)               (declare (dynamic-extent more-numbers))               (if (null more-numbers)                   (progn (unless (numberp number) (report-bad-arg number 'number))                          t)                 (block /=                   (do* ((number number (%car tail1))                         (tail1 more-numbers (%cdr tail1)))                        ((null tail1)                         t)                     (do ((tail2 tail1 (%cdr tail2)))                         ((null tail2))                       (when (= number (%car tail2))                         (return-from /= nil))))))))(defun gcd (&lap &rest numbers)  (old-lap   (if# (eq (sub.w ($ 8) nargs))     gcd2     (spush vsp)     (bif (eq (tst.l arg_y)) IntAbs)     (exg arg_y arg_z)     (bif (eq (tst.l arg_y)) IntAbs)     (jsr_subprim $sp-bigintarg1)     (move.l atemp0 atemp1)     (move.l arg_y arg_z)     (jsr_subprim $sp-bigintarg2)     (vsize atemp0 dtemp0)     (vsize atemp1 dtemp1)     (add.l dtemp1 dtemp0)     (add.l ($ 4) dtemp0)     (preserve_regs #(asave0 asave1))     (move.l atemp0 asave0)     (move.l atemp1 asave1)     (move.l ($ $v_bignum) arg_y)     (jsr_subprim $sp-reservevect)     (add.w ($ (+ $v_data 2)) atemp0)     (getvect asave0 dtemp0)     (lsr.l ($ 1) dtemp0)     (move.l atemp0 atemp1)     (move.l dtemp0 dtemp1)     (bmovdown.w asave0 atemp1 dtemp1)     (add.w ($ 2) atemp1)     (getvect asave1 dtemp1)     (lsr.l ($ 1) dtemp1)     (move.l atemp1 asave0)     (move.l dtemp1 da)     (bmovdown.w asave1 asave0 da)     (restore_regs)     (jsr_subprim $sp-nBgGcd)     (jsr_subprim $sp-MkPermInt)     (lfret))   (add.w ($ 8) nargs)   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (move.l (vsp) acc)               ;One arg case       IntAbs       (jsr_subprim $sp-bigintarg1)       (tst.w (atemp0 $v_data))       (if# mi (jsr_subprim $sp-negBg))       (lfret))     (move.l '0 acc)                    ;No arg case     (lfret))   (preserve_regs #(asave0 dsave0)) (equate _vtop 8)   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w _vtop) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (bsr gcd2)    (until# (eq (sub.l '1 dsave0))))   (restore_regs)   (lfret)))(defun lcm (&lap &rest numbers)  (old-lap   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (ccall gcd (vsp))      else#       (move.l (fixnum 1) acc))     (lfret))   (preserve_regs #(asave0 dsave0 dsave1 dsave2))   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w 16) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (move.l arg_y dsave1)    (move.l arg_z dsave2)    (jsr_subprim $sp-times2)    (ccall abs acc)    (exg dsave2 acc)    (ccall gcd dsave1 acc)    (if# (eq (move.l dsave2 arg_y))      (move.l arg_y acc)     else#      (ccall / arg_y acc))    (sub.l (fixnum 1) dsave0)    (until# eq))   (restore_regs)   (lfret)))#|(defun rationalize (number)  (cond ((not (floatp number)) (rational number))        ((minusp number) (- (rationalize (- number))))        ((zerop number) 0)        (t (let ((onum 1) (oden 0) num (den 1) rem)             (multiple-value-setq (num rem) (truncate number))             (until (<= (abs (/ (- number (/ (float num) den)) number))                        single-float-epsilon)               (multiple-value-bind (q r) (truncate 1.0 rem)                 (setq rem (/ r rem))                 (let ((nnum (+ (* q num) onum)))                   (setq onum num num nnum))                 (let ((nden (+ (* q den) oden)))                   (setq oden den den nden))))             (/ num den)))));Rationalize failed. Input 1.9998229581607005 Rational 70903515/35454896 Float 1.9998229581607008; also gets overflow and underflow sometimes|#; Kalman's more better one(defun rationalize (number)  (if (floatp number)    (labels ((simpler-rational (less-predicate lonum loden hinum hiden                                               &aux (trunc (if (eql less-predicate #'<=)                                                             #'ceiling                                                             #'(lambda (n d) (1+ (floor n d)))))                                               (term (funcall trunc lonum loden)))               ;(pprint (list lonum loden hinum hiden))               (if (funcall less-predicate (* term hiden) hinum)                 (values term 1)                 (multiple-value-bind                    (num den)                   (simpler-rational less-predicate hiden (- hinum (* (1- term) hiden))                                     loden (- lonum (* (1- term) loden)))                   (values (+ den (* (1- term) num)) num)))))                                 (multiple-value-bind (fraction exponent sign) (integer-decode-float number)        (if (or (eq exponent -1074)(zerop (logand fraction (1- fraction))))          (rational number)          (if (minusp exponent)	    ;;less than 1            (let ((num (ash fraction 2))	          (den (ash 1 (- 2 exponent))))	      (multiple-value-bind                 (n d)                (simpler-rational (if (evenp fraction) #'<= #'<)                                  (- num 2) ;(if (zerop (logand fraction (1- fraction))) 1 2))                                  den  (+ num 2) den)	        (when (minusp sign)	          (setq n (- n)))	        (/ n d)))            ;;greater than 1            (ash (if (minusp number) (- fraction) fraction) exponent)))))    (rational number)))#|(defun testrat (&optional (n 1000))  (dotimes (i n)    (let* (( numerator (random (ash 1 63)))          (denominator (random (ash 1 63)))          (sign  (if (zerop (random 2)) 1 -1))          (trial (float (/ (* sign numerator) denominator)))          (rat (rationalize trial)))      (when (not (= (float rat) trial))        (error "Rationalize failed. Input ~s Rational ~s Float ~s" trial rat (float rat))))))|#(defun logcount (integer)  (lap-inline ()    (:variable integer)    (if# (eq (ttag acc da))      (asr.l ($ $fixnumshift) arg_z)     ; clears X flag      (if# (mi (move.l arg_z da)) (not.l da))      (move.l ($ 0) acc)      (move.l ($ 0) db)      (prog#       (addx.w db acc)       (lsr.l 1 da)       (until# eq))      (addx.w db acc)      (mkint acc)      else#      (move.l acc atemp0)      (if# (or (ne (sub.w ($ $t_vector) da))               (ne (vsubtypep ($ $v_bignum) atemp0 da)))        (wtaerr acc 'integer))      (move.l (fixnum 0) acc)      (move.l ($ 0) db)      (getvect atemp0 da)      (lea (atemp0 da.l) atemp1)      (lsr.l 1 da)                         ; clears X flag      (bif (pl (tst.w (atemp0))) @22)      (move.l ($ 16) db)      (sub.l ($ 1) acc)                    ; account for the sign bit      (bra @11)      (prog#       (add.l db acc)       @11 (sub.l ($ 1) da)       (move.w (-@ atemp1) dy)       (until# ne))      (sub.w ($ 1) dy)      (move.l ($ 0) db)      (bra @21)@20   (move.w (-@ atemp1) dy)      (prog#       (addx.l db acc)@21    (lsr.w 1 dy)       (until# eq))      (addx.l db acc)@22   (dbf da @20)      (mkint acc))))(defun logtest (integer1 integer2)  (old-lap   (if# (and (eq (ttagp ($ $t_fixnum) arg_y da))             (eq (ttagp ($ $t_fixnum) arg_z da)))     (and.l arg_y arg_z)     @retcc     (setpred ne da)     (lfret))   (preserve_regs #(asave0 asave1))   (jsr_subprim $sp-logbigargs)   (if# pl (move.l da db))   (jsr_subprim $sp-logreserv)   (prog#    (move.w (-@ asave0) dy)    (and.w (-@ asave1) dy)    (dbne da (top#))    (bne @ret)    (add.w ($ 1) da)    (sub.l ($ 1) da)    (bcc (top#)))   (moveq 0 da)   (bra @1)   @0 (tst.w (-@ asave1))   @1 (dbne db @0)      (bne @ret)      (add.w ($ 1) db)      (sub.l ($ 1) db)      (bcc @0)   (moveq 0 da)@ret   (restore_regs)   (bra @retcc)))(defun logeqv (&lap &rest nums)  (old-lap   (if# (eq (sub.w ($ 8) nargs))     logeqv2     (if# (and (eq (ttagp ($ $t_fixnum) arg_y da))               (eq (ttagp ($ $t_fixnum) arg_z da)))       (eor.l arg_y arg_z)       (not.l arg_z)       (sub.w ($ $typemask) arg_z)       (rts))     (preserve_regs #(asave0 asave1))     (jsr_subprim $sp-logbigargs)     (jsr_subprim $sp-logreserv)     (prog# (move.w (-@ asave0) dy) (not.w dy) (eor.w dy (-@ asave1)) (dbfl da (top#)))     (if# (mi (tst.w dy)) (dbfloop.l db (not.w (-@ asave1))))     (restore_regs)     (jmp_subprim $sp-logval))   (add.w ($ 8) nargs)   (klexpr)   (sub.w ($ 4) nargs)   (if# ls     (if# eq       (move.l (vsp) arg_z)            ;One arg case       (jsr_subprim $sp-req-integerZ)      else#       (move.l '-1 acc))                 ;No arg case     (lfret))   (preserve_regs #(asave0 dsave0)) (equate _vtop 8)   (move.l nargs dsave0)   (vunscale.l dsave0)   (lea (vsp nargs.w _vtop) asave0)   (move.l (asave0) arg_z)   (prog#    (move.l (-@ asave0) arg_y)    (bsr logeqv2)    (until# (eq (sub.l '1 dsave0))))   (restore_regs)   (lfret)))(defun lognand (integer1 integer2)  (lap-inline ()    (:variable integer1 integer2)    (if# (and (eq (ttagp ($ $t_fixnum) arg_y da))              (eq (ttagp ($ $t_fixnum) arg_z da)))      (and.l arg_y arg_z)      (not.l arg_z)      (sub.w ($ $typemask) arg_z)      else#      (preserve_regs #(asave0 asave1))      (jsr_subprim $sp-logbigargs)      (if# pl (move.l da db))      (jsr_subprim $sp-logreserv)      (prog#       (move.w (-@ asave0) dy)       (and.w (-@ asave1) dy)       (not.w dy)       (move.w dy (asave1))       (dbfl da (top#)))      (dbfloop.l db (not.w (-@ asave1)))      (restore_regs)      (jsr_subprim $sp-logval))))(defun lognor (integer1 integer2)  (lap-inline ()    (:variable integer1 integer2)    (if# (and (eq (ttagp ($ $t_fixnum) arg_y da))              (eq (ttagp ($ $t_fixnum) arg_z da)))      (or.l arg_y arg_z)      (not.l arg_z)      (sub.w ($ $typemask) arg_z)      else#      (preserve_regs #(asave0 asave1))      (jsr_subprim $sp-logbigargs)      (if# mi (move.l da db))      (jsr_subprim $sp-logreserv)      (prog#       (move.w (-@ asave0) dy)       (or.w (-@ asave1) dy)       (not.w dy)       (move.w dy (asave1))       (dbfl da (top#)))      (dbfloop.l db (not.w (-@ asave1)))      (restore_regs)      (jsr_subprim $sp-logval))));==> Needs a transform...(defun logandc2 (integer1 integer2) (logandc1 integer2 integer1))(defun logorc2 (integer1 integer2) (logorc1 integer2 integer1))(defun logorc1 (integer1 integer2)  (old-lap   (if# (and (eq (ttagp ($ $t_fixnum) arg_y da))             (eq (ttagp ($ $t_fixnum) arg_z da)))     (not.l arg_y)     (or.l arg_y arg_z)     (sub.w ($ $typemask) arg_z)     (lfret))   (preserve_regs #(asave0 asave1))   (jsr_subprim $sp-bigintarg1)   (move.l atemp0 asave1)   (move.l arg_y arg_z)   (jsr_subprim $sp-bigintarg2)   (move.l atemp0 asave0)   (vsize asave0 da)   (vsize asave1 db)   (if# (le (cmp.l db da))     (if# (pl (tst.w (asave0 $v_data))) (move.l da db))     (jsr_subprim $sp-logreserv)     (prog#      (move.w (-@ asave0) dy)           ;  ~asave0 or asave1      (not.w dy)      (or.w dy (-@ asave1))      (dbfl da (top#)))    else#     (exg da db)     (exg asave0 asave1)     (if# (mi (tst.w (asave0 $v_data))) (move.l da db))     (jsr_subprim $sp-logreserv)     (prog#      (move.w (-@ asave1) dy)           ; asave0 or ~asave1      (not.w dy)      (or.w (-@ asave0) dy)      (move.w dy (asave1))      (dbfl da (top#)))     (dbfloop.l db (not.w (-@ asave1))))   (restore_regs)   (jsr_subprim $sp-logval)   (lfret)));===> Change these constants to match maclisp!!(defun boole (op integer1 integer2)  (old-lap   (if# (or (ne (ttagp ($ $t_fixnum) arg_x da)) (geu (cmp.l '16 arg_x)))     (wtaerr arg_x '(integer 0 16)))   (lfunlk)   (vscale.l arg_x)   (jmp (pc arg_x.w 2))   (moveq '0 acc) (rts)                 ;boole-clr   (moveq '-1 acc) (rts)                ;boole-set   (move.l arg_y acc) (rts)             ;boole-1   (rts) (illegal)                      ;boole-2   (move.l arg_y acc) (bra @lognot)     ;boole-c1   (bra @lognot) (illegal)              ;boole-c2   (set_nargs 2) (bra @logand2)         ;boole-and   (set_nargs 2) (bra @logior2)         ;boole-ior   (set_nargs 2) (bra @logxor2)         ;boole-xor   (set_nargs 2) (bra @logeqv2)         ;boole-eqv   (set_nargs 2) (bra @lognand2)        ;boole-nand   (set_nargs 2) (bra @lognor2)         ;boole-nor   (bra @logandc1) (illegal)            ;boole-andc1   (exg arg_y arg_z) (bra @logandc1)    ;boole-andc2   (bra @logorc1) (illegal)             ;boole-orc1   (exg arg_y arg_z) ;(bra @logorc1)    ;boole-orc2   @logorc1 (set_nargs 2) (jmp #'logorc1)   @logandc1 (set_nargs 2) (jmp #'logandc1)   @lognot (set_nargs 1) (jmp #'lognot)   @logand2 (jmp #'logand)   @logior2 (jmp #'logior)   @logxor2 (jmp #'logxor)   @logeqv2 (jmp #'logeqv)   @lognand2 (jmp #'lognand)   @lognor2 (jmp #'lognor) ));;;;;;;;;;  Transcendental functions ;;;;;;;;;;;;(eval-when (:compile-toplevel :execute)  (deflapgen fpunaryop (&rest fpinstrs)    (lap-instr `(progn                  (if# (ne (dtagp acc $t_sfloat))                    (jsr_subprim $sp-SFloatFP1)                    (lea (a5 $sp-FP1SFloat) atemp0)                    else#                    (move.l acc atemp0)                    (store_float atemp0 fp1)                    (lea (a5 $sp-FP1DFloat) atemp0))                  ,@fpinstrs                  (jsr @atemp0))))  (deflapgen fpunaryreturn (temp-var &rest fpinstrs)    (lap-instr `(progn                  (if# (ne (dtagp acc $t_sfloat))                    (jsr_subprim $sp-SFloatFP1)                    (lea (a5 $sp-FP1SFloat) atemp0)                    else#                    (move.l acc atemp0)                    (move.l (varg ,temp-var) arg_z)                    (store_float atemp0 fp1)                    (lea (a5 $sp-cstoreFP1D) atemp0))                  ,@fpinstrs                  (jsr @atemp0)))))    (defun sin (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (a b c)      (values       (if (complexp x)         (progn           (setq a (%temp-float a (complex.real x))                 b (%temp-float b (complex.imag x)))           (complex (lap-inline ((%temp-float-one-arg #'%fcosh c b))         ; (* (sin a) (cosh b))                      (:variable a)                      (if# (eq (dtagp arg_z $t_sfloat))                        (move.l acc atemp0)                        (store_float atemp0 fp0)                        (move.l (varg a) atemp0)                        (store_float atemp0 fp1)                        (fsin.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1DFloat)                        else#                        (jsr_subprim $sp-SFloatFP1)                        (fmove.x fp1 fp0)                        (move.l (varg a) arg_z)                        (jsr_subprim $sp-SFloatFP1)                        (fsin.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1SFloat)))                    (lap-inline ((%temp-float-one-arg #'%fsinh c b))         ; (* (cos a) (sinh b))                      (:variable a)                      (if# (eq (dtagp arg_z $t_sfloat))                        (move.l acc atemp0)                        (store_float atemp0 fp0)                        (move.l (varg a) atemp0)                        (store_float atemp0 fp1)                        (fcos.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1DFloat)                        else#                        (jsr_subprim $sp-SFloatFP1)                        (fmove.x fp1 fp0)                        (move.l (varg a) arg_z)                        (jsr_subprim $sp-SFloatFP1)                        (fcos.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1SFloat)))))         (lap-inline ((%temp-float a x))           (:variable result)           (fpunaryreturn result (fsin.x fp1))))))))(defun cos (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (a b c)      (values       (if (complexp x)         (progn           (setq a (%temp-float a (complex.real x))                 b (%temp-float b (complex.imag x)))           (complex (lap-inline (a (%temp-float-one-arg #'%fcosh c b))      ; (* (cos a) (cosh b))                      (if# (eq (dtagp arg_z $t_sfloat))                        (move.l acc atemp0)                        (store_float atemp0 fp0)                        (move.l arg_y atemp0)                        (store_float atemp0 fp1)                        (fcos.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1DFloat)                        else#                        (jsr_subprim $sp-SFloatFP1)                        (fmove.x fp1 fp0)                        (move.l arg_y arg_z)                        (jsr_subprim $sp-SFloatFP1)                        (fcos.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1SFloat)))                    (lap-inline (a (%temp-float-one-arg #'%fsinh c b))      ; (* (sin a) (sinh b))                      (if# (eq (dtagp arg_z $t_sfloat))                        (move.l acc atemp0)                        (store_float atemp0 fp0)                        (move.l arg_y atemp0)                        (store_float atemp0 fp1)                        (fsin.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1DFloat)                        else#                        (jsr_subprim $sp-SFloatFP1)                        (fmove.x fp1 fp0)                        (move.l arg_y arg_z)                        (jsr_subprim $sp-SFloatFP1)                        (fsin.x fp1)                        (fmul.x fp0 fp1)                        (jsr_subprim $sp-FP1SFloat)))))         (lap-inline ((%temp-float a x))           (:variable result)           (fpunaryreturn result (fcos.x fp1))))))))(defun tan (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (t1 t2)      (values        (if (complexp x)         ;(/ (%temp-float-one-arg #'sin t1 x) (%temp-float-one-arg #'cos t2 x))         (lap-inline (result (%temp-float-one-arg #'sin t1 x) (%temp-float-one-arg #'cos t2 x))           (if# (eq (dtagp arg_z $t_sfloat))             (move.l arg_y atemp0)             (store_float atemp0 fp1)             (move.l arg_z atemp0)             (store_float atemp0 fp0)             (fdiv.x fp0 fp1)             (move.l arg_x arg_z)             (jsr_subprim $sp-cstoreFP1D)             else#             (jsr_subprim $sp-SFloatFP1)             (fmove.x fp1 fp0)             (move.l arg_y arg_z)             (jsr_subprim $sp-SFloatFP1)             (fdiv.x fp0 fp1)             (jsr_subprim $sp-FP1SFloat)))         (lap-inline ((%temp-float t1 x))           (:variable result)           (fpunaryreturn result (ftan.x fp1))))))))(defun cis (x)  (with-stack-double-floats (tempx)    (setq tempx (%temp-float tempx x))     (values     (complex (lap-inline (tempx)                (fpunaryop (fcos.x fp1)))              (lap-inline (tempx)                (fpunaryop (fsin.x fp1)))))))(defun atan (y &optional x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (t1 t2)      (values       (cond (x (%fatan2 (%temp-float t1 y) (%temp-float t2 x) result))             ((complexp y)              (let* ((iy (* (sqrt -1) y)))                (/ (- (log (+ 1 iy)) (log (- 1 iy)))                   #c(0 2))))             (t (lap-inline ((%temp-float t1 y))                  (:variable result)                  (fpunaryreturn result (fatan.x fp1)))))))))(defun phase (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (t1 t2)      (values (%fatan2 (%temp-float t1 (imagpart x)) (%temp-float t2 (realpart x)) result)))))(defun log (x &optional b)  (cond   ((bignump x)    (if (minusp x)      (complex (log (- x) b) pi)    (let* ((base1 (cond ((integerp b) b)                        ((null b) 3)                        (t (ceiling b))))           (guess (floor (1- (integer-length x))                         (log base1 2)))           (guess1 (when (not (eq base1 b))                     (* guess (log base1 b)))))      (+ (or guess1 guess)         (log (/ x (expt base1 guess)) b)))))   ((and (ratiop x)(or (> x most-positive-double-float)(< x most-negative-double-float)))    (- (log (numerator x) b)(log (denominator x) b)))   (t     (let ((result (%temp-dfloat-result-p)))      (with-stack-double-floats (t1 t2)        (values         (if b            (if (zerop b)              (if (zerop x)                (report-bad-arg x '(not (satisfies zerop) ))               (float 0.0 x))             (%temp-float-binop-subprim $sp-quo2 result (%temp-float-one-arg #'log t2 b) (%temp-float-one-arg #'log t1 x)))           (if (and (realp x) (not (minusp x)))             (lap-inline ((%temp-float t1 x))               (:variable result)               (fpunaryreturn result (flogn.x fp1)))             (complex (log  (%temp-float-one-arg #'abs t1 x)) (phase x))))))))))(defun exp (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (t1)      (values       (if (complexp x)         (* (%temp-float-one-arg #'exp t1 (realpart x)) (cis (imagpart x)))         (lap-inline ((%temp-float t1 x))           (:variable result)           (fpunaryreturn result (fetox.x fp1))))))))(defun expt (b e)  (let ((result (%temp-dfloat-result-p)))      (with-stack-double-floats (t1 t2)      (values       (cond ((integerp e)              (if (minusp e) (/ (%integer-power b (- e))) (%integer-power b e)))             ((zerop b)              ; steele says its an error if base is 0 and exp is 0 not integer - strange              (if (plusp (realpart e)) b (report-bad-arg e '(number (0) *))))             ((and (realp b) (plusp b) (realp e))              (lap-inline ((%temp-float t1 b) (%temp-float t2 e))                (:variable result)                (moveq 0 db)                (if# (ne (dtagp arg_z $t_sfloat))                  (jsr_subprim $sp-sfloatFP1)                  (fmove.x fp1 fp2)                  else#                  (move.l arg_z atemp0)                  (store_float atemp0 fp2)                  (moveq 1 db))                (if# (ne (dtagp arg_y $t_sfloat))                  (move.l arg_y arg_z)                  (jsr_subprim $sp-SFloatFP1)                  else#                  (moveq 1 db)                  (move.l arg_y atemp0)                  (store_float atemp0 fp1))                (if# (eq (tst.b (a5 $fp68881flag)))                  (move.l ($ 18) acc)                  (jsr_subprim $sp-mknlisparea)                  (lea (a5 (+ $xfp0 10)) atemp0)   ; XFP1                  (move.l atemp0 (sp 6))                  (add.w ($ 10) atemp0)            ; XFP2                  (move.l atemp0 (sp 10))                  (move.w ($ _fexpwry) (sp 4))                  (jsr_subprim $sp-strap)                  (dc.w #xa9ec)                       ; _Elems68k                  else#                   (flogn.x fp1)                  (fmul.x fp2 fp1)                  (fetox.x fp1)                  )                (if# (ne (tst.b d1))                  (move.l (varg result) arg_z)                  (jsr_subprim $sp-cstoreFP1D)                else#                (jsr_subprim $sp-FP1Sfloat))))             (t (exp (* e (log b)))))))))(defun %integer-power (b e) (if (eq e 0) (+ 1 (* 0 b))   (let ((x (%integer-power b (ash e -1))))      (if (oddp e) (* b x x) (* x x)))))(defun signum (x)  (cond ((complexp x) (cis (phase x)))        ((rationalp x) (if (plusp x) 1 (if (zerop x) 0 -1)))        ((zerop x) (float 0.0 x))        (t (float-sign x))))(defun sqrt (x &aux a b)  (let ((result (%temp-dfloat-result-p)))    (cond ((zerop x) x)          ((complexp x) (* (sqrt (abs x)) (cis (/ (phase x) 2))))                    ((minusp x) (complex 0 (sqrt (- x))))          ((floatp x)           (lap-inline (x)                          (:variable  result)             (fpunaryreturn result (fsqrt.x fp1))))          ((and (integerp x) (eql x (* (setq a (isqrt x)) a))) a)          ((and (ratiop x)                (let ((n (numerator x))                      d)                  (and (eql n (* (setq a (isqrt n)) a))                       (eql (setq d (denominator x))                            (* (setq b (isqrt d)) b)))))           (/ a b))                    (t            (with-stack-double-floats (t1)             (values              (lap-inline ((%temp-float t1 x))                (:variable result)                (fpunaryreturn result (fsqrt.x fp1))))))))); Thanks to d34676@tansei.cc.u-tokyo.ac.jp (Akira KURIHARA)(defun isqrt (n &aux n-len-quarter n-half n-half-isqrt                init-value iterated-value)  "argument n must be a non-negative integer"  (cond   ((eql n 0) 0)   ((not (int>0-p n)) (report-bad-arg n '(integer 0))) ;'unsigned-byte)) ; Huh?   ((> n 24)		; theoretically (> n 7) ,i.e., n-len-quarter > 0    (setq n-len-quarter (ash (integer-length n) -2))    (setq n-half (ash n (- (ash n-len-quarter 1))))    (setq n-half-isqrt (isqrt n-half))    (setq init-value (ash (1+ n-half-isqrt) n-len-quarter))    (loop      (setq iterated-value (ash (+ init-value (floor n init-value)) -1))      (if (not (< iterated-value init-value))        (return init-value)        (setq init-value iterated-value))))   ((> n 15) 4)   ((> n  8) 3)   ((> n  3) 2)   (t 1)))(defun asin (x)  (let ((result (%temp-dfloat-result-p)))    (if (and (realp x) (<= -1.0 (setq x (float x)) 1.0))      (lap-inline (x)        (:variable result)        (fpunaryreturn result (fasin.x fp1)))      (progn        (setq x (+ (complex (- (imagpart x)) (realpart x))                   (sqrt (- 1 (* x x)))))        (complex (phase x) (- (log (abs x))))))))(eval-when (:execute :compile-toplevel)  (defconstant half-pi (asin 1.0))  ;Not CL.)(defun acos (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (x1)      (values       (if (and (realp x) (<= -1.0 (setq x (%temp-float x1 x)) 1.0))         (lap-inline (x)           (:variable result)           (fpunaryreturn result (facos.x fp1)))         (- half-pi (%temp-float-one-arg #'asin x1 x)))))))(defun sinh (x)  (if (complexp x) (/ (- (exp x) (exp (- x))) 2) (%fsinh (float x))))(defun cosh (x)  (if (complexp x) (/ (+ (exp x) (exp (- x))) 2) (%fcosh (float x))))(defun tanh (x)  (if (complexp x) (/ (sinh x) (cosh x)) (%ftanh (float x))))(defun asinh (x)  (if (complexp x) (log (+ x (sqrt (+ 1 (* x x))))) (%fasinh (float x))))(defun acosh (x)  (if (and (realp x) (<= 1.0 x)) (%facosh (float x))      (* 2 (log (+ (sqrt (/ (1+ x) 2)) (sqrt (/ (1- x) 2)))))))(defun atanh (x)  (if (and (realp x) (<= -1.0 (setq x (float x)) 1.0)) (%fatanh x)      (/ (log (/ (+ 1 x) (- 1 x))) 2)));Stuff which should be lapified when I get around to it...(defun %fatan2 (y x &optional result)  (if (zerop x)    (float-sign y                (if (zerop y)                  (if (or (eql x 0.0d0) (eq x 0.0s0)) (float 0.0 x) (float pi x))                  (float half-pi x)))    (lap-inline ()    ; (atan (/ y x))      (:variable x y result)      (move.l (varg x) arg_z)      (dtagp arg_z $t_sfloat)      (seq db)      (if# ne        (jsr_subprim $sp-SFloatFP1)        (fmove.x fp1 fp0)        else#        (move.l arg_z atemp1)        (store_float atemp1 fp0))      (move.l (varg y) arg_z)      (dtagp arg_z $t_sfloat)      (seq da)      (if# ne        (jsr_subprim $sp-SFloatFP1)        else#        (move.l arg_z atemp0)        (store_float atemp0 fp1))      (fdiv.x fp0 fp1)      (fatan.x fp1)      (move.b db dx)      (or.b da dx)      (if# (or (and (ne (tst.b db)) (mi (tst.l (atemp1 $floathi))))               (and (eq (tst.b db)) (ne (progn (move.l (varg x) arg_z) (btst ($ 3) arg_z))))); if x < 0        (move.l '#.pi atemp0)        (store_float atemp0 fp0)	(sub.w ($ 8) sp)        (FMOVE.D fp1 (sp))        (move.l (@+ sp) da)        (move.l (@+ sp) db)        (if#          ;This is the way it's in the cleanup proposal, seems right.          (pl (tst.l da))          ;This is the way it's in the book, but it seems wrong.          ;(or (gt (tst.l da)) (and eq (ne (tst.l db))))          (fsub.x fp0 fp1)         else#         (fadd.x fp0 fp1)))      (if# (eq (tst.b dx))        (jsr_subprim $sp-FP1Sfloat)        else#        (move.l (varg result) arg_z)        (jsr_subprim $sp-cstoreFP1D)))))(defun %fsinh (&lap x)  (lap    (if# (ne (dtagp arg_z $t_sfloat))      (jsr_subprim $sp-SFloatFP1)      (moveq 1 da)      (lea (a5 $sp-FP1SFloat) atemp0)      else#      (move.l arg_z atemp0)      (store_float atemp0 fp1)      (lea (a5 $sp-FP1DFloat) atemp0)      (moveq 0 da)      (fmove.l da fp0))    (fsub.x fp1 fp0)    (fetox.x fp0)                  ; fp0 = e^(-x)    (fetox.x fp1)                  ; fp1 = e^x    (fsub.x fp0 fp1)    (moveq -1 da)    (jsr #'%%scale-float)    (jmp @atemp0)))(defun %fcosh (&lap x)  (old-lap    (moveq 0 da)    (fmove.l da fp0)   (if# (ne (dtagp arg_z $t_sfloat))     (jsr_subprim $sp-SFloatFP1)     (lea (a5 $sp-FP1SFloat) atemp0)     else#     (move.l arg_z atemp0)     (store_float atemp0 fp1)     (lea (a5 $sp-FP1DFloat) atemp0))   (fsub.x fp1 fp0)   (fetox.x fp0)                  ; fp0 = e^(-x)   (fetox.x fp1)                  ; fp1 = e^x   (fadd.x fp0 fp1)   (moveq -1 da)   (jsr #'%%scale-float)   (jmp @atemp0)))(defun %ftanh (x)  (let ((result (%temp-dfloat-result-p)))    (with-stack-double-floats (t1 t2)      (values       (lap-inline ((%temp-float-one-arg #'%fsinh t1 x) (%temp-float-one-arg #'%fcosh t2 x))         (:variable result)         ; (assert (= (%ttag arg_y) (%ttag arg_z)))         (if# (ne (dtagp arg_z $t_sfloat))           (jsr_subprim $sp-SFloatFP1)     ; arg_z -> fp0           (fmove.x fp1 fp0)           (move.l arg_y arg_z)           (jsr_subprim $sp-SFloatFP1)           (lea (a5 $sp-FP1SFloat) atemp0)           else#                  (move.l arg_y atemp0)           (store_float atemp0 fp1)           (move.l arg_z atemp0)           (store_float atemp0 fp0)           (move.l (varg result) arg_z)           (lea (a5 $sp-cstoreFP1D) atemp0))         (fdiv.x fp0 fp1)         (jsr @atemp0))))))(defun %fasinh (&lap x)   (lap                  ; ln(x+sqrt(x*x+1))    (moveq 0 da)    (if# (ne (dtagp arg_z $t_sfloat))      (jsr_subprim $sp-SFloatFP1)      (moveq 1 da)      else#      (move.l arg_z atemp0)      (store_float atemp0 fp1))    (fmove.x fp1 fp0)    (fmul.x fp0 fp1)    (moveq 1 db)    (fmove.l db fp2)    (fadd.x fp2 fp1)    (fsqrt.x fp1)    (fadd.x fp0 fp1)    (flogn.x fp1)    (if# (ne (tst.w da))      (jmp_subprim $sp-FP1Sfloat))    (jmp_subprim $sp-FP1DFloat)))(defun %facosh (&lap x)  (lap                 ; ln(x+sqrt(x*x-1))    (moveq 0 da)    (if# (ne (dtagp arg_z $t_sfloat))      (jsr_subprim $sp-SFloatFP1)      (moveq 1 da)      else#      (move.l arg_z atemp0)      (store_float atemp0 fp1))    (fmove.x fp1 fp0)    (fmul.x fp0 fp1)    (moveq 1 db)    (fmove.l db fp2)    (fsub.x fp2 fp1)    (fsqrt.x fp1)    (fadd.x fp0 fp1)    (flogn.x fp1)    (if# (ne (tst.w da))      (jmp_subprim $sp-FP1Sfloat))    (jmp_subprim $sp-FP1DFloat)))(eval-when (eval compile)   (defconstant trig-epsilon (scale-float 1.0 -33)))(defun %fatanh (x &aux (y (%fabs x)))  (if (< y trig-epsilon)     x    (float-sign x (lap-inline ()                    (:variable y)                    (move.l '1.0 atemp0)                    (store_float atemp0 fp2)   ; fp2 = 1.0                    (move.l (varg y) atemp0)                    (store_float atemp0 fp1)                    (fmove.x fp2 fp0)                    (fsub.x fp1 fp0)   ; fp0 = 1-y                    (fadd.x fp2 fp1)   ; fp1 = 1+y                    (fdiv.x fp0 fp1)   ; 1+y / 1-y                    (flogn.x fp1)                    (moveq -1 da)                    (jsr #'%%scale-float)                    (jsr_subprim $sp-FP1DFloat)))))(defun %fabs (float)  (lap-inline ()    (:variable float)    (if# (ne (dtagp arg_z $t_sfloat))      (bclr ($ 3) arg_z)      (movereg arg_z acc)      else#      (move.l acc atemp0)      (if# (mi (move.l (atemp0 $floathi) arg_y))        (bclr ($ 31) arg_y)        (move.l (atemp0 (+ 4 $floathi)) arg_z)        (jsr_subprim $sp-makefloat)))))(defun ffloor (number &optional divisor)  (multiple-value-bind (q r) (floor number divisor)    (values (float q (if (floatp r) r 0.0)) r)))(defun fceiling (number &optional divisor)  (multiple-value-bind (q r) (ceiling number divisor)    (values (float q (if (floatp r) r 0.0)) r)))(defun ftruncate (number &optional divisor)  (multiple-value-bind (q r) (truncate number divisor)    (values (float q (if (floatp r) r 0.0)) r)))(defun fround (number &optional divisor)  (multiple-value-bind (q r) (round number divisor)    (values (float q (if (floatp r) r 0.0)) r)))(defun rational (number)  (if (floatp number)      (multiple-value-bind (s e sign) (integer-decode-float number)         (if (eq sign -1) (setq s (- s)))         (if (%iminusp e) (/ s (ash 1 (%i- 0 e))) (ash s e)))    (if (rationalp number) number      (report-bad-arg number 'real)))); make power tables for floating point reader(progn  (setq float-powers-of-5 (make-array 23))  (let ((array float-powers-of-5))    (dotimes (i 23)      (setf (svref array i)  (float (expt 5 i)))))  (setq integer-powers-of-5 (make-array (+ 12 (floor 324 12))))  (let ((array integer-powers-of-5))    (dotimes (i 12)      (setf (svref array i)  (expt 5 i)))    (dotimes (i (floor 324 12))      (setf (svref array (+ i 12)) (expt 5 (* 12 (1+ i)))))))(provide 'numbers)#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)