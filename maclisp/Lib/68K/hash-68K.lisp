;;-*- Mode: Lisp; Package: CCL -*-;;	Change History (most recent first):;;  2 8/25/97  akh  sxhash;;  7 9/15/96  akh   add-locked-additions from 4.0, also puthash and the maphash support;;                     also hash-table-weak-p & (setf hash-table-weak-p);;  6 4/11/96  akh  bill's fix to grow-hash-table;;  5 9/14/95  akh  fix sxhash by working around compiler bug re 3arg + of fixnums;;  4 7/27/95  akh  merge patches to grow-hash-table, gethash, puthash and %%equal-hash.;;  2 5/4/95   akh  change a wtaerr;;  6 2/17/95  akh  probably no change;;  5 2/9/95   slh  fix maphash crash for wta;;  4 1/31/95  akh  put back some stuff missed while merging;;  3 1/30/95  akh  fix for processes;;  (do not edit before this line!!); Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!;;;;;;;;;;;;;;;;; hash.lisp;; New hash table implementation;;;;;;;;;;;;;;;;; Things I didn't do;;;; Save the 32-bit hash code along with the key so that growing the table can;; avoid calling the hashing function (at least until a GC happens during growing).;;;; Maybe use Knuth's better method for hashing:;; find two primes N-2, N.  N is the table size.;; First probe is at primary = (mod (funcall (nhash.keytransF h) key) N);; Secondary probes are spaced by (mod (funcall (nhash.keytransF h) key) N-2);; This does a bit better scrambling of the secondary probes, but costs another divide.;;;; Rethink how finalization is reported to the user.  Maybe have a finalization function which;; is called with the hash table and the deleted key & value.;;;;;;;;;;;;;;;;; Modification History;;;;  5/27/95 slh   make-hash-table: slightly better error reporting;;  2/09/95 slh   start-hash-table-iterator: clear hti.hash-table if bogus;;                finish-hash-table-iterator: check for null hti.hash-table;; 01/30/95 alice fix for processes;; 10/05/93 bill %%equalhash-aux & %%equalphash-aux say (car atemp0) instead of -@atemp0;; 09/15/93 bill Bob Cassell's patch to the make-load-form method.;;               Makes it generate simple enough forms that the;;               new fasl-scan-user-form will not compile them.;; ------------- 3.0d13;; 07/29/93 bill gethash neglected to branch after calling asseql.;;               Worse, calling add-locked-additions clobbers the temp registers, unbeknownst;;               to the earlier version of gethash.;;               fasl-lock-hash-table, fasl-unlock-hash-tables;; 06/05/93 bill %rehash now puts $nhash.lock-while-rehashing in nhash.lock;;               as it was designed to do. %maybe-rehash checks for the;;               proper value, too.;; ------------- 3.0d11;; 11/20/92 gb   keep cache value/index in hash vector so gc can zap them.;; 12/11/92 bill Moon's fix to compute-hash-code, pop saved update-maybe-rehash;;               before restoring registers and jumping to %hash-linear-probe.;;               This only happens when the table is locked and needs rehashing;;               (e.g. GETHASH is called during MAPHASH when the table needs;;               to be rehashed).;; 08/11/92 bill EQUALP hash tables no longer error with CLOS instances as keys.;; 07/30/92 bill gethash now returns the proper value when it finds the;;               entry in the locked-additions alist (during mapping).;; 06/22/92 bill in puthash: Don't need to check for both weak & finalizeable.;;               (besides, the test for weak was wrong).;; 06/19/92 bill clrhash now calls $sp-eventch occasionally so that calling;;               it on a big hash table in a VM environment will be interruptable.;;               grow-hash-table no longer throws away nhash.vector.weak-deletions-count.;;               Decrementers of nhash.vector.deleted-count also update;;               nhash.vector.weak-deletions-count, when appropriate.;; 05/23/92 bill do-rehash now cerror's on duplicate keys.;;               It also handles nhash.vector.deleted-count correctly;;               if you throw out of it.;; 05/22/92 bill clrhash now clears the rehashing bits.;; 05/21/92 bill do-rehash got in an infinite loop on Bob Cassels.;;               Was a bug in neglecting to set the $nhash_key_moved_bit;;               when we get a key whose address was used to compute;;               the hash code and we're not getting GC assistance.;;               Also, %hash-probe now passes its maybe-update-rehash arg;;               to %general-hash-probe. This prevents gethash from;;               changing the when-does-this-table-need-rehashing information.;;               Finally, get-fwdnum had a bug in code that is never used.;; ------------- 2.0;; 12/31/91 bill report-bad-arg is not funcallable.;; 10/11/91 bill Speed up make-hash-table by by speeding up %cons-nhash-vector.;;               This makes growing a hash table much faster, as well.;; 10/07/91 gb   Fix bug in %hash-probe for EQL hash tables.;; 10/03/91 bill Compute secondary offset from original hash code, not normalized one.;; 10/02/91 bill speed up gethash & %hash-probe by a few microseconds each.;;               make EQUALP hash tables work for vectors with fill pointers.;; 09/24/91 bill Doing many REMHASH'es no longer causes a hash table to become;;               extremely slow.;; 09/18/91 bill %%equalhash works for bit vectors.;;               eql hash tables work for all numbers, not just fixnums;; 09/17/91 bill gethash returns two values;; 09/04/91 gb   (atemp0 nhash.vector) -> (svref atemp0 nhash.vector) in ;;               %does-not-need-rehashing.;; 08/29/91 gb   use (a5 $relocnum) - a fixnum - vice dynamic gc-count.;; 08/24/91 gb   use new trap syntax.;; 08/21/91 bill missing (the fixnum ...) in sxhash;; 08/19/91 bill make cacheing work in do-hash-table-iteration;; 08/16/91 bill hash tables can become completely filled with deleted entries:;;               add terminating test to %xx-hash-probe.;; 08/10/91 gb   clear caches when rehashing.  Interact with gc.;; 08/04/91 gb   only cache keys that are in the table in gethash.;; 08/02/91 bill finish %%equalphash.  sxhash hashes on %type-of as a last resort.;;               with-hash-table-iterator sets the cache.;; 08/01/91 bill Moon's bug: da->acc in compute-hash-code (only affects user hashing functions);; 07/31/91 bill nhash.vector.weak-deletions-count, nhash.vector.hash.;;               Sample and map through nhash.locked-additions in with-hash-table-iterator.;;               User supplied hash-function & test to make-hash-table must be symbols;;               (otherwise fasdumping a hash table becomes problematical).;;               make-load-form;; 07/12/91 bill Chisel a toothpick out of solid granite;; 07/01/91 gb   Initial data structures and hashing functions;;;;;;;;;;;;;;;;; Documentation;;;; MAKE-HASH-TABLE is extended to accept a :HASH-FUNCTION keyword arg which;; defaults for the 4 Common Lisp defined :TEST's.  Also, any fbound symbol can;; be used for the :TEST argument.  The HASH-FUNCTION is a function of one;; argument, the key, which returns one, two, or three values:;;;; 1) HASH-CODE;; 2) ADDRESSP;; 3) EPHEMERAL-P;;;; The HASH-CODE can be any object.  If it is a relocateable object (not a;; fixnum, short float, or immediate) then ADDRESSP will default to :KEY;; and it is an error if NIL is returned for ADDRESSP.;;;; If ADDRESSP is NIL, the hashing code assumes that no addresses were used;; in computing the HASH-CODE.  If ADDRESSP is :KEY (which is the default;; if the hash function returns only one value and it is relocateable) then;; the hashing code assumes that only the KEY's address was used to compute;; the HASH-CODE.  Otherwise, it is assumed that the address of a;; component of the key was used to compute the HASH-CODE.;;;; If EPHEMERAL-P is returned and is NIL, the hashing code assumes that none;; of the objects whose addresses were used in calculating the;; HASH-CODE were ephemeral.  E.g. the table will not need to be rehashed;; after an ephemeral GC.  If the hash function returns one or two values,;; and the value returned or defaulted for ADDRESSP is :KEY, then;; EPHEMERAL-P will be true iff the KEY is not in tenured space.;;;;;; Some (proposed) functions for using in user hashing functions:;;;; (HASH-CODE object);;;; returns three values:;;;; 1) HASH-CODE;; 2) ADDRESSP;; 3) EPHEMERAL-P;;;; HASH-CODE is the object transformed into a fixnum by changing its tag;; bits to a fixnum's tag.  ADDRESSP is true if the object was;; relocateable.  EPHEMERAL-P is true if ADDRESSP was true and the object;; is not in tenured space.;;;;;; (FIXNUM-ADD o1 o2);; Combines two objects additively and returns a fixnum.;; If the two objects are fixnums, will be the same as (+ o1 o2) except;; that the result can not be a bignum.;;;; (FIXNUM-MULTIPLY o1 o2);; Combines two objects multiplicatively and returns a fixnum.;;;; (FIXNUM-FLOOR dividend &optional divisor);; Same as Common Lisp's FLOOR function, but converts the objects into;; fixnums before doing the divide and returns two fixnums: quotient &;; remainder.;;;;;;;;;;;;;;;;;;; Implementation details.;;;; Hash table vectors have a header that the garbage collector knows about;; followed by alternating keys and values.  Empty or deleted slots are;; denoted by a key of $undefined.  Empty slots have a value of $undefined.;; Deleted slots have a value of NIL.;;;; The nhash.lock slot is used to control access to the nhash.vector.;; 0  means no one is mapping;; >0 means MAPHASH or WITH-HASH-TABLE-ITERATOR is mapping.;;    If PUTHASH needs to grow the table it must do it via the;;    nhash.locked-additions alist.;; -1 means the table is being grown.  GETHASH can probe normally but;;    PUTHASH & REMHASH need to make their modifications on the;;    nhash.locked-additions alist.;; -2 means the table is being rehashed.  GETHASH must do linear search,;;    and PUTHASH & REMHASH must use the nhash.locked-additions alist.;;;; changed to count of mappers in low 16  + bit for grow and bit for rehash;; if nhash.lock is 0 nobody is mapping or rehashing or growing;; in which case puthash and gethash and remhash act normally;; maphash and WITH-HASH-TABLE-ITERATOR;;  if rehashing, process-wait for rehash to be finished then proceed normally;;   otherwise increment map-count, map and decrement map-count when done.;;   (won't quite work if growing - if we are modifying the hash entries the mods will;;     happen in the old vector which will then be replaced by the new vector);;  so wait on growing too.;; puthash;;  if growing or rehashing, add to locked additions alist;;  if nhash.lock not zero and needs rehashing add to locked-additions alist.;;  if lock not zero and wants to grow add to locked-additions alist.;; gethash;;   if mapping be normal;;   if rehashing - go without interrupts and do linear scan;;   if growing - if needs rehash go without interrupts and do linear scan;;			if not needs rehashing do normal;; rehash;;   dont do it if lock not 0;; remhash;;   if growing or rehashing use locked-additions list;;    else be normal.;; grow ;;   may do rehash instead if enough deleted entries and map count is zero ;; ;;;; Five bits in the nhash.vector.flags fixnum interact with the garbage;; collector.  This description uses the symbols that represent bit numbers;; in a fixnum.  $nhash_xxx_bit has a corresponding $nhash_lap_xxx_bit which;; gives the byte offset of the bit for LAP code.  The two bytes in;; question are at offsets $nhash.vector-weak-byte and;; $nhash.vector-track-keys-byte offsets from the tagged vector.;; The 32 bits of the fixnum at nhash.vector.flags look like:;;;;     TKEC0000 00000000 WVF00000 00000000;;;;;; $nhash_track_keys_bit         "T" in the diagram above;;                               Sign bit of the longword at $nhash.vector.flags;;                               or the byte at $nhash.vector-track-keys-byte.;;                               If set, GC tracks relocation of keys in the;;                               vector.;; $nhash_key_moved_bit          "K" in the diagram above;;                               Set by GC to indicate that a key moved.;;                               If $nhash_track_keys_bit is clear, this bit is set to;;                               indicate that any GC will require a rehash.;;                               GC never clears this bit, but may set it if;;                               $nhash_track_keys_bit is set.;; $nhash_ephemeral_bit          "E" in the diagram above;;                               Ignored by GC.  Set to indicate that an;;                               ephemeral address was used to calculate one;;                               or more of the hash codes.;; $nhash_component_address_bit  "C" in the diagram above.;;                               Ignored by GC.  Set to indicate that the;;                               address of a component of a key was used. ;;                               Means that $nhash_track_keys_bit will;;                               never be set until all such keys are;;                               removed.;; $nhash_weak_bit               "W" in the diagram above;;                               Sign bit of the byte at $nhash.vector-weak-byte;;                               Set to indicate a weak hash table;; $nhash_weak_value_bit         "V" in the diagram above;;                               If clear, the table is weak on key;;                               If set, the table is weak on value;; $nhash_finalizeable_bit       "F" in the diagram above;;                               If set the table is finalizeable:;;                               If any key/value pairs are removed, they will be added to;;                               the nhash.vector.finalization-alist using cons cells;;                               from nhash.vector.free-alist(in-package :ccl)(eval-when (eval compile load)(def-accessors (hash-table) %svref  nil                                   ; 'HASH-TABLE  nhash.rehashF                         ; function: rehashes if necessary  nhash.keytransF                       ; transform key into (values primary addressp)  nhash.compareF                        ; comparison function: 0 -> eq, -1 ->eql, else function  nhash.rehash-bits                     ; bitset (array (unsigned-byte 32)) for rehash  nhash.vector                          ; N <key,value> pairs; n relatively prime to & larger than all secondary keys  nhash.lock                            ; fixnum: count of mappers in low 16 bits + bits for grow and rehash  nhash.count                           ; Number of entries  nhash.locked-additions                ; Alist to look in when table locked & not otherwise found  nhash.fixnum                          ; (a5 $fwdnum)  nhash.gc-count                        ; (a5 $relocnum) - incremented by full gc, growzone.  nhash.grow-threshold                  ; Max # entries before grow  nhash.rehash-ratio                    ; inverted rehash-threshold  nhash.rehash-size			; rehash-size from user  nhash.puthash-count                   ; number of times table has been rehashed or grown  ); It's wired in to the code that the length of this vector is 8 and; that its largest element is < 30(defconstant secondary-keys #(3 5 7 11 13 17 19 23)))(eval-when (:compile-toplevel :execute)(declaim (inline index->vector-index vector-index->index))(assert (eql $fixnumshift 3)); now in lispequ; (defconstant $v_nhash 56)               ; vector subtype for nhash.vector of weak hash tables.; undistinguished values of nhash.lock(defconstant $nhash.lock-while-growing #x10000)(defconstant $nhash.lock-while-rehashing #x20000)(defconstant $nhash-lap-growing-bit (+ $fixnumshift 16))(defconstant $nhash-lap-rehashing-bit (+ $fixnumshift 17))(defconstant $nhash.lock-grow-or-rehash #x30000)(defconstant $nhash.lock-map-count-mask #xffff)(defconstant $nhash.lock-not-while-rehashing #x-20001); The hash.vector cell contains a vector with 8 longwords of overhead; followed by alternating keys and values.; A key of $undefined denotes an empty or deleted value; The value will be $undefined for empty values, or NIL for deleted values.(def-accessors () %svref  nhash.vector.link                     ; GC link for weak vectors  nhash.vector.flags                    ; a fixnum of flags  nhash.vector.free-alist               ; empty alist entries for finalization  nhash.vector.finalization-alist       ; deleted out key/value pairs put here  nhash.vector.weak-deletions-count     ; incremented when the GC deletes an element  nhash.vector.hash                     ; back-pointer  nhash.vector.deleted-count            ; number of deleted entries  nhash.vector.cache-idx                ; index of last cached key/value pair  nhash.vector.cache-key                ; cached key  nhash.vector.cache-value              ; cached value  ); number of longwords of overhead in nhash.vector.; Must be a multiple of 2 or INDEX parameters in LAP code will not be tagged as fixnums.(defconstant $nhash.vector_overhead 10)(defconstant $nhash_data (+ $v_data (* 4 $nhash.vector_overhead)))      ; byte offset to first key/value pair(defconstant $nhash_weak_bit 12)        ; weak hash table(defconstant $nhash_weak_value_bit 11)  ; weak on value vice key if this bit set(defconstant $nhash_finalizeable_bit 10)(defconstant $nhash_weak_flags_mask  (bitset $nhash_weak_bit (bitset $nhash_weak_value_bit (bitset $nhash_finalizeable_bit 0))))(defconstant $nhash_track_keys_bit 28)  ; request GC to track relocation of keys.(defconstant $nhash_key_moved_bit 27)   ; set by GC if a key moved.(defconstant $nhash_ephemeral_bit 26)   ; set if a hash code was computed using an address                                        ; in ephemeral space(defconstant $nhash_component_address_bit 25)                                        ; a hash code was computed from a key's component(defconstant $nhash.vector.flags (+ $v_data (* 4 nhash.vector.flags)))(defconstant $nhash.vector-weak-byte (+ $nhash.vector.flags 2))(defconstant $nhash.vector-track-keys-byte $nhash.vector.flags); Bits within the bytes defined above(defconstant $nhash_lap_weak_bit (+ $nhash_weak_bit $fixnumshift -8))(defconstant $nhash_lap_weak_value_bit (+ $nhash_weak_value_bit $fixnumshift -8))(defconstant $nhash_lap_finalizeable_bit (+ $nhash_finalizeable_bit $fixnumshift -8))(defconstant $nhash_lap_track_keys_bit (+ $nhash_track_keys_bit $fixnumshift -24))(defconstant $nhash_lap_key_moved_bit (+ $nhash_key_moved_bit $fixnumshift -24))(defconstant $nhash_lap_ephemeral_bit (+ $nhash_ephemeral_bit $fixnumshift -24))(defconstant $nhash_lap_component_address_bit (+ $nhash_component_address_bit $fixnumshift -24)); mask of the long word(defconstant $nhash_lap_weak_flags_mask (ash $nhash_weak_flags_mask 3)); Return number of keys in a hash table vector.; This may return a bogus cons if the vector is not a hash table vector.(defmacro nhash.vector-size (vector)  `(lap-inline (,vector)     (move.l arg_z atemp0)     (vsize atemp0 acc)     (sub.l ($ (* 4 $nhash.vector_overhead)) acc)))(defmacro get-fwdnum (&optional hash)  (if hash    `(lap-inline (,hash)       (move.l arg_z atemp0)       (move.l (a5 $fwdnum) (svref atemp0 nhash.fixnum)))    `(lap-inline () (move.l (a5 $fwdnum) acc))))(defmacro gc-count (&optional hash)  (if hash    `(lap-inline (hash)       (move.l arg_z atemp0)       (move.l (a5 $relocnum) (svref atemp0 nhash.gc-count)))    `(lap-inline ()       (move.l (a5 $relocnum) acc))))#|(defmacro nhash-locked-additions-cell (key-sym hash-sym &optional addp)  (let ((cell (gensym)))    `(let ((,cell (assoc ,key-sym (nhash.locked-additions ,hash-sym)                         :test (hash-table-test-function ,hash-sym))))       ,(if addp          `(or ,cell (car (push (cons ,key-sym nil) (nhash.locked-additions ,hash-sym))))          cell))))|#; This is in the main path, so it needs to be fast(defmacro nhash-locked-additions-cell (key-sym hash-sym &optional addp locked-additions)  `(lap-inline (,@(if locked-additions `(,locked-additions)))     (:variable ,key-sym ,hash-sym)     (move.l (varg ,hash-sym) atemp0)     ,@(unless locked-additions         `((move.l (svref atemp0 nhash.locked-additions) arg_z)))     (,@(if addp '(progn) '(if# (ne (cmp.l arg_z nilreg))))       (move.l (varg ,key-sym) arg_y)       (move.l (svref atemp0 nhash.compareF) da)       (if# (ne (dtagp da $t_fixnum))         (if# (eq (tst.l da))           (jsr_subprim $sp-assq)           (bra @ret)          else#           (ccall asseql arg_y arg_z))        else#         (ccall assoc arg_y arg_z ':test da))@ret       ,(if addp          `(if# (eq (cmp.l nilreg acc))             (move.l (varg ,key-sym) arg_z)             (jsr_subprim $sp-consznil)             (movereg acc arg_z)             (jsr_subprim $sp-consznil)             (move.l acc atemp1)             (move.l (varg ,hash-sym) atemp0)             (move.l (svref atemp0 nhash.locked-additions) (cdr atemp1))             (move.l atemp1 (svref atemp0 nhash.locked-additions))             (move.l (car atemp1) acc)))))); clear Z bit if hash table needs rehashing; allowed to clobber atemp0, atemp1, da, db; Update later to interact appropriately with EGC(deflapgen %needs-rehashing-p (hash)  (lap-instr   `(progn      (movereg ,hash atemp0)      (move.l (a5 $fwdnum) da)      (if# (ne (svref atemp0 nhash.fixnum) da)        (move.l (svref atemp0 nhash.gc-count) da)        (move.l (svref atemp0 nhash.vector) atemp1)        (move.b (svref atemp1 nhash.vector.flags) db)        (if# mi          ; GC is tracking key movement          (btst ($ $nhash_lap_key_moved_bit) db)         else#          ; GC is not tracking key movement.          (if# (eq (btst ($ $nhash_lap_key_moved_bit) db))            ; key_moved_bit clear means only rehash on full gc or growzone.            (cmp.l (a5 $relocnum) da)))))))            (defmacro %needs-rehashing-p (hash)  `(lap-inline (,hash)     (movereg arg_z acc)     (if# (eq (%needs-rehashing-p acc))       (move.l nilreg acc))))(defmacro %does-not-need-rehashing (hash)  `(lap-inline (,hash)     (move.l arg_z atemp0)     (move.l (a5 $fwdnum) (svref atemp0 nhash.fixnum))     (move.l (a5 $relocnum) (svref atemp0 nhash.gc-count))     (move.l (svref atemp0 nhash.vector) atemp1)     (if# (mi (tst.b (svref atemp1 nhash.vector.flags)))       (bclr ($ $nhash_lap_key_moved_bit) (svref atemp1 nhash.vector.flags))))); Declare that a hash table needs rehashing.; Clobbers atemp1.  Clobbers atemp0 unless HASH is atemp0.; compute-hash-code assumes that this preserves acc(deflapgen %needs-rehashing (hash)  (lap-instr   `(progn      (movereg ,hash atemp0)      (move.l (a5 $fwdnum) (svref atemp0 nhash.fixnum))      (sub.l '1 (svref atemp0 nhash.fixnum))      (move.l (a5 $relocnum) (svref atemp0 nhash.gc-count))      (sub.l '1 (svref atemp0 nhash.gc-count))      (move.l (svref atemp0 nhash.vector) atemp1)      (if# (mi (tst.b (svref atemp1 nhash.vector.flags)))        (bset ($ $nhash_lap_key_moved_bit) (svref atemp1 nhash.vector.flags))))))(defmacro %needs-rehashing (hash)  `(lap-inline (,hash)     (%needs-rehashing arg_z))); Mixup a hash code so that dividing by the table length will randomize.; fixnum in implies fixnum out.(deflapgen mixup-hash-code (dreg)  (lap-instr   `(progn      (vpush ,dreg)      (add.b ,dreg @vsp)      (vpop ,dreg))))(defmacro mixup-hash-code (fixnum)  `(lap-inline (,fixnum)     (mixup-hash-code arg_z)     (movereg arg_z acc))); A more thorough mixing for use when you want to add up a bunch of characters.(deflapgen rotate-hash-code (dreg &optional temp-reg)  (lap-instr   `(progn      (lsr.l 3 ,dreg)      ,(if temp-reg         `(movereg ,dreg ,temp-reg)         `(vpush ,dreg))      (move.l ($ 7) ,dreg)      ,@(if temp-reg          `((and.w ,temp-reg ,dreg)            (eor.w ,dreg ,temp-reg)            (swap ,temp-reg)            (eor.w ,dreg ,temp-reg)            (swap ,temp-reg))          `((and.w (vsp 2) ,dreg)       ; low three bits            (eor.w ,dreg (vsp 2))       ; clear low three bits on stack            (eor.w ,dreg @vsp)))        ; eor in times 64K      (ror.l 3 ,dreg)      ,(if temp-reg         `(add.l ,temp-reg ,dreg)         `(add.l vsp@+ ,dreg)))))(defmacro rotate-hash-code (fixnum)  `(the fixnum        (lap-inline (,fixnum)          (rotate-hash-code arg_z arg_y)          (movereg arg_z acc)))); This will eventually be a subprim.; Call with a relocatable object, not a fixnum, short float, or immediate.; clobbers atemp0; returns with Z bit set if the object is ephemeral(deflapgen ephemeral-p (dreg)  (lap-instr   `(progn      (move.l (a5 $Pdynamic_cons_area) atemp0)      (if# (and (ls (cmp.l (atemp0 $cons-area.ispace-start) ,dreg))                (hi (cmp.l (atemp0 $cons-area.gspace-end) ,dreg)))        (move.l (a5 $Pdefault_cons_area) atemp0)        (cmp.l (a5 $Pe0cons_area) atemp0)       else#        (tst.l ,dreg))))); Compute hash code for %hash-probe, %rehash-probe, & %growhash-probe.; maybe-rehash-p is true if we need to funcall the nhash.rehashF in which; case updating that function is conditional.; Assumes register definitions exist for:; HASH, EPHEMERAL-P, KEY, PRIMARY, ADDRESSP, DIVTEMP, VECTOR, VLEN; if maybe-rehash-p is true, also assumes there's a definition for; UPDATE-MAYBE-REHASH, that VECTOR is the value of (svref HASH nhash.vector),; and that this macro is called while their are preserved registers plus; one more longword on the vstack (this is what %hash-probe does, and it is; the only caller that passes true for maybe-rehash-p).; All registers are assumed to be saved registers except ADDRESSP & EPHEMERAL-P; inputs:  HASH, VECTOR, KEY, UPDATE-MAYBE-REHASH; outputs: PRIMARY, VLEN; maybe-rehash-p is t from %hash-probe, nil from %rehash-probe; update-maybe-rehash is t from puthash nil otherwise - I dont get it yet.(deflapgen compute-hash-code (maybe-rehash-p &optional (normalize-p t))  (lap-instr   `(progn@retry      (move.l (svref HASH nhash.keytransF) da)      (if# (eq (dtagp da $t_fixnum))        ; not EQ or EQL hash table        (vpush (a5 $fwdnum))      ; it's a fixnum        (move.l da atemp0)        (move.l KEY arg_z)        (set_nargs 1)        (jsr_subprim $sp-mvfpass)        (if# (ne (sub.w ($ 4) nargs))          ; no values returned          (if# mi            (move.l KEY PRIMARY)            (move.l nilreg ADDRESSP)            (move.l nilreg EPHEMERAL-P)           else#            ; 2 or more values returned            (if# (pl (sub.w ($ 8) nargs))              ; 3 or more values returned              (add.w nargs vsp)              (vpop EPHEMERAL-P)             else#              (move.l nilreg EPHEMERAL-P))            ; 2 values returned            (vpop ADDRESSP)            (vpop PRIMARY))         else#          ; 1 value returned.          (vpop PRIMARY)          (move.l nilreg ADDRESSP)          (move.l nilreg EPHEMERAL-P))        (vpop da)                       ; $fwdnum        ,@(when maybe-rehash-p            ; vector may have changed due to growing            '((move.l (svref HASH nhash.vector) VECTOR)))        (if# (and (ne (a5 $fwdnum) da)                  (or (ne (cmp.l nilreg ADDRESSP))                      (eq (dtagp PRIMARY $t_fixnum $t_sfloat $t_imm))))          ; GC happenned while computing address-based hash code.  Try again.          ; should probably be smarter about ephemeral-p here.          (bra @retry))        (move.l PRIMARY acc)        (move.w ($ -8) da)        (and.w da PRIMARY)        (if# (eq (dtagp acc $t_fixnum $t_sfloat $t_imm))          (mixup-hash-code PRIMARY)          (move.l ':key ADDRESSP)          (if# (eq (ephemeral-p acc))            (move.l '1 EPHEMERAL-P))          (bra @maybe-rehash))        (bif (eq (cmp.l nilreg ADDRESSP)) @mod)        (bra @maybe-rehash))            ; EQ or EQL hash table      (if# (ne (tst.l da))        ; EQL hash table        (bif (eq (dtagp KEY $t_dfloat $t_vector)) @eq-keytrans)        (ccall %%eqlhash-internal KEY)        (move.l acc PRIMARY)       else#@eq-keytrans        ; EQ hash table        (move.l KEY PRIMARY))      (if# (ne (dtagp PRIMARY $t_fixnum $t_sfloat $t_imm))        (move.w ($ -8) da)        (and.w da PRIMARY)        (mixup-hash-code PRIMARY)        (bra @mod))      (move.l ':key ADDRESSP)      (move.l nilreg EPHEMERAL-P)      (if# (eq (ephemeral-p PRIMARY))        (move.l '1 EPHEMERAL-P))      (move.w ($ -8) da)      (and.w da PRIMARY)      (mixup-hash-code PRIMARY)      @maybe-rehash      ,@(when maybe-rehash-p          '(            ; Might need to rehash.            ;Won't execute this code unless the hash code depended on an address.            (move.l (svref HASH nhash.rehashF) atemp0)            (move.l HASH arg_z)            (vpush ADDRESSP)            (vpush EPHEMERAL-P)            (set_nargs 1)            (jsr @atemp0)            (vpop EPHEMERAL-P)            (vpop ADDRESSP)            (if# (and (ne (cmp.l nilreg acc))                      (ne (tst.l acc)))              (move.l (svref HASH nhash.vector) VECTOR)         ; may have grown              (bra @retry))))            ; Update rehashing bits if requested to do so      ; This code must preserve ACC until it's tested below.      (,@(if maybe-rehash-p '(if# (ne (cmp.l nilreg UPDATE-MAYBE-REHASH))) '(progn))        ; God save you if you (fmakunbound '%maybe-rehash)        ; probably wants to be stored in a special eventually to save a cycle        (move.l '%maybe-rehash atemp0)        (move.l (atemp0 $sym.entrypt) (svref HASH nhash.rehashF))        (move.b (svref VECTOR nhash.vector.flags) da)        (if# (ne (cmp.l nilreg EPHEMERAL-P))          (bset ($ $nhash_lap_ephemeral_bit) da))        (if# (eq (cmp.l ':key ADDRESSP))          (if# (eq (btst ($ $nhash_lap_component_address_bit) da))            (if# (eq (bset ($ $nhash_lap_track_keys_bit) da))              (bclr ($ $nhash_lap_key_moved_bit) da))           else#            (if# (ne (cmp.l nilreg EPHEMERAL-P))              (bset ($ $nhash_lap_key_moved_bit) da)))         else#          (bclr ($ $nhash_lap_track_keys_bit) da)          (bset ($ $nhash_lap_component_address_bit) da)          (if# (ne (btst ($ $nhash_lap_ephemeral_bit) da))            (bset ($ $nhash_lap_key_moved_bit) da)           elseif# (and (ne (bclr ($ $nhash_lap_key_moved_bit) da))                        (mi (tst.b (svref VECTOR nhash.vector.flags))))            ; GC moved a key, but we're disabling that feature.  Remember rehash necessity            (move.b da (svref VECTOR nhash.vector.flags))            (%needs-rehashing HASH)            (move.b (svref VECTOR nhash.vector.flags) da)))        (move.b da (svref VECTOR nhash.vector.flags)))            ,@(when maybe-rehash-p          '((if# (eq (tst.l acc))              ; Table is locked and needs rehashing              (move.l HASH arg_y)              (move.l KEY arg_z)              (lea (vsp 4) vsp)         ; pop saved update-maybe-rehash              (unuse_regs)              (cjmp %hash-linear-probe arg_y arg_z))))      @mod      (vsize VECTOR VLEN)      (sub.l ($ (* 4 $nhash.vector_overhead)) VLEN)      ,@(when normalize-p          `((move.l PRIMARY SECONDARY)        ; save original hash code.            (move.l PRIMARY DIVTEMP)            (divul.l VLEN (PRIMARY DIVTEMP))))      ))); Clears the Z bit if the PRIMARY'th bit is set in *rehash-bits*; Clobbers atemp0, da, db; PRIMARY is a fixnum denoting the bit number.(deflapgen %already-rehashed-p (primary rehash-bits)  (lap-instr   `(progn      (move.l ,rehash-bits atemp0)      (add ($ $v_data) atemp0)      (move.l ,primary da)      (lsr.l ($ $fixnumshift) da)      (move.l da db)      (lsr.l 3 da)      (btst db (atemp0 da.l))))); Sets the primary'th bit in *rehash-bits*(deflapgen %set-already-rehashed-p (primary rehash-bits)  (lap-instr   `(progn      (move.l ,rehash-bits atemp0)      (lea (atemp0 $v_data) atemp0)      (move.l ,primary da)      (lsr.l ($ $fixnumshift) da)      (move.l da db)      (lsr.l 3 da)      (bset db (atemp0 da.l)))))(defmacro %already-rehashed-p (primary rehashed-bits)  `(lap-inline (,primary ,rehashed-bits nil)     (movereg arg_z acc)     (if# (ne (%already-rehashed-p arg_x arg_y))       (add.l ($ $t_val) acc))))(defmacro %set-already-rehashed-p (primary rehashed-bits)  `(lap-inline (,primary ,rehashed-bits)     (%set-already-rehashed-p arg_y arg_z)     (move.l arg_y acc))); HASH should be a data register; Set Z bit if it is a hash table; moves HASH into atemp0(deflapgen %hash-table-p (hash)  (let ((lab (gensym)))    (lap-instr     `(progn        (if# (eq (dtagp ,hash $t_vector))          (move.l ($ 1) da)          (bra ,lab))        (bif (ne (progn (move.l ,hash atemp0)                        (move.l 'hash-table da)                        (cmp.l (atemp0 $v_data) da)))             ,lab)        (vsubtypep ($ $v_istruct) atemp0 da)        ,lab)))); This must be uninterruptable for its use in puthash(defmacro %normalize-hash-table-count (hash)  `(lap-inline (,hash)     (move.l arg_z atemp0)     (move.l (svref atemp0 nhash.vector) atemp1)     (move.l (svref atemp1 nhash.vector.weak-deletions-count) da)     (if# ne       (move.l '0 (svref atemp1 nhash.vector.weak-deletions-count))       (add.l da (svref atemp1 nhash.vector.deleted-count))       (sub.l da (svref atemp0 nhash.count))))); state is #(index vector hash-table saved-lock)(def-accessors %svref  hti.index  hti.vector  hti.hash-table  hti.lock  hti.locked-additions); hashes the double float in fp1; result -> acc; clobbers dy(deflapgen fp1-hash ()  (lap-instr   `(progn      (sub ($ 8) sp)      (fmove.d fp1 @sp)      (spop acc)      (spop dy)      (rol.l ($ 3) acc)      (add.w acc dy)      (swap acc)      (ror.w acc dy)      (rol.l dy acc)      (eor.l dy acc)      (mkint acc)      (mixup-hash-code acc)))))   ; end of EVAL-WHEN(defun index->vector-index (index)  (declare (fixnum index))  (the fixnum (+ $nhash.vector_overhead (the fixnum (+ index index)))))(defun vector-index->index (index)  (declare (fixnum index))  (the fixnum (ash (the fixnum (- index $nhash.vector_overhead)) -1)))(defun %cons-hash-table (rehash-function keytrans-function compare-function vector                                             threshold rehash-ratio rehash-size)  (%gvector $v_istruct            'HASH-TABLE             ; type            rehash-function             ; nhash.rehashF            keytrans-function           ; nhash.keytransF            compare-function            ; nhash.compareF            nil                         ; nhash.rehash-bits            vector                      ; nhash.vector            0                           ; nhash.lock            0                           ; nhash.count            nil                         ; nhash.locked-additions             (get-fwdnum)                ; nhash.fixnum            (gc-count)                  ; nhash.gc-count            threshold                   ; nhash.grow-threshold            rehash-ratio                ; nhash.rehash-ratio            rehash-size                 ; nhash.rehash-size            0))                         ; nhash.puthash-count(defun %cons-nhash-vector (size &optional (flags 0))  (declare (fixnum size))  (let* ((vector (%make-uvector (+ size size $nhash.vector_overhead) $v_nhash (%unbound-marker-8))))    (setf (nhash.vector.link vector) 0          (nhash.vector.flags vector) flags          (nhash.vector.free-alist vector) nil          (nhash.vector.finalization-alist vector) nil          (nhash.vector.weak-deletions-count vector) 0          (nhash.vector.hash vector) nil          (nhash.vector.deleted-count vector) 0          (nhash.vector.cache-key vector) (%unbound-marker-8)          (nhash.vector.cache-value vector) nil          (nhash.vector.cache-idx vector) nil)    vector))(defun make-hash-table (&key (test 'eql)                             (size 60)                             (rehash-size 1.5)                             (rehash-threshold .85)                             (hash-function nil)                             (weak nil)                             (finalizeable nil))  (unless (and test (or (functionp test) (symbolp test)))    (report-bad-arg test '(and (not null) (or symbol function))))  (unless (or (functionp hash-function) (symbolp hash-function))    (report-bad-arg hash-function '(or symbol function)))  (unless (and (realp rehash-threshold) (<= 0.0 rehash-threshold 1.0))    (report-bad-arg rehash-threshold '(real 0 1)))  (unless (or (fixnump rehash-size) (and (realp rehash-size) (< 1.0 rehash-size)))    (report-bad-arg rehash-size '(or fixnum (real 1 *))))  (setq rehash-threshold (/ 1.0 (max 0.01 rehash-threshold)))  (let ((default-hash-function          (cond ((or (eq test 'eq) (eq test #'eq))                  (setq test 0))                ((or (eq test 'eql) (eq test #'eql))                  (setq test -1))                ((or (eq test 'equal) (eq test #'equal))                 (setq test #'equal) #'%%equalhash)                ((or (eq test 'equalp) (eq test #'equalp))                 (setq test #'equalp) #'%%equalphash)                ((null hash-function)                 (error "No hash-function specified for non-standard test"))                (t (setq test (require-type test 'symbol))                   hash-function))))    (setq hash-function          (if hash-function            (require-type hash-function 'symbol)            default-hash-function)))  (when (and weak (neq weak :value) (neq test 0))    (error "Only EQ hash tables can be weak."))  (when (and finalizeable (not weak))    (error "Only weak hash tables can be finalizeable."))  (multiple-value-bind (size total-size)                       (compute-hash-size (1- size) 1 rehash-threshold)    (let* ((flags (if weak                    (+ (ash 1 $nhash_weak_bit)                       (ecase weak                         ((t :key) 0)                         (:value (ash 1 $nhash_weak_value_bit)))                       (if finalizeable (ash 1 $nhash_finalizeable_bit) 0))                    0))           (hash (%cons-hash-table                   #'%no-rehash hash-function test                  (%cons-nhash-vector total-size flags)                  size rehash-threshold rehash-size)))      (setf (nhash.vector.hash (nhash.vector hash)) hash)      hash)))(defun compute-hash-size (size rehash-size rehash-ratio)  (let* ((new-size size))    (setq new-size (max 30 (if (fixnump rehash-size)                             (+ size rehash-size)                             (ceiling (* size rehash-size)))))    (if (<= new-size size)      (setq new-size (1+ size)))        ; God save you if you make this happen        (values new-size             (%hash-size (max (+ new-size 2) (ceiling (* new-size rehash-ratio))))))); Suggested size is a fixnum: number of pairs.;  Return a fixnum >= that size that is relatively prime to all secondary keys.(defun %hash-size (suggestion)  (if (<= suggestion #.(aref secondary-keys 7))    (setq suggestion (+ 2 #.(aref secondary-keys 7)))    (if (evenp suggestion) (incf suggestion)))  (lap-inline (secondary-keys suggestion)    (move.l arg_y atemp1) @try    (lea (atemp1 $v_data) atemp0)    (moveq 8 db)    (dbfloop db              (move.l atemp0@+ da)             (move.l arg_z arg_y)             (divul.l da (dx arg_y))             (tst.l dx)                 ; Remainder 0 ?             (if# eq                    ; Then not relatively prime, try again               (add.l '1 arg_z)               (add.l '1 arg_z)               (bra @try)))))(defvar *hash-table-class* (make-built-in-class 'hash-table *istruct-class*))(defmacro %hash-table-p (hash)  `(lap-inline (,hash)     (movereg arg_z acc)     (if# (ne (%hash-table-p acc))       (move.l nilreg acc))))(defun hash-table-p (hash)  (%hash-table-p hash))(setf (type-predicate 'hash-table) 'hash-table-p); what if somebody is mapping, growing, rehashing? (defun clrhash (hash)  (unless (%hash-table-p hash)    (report-bad-arg hash 'hash-table))  ;(when (neq 0 (nhash.lock hash))(dbg (nhash.lock hash)))  (without-interrupts   (let* ((vector (nhash.vector hash))          (size (nhash.vector-size vector)))     (lap-inline ()       (:variable vector size)       (move.l (varg vector) atemp0)       (move.l (varg size) da)       (lea (atemp0 $nhash_data) atemp0)       (lsr.l 2 da)                     ; fixnum (bytes) -> longwords       (move.l ($ $undefined) acc)       (bra @initdb)       (dbfloop.l da         (move.l acc atemp0@+)         (if# (eq (sub.w ($ 1) db))           (move.l atemp0 acc)           (sub.l (varg vector) acc)           (mkint acc)           (vpush acc)           (mkint da)           (vpush da)           (jsr_subprim $sp-eventch)           (vpop da)           (getint da)           (vpop acc)           (getint acc)           (add.l (varg vector) acc)           (move.l acc atemp0)           (move.l ($ $undefined) acc)           @initdb           (move.w ($ #x1000) db))))     (incf (the fixnum (nhash.grow-threshold hash))           (the fixnum (+ (the fixnum (nhash.count hash))                          (the fixnum (nhash.vector.deleted-count vector)))))     (setf (nhash.count hash) 0           (nhash.locked-additions hash) nil           (nhash.vector.cache-key vector) (%unbound-marker-8)           (nhash.vector.cache-value vector) nil           (nhash.vector.finalization-alist vector) nil           (nhash.vector.free-alist vector) nil           (nhash.vector.weak-deletions-count vector) 0           (nhash.vector.deleted-count vector) 0           (nhash.vector.flags vector) (logand $nhash_weak_flags_mask                                               (nhash.vector.flags vector))))   hash))(defun hash-table-count (hash)  (if (nhash.locked-additions (require-type hash 'hash-table))    (add-locked-additions hash))  (%normalize-hash-table-count hash)  (+ (the fixnum (nhash.count hash))     (the fixnum (length (nhash.locked-additions hash)))))(defun hash-table-rehash-size (hash)  (nhash.rehash-size (require-type hash 'hash-table)))(defun hash-table-rehash-threshold (hash)  (/ 1.0 (nhash.rehash-ratio (require-type hash 'hash-table))))(defun hash-table-size (hash)  (+ (the fixnum (hash-table-count hash))     (the fixnum (nhash.grow-threshold hash))     (the fixnum (nhash.vector.deleted-count (nhash.vector hash)))))(defun hash-table-test (hash)  (let ((f (nhash.compareF (require-type hash 'hash-table))))    (if (fixnump f)      (if (eql 0 f) 'eq 'eql)      (let ((name (if (symbolp f) f (function-name f))))        (if (memq name '(equal equalp)) name f))))); sometimes you'd rather have the function than the symbol.(defun hash-table-test-function (hash)  (let ((f (nhash.compareF (require-type hash 'hash-table))))    (if (fixnump f)      (if (eql 0 f) #'eq #'eql)      f)))#| ; below all in lib;hash.lisp(defun hash-table-finalization-list (&lap hash-table)  (lap    (if# (ne (%hash-table-p arg_z))      (wtaerr arg_z 'hash-table))    (move.l arg_z atemp0)    (move.l (svref atemp0 nhash.vector) atemp0)    (if# (eq (btst ($ $nhash_lap_finalizeable_bit) (atemp0 $nhash.vector-weak-byte)))      (wtaerr arg_z 'hash-table))  ; this aint right      ;(wtaerr arg_z '"finalizeable hash table")) ; but this wasnt either    (move.l (svref atemp0 nhash.vector.finalization-alist) acc)    (rts)))(defun (setf hash-table-finalization-list) (&lap value hash-table)    (lap    (if# (ne (%hash-table-p arg_z))      (wtaerr arg_z 'hash-table))    (move.l arg_z atemp0)    (move.l (svref atemp0 nhash.vector) atemp0)    (if# (eq (btst ($ $nhash_lap_finalizeable_bit) (atemp0 $nhash.vector-weak-byte)))      (wtaerr arg_z '"finalizeable hash table"))    (move.l arg_y (svref atemp0 nhash.vector.finalization-alist))    (move.l arg_y acc)    (rts))) (defmethod print-object ((table hash-table) stream)  (print-unreadable-object (table stream :type t :identity t)    (format stream "~S ~S size ~D/~D~:[ Locked~]"            ':test (hash-table-test table)            (hash-table-count table)            (hash-table-size table)            (eql (nhash.lock table) 0))))|##| ; this version gets the "this can't happen" error(defun puthash (key hash default &optional (value default) &aux vector)    (unless (%hash-table-p hash)    (report-bad-arg hash 'hash-table))  (setq vector (nhash.vector hash))  (when (and (eq key (nhash.vector.cache-key vector))             (eq 0 (%ilogand (nhash.lock hash) $nhash.lock-grow-or-rehash))) ; while growing or rehashing, can't mod vector    (return-from puthash      (lap-inline ()        (:variable value vector)        (move.l (varg vector) atemp0)        (move.l (svref atemp0 nhash.vector.cache-idx) arg_y)        (move.l (varg value) acc)        (move.l acc (atemp0 arg_y.l (+ $nhash_data 4)))        (move.l acc (svref atemp0 nhash.vector.cache-value)))))    (when (and (neq 0 (nhash.lock hash))             (or (neq 0 (%ilogand (nhash.lock hash) $nhash.lock-grow-or-rehash))                 (%needs-rehashing-p hash)))                   (let ((cell (nhash-locked-additions-cell key hash t)))  ; its a macro - lets not say it 49 times       (declare (cons cell))       ; Table must be locked, add to locked-additions alist       (setf (nhash.vector.cache-key vector) (%unbound-marker-8)             (nhash.vector.cache-value vector) nil)       (setf (car cell) key             (cdr cell) value)       (return-from puthash value)))  (when (nhash.locked-additions hash)          ; may be left over from an aborted map    (add-locked-additions hash))   ; It is important that we are non-interruptable between the time   ; that %hash-probe decides on an index and when we actually put   ; the key/value pair in the table at that index.  (let ((level *interrupt-level*))    (without-interrupts  ; added this  - dont trust it otherwise     (multiple-value-bind (foundp old-val index) (%hash-probe hash key 1)       (declare (ignore old-val))       (unless foundp         (unless index                   ; null index = locked and needs rehash           ; who says it cant happen - maybe it cant now that bug is fixed?           (cerror "foo" "Table became locked during PUTHASH.  This can't happen. ~X"                   (nhash.lock hash))           ; flet this? or remove this use.           (let ((cell (nhash-locked-additions-cell key hash t)))             (declare (cons cell))             ; Table must be locked, add to locked-additions alist             (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                   (nhash.vector.cache-value vector) nil)             (setf (car cell) key                   (cdr cell) value)             (return-from puthash value)))         (when (eql 0 (nhash.grow-threshold hash))           (when (neq 0 (nhash.lock hash))             (let ((cell (nhash-locked-additions-cell key hash t)))               (declare (cons cell))               ; Table must be locked, add to locked-additions alist               (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                     (nhash.vector.cache-value vector) nil)               (setf (car cell) key                     (cdr cell) value)               (return-from puthash value)))           ; lock it now then allow interrupts           ; this wont prevent somebody from starting a maphash between now and decision to rehash           (setf (nhash.lock hash) (%ilogior (nhash.lock hash) $nhash.lock-while-growing))           (setq *interrupt-level* level)           (return-from puthash (grow-hash-table hash key value)))                (lap-inline ()           (:variable hash)           (move.l (varg hash) atemp0)           (sub.l '1 (svref atemp0 nhash.grow-threshold))           (add.l '1 (svref atemp0 nhash.count))))       (lap-inline ()         (:variable key value hash index foundp)         (move.l (varg hash) atemp1)         (add.l '1 (svref atemp1 nhash.puthash-count))         (move.l (svref atemp1 nhash.vector) atemp0)         (move.b (atemp0 $nhash.vector-weak-byte) db)      ; save weak flags         (move.l (varg index) arg_x)         (lea (atemp0 arg_x.l $nhash_data) atemp0)         (move.l (varg key) da)         (move.l da atemp0@+)         (move.l (varg value) acc)         (move.l @atemp0 arg_y)            ; old value         (move.l acc @atemp0)         (move.l (svref atemp1 nhash.vector) atemp0)         (move.l da (svref atemp0 nhash.vector.cache-key))         (move.l acc (svref atemp0 nhash.vector.cache-value))         (move.l arg_x (svref atemp0 nhash.vector.cache-idx))         (if# (eq (cmp.l (varg foundp) nilreg))           (if# (eq (cmp.l arg_y nilreg))             ; Writing over a deleted entry.  Adjust deleted-count             (move.l (svref atemp1 nhash.vector) atemp0)             (if# (mi (sub.l '1 (svref atemp0 nhash.vector.deleted-count)))               (move.l (svref atemp0 nhash.vector.weak-deletions-count) da)               (clr.l (svref atemp0 nhash.vector.weak-deletions-count))               (add.l da (svref atemp0 nhash.vector.deleted-count))               (sub.l da (svref atemp1 nhash.count)))             (add.l '1 (svref atemp1 nhash.grow-threshold)))           (if# (ne (btst ($ $nhash_lap_finalizeable_bit) db))             ; new entry is finalizeable.  Push a cell on the free-alist             (vpush acc)             (move.l nilreg arg_z)             (jsr_subprim $sp-consznil)             (movereg acc arg_z)             (jsr_subprim $sp-consznil)             (move.l acc atemp1)             (vpop acc)             (move.l (varg hash) atemp0)             (move.l (svref atemp0 nhash.vector) atemp0)             (move.l (svref atemp0 nhash.vector.free-alist) (cdr atemp1))             (move.l atemp1 (svref atemp0 nhash.vector.free-alist)))))))))|#; from 4.0(defun puthash (key hash default &optional (value default))  (unless (hash-table-p hash)    (report-bad-arg hash 'hash-table))  (when (and (eq 0 (nhash.lock hash))             (%needs-rehashing-p hash))    (%rehash hash))  (let ((level *interrupt-level*))    (without-interrupts ; ???     ;(multiple-p hash key) ;49     (let ((vector (nhash.vector  hash)))            (when (and (eq key (nhash.vector.cache-key vector))                  (eql 0 (%ilogand (nhash.lock hash) $nhash.lock-grow-or-rehash))) ; while growing or rehashing, can't mod vector         (let* ((idx (nhash.vector.cache-idx vector)))           (declare (fixnum idx))           (setf (%svref vector (the fixnum (1+ (the fixnum (index->vector-index idx)))))                 value)           (setf (nhash.vector.cache-value vector) value)           (return-from puthash value)))                      (when (or (neq 0 (%ilogand (nhash.lock hash) $nhash.lock-grow-or-rehash))                 (and nil (neq 0 (nhash.lock hash))  ; we could see if its already there? - DO LINEAR BELOW                      (%needs-rehashing-p hash)))         (let ((cell (nhash-locked-additions-cell key hash t)))           (declare (cons cell))           ; Table must be locked, add to locked-additions alist           (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                 (nhash.vector.cache-value vector) nil)           (setf (car cell) key                 (cdr cell) value)           (return-from puthash value)))       (when (nhash.locked-additions hash)          ; may be left over from an aborted map         (add-locked-additions hash))       (when (nhash.locked-additions hash)         (let ((cell (nhash-locked-additions-cell key hash)))           (declare (list cell))           (when cell             (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                   (nhash.vector.cache-value vector) nil)             (setf (cdr cell) value)             (return-from puthash value))))       (when (neq 0 (%ilogand (nhash.lock hash) $nhash.lock-grow-or-rehash)) ; sunday added         (return-from puthash (puthash key hash value)))       ; It is important that we are non-interruptable between the time       ; that %hash-probe decides on an index and when we actually put       ; the key/value pair in the table at that index.       (let () ;((level *interrupt-level*))         (progn ;without-interrupts  ; already woi           (setq vector (nhash.vector hash))  ; maybe changed           (multiple-value-bind (foundp old-val index) (%hash-probe hash key 1)             (declare (ignore-if-unused old-val))             (when (and nil (not foundp)(null index)) ; %hash-probe did this already in 3.1               ; table locked and needs rehash               (multiple-value-setq (foundp old-val index) (%hash-linear-probe hash key)))             (when (not foundp)               (when (or (null index) ; null index = locked and needs rehash and not already there                         (and (eql 0 (nhash.grow-threshold hash))  ; 7/96 - merged two cases - lose cerror                              (neq 0 (nhash.lock hash))))                                  ;(incf n4)                 (let ((cell (nhash-locked-additions-cell key hash t)))                   (declare (cons cell))                   ; Table is locked and needs rehash or wants to grow                   (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                         (nhash.vector.cache-value vector) nil)                   (setf (car cell) key                         (cdr cell) value)                   (return-from puthash value)))               (when (< (the fixnum (nhash.grow-threshold hash)) 0)                 (cerror "a" "negative grow ~s" (nhash.grow-threshold hash)))               (when (eql 0 (nhash.grow-threshold hash))                                  ; lock it now then allow interrupts                 ; this wont prevent somebody from starting a maphash between now and decision to rehash                                  (unwind-protect                   (progn                     (setf (nhash.lock hash) (%ilogior (nhash.lock hash) $nhash.lock-while-growing))                     (setq *interrupt-level* level) ; <<<                     (grow-hash-table hash key value))                   (setf (nhash.lock hash)(%ilogand (nhash.lock hash)                                            #.(%ilognot $nhash.lock-while-growing))))                 (return-from puthash (puthash key hash value)))               (decf (the fixnum (nhash.grow-threshold hash)))               (incf (the fixnum (nhash.count hash))))             (locally (declare (fixnum index))               (incf (the fixnum (%svref hash nhash.puthash-count)))               (let ((flags (nhash.vector.flags vector))                     (vector-index (index->vector-index index)))                 (declare (fixnum flags vector-index))                 #-ppc-target (setf (%svref vector vector-index) key)                 #+ppc-target (%set-hash-table-vector-key vector vector-index key)                 (incf vector-index)                 (let ((old-value (%svref vector vector-index)))    ; ---can this be the old-val from %hash-probe?                   (setf (%svref vector vector-index) value                         (nhash.vector.cache-idx vector) index                         (nhash.vector.cache-key vector) key                         (nhash.vector.cache-value vector) value)                   (when (null foundp)                     (when (null old-value)                       ; Writing over a deleted entry.  Adjust deleted-count                       (when (> 0 (the fixnum (decf (the fixnum (nhash.vector.deleted-count vector)))))                         (let ((weak-deletions (nhash.vector.weak-deletions-count vector)))                           (declare (fixnum weak-deletions))                           (setf (nhash.vector.weak-deletions-count vector) 0)                           (incf (the fixnum (nhash.vector.deleted-count vector)) weak-deletions)                           (decf (the fixnum (nhash.count hash)) weak-deletions)))                       (incf (the fixnum (nhash.grow-threshold hash)))                       (when (logbitp $nhash_finalizeable_bit flags)                         ; new entry is finalizeable.  Push a cell on the free-alist                         (push (cons nil nil) (nhash.vector.free-alist vector))))))))))         ;(multiple-p hash key)  ; 49         (when nil ;(neq value (gethash key hash default))           (cerror "put" "put"))         value)))))(defsetf gethash puthash)#| ; too slow, but save for documentation(defun gethash (key hash &optional default &aux vector)  (unless (%hash-table-p hash)    (report-bad-arg hash 'hash-table))  (if (eq key (nhash.vector.cache-key (setq vector (nhash.vector hash))))    (values (nhash.vector.cache-value vector) t)    (progn      (when (and (nhash.locked-additions hash)      ; may be left over from an aborted map                 (not (add-locked-additions hash)))        (let ((cell (nhash-locked-additions-cell key hash)))          (declare (list cell))          (when cell            (return-from gethash              (if (eq (cdr cell) (%unbound-marker-8))              (values default nil)              (values (cdr cell) t))))))      (multiple-value-bind (foundp value index) (%hash-probe hash key nil)        (if foundp          (progn            (setf (nhash.vector.cache-key (setq vector (nhash.vector hash))) key                  (nhash.vector.cache-value vector) value                  (nhash.vector.cache-idx vector) index)            (values value t))          (values default nil))))))|#; do gethash without interrupts using linear search; called by gethash if rehashing or (if growing and need rehashing).; seems hardly more time woi than copying the vector (woi); and much less space consuming; cant seem to get this to happen in real life - tested by setting rehashing bit at toplevel(defun gethash-woi (key hash default)  (without-interrupts   ; either this guy has to look at locked additions or...   (when (nhash.locked-additions hash)     (let ((cell (nhash-locked-additions-cell key hash)))       (declare (list cell))       (when cell         (return-from gethash-woi           (if (eq (cdr cell) (%unbound-marker-8))             (values default nil)             (values (cdr cell) t))))))   (multiple-value-bind (foundp value)     (%hash-linear-probe hash key)     (values (if foundp value default) foundp))))(defun gethash (key hash &optional default)  (lap-inline ()    (:variable key hash default)    (move.l (varg hash) arg_x)    (if# (ne (%hash-table-p arg_x))      ;(dc.w #_debugger)      (ccall %badarg arg_x 'hash-table))    (move.l (varg key) arg_y)    (move.l (svref atemp0 nhash.vector) atemp1)    (if# (eq (cmp.l (svref atemp1 nhash.vector.cache-key) arg_y))      (move.l @sp vsp)      (vpush (svref atemp1 nhash.vector.cache-value))      (vpush 't)      (set_nargs 2)      (jmp_subprim $sp-nvalret))    (move.l (svref atemp0 nhash.lock) da)    ;(dc.w #_debugger)    (if# (or (ne (btst ($ $nhash-lap-rehashing-bit) da))  ;<< changed order             (and (ne (btst ($ $nhash-lap-growing-bit) da))                  (ne (%needs-rehashing-p (varg hash)))))  ; this clobbers da        (tail-ccall gethash-woi (varg key)(varg hash)(varg default)))    (if# (ne (cmp.l (svref atemp0 nhash.locked-additions) nilreg))      ; may be left over from an aborted map      (if# (eq (progn (ccall add-locked-additions atemp0) (cmp.l nilreg acc)))        (move.l (varg hash) atemp0)        (move.l (varg key) arg_y)        (move.l (svref atemp0 nhash.locked-additions) arg_z)        (move.l (svref atemp0 nhash.compareF) da)        (if# (ne (dtagp da $t_fixnum))          (if# (eq (tst.l da))            (jsr_subprim $sp-assq)            (bra @gotit)           else#            (ccall asseql arg_y arg_z)            (bra @gotit))         else#          (ccall assoc arg_y arg_z ':test da))@gotit        (if# (ne (cmp.l nilreg acc))          (move.l acc atemp0)          (move.l ($ $undefined) da)          (move.l (varg default) arg_z)          (move.l @sp vsp)          (if# (eq (cmp.l (cdr atemp0) da))            (vpush arg_z)            (vpush nilreg)           else#            (vpush (cdr atemp0))  ;; <<< was car - twas wrong            (vpush 't))          (set_nargs 2)          (jmp_subprim $sp-nvalret)))      ; restore arg_x and arg_y      (move.l (varg hash) arg_x)      (move.l (varg key) arg_y))    ; hash is already in arg_x    ; key is already in arg_y    (move.l nilreg arg_z)    (set_nargs 3)    (lea #'%hash-probe atemp0)    (jsr_subprim $sp-mvpass)    (if# (ne (cmp.w ($ 12) nargs)) (dc.w #_debugger))    ; three values required    (equate _vtop 12)    (equate _foundp 8)    (equate _value 4)    (equate _index 0)    (if# (eq (vsp _foundp) nilreg)      (move.l (varg default _vtop) arg_y)      (move.l @sp vsp)      (vpush arg_y)      (vpush nilreg)      (set_nargs 2)      (jmp_subprim $sp-nvalret)     else#      (move.l (varg hash _vtop) atemp0)      (vpop acc)      (move.l (svref atemp0 nhash.vector) atemp1)      (move.l (atemp1 acc.l $nhash_data) (svref atemp1 nhash.vector.cache-key))      (move.l acc (svref atemp1 nhash.vector.cache-idx))      (vpop acc)      (move.l acc (svref atemp1 nhash.vector.cache-value))      (move.l @sp vsp)      (vpush acc)                       ; value      (vpush 't)                        ; found      (set_nargs 2)      (jmp_subprim $sp-nvalret))))(defun remhash (key hash)  (unless (%hash-table-p hash)    (report-bad-arg hash 'hash-table))  (let* ((index nil)         (vector (nhash.vector hash)))    (when (neq 0 (%ilogand (nhash.lock hash) $nhash.lock-grow-or-rehash))       ; growing or rehashing.  Not allowed to touch the vector      ;(push 'remhash-while-grow barf)      (return-from remhash        (prog1          (if (eq (gethash key hash (%unbound-marker-8)) (%unbound-marker-8))            nil ; wasnt there anyway            (let ((cell (nhash-locked-additions-cell key hash t)))              (declare (cons cell))              (setf (cdr cell) (%unbound-marker-8))              t))          (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                (nhash.vector.cache-value vector) nil))))        (when (or (and (eq key (nhash.vector.cache-key vector))                   (setf index (nhash.vector.cache-idx vector)))              (when (and (nhash.locked-additions hash)    ; may be left over from an aborted map                         (not (add-locked-additions hash)))                (let ((cell (nhash-locked-additions-cell key hash)))                  (declare (list cell))                  (when (and cell (neq (cdr cell) (%unbound-marker-8)))                    (setf (cdr cell) (%unbound-marker-8))                    (setf (nhash.vector.cache-key vector) (%unbound-marker-8)                          (nhash.vector.cache-value vector) nil)                    (return-from remhash t))))                            (multiple-value-bind (foundp value idx) (%hash-probe hash key nil)                (declare (ignore value))                (setq index idx)                foundp))      (lap-inline ()        (:variable hash index)        (move.l (varg hash) atemp1)        ; always clear the cache cause I'm too lazy to call the comparison function        ; and don't want to keep a possibly deleted key from being GC'd        (move.l (svref atemp1 nhash.vector) atemp0)        (move.l ($ $undefined) acc)        (move.l acc (svref atemp0 nhash.vector.cache-key))        (move.l nilreg (svref atemp0 nhash.vector.cache-value))        ; Update the count        (add.l '1 (svref atemp0 nhash.vector.deleted-count))        (sub.l '1 (svref atemp1 nhash.count))        ; Remove a cons from the free-alist if the table is finalizeable        (if# (and (ne (move.b (atemp0 $nhash.vector-weak-byte) da))                  (ne (btst ($ $nhash_lap_finalizeable_bit) da)))          (move.l (svref atemp0 nhash.vector.free-alist) atemp1)          (move.l (cdr atemp1) (svref atemp0 nhash.vector.free-alist)))        ; Delete the value from the table.        (move.l (varg index) da)        (lea (atemp0 da.l $nhash_data) atemp0)        (move.l acc atemp0@+)           ; $undefined        (move.l nilreg @atemp0)        (move_t acc)))))                ; Found something                  ; Grow the hash table, then add the given (key value) pair.; caller has set lock-while growing (defun grow-hash-table (hash key value)  (unless (%hash-table-p hash)    (report-bad-arg hash 'hash-table))  (let* ((old-vector (nhash.vector hash))         (old-size (nhash.count hash))         (old-total-size (nhash.vector-size old-vector))         (flags 0)         (flags-sans-weak 0)         (weak-flags)         rehashF)    (declare (fixnum old-total-size flags flags-sans-weak weak-flags))    (%normalize-hash-table-count hash)    #|    (unless  (eql 0 (nhash.vector.deleted-count old-vector))                  (%rehash hash)      (return-from grow-hash-table (puthash key hash value)))    |#    ; well we knew lock was 0 when we called this - is it still 0?    (when (and (> (nhash.vector.deleted-count old-vector) 0)               ; make sure nobody started mapping after we allowed interrupts               (eq 0 (%ilogand (nhash.lock hash) $nhash.lock-map-count-mask)))  ; <<<      ; There are enough deleted entries. Rehash to get rid of them      ;(push (format nil "rehash from grow ~x" (nhash.lock hash)) barf)      (%rehash hash)      (setf (nhash.lock hash) (%ilogand (nhash.lock hash)                                #.(%ilognot $nhash.lock-while-growing)))      (return-from grow-hash-table (puthash key hash value)))    (multiple-value-bind (size total-size)                         (compute-hash-size                           old-size (nhash.rehash-size hash) (nhash.rehash-ratio hash))      (unless (eql 0 (nhash.grow-threshold hash))       ; maybe it's done already        (setf (nhash.lock hash) (%ilogand (nhash.lock hash)                                    #.(%ilognot $nhash.lock-while-growing)))        (return-from grow-hash-table (puthash key hash value)))      (unless (eql old-vector (nhash.vector hash))        ; Somebody screwed around with my hash table.  Try again.        (return-from grow-hash-table (grow-hash-table hash key value)))      (unwind-protect        (let ((fwdnum (get-fwdnum))              (gc-count (gc-count))              vector)          (setq flags (nhash.vector.flags old-vector)                flags-sans-weak (logand flags (logxor -1 $nhash_weak_flags_mask))                weak-flags (logand flags $nhash_weak_flags_mask)                rehashF (nhash.rehashF hash))                               (setf (nhash.lock hash) (%ilogior (nhash.lock hash) $nhash.lock-while-growing)                (nhash.rehashF hash) #'%am-growing                (nhash.vector.flags old-vector) flags-sans-weak)      ; disable GC weak stuff          (%normalize-hash-table-count hash)          (setq vector (%cons-nhash-vector total-size 0))          (do ((index 0 (1+ index)))              ((>= index old-total-size))            (declare (fixnum index))            (lap-inline ()              (:variable old-vector vector index hash)              (move.l (varg old-vector) atemp0)              (move.l (varg index) da)              (lea (atemp0 da.l $nhash_data) atemp0)              (move.l atemp0@+ acc)              (move.l ($ $undefined) da)              (if# (ne (cmp.l acc da))                (vpush @atemp0)                (vpush acc)                (ccall %growhash-probe (varg vector 8) (varg hash 8) acc)                (move.l (varg vector 8) atemp0)                (lea (atemp0 acc.l $nhash_data) atemp0)                (vpop atemp0@+)                (vpop @atemp0))))          (setf (nhash.vector.finalization-alist vector)                (nhash.vector.finalization-alist old-vector)                (nhash.vector.free-alist vector)                (nhash.vector.free-alist old-vector)                (nhash.vector.flags vector)                (logior weak-flags (the fixnum (nhash.vector.flags vector))))          (lap-inline ()            (:variable hash)            (move.l (varg hash) atemp0)            (add.l '1 (svref atemp0 nhash.puthash-count)))          (setf (nhash.rehash-bits hash) nil                (nhash.vector hash) vector                (nhash.vector.hash vector) hash                (nhash.vector.cache-key vector) (%unbound-marker-8)                (nhash.vector.cache-value vector) nil                (nhash.fixnum hash) fwdnum                (nhash.gc-count hash) gc-count                (nhash.grow-threshold hash) (- size (nhash.count hash))                (nhash.lock hash) (%ilogand (nhash.lock hash)                                    #.(%ilognot $nhash.lock-while-growing)))          (when (eq #'%am-growing (nhash.rehashF hash))            (setf (nhash.rehashF hash) #'%no-rehash))          (setq rehashF nil)       ; tell clean-up form we finished the loop          (puthash key hash value))        ; Clean up if aborted out of the loop        (when rehashF          (setf (nhash.rehashF hash) rehashF                (nhash.vector.flags old-vector)                (logior weak-flags (the fixnum (nhash.vector.flags old-vector)))                (nhash.lock hash) (%ilogand (nhash.lock hash)                                    #.(%ilognot $nhash.lock-while-growing))))))))(defun add-locked-additions (hash)  (without-interrupts   (when (eql 0 (nhash.lock hash))     (progn ;without-interrupts ; we dont like this but dont see how it can work otherwise.      ; it makes locked additions temporarily invisible so gethash will fail.       ; It makes locked additions invisible so remhash will remove       ; from the TABLE if it is there and not just mark it in locked additions      ; and if so the unwind protect is not needed       ; also could get messy if 2 processes are doing this      (let ((additions (nhash.locked-additions hash))            cell)        (declare (list additions cell))                (setf (nhash.locked-additions hash) nil)        (unwind-protect          (progn            (while (and additions (neq 0 (nhash.grow-threshold hash))) ; but what if its a bunch of remhashes?              (setq cell (car additions))              (if (neq (cdr cell) (%unbound-marker-8))                (puthash (car cell) hash (cdr cell))                (remhash (car cell) hash))              (pop additions))            (when  additions ; ok so just do the remhashes - is this worth the trouble?              (let* ((tem additions))                (declare (list tem))                (while tem                  (let ((cell (car tem)))                    (setq tem (cdr tem))                    (when (eq (cdr cell)(%unbound-marker-8))                      (remhash (car cell) hash)                       (setq additions (delq cell additions))))))))          (when additions            (setf (nhash.locked-additions hash)                  (nconc additions (nhash.locked-additions hash)))))))      t))); #'%no-rehash & #'%maybe-rehash & #'%am-rehashing are stored in the nhash.rehashF slot.; They don't do number of args checking so they can be fast and uninterruptable.; They return one of three values:; 1) NIL - Table does not need to be rehashed.; 2) T   - Table was rehashed.; 3) 0   - Table needs rehashing but is locked.  Did not rehash.; NARGS may not be set by callers of these functions.; They should assume it is correct.(defun %no-rehash (&lap hash)  (lap (move.l nilreg acc) (rts)))(defun %maybe-rehash (&lap hash)  (lap    (move.l arg_z atemp0)    (if# (eq (%needs-rehashing-p atemp0))      (move.l nilreg acc)      (move.l '#.$nhash.lock-while-rehashing da)      (if# (ne (and.l (svref atemp0 nhash.lock) da))        (move.l ($ 0) acc))             ; rehashing already.      (rts))    (if# (ne (tst.l (svref atemp0 nhash.lock)))      (move.l ($ 0) acc)      (rts))    (vpush arg_z)    (prog#     (ccall %rehash @vsp)     (bif (ne (%needs-rehashing-p @vsp)) (top#)))    (add.l ($ 4) vsp)    (move_t acc)    (rts)))(defun %am-rehashing (&lap hash)  (lap    (move.l ($ 0) acc)    (rts)))(defun %am-growing (&lap hash)  (lap    (jmp #'%maybe-rehash))); Returns three values: ; 1) foundp - true if the key was found; 2) value  - NIL if not found; 3) index  - the array index in the vector.;             NIL if not found and locked and needs rehashing.#|; Too slow(defun %hash-probe (hash key update-maybe-rehash)  (if (eql 0 (funcall (nhash.rehashF hash) hash))    (return-from %hash-probe (%hash-linear-probe hash key)))  (multiple-value-bind (primary addressp)                       (let ((keytransf (nhash.keytransF hash)))                         (if (fixnump keytransf)                           (if (eql 0 keytransf)                             (%%eqhash key)                             (%%eqlhash key))                           (funcall keytransf key)))    (unless (fixnump primary)      (setq addressp t)      (setq primary (lap-inline (primary) (movereg arg_z acc) (and.w ($ -8) acc))))    (when (and addressp update-maybe-rehash)      (setf (nhash.rehashF hash) #'%maybe-rehash))    (locally      (declare (fixnum primary))      (let* ((vector (nhash.vector hash))             (comparef (nhash.compareF hash))             (vlen (nhash.vector-size vector)))        (setq primary              (lap-inline (vlen primary)                (move.l arg_z da)                (divul.l arg_y (acc da))))        (if (fixnump compareF)          (if (eql 0 compareF)            (%eq-hash-probe key vector vlen primary)            (%eql-hash-probe key vector vlen primary))          (%general-hash-probe key vector vlen primary compareF))))))(defun %eq-hash-probe (&lap key vector vlen primary)  (lap    (if# (ne (cmp.l ($ (* 4 4)) nargs))      (move.l ($ (* 4 4)) da)      (jsr_subprim $sp-da-req-args)      (dc.w #_debugger))    (pea (vsp 4))                       ; complete stack frame    (move.l nilreg -@vsp)    (move.l nilreg -@vsp)    (move.l nilreg -@vsp)               ; VSP is vKEY/vFOUNDP,vINDEX,vVALUE,vDELETED    (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)      (equate _vtop 20)      (equate _vKEY (+ _vtop 12))      (equate _vFOUNDP _vKEY)      (equate _vVALUE (- _vFOUNDP 4))      (equate _vINDEX (- _VFOUNDP 8))      (equate _vDELETED (- _vFOUNDP 12))      (defreg VECTOR asave0 SECONDARY asave1 KEY dsave0 PRIMARY dsave1 VLEN dsave2)      (move.l (vsp _vKEY) KEY)      (move.l arg_x VECTOR)      (move.l arg_y VLEN)      (move.l arg_z PRIMARY)      (move.l VLEN (vsp _vFOUNDP))      ; assume found (VLEN is not NIL)      ; First probe may win.  Don't look up secondary key unless first probe loses.      (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table      (move.l ($ $undefined) da)      (if# (eq (cmp.l da arg_z))        (if# (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))          (move.l nilreg (vsp _vFOUNDP))         ; not found          (bra @done)         else#                          ; found a deleted entry          (if# (eq (cmp.l (vsp _vDELETED) nilreg))            (move.l PRIMARY (vsp _vDELETED))))          ; remember first deleted entry       else#        (if# (eq (cmp.l KEY arg_z))          (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vVALUE))          (bra @done)))      ; Lost on initial probe, get secondary key and loop      (move.l '7 da)      (and.l PRIMARY da)      (vscale.l da)      (move.l '#.secondary-keys atemp0)      (move.l (atemp0 da $v_data) SECONDARY)    ; secondary key      (move.l ($ $undefined) da);      (move.l PRIMARY arg_x)            ; initial position      (bra @increment)      (prog#       (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table       (if# (eq (cmp.l da arg_z))         (if# (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))           (move.l nilreg (vsp _vFOUNDP))       ; not found           (bra (exit#))          else#                         ; found a deleted entry           (if# (eq (cmp.l (vsp _vDELETED) nilreg))             (move.l PRIMARY (vsp _vDELETED))))         ; remember first deleted entry        else#         (if# (eq (cmp.l KEY arg_z))           (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vValue))           (bra (exit#))))@increment       (add.l SECONDARY PRIMARY)       (if# (ls (cmp.l PRIMARY VLEN))         (sub.l VLEN PRIMARY))       (bra (top#)));       (bif (ne (cmp.l PRIMARY arg_x)) (top#));       ; Came back around to initial position;       (move.l nilreg (vsp _vFOUNDP)))@done            (move.l PRIMARY (vsp _vINDEX)))   ; index    ; stack (top last) is foundp,value,index,deleted    (if# (ne (cmp.l (vsp 12) nilreg))      (add.l ($ 4) vsp)                 ; ignore deleted if found     else#      (vpop acc)      (if# (ne (cmp.l nilreg acc))        (move.l acc @vsp)))    (set_nargs 3)    (lea (sp 12) sp)                   ; pop my VSP, ret1valn, callers VSP    (rts)))(defun %eql-hash-probe (&lap key vector vlen primary)  (lap    (if# (ne (cmp.l ($ (* 4 4)) nargs))      (move.l ($ (* 4 4)) da)      (jsr_subprim $sp-da-req-args)      (dc.w #_debugger))    (pea (vsp 4))                       ; complete stack frame    (move.l nilreg -@vsp)    (move.l nilreg -@vsp)    (move.l nilreg -@vsp)               ; VSP is vKEY/vFOUNDP,vINDEX,vVALUE,vDELETED    (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)      (equate _vtop 20)      (equate _vKEY (+ _vtop 12))      (equate _vFOUNDP _vKEY)      (equate _vVALUE (- _vFOUNDP 4))      (equate _vINDEX (- _VFOUNDP 8))      (equate _vDELETED (- _vFOUNDP 12))      (defreg VECTOR asave0 SECONDARY asave1 KEY dsave0 PRIMARY dsave1 VLEN dsave2)      (move.l (vsp _vKEY) KEY)      (move.l arg_x VECTOR)      (move.l arg_y VLEN)      (move.l VLEN (vsp _vFOUNDP))      ; assume found (VLEN is not NIL)      (move.l acc PRIMARY)      ; First probe may win.  Don't look up secondary key unless first probe loses.      (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table      (move.l ($ $undefined) da)      (if# (eq (cmp.l da arg_z))        (if# (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))          (move.l nilreg (vsp _vFOUNDP))         ; not found          (bra @done)         else#                          ; found a deleted entry          (if# (eq (cmp.l (vsp _vDELETED) nilreg))            (move.l PRIMARY (vsp _vDELETED))))          ; remember first deleted entry       else#        (move.l KEY arg_y)        (jsr_subprim $sp-eql)        (if# (ne (cmp.l nilreg acc))          (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vVALUE))          (bra @done)))      ; Lost on initial probe, get secondary key and loop      (move.l '7 da)      (and.l PRIMARY da)      (vscale.l da)      (move.l '#.secondary-keys atemp0)      (move.l (atemp0 da $v_data) SECONDARY)    ; secondary key;      (move.l PRIMARY arg_x)            ; save original primary      (bra @increment)      (prog#       (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table       (move.l ($ $undefined) da)       (if# (eq (cmp.l da arg_z))         (if# (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))           (move.l nilreg (vsp _vFOUNDP))       ; not found           (bra (exit#))          else#                         ; found a deleted entry           (if# (eq (cmp.l (vsp _vDELETED) nilreg))             (move.l PRIMARY (vsp _vDELETED))))         ; remember first deleted entry        else#         (move.l KEY arg_y)         (vpush arg_x)         (jsr_subprim $sp-eql)         (vpop arg_x)         (if# (ne (cmp.l nilreg acc))           (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vValue))           (bra (exit#))))@increment       (add.l SECONDARY PRIMARY)       (if# (ls (cmp.l PRIMARY VLEN))         (sub.l VLEN PRIMARY))       (bra (top#)));       (bif (ne (cmp.l PRIMARY arg_x)) (top#));       (move.l nilreg (vsp _vFOUNDP)))@done            (move.l PRIMARY (vsp _vINDEX)))   ; index    ; stack (top last) is foundp,value,index,deleted    (if# (ne (cmp.l (vsp 12) nilreg))      (add.l ($ 4) vsp)                 ; ignore deleted if found     else#      (vpop acc)      (if# (ne (cmp.l nilreg acc))        (move.l acc @vsp)))    (set_nargs 3)    (lea (sp 12) sp)                   ; pop my VSP, ret1valn, callers VSP    (rts)))|#(defun ephemeral-p (x)  (lap-inline ()    (:variable x)    (move.l (varg x) da)    (move.l nilreg acc)    (if# (and (eq (dtagp da $t_fixnum $t_sfloat $t_imm))              (eq (ephemeral-p da)))      (add.w ($ $t_val) acc)))); must be called expecting multiple values because; %general-hash-probe, %eq-hash-probe, %eql-hash-probe require it.; puthash calls this with 3rd arg = 1(defun %hash-probe (&lap hash key update-maybe-rehash)    (lap    (if# (ne (cmp.w ($ 12) nargs))      (jsr_subprim $sp-three-args)      (dc.w #_debugger));    (dc.w #_debugger)    (vpush nilreg)    (vpush nilreg)    (vpush nilreg)                      ; VSP is vFOUNDP,vINDEX,vVALUE    (preserve_regs #(asave0 asave1 dsave0 dsave1 dsave2))    (defreg HASH asave0 SECONDARY asave0      VECTOR asave1      KEY dsave0      PRIMARY dsave1       UPDATE-MAYBE-REHASH dsave2 VLEN dsave2      ADDRESSP arg_x DIVTEMP arg_x      EPHEMERAL-P arg_y      COMPAREF da)    (move.l arg_x HASH)    (move.l arg_y KEY)    (move.l arg_z UPDATE-MAYBE-REHASH)    (vpush UPDATE-MAYBE-REHASH)         ; save for call to %general-hash-probe    (move.l (svref HASH nhash.vector) VECTOR)    (compute-hash-code t nil)    (move.l (svref HASH nhash.compareF) COMPAREF)    (if# (ne (dtagp COMPAREF $t_fixnum))      (add ($ 4) vsp)                 ; pop saved update-maybe-rehash      (move.l PRIMARY SECONDARY)      (move.l PRIMARY DIVTEMP)      (divul.l VLEN (PRIMARY DIVTEMP))      (if# (eq (tst.l COMPAREF))        (equate _vtop 20)        (equate _vFOUNDP (+ _vtop 8))        (equate _vVALUE (- _vFOUNDP 4))        (equate _vINDEX (- _VFOUNDP 8))@eq-hash        ; First probe may win.  Don't look up secondary key unless first probe loses.        (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table        (move.l ($ $undefined) da)        (if# (eq (cmp.l da arg_z))          (move.l PRIMARY (vsp _vINDEX))          (bif (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))            @done)         else#          (if# (eq (cmp.l KEY arg_z))            (move.l PRIMARY (vsp _vINDEX))            (move.l PRIMARY (vsp _vFOUNDP))            (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vVALUE))            (bra @done)))        ; Lost on initial probe, get secondary key and loop        (move.l SECONDARY db)        (and.l '7 db)        (vscale.l db)        (move.l '#.secondary-keys atemp0)        (move.l (atemp0 db $v_data) SECONDARY)          ; secondary key        (bra @increment)        (prog#         (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table         (if# (eq (cmp.l da arg_z))           (if# (eq (cmp.l (vsp _vINDEX) nilreg))             (move.l PRIMARY (vsp _vINDEX)))           (bif (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))             (exit#))          else#           (if# (eq (cmp.l KEY arg_z))             (move.l PRIMARY (vsp _vINDEX))             (move.l PRIMARY (vsp _vFOUNDP))             (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vVALUE))             (bra (exit#))))@increment         (add.l SECONDARY PRIMARY)         (bif (hi (cmp.l PRIMARY VLEN)) (top#))         (sub.l VLEN PRIMARY)         (bra (top#)))@done        (unuse_regs)        (set_nargs 3)        (lea (sp 8) sp)                 ; pop ret1valn, callers VSP        (rts))      ; EQL hash table.      (progn        ; May be able to save some time if EQ will work for comarison        (bif (eq (dtagp KEY $t_vector $t_dfloat)) @eq-hash)        (if# (ne (dtagp key $t_vector))          (move.l KEY atemp0)	  (vsubtype atemp0 da)          (bif (and (ne (cmp.b ($ $v_bignum) da))                    (ne (cmp.b ($ $v_ratio) da))                    (ne (cmp.b ($ $v_complex) da))                    (ne (cmp.b ($ $v_macptr) da)))               @eq-hash))        ; First probe may win.  Don't look up secondary key unless first probe loses.        (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table        (move.l ($ $undefined) da)        (if# (eq (cmp.l da arg_z))          (move.l PRIMARY (vsp _vINDEX))  ; hit an unused slot - return index but not foundp          (bif (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))            @done2)         else#          (move.l KEY arg_y)          (jsr_subprim $sp-eql)          (if# (ne (cmp.l nilreg acc))            (move.l PRIMARY (vsp _vINDEX))            (move.l PRIMARY (vsp _vFOUNDP))            (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vVALUE))            (bra @done2)))        ; Lost on initial probe, get secondary key and loop        (move.l SECONDARY db)        (and.l '7 db)        (vscale.l db)        (move.l '#.secondary-keys atemp0)        (move.l (atemp0 db $v_data) SECONDARY)          ; secondary key        (bra @increment2)        (prog#         (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table         (move.l ($ $undefined) da)         (if# (eq (cmp.l da arg_z))           (if# (eq (cmp.l (vsp _vINDEX) nilreg))             (move.l PRIMARY (vsp _vINDEX)))           (bif (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))             (exit#))          else#           (move.l KEY arg_y)           (jsr_subprim $sp-eql)           (if# (ne (cmp.l nilreg acc))             (move.l PRIMARY (vsp _vINDEX))             (move.l PRIMARY (vsp _vFOUNDP))             (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) (vsp _vVALUE))             (bra (exit#))))@increment2         (add.l SECONDARY PRIMARY)         (bif (hi (cmp.l PRIMARY VLEN)) (top#))         (sub.l VLEN PRIMARY)         (bra (top#)))@done2        (unuse_regs)        (set_nargs 3)        (lea (sp 8) sp)                 ; pop ret1valn, callers VSP        (rts)))    (move.l COMPAREF arg_z)    (move.l PRIMARY arg_y)    (move.l VLEN ARG_X)    (move.l HASH da)    (move.l KEY db)    (vpop atemp0)                       ; update-maybe-rehash    (restore_regs)    (lea (vsp 12) vsp)    (vpush db)                          ; key    (vpush da)                          ; hash    (vpush atemp0)                      ; update-maybe-rehash    (set_nargs 6)    (jmp #'%general-hash-probe))); This will crash if you call it not expecting multiple values.(defun %general-hash-probe (&lap key hash update-maybe-rehash vlen primary compareF)  (lap    (if# (ne (cmp.l ($ (* 6 4)) nargs))      (move.l ($ (* 6 4)) da)      (jsr_subprim $sp-da-req-args)      (dc.w #_debugger));    (dc.w #_debugger)    (pea (vsp 12))    (move.l nilreg -@vsp)    (move.l nilreg -@vsp)               ; VSP is vKEY/vFOUNDP,vHASH/vVALUE,                                        ;  vUPDATE-MAYBE-REHASH/vINDEX,vDELETED,rehash-count    (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)      (vpush arg_y)                     ; original PRIMARY      (equate _vtop 24)      (equate _vKEY (+ _vtop 16))      (equate _vHASH (- _vKEY 4))      (equate _vUPDATE-MAYBE-REHASH (- _vHASH 4))      (equate _vFOUNDP _vKEY)      (equate _vVALUE (- _vFOUNDP 4))      (equate _vINDEX (- _VFOUNDP 8))      (equate _vDELETED (- _vFOUNDP 12))      (equate _vREHASH-COUNT (- _vFOUNDP 16))      (defreg VECTOR asave0 COMPAREF asave1 KEY dsave0 PRIMARY dsave1 VLEN dsave2)      (move.l (vsp _vKEY) KEY)      (move.l (vsp _vHASH) atemp0)      (move.l (svref atemp0 nhash.vector) VECTOR)      (move.l (svref atemp0 nhash.puthash-count) (vsp _vREHASH-COUNT))      (move.l arg_x VLEN)      (divul.l VLEN (PRIMARY arg_y))     ; normalize      (move.l arg_z COMPAREF)      (move.l VLEN (vsp _vFOUNDP))      ; assume found (VLEN is not NIL)      (if# (eq (progn (move.l COMPAREF arg_z) (dtagp arg_z $t_lfun)))        (ccall symbol-function arg_z)        (move.l acc COMPAREF))      ; First probe may win.  Don't look up secondary key unless first probe loses.      (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table      (move.l ($ $undefined) da)      (if# (eq (cmp.l da arg_z))        (if# (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))          (move.l nilreg (vsp _vFOUNDP))         ; not found          (bra @done)         else#                          ; found a deleted entry          (if# (eq (cmp.l (vsp _vDELETED) nilreg))            (move.l PRIMARY (vsp _vDELETED))))          ; remember first deleted entry       else#        (move.l KEY arg_y)        (set_nargs 2)        (jsr @COMPAREF)        (if# (ne (cmp.l nilreg acc))          (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da)          (bra @done)))      ; Lost on initial probe, get secondary key and loop      (move.l '7 da)      (and.l @vsp da)      (vscale.l da)      (move.l '#.secondary-keys atemp0)      (move.l (atemp0 da $v_data) @vsp)    ; secondary key      (bra @increment)      (prog#       (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table       (move.l ($ $undefined) da)       (if# (eq (cmp.l da arg_z))         (if# (eq (cmp.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da))           (move.l nilreg (vsp _vFOUNDP))       ; not found           (bra (exit#))          else#                         ; found a deleted entry           (if# (eq (cmp.l (vsp _vDELETED) nilreg))             (move.l PRIMARY (vsp _vDELETED))))         ; remember first deleted entry        else#         (move.l KEY arg_y)         (set_nargs 2)         (jsr @COMPAREF)         (if# (ne (cmp.l nilreg acc))           (move.l (VECTOR PRIMARY.l (+ $nhash_data 4)) da)           (bra (exit#))))@increment       (add.l @vsp PRIMARY)       (bif (hi (cmp.l PRIMARY VLEN)) (top#))       (sub.l VLEN PRIMARY)       (bra (top#)))@done      ; value is in DA.  We're done unless the vector changed from under us      (move.l (vsp _vHASH) atemp0)      (move.l (svref atemp0 nhash.puthash-count) db)      (if# (ne (cmp.l (vsp _vREHASH-COUNT) db))        ; rehashed or grew while we were searching, need to try again.        (move.l atemp0 arg_x)           ; hash        (move.l KEY arg_y)              ; key        (move.l (vsp _vUPDATE-MAYBE-REHASH) arg_z)     ; update-maybe-rehash        (set_nargs 3)        (lea (vsp 4) vsp)               ; pop secondary key        (unuse_regs)        (spop vsp)        (jmp #'%hash-probe))         ; (hash-probe hash key 1)      (move.l da (vsp _vVALUE))      (move.l PRIMARY (vsp _vINDEX))    ; index      (lea (vsp 4) vsp))                ; pop secondary key    (add.l ($ 4) vsp)                   ; pop vREHASH-COUNT    ; stack (top last) is foundp,value,index,deleted    (if# (ne (cmp.l (vsp 12) nilreg))      (add.l ($ 4) vsp)                 ; ignore deleted if found     else#      (vpop acc)      (if# (ne (cmp.l nilreg acc))        (move.l acc @vsp)))    (set_nargs 3)    (lea (sp 12) sp)                       ; pop my VSP, ret1valn, callers VSP    (rts))); Here when the table is locked and needs rehashing(defun %hash-linear-probe (hash key)  (let ((test (nhash.compareF hash)))    (if (fixnump test)      (if (eql 0 test)        (%eq-linear-probe hash key)        (%eql-linear-probe hash key))      (%general-linear-probe hash key test))))(defun %general-linear-probe (hash key test)  (let (index value)    (lap-inline ()      (:variable hash key test index value)      (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)        (equate _vtop 20)        (defreg VECTOR asave0 TEST asave1 UNDEFINED dsave0 KEY dsave1 INDEX dsave2)        (move.l (varg hash _vtop) atemp0)        (move.l (svref atemp0 nhash.vector) VECTOR)        (move.l (varg test _vtop) TEST)        (if# (eq (progn (move.l TEST da) (dtagp da $t_lfun)))          (ccall symbol-function TEST)          (move.l acc TEST))        (move.l ($ $undefined) UNDEFINED)        (move.l (varg key _vtop) KEY)        (vsize VECTOR INDEX)        (move.l ($ (* 4 $nhash.vector_overhead)) da)        (sub.l da INDEX)        (bra @decr)        (prog#         (move.l (VECTOR INDEX.l $nhash_data) arg_z)         (if# (ne (cmp.l UNDEFINED arg_z))           (move.l KEY arg_y)           (set_nargs 2)           (jsr @TEST)           (if# (ne (cmp.l nilreg acc))             (move.l INDEX (varg index _vtop))             (move.l (VECTOR INDEX.l (+ $nhash_data 4)) (varg value _vtop))             (bra (exit#))))@decr    (bif (cc (sub.l '1 INDEX)) (top#)))))    (values index value index)))        ; found, value, index(defun %eq-linear-probe (hash key)          (let (index value)    (lap-inline ()      (:variable hash key test index value)      (with-preserved-registers #(asave0 dsave1 dsave2)        (equate _vtop 12)        (defreg VECTOR asave0 KEY dsave1 INDEX dsave2)        (move.l (varg hash _vtop) atemp0)        (move.l (svref atemp0 nhash.vector) VECTOR)        (move.l (varg key _vtop) KEY)        (vsize VECTOR INDEX)        (move.l ($ (* 4 $nhash.vector_overhead)) da)        (sub.l da INDEX)        (bra @decr)        (prog#         (move.l (VECTOR INDEX.l $nhash_data) arg_z)         (if# (eq (cmp.l key arg_z))           (move.l INDEX (varg index _vtop))           (move.l (VECTOR INDEX.l (+ $nhash_data 4)) (varg value _vtop))           (bra (exit#)))@decr    (bif (cc (sub.l '1 INDEX)) (top#)))))    (values index value index)))        ; found, value, index(defun %eql-linear-probe (hash key)  (let (index value)    (lap-inline ()      (:variable hash key test index value)      (with-preserved-registers #(asave0 dsave0 dsave1 dsave2)        (equate _vtop 16)        (defreg VECTOR asave0 UNDEFINED dsave0 KEY dsave1 INDEX dsave2)        (move.l (varg hash _vtop) atemp0)        (move.l (svref atemp0 nhash.vector) VECTOR)        (move.l ($ $undefined) UNDEFINED)        (move.l (varg key _vtop) KEY)        (vsize VECTOR INDEX)        (move.l ($ (* 4 $nhash.vector_overhead)) da)        (sub.l da INDEX)        (bra @decr)        (prog#         (move.l (VECTOR INDEX.l $nhash_data) arg_z)         (if# (ne (cmp.l UNDEFINED arg_z))           (move.l KEY arg_y)           (jsr_subprim $sp-eql)           (if# (ne (cmp.l nilreg acc))             (move.l INDEX (varg index _vtop))             (move.l (VECTOR INDEX.l (+ $nhash_data 4)) (varg value _vtop))             (bra (exit#))))@decr    (bif (cc (sub.l '1 INDEX)) (top#)))))    (values index value index)))        ; found, value, index; Rehash(defun %rehash (&lap hash)    (lap    (if# (ne (cmp.w ($ 4) nargs))      (jsr_subprim $sp-one-arg)      (dc.w #_debugger))    (spush vsp)                         ; complete stack frame    (move.l arg_z atemp0)    (move.l '%am-rehashing atemp1)    (move.l (atemp1 $sym.entrypt) da)    (move.l da (svref atemp0 nhash.rehashF))    (move.l (svref atemp0 nhash.vector) atemp1)    (vpush (svref atemp1 nhash.vector.flags))    (move.w ($ 0) (svref atemp1 nhash.vector.flags))    ; clear rehash info    (vpush nilreg)                      ; flag set true if we complete successfully    (vpush da)                          ; #'%am-rehashing    (vpush (svref atemp0 nhash.lock))   ; saved lock ???    (or.l '#.$nhash.lock-while-rehashing (svref atemp0 nhash.lock))   ; rehashing:    ; we got here and got the error doing    ; puthash, add-locked-additions, puthash,hash-probe, maybe-rehash    ;(dc.w #_debugger)    (vpush arg_z)                       ; hash    (pea (^ @cleanup))    (jsr_subprim $sp-mkunwind)    (bra @doit)@cleanup     ; There's one more thing on the VSP stack than when we called $sp-mkunwind     (move.l (vsp 4) atemp0)            ; hash     (move.l ($ $undefined) da)     (move.l (svref atemp0 nhash.vector) atemp1)     (move.l da (svref atemp1 nhash.vector.cache-key))         ; clear the cache     (move.l nilreg (svref atemp1 nhash.vector.cache-value))     (if# (eq (cmp.l (vsp 16) nilreg))       ; We threw out before we were done rehashing.       (move.w (vsp 20) (svref atemp1 nhash.vector.flags))      ; restore rehashing info       (move.l '%maybe-rehash atemp1)       (move.l (atemp1 $sym.entrypt) (svref atemp0 nhash.rehashF))       (%needs-rehashing atemp0))       ; did not complete: still needs rehashing.     ;(dc.w #_debugger)     (and.l '#.$nhash.lock-not-while-rehashing (svref atemp0 nhash.lock))     ; ??? no I think -maybe ok we dont rehash unless lock is zero     ; but we could start mapping while rehashing? - hope not     ;(move.l (vsp 8) (svref atemp0 nhash.lock))       (move.l (vsp 12) da)               ; #'%am-rehashing     (if# (eq (cmp.l (svref atemp0 nhash.rehashF) da))       ; No longer needs rehashing (or nhash.rehashF would contain #'maybe-rehash)       (move.l '%no-rehash atemp1)       (move.l (atemp1 $sym.entrypt) (svref atemp0 nhash.rehashF)))     (rts)@doit     (ccall do-rehash @vsp)     (move.l ($ 0) (vsp 12))            ; tell @cleanup that we completed     (jmp_subprim $sp-lfret1v1)))(defun %make-rehash-bits (hash &optional (size (nhash.vector-size (nhash.vector hash))))  (declare (fixnum size))  (let ((rehash-bits-size (ash (the fixnum (+ size 31)) -5))        (rehash-bits (nhash.rehash-bits hash)))    (declare (fixnum rehash-bits-size))    (unless (and rehash-bits                 (>= (uvsize rehash-bits) rehash-bits-size))      (setq rehash-bits             (setf (nhash.rehash-bits hash) (%make-uvector rehash-bits-size $v_ulongv))))    (lap-inline ()      (:variable rehash-bits rehash-bits-size)      (move.l (varg rehash-bits) atemp0)      (move.l (varg rehash-bits-size) da)      (lea (atemp0 $v_data) atemp0)      (getint da)      (dbfloop.l da (move.l ($ 0) atemp0@+)))    rehash-bits))(defun do-rehash (hash)  (unless (%hash-table-p hash)    (report-bad-arg hash 'hash-table))  (let* ((vector (nhash.vector hash))         (size (nhash.vector-size vector))         (rehash-bits (%make-rehash-bits hash size))         (index -1)         key value)    (declare (fixnum size index))    (%does-not-need-rehashing hash)    (lap-inline ()      (:variable hash)      (move.l (varg hash) atemp0)      (add.l '1 (svref atemp0 nhash.puthash-count)))    (loop      (if (>= (incf index) size) (return))      (unless (%already-rehashed-p index rehash-bits)        (unless          (lap-inline ()            (:variable vector index key value hash)            (move.l (varg vector) atemp0)            (move.l (varg index) da)            (lea (atemp0 da.l $nhash_data) atemp0)            (move.l atemp0@+ arg_x)            (move.l arg_x (varg key))            (move.l @atemp0 (varg value))            (move.l nilreg acc)         ; assume not an empty or deleted entry            (move.l ($ $undefined) da)            (if# (eq (cmp.l da arg_x))              (if# (eq (cmp.l @atemp0 nilreg))                ; one less deleted entry                (move.l (varg vector) atemp1)                (if# (mi (sub.l '1 (svref atemp1 nhash.vector.deleted-count)))                  (move.l (svref atemp1 nhash.vector.weak-deletions-count) db)                  (clr.l (svref atemp1 nhash.vector.weak-deletions-count))                  (add.l db (svref atemp1 nhash.vector.deleted-count))                  (move.l (varg hash) atemp1)                  (sub.l db (svref atemp1 nhash.count)))                (move.l (varg hash) atemp1)                (add.l '1 (svref atemp1 nhash.grow-threshold)))              (move.l da @atemp0)       ; deleted -> empty              (add.l ($ $t_val) acc)))          (loop            ; can this happen? - somebody starts mapping while we are rehashing            (when (neq 0 (%ilogand (nhash.lock hash) $nhash.lock-map-count-mask))              (cerror "Stop rehashing." "Map count became non zero during rehash. ~x" (nhash.lock hash))              (return-from do-rehash nil))            (let ((found-index (%rehash-probe rehash-bits hash key)));                (format t "~&index: ~d, key: ~s, value: ~s, found-index: ~s~%";                        index key value found-index)              (%set-already-rehashed-p found-index rehash-bits)              (unless (lap-inline ()                        (:variable index found-index vector key value hash rehash-bits)                        (move.l (varg found-index) da)                        (move.l (varg index) db)                        (move.l ($ $undefined) acc)                        (if# (eq (cmp.l da db))                          (move.l nilreg acc)         ; found myself, nothing to do                         else#                          (move.l (varg vector) atemp1)                          ; swap entry with found location                          (lea (atemp1 da.l $nhash_data) atemp0)                          (move.l @atemp0 arg_x)                          (move.l (varg key) da)                          (move.l da atemp0@+)                          (move.l arg_x (varg key))                          (move.l @atemp0 arg_y)                          (move.l (varg value) @atemp0)                          (move.l arg_y (varg value))                          (if# (eq (cmp.l acc arg_x))                            (if# (eq (cmp.l arg_y nilreg))                              ; one less deleted entry                              (if# (mi (sub.l '1 (svref atemp1 nhash.vector.deleted-count)))                                (move.l (svref atemp1 nhash.vector.weak-deletions-count) arg_y)                                (clr.l (svref atemp1 nhash.vector.weak-deletions-count))                                (add.l arg_y (svref atemp1 nhash.vector.deleted-count))                                (move.l (varg hash) atemp0)                                (sub.l arg_y (svref atemp0 nhash.count)))                              (move.l (varg hash) atemp0)                              (add.l '1 (svref atemp0 nhash.grow-threshold)))                            (move.l acc arg_y)        ; $undefined for value                            (move.l nilreg acc))      ; empty table entry                          ; Put the entry in our hand in the table so GETHASH can find it                          (lea (atemp1 db.l $nhash_data) atemp0)                          (move.l arg_x atemp0@+)                          (move.l arg_y @atemp0)                          (if# (eq (cmp.l da arg_x))    ; old key = new key?                            (ccall cerror                                   '"Delete one of the entries."                                   '"Duplicate key: ~s in ~s"                                   arg_x (varg hash))                            (move.l (varg vector) atemp1)                            (move.l (varg index) db)                            (lea (atemp1 db.l $nhash_data) atemp0)                            (move.l ($ $undefined) da)                            (move.l da atemp0@+)                            (move.l da atemp0@+)                            (move.l (varg hash) atemp0)                            (sub.l '1 (svref atemp0 nhash.count))                            (add.l '1 (svref atemp0 nhash.grow-threshold))                            (move.l nilreg acc))))                (return))))          (when (%needs-rehashing-p hash)     ; somebody consed too much            (return-from do-rehash nil))))))  (add-locked-additions hash)); Hash to an index that is not set in rehash-bits(defun %rehash-probe (&lap rehash-bits hash key)  (lap    (if# (ne (cmp.w ($ 12) nargs))      (jsr_subprim $sp-two-args)      (dc.w #_debugger));    (dc.w #_debugger)    (spush vsp)                         ; complete stack frame    (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)      (defreg HASH asave0        VECTOR asave1        KEY dsave0 PRIMARY dsave1 VLEN dsave2        ADDRESSP arg_x DIVTEMP arg_x        EPHEMERAL-P arg_y SECONDARY arg_y)      (vpush arg_x)                     ; rehash-bits on top of stack      (move.l arg_y HASH)      (move.l arg_z KEY)      (move.l (svref HASH nhash.vector) VECTOR)      (compute-hash-code nil)      ; First probe may win.  Don't look up secondary key unless first probe loses.      (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table      (bif (eq (cmp.l KEY arg_z)) @done)      (bif (eq (%already-rehashed-p PRIMARY @vsp)) @done)      ; Lost on initial probe, get secondary key and loop      (move.l '7 da)      (and.l SECONDARY da)      (vscale.l da)      (move.l '#.secondary-keys atemp0)      (move.l (atemp0 da $v_data) SECONDARY)      (bra @increment)      (prog#       (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table       (bif (eq (cmp.l KEY arg_z)) (exit#))       (bif (eq (%already-rehashed-p PRIMARY @vsp)) (exit#))@increment       (add.l SECONDARY PRIMARY)       (if# (ls (cmp.l PRIMARY VLEN))         (sub.l VLEN PRIMARY))       (bra (top#)))@done            (move.l PRIMARY acc)              ; index      (add.l ($ 4) vsp))    (add.l ($ 4) sp)                    ; pop frame pointer    (rts))); Returns one value: the index of the entry in the vector; Since we're growing, we don't need to compare and can't find a key that's; already there.(defun %growhash-probe (&lap vector hash key)  (lap    (if# (ne (cmp.w ($ 12) nargs))      (jsr_subprim $sp-two-args)      (dc.w #_debugger));    (dc.w #_debugger)    (spush vsp)                         ; complete stack frame    (with-preserved-registers #(asave0 asave1 dsave0 dsave1 dsave2)      (defreg HASH asave0 UNDEFINED asave0        VECTOR asave1        KEY dsave0 PRIMARY dsave1 VLEN dsave2        ADDRESSP arg_x DIVTEMP arg_x        EPHEMERAL-P arg_y  SECONDARY arg_y)      (move.l arg_x VECTOR)      (move.l arg_y HASH)      (move.l arg_z KEY)      (compute-hash-code nil)      ; First probe may win.  Don't look up secondary key unless first probe loses.      (move.l ($ $undefined) UNDEFINED)      (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table      (bif (eq (cmp.l UNDEFINED arg_z)) @done)      (bif (eq (cmp.l KEY arg_z)) @done)        ; not really necessary      ; Lost on initial probe, get secondary key and loop      (move.l '7 da)      (and.l SECONDARY da)      (vscale.l da)      (move.l '#.secondary-keys atemp0)      (move.l (atemp0 da $v_data) SECONDARY)      (bra @increment)      (prog#       (move.l (VECTOR PRIMARY.l $nhash_data) arg_z)        ; key from table       (bif (eq (cmp.l UNDEFINED arg_z)) (exit#))       (bif (eq (cmp.l KEY arg_z)) (exit#))       @increment       (add.l SECONDARY PRIMARY)       (if# (ls (cmp.l PRIMARY VLEN))         (sub.l VLEN PRIMARY))       (bra (top#)))      @done            (move.l PRIMARY acc))             ; index    (add.l ($ 4) sp)                    ; pop frame pointer    (rts)))#| ; in lib;hash.lisp; Returns nil, :key or :value(defun hash-table-weak-p (hash)  (unless (hash-table-p hash)    (setq hash (require-type hash 'hash-table)))  (let* ((vector (nhash.vector hash))         (flags (nhash.vector.flags vector)))    (when (logbitp $nhash_weak_bit flags)      (if (logbitp $nhash_weak_value_bit flags)        :value        :key)))); value should be nil, :key or :value(defun (setf hash-table-weak-p) (value hash)  (unless (hash-table-p hash)    (setq hash (require-type hash 'hash-table)))  (without-interrupts                   ; while we've got flags in our hand   (let* ((vector (nhash.vector hash))          (flags (nhash.vector.flags vector)))     (ecase value       (:key        (unless (eq (hash-table-test hash) 'eq)          (error "Only EQ hash tables can be weak on key"))        (setf (nhash.vector.flags vector)              (bitset $nhash_weak_bit                      (bitclr $nhash_weak_value_bit flags))))       (:value        (setf (nhash.vector.flags vector)              (bitset $nhash_weak_bit                      (bitset $nhash_weak_value_bit flags))))       ((nil)        (setf (nhash.vector.flags vector) (bitclr $nhash_weak_bit flags))))))  value)|#;;;;;;;;;;;;;;;;; Mapping functions;;#| ; in lib;hash.lisp(defmacro with-hash-table-iterator ((mname hash-table) &body body)  (let ((state (gensym)))    `(let ((,state (vector nil nil ,hash-table nil nil)))       (declare (dynamic-extent ,state))       (unwind-protect         (macrolet ((,mname () `(do-hash-table-iteration ,',state)))           (start-hash-table-iterator ,state)           ,@body)         (finish-hash-table-iterator ,state)))))|##|(defun start-hash-table-iterator (state)  (let ((hash (hti.hash-table state))        lock vector)    (unless (hash-table-p hash)      (setf (hti.hash-table state) nil)         ; for finish-hash-table-iterator      (report-bad-arg hash 'hash-table))        ; if rehash or grow in progress - hang out till its done     (when (neq 0 (%ilogand (nhash.lock hash)  $nhash.lock-grow-or-rehash))      (process-wait "Wait rehash done"                     #'(lambda (hash)                        (eq 0 (%ilogand (nhash.lock hash)  $nhash.lock-grow-or-rehash)))                    hash)      ;(print 'waited)      )    (without-interrupts     (setf (hti.lock state) (setq lock (nhash.lock hash))           (hti.locked-additions state) (nhash.locked-additions hash))          (when (eq $nhash.lock-map-count-mask                (%ilogand lock $nhash.lock-map-count-mask))       ; is this check silly?       (error "Too many mappers ~s of hash table ~S" lock hash))     (setq vector (nhash.vector hash))     (setf (hti.vector state) vector)     #|     ; this isnt right - in case the mapper is modifying the table.      ; if rehashing - copy the vector and iterate on the copy - actually copy the whole darn thing     (if (neq 0 (%ilogand lock $nhash.lock-while-rehashing))       (without-interrupts        ;(print 'copying-to-map)        (let* ((vector (copy-uvector vector))               (new-hash (%cons-hash-table (nhash.rehashF hash)                                           (nhash.keytransf hash)                                           (nhash.compareF hash)                                           vector                                           (nhash.grow-threshold hash)                                           (nhash.rehash-ratio hash)                                           (nhash.rehash-size hash))))          (setf (hti.vector state) vector)          (setf (hti.hash-table state) new-hash)          (setq hash new-hash)          (setf (hti.lock hash) 0)          (setq lock 0)))       (setf (hti.vector state) vector))     |#      (setf (nhash.lock hash) (1+ lock))     (setf (hti.index state) (nhash.vector-size vector)))))|##| ; in lib;hash.lisp; from 4.0(defun start-hash-table-iterator (state)  (let ((hash (hti.hash-table state))        lock vector)    (unless (hash-table-p hash)      (setf (hti.hash-table state) nil)         ; for finish-hash-table-iterator      (report-bad-arg hash 'hash-table))        ; if rehash or grow in progress - hang out till its done     (when (neq 0 (%ilogand (nhash.lock hash)  $nhash.lock-grow-or-rehash))      (process-wait "Wait rehash done"                     #'(lambda (hash)                        (eq 0 (%ilogand (nhash.lock hash)  $nhash.lock-grow-or-rehash)))                    hash)      ;(print 'waited)      )    (without-interrupts     ; paranoia - maybe a rehash started between success of wait function and now     (when (neq 0 (%ilogand (nhash.lock hash)  $nhash.lock-grow-or-rehash)) ; 7/96       ; hasnt happened so far       ;(incf n1)       (return-from start-hash-table-iterator (start-hash-table-iterator state)))      (setf (hti.lock state) (setq lock (nhash.lock hash))           (hti.locked-additions state) (nhash.locked-additions hash))          (when (eq $nhash.lock-map-count-mask                (%ilogand lock $nhash.lock-map-count-mask))       ; is this check silly?       (error "Too many mappers ~s of hash table ~S" lock hash))     (setq vector (nhash.vector hash))     (setf (hti.vector state) vector)     #|     ; this isnt right - in case the mapper is modifying the table.      ; if rehashing - copy the vector and iterate on the copy - actually copy the whole darn thing     (if (neq 0 (%ilogand lock $nhash.lock-while-rehashing))       (without-interrupts        ;(print 'copying-to-map)        (let* ((vector (copy-uvector vector))               (new-hash (%cons-hash-table (nhash.rehashF hash)                                           (nhash.keytransf hash)                                           (nhash.compareF hash)                                           vector                                           (nhash.grow-threshold hash)                                           (nhash.rehash-ratio hash)                                           (nhash.rehash-size hash))))          (setf (hti.vector state) vector)          (setf (hti.hash-table state) new-hash)          (setq hash new-hash)          (setf (hti.lock hash) 0)          (setq lock 0)))       (setf (hti.vector state) vector))     |#      (setf (nhash.lock hash) (1+ lock))     (setf (hti.index state) (nhash.vector-size vector)))))|# #|(defun do-hash-table-iteration (state)  (let ((vector (hti.vector state))        (index (hti.index state))        key value)    (if (setf (hti.index state)               (lap-inline ()                (:variable vector index key value)                (move.l (varg index) arg_x)                (if# (ne nilreg arg_x)                         (move.l (varg vector) atemp0)                         (move.l ($ $undefined) da)                         (move.l '1 db)                         (until# (mi (sub.l db arg_x))                                 (lea (atemp0 arg_x.l $nhash_data) atemp1)                                 (move.l atemp1@+ acc)                                 (if# (ne (cmp.l acc da))                                   (move.l acc (varg key))                                   (move.l @atemp1 (varg value))                                   (move.l arg_x acc)                                   (bra @success))))                (move.l nilreg acc)                @success                (move.l acc (varg index))))      (let ((hash (hti.hash-table state)))        (if (nhash-locked-additions-cell key hash nil (hti.locked-additions state))          (do-hash-table-iteration state)          (progn            (setf (nhash.vector.cache-idx (setq vector (nhash.vector hash))) index                  (nhash.vector.cache-key vector) key                  (nhash.vector.cache-value vector) value)            (values t key value))))      (loop        (let ((cell (pop (hti.locked-additions state))))          (declare (list cell))          (if cell            (unless (eq (cdr cell) (%unbound-marker-8))              (return (values t (car cell) (cdr cell))))            (return nil)))))))(defun finish-hash-table-iterator (state)  (without-interrupts   (let ((hash (hti.hash-table state)))     (when hash       (let ((lock  (hti.lock state))             (hlock (nhash.lock hash)))         (when (eq 0 (logand hlock #xffff))           (error "Hash-table-iterator is confused."))         (setf (nhash.lock hash) (decf hlock))         (when lock           (setf            ;(nhash.lock hash) lock            (hti.index state)  nil            (hti.vector state) nil            (hti.lock state)   nil)))))))|##|(defun do-hash-table-iteration (state)  (let ((vector (hti.vector state))        (index (hti.index state))        key value)    (declare (optimize (speed 3) (safety 0))) ; what if its big  and empty?    (if (setf (hti.index state)              (if index                (loop                  (if (eq index 0)(return (setq index nil)))                  (locally (declare (fixnum index))                    (setq index (- index 1))                    (let* ((vector-index (index->vector-index index)))                      (declare (fixnum vector-index))                      (setq key (%svref vector vector-index))                      (when (neq key (%unbound-marker-8))                        (setq value (%svref vector (the fixnum (1+ vector-index))))                        (return index)))))))      (let ((hash (hti.hash-table state)))        (if (and (hti.locked-additions state)                 (nhash-locked-additions-cell key hash nil (hti.locked-additions state)))          (do-hash-table-iteration state)          (progn            (setf (nhash.vector.cache-idx (setq vector (nhash.vector hash))) index                  (nhash.vector.cache-key vector) key                  (nhash.vector.cache-value vector) value)            (values t key value))))      (loop        (let ((cell (pop (hti.locked-additions state))))          (declare (list cell))          (if cell            (unless (eq (cdr cell) (%unbound-marker-8))              (return (values t (car cell) (cdr cell))))            (return nil)))))))(defun finish-hash-table-iterator (state)  (without-interrupts   (let ((hash (hti.hash-table state)))     (when hash       (let* ((lock  (hti.lock state))              (hlock (nhash.lock hash)))                  (when lock ; unless we never started  ; 7/96           (when (eq 0 (logand hlock #xffff))             (error "Hash-table-iterator is confused. hlock ~s hit.lock ~s" hlock lock))           (setf (nhash.lock hash) (decf hlock))           (setf            (hti.index state)  nil            (hti.vector state) nil            (hti.lock state)   nil)))))))(defun maphash (function hash-table)  (with-hash-table-iterator (m hash-table)    (loop      (multiple-value-bind (found key value) (m)        (unless found (return))        (funcall function key value)))))|#;;;;;;;;;;;;;;;;; Hashing functions;; EQ & the EQ part of EQL are done in-line.;;; Hash on address.; If all keys are fixnums, short floats, or immediates, rehashing won't ever be necessary.(defun %%eqhash (&lap key)  (lap    (movereg arg_z acc)    (movereg acc db)    (move.w ($ -8) da)    (and.w da acc)    (mixup-hash-code acc)    (if# (ne (dtagp db $t_fixnum $t_sfloat $t_imm))      (rts))    (vpush acc)    (vpush ':key)    (vpush nilreg)    (if# (eq (ephemeral-p db))      (add.l ($ $t_val) @vsp))    (set_nargs 3)    (jmp_subprim $sp-values)))(defun %%eqlhash (&lap key); if key is a macptr, float, bignum, ratio, or complex, convert it to a fixnum  (lap    (jsr #'%%eqlhash-internal)    (if# (ne (dtagp acc $t_fixnum $t_sfloat $t_imm))      (move.w ($ -8) da)      (and.w da acc)      (mixup-hash-code acc)      (rts))    (set_nargs 1)    (jmp #'%%eqhash)))(defun %%eqlhash-internal (&lap key)  (lap    @recurse    (if# (ne (dtagp arg_z $t_dfloat))      (sub ($ $t_dfloat) arg_z)      (move.l arg_z atemp0)      (move.l atemp0@+ arg_z)      (add.l @atemp0 arg_z)      (mkint arg_z)     elseif# (ne (dtagp arg_z $t_vector))      (move.l arg_z atemp0)      (vsubtype atemp0 da)      (if# (eq (cmp.b ($ $v_bignum) da))        (getvect atemp0 db)        (moveq 0 arg_z)        (moveq 0 arg_y)        (asr 1 db)        (dbfloop.l db         (move.w atemp0@+ arg_y)         (add.l arg_y arg_z)         (swap arg_z))        (mkint arg_z)       elseif# (or (eq (cmp.b ($ $v_ratio) da)) (eq (cmp.b ($ $v_complex) da)))        ; Hash each component, xor results        (vpush (atemp0 $v_data))        (move.l (atemp0 (+ 4 $v_data)) arg_z)        (bsr @recurse)        (move.l acc arg_y)        (move.l @vsp arg_z)        (move.l arg_y @vsp)        (bsr @recurse)        (vpop arg_y)        (swap arg_z)        (eor.l arg_y arg_z)       elseif# (eq (cmp.b ($ $v_macptr) da))        (move.l arg_z atemp0)        (move.l (svref atemp0 macptr.ptr) arg_z)        (mixup-hash-code arg_z)        (move.w ($ -8) da)        (and.w da arg_z)))    (movereg arg_z acc)    (rts)))(defun %%equalhash (&lap key)  ; certain types of objects are EQUAL when they're not EQL; traverse their components in some way  (lap    (if# (eq (dtagp arg_z $t_cons $t_vector))      (jmp #'%%eqlhash))    (if# (ne (dtagp arg_z $t_vector))   ; we care only if it's a string,  bit-vector, or pathname.      (move.l arg_z atemp0)      (vsubtype atemp0 da)      (if# (eq (cmp.b ($ $v_sstr) da))        (getvect atemp0 da)        ; da = number of chars        ; atemp0 points at first char@sstr-hash        (move.l da arg_z)        (dbfloop.l da                   (ror.l 5 arg_z)                   (moveq 0 arg_y)                   (move.b atemp0@+ dy)                   (eor.l dy arg_z)                   (swap dy)                   (eor.l dy arg_z))        (move.l ($ 7) dy)        (and.w arg_z dy)        (eor.w dy arg_z)        (ror.l 3 dy)        (eor.l dy arg_z)       elseif# (eq (cmp.b ($ $v_xstr) da))        (getvect atemp0 da)        ; da = number of chars        ; atemp0 points at first char@xstr-hash        (asr.l da)        (move.l da arg_z)        (dbfloop.l da                   (ror.l 5 arg_z)                   (moveq 0 arg_y)                   (move.w atemp0@+ dy)                   (eor.l dy arg_z)                   (swap dy)                   (eor.l dy arg_z))        (move.l ($ 7) dy)        (and.w arg_z dy)        (eor.w dy arg_z)        (ror.l 3 dy)        (eor.l dy arg_z)              elseif# (eq (cmp.b ($ $v_bitv) da))        (getvect atemp0 da)        (moveq 0 dy)        (sub.l ($ 2) da)                ; number of complete bytes        (move.b atemp0@+ dy)            ; number of bits in last byte        (lsl.l ($ 3) da)        (add.l dy da)                   ; total number of bits        (move.l da dy)        ; Here with da = number of bits, dy = displacement to last bit        ; atemp0 = first data byte of vector (offset of $v_data+1)@bitv-hash        (moveq 7 db)        (move.l db dx)        (and.l dy db)        (neg.w db)        (add.w dx db)        (lsr.l ($ 3) dy)        (moveq 0 arg_z)        (dbfloop.l da                 (rol.l ($ 5) arg_z)                 (add.w ($ 1) db)                 (if# (eq (and.w dx db))                   (sub.l ($ 1) dy))                 (if# (eq (btst db (atemp0 dy.l)))                   (add.l ($ 17) arg_z)                   else#                   (add.l ($ 31) arg_z)))        (mkint arg_z)        elseif# (and                 (eq                  (progn                    (move.l (atemp0 $v_data) db)                    (cmp.b ($ $v_istruct) da)))                 (or (eq (cmp.l 'pathname db))                     (eq (cmp.l 'logical-pathname db))))         ; use equalp-hash for pathnames (EQUAL is case-insensitive for them)         (cjmp %%equalphash-structure '11 arg_z)         elseif# (and (eq (cmp.b ($ $v_arrayh) da))                      (eq (cmp.w ($ $arh_one_dim) (svref atemp0 arh.fixnum $arh_rank4)))                      (eq (progn (move.b (svref atemp0 arh.fixnum $arh_type) db)                                 (if# (ne (cmp.b ($ $v_sstr) db))                                   (cmp.b ($ $v_bitv) db)))))        ; Dereference the sucker, then do -exactly- the same kind of hashing on active part of string/bit vector        ; as is done in simple case.        (move.l (svref atemp0 arh.fill) dy)        (move.l '0 da)        (prog#         (add.l (svref atemp0 arh.offs) da)         (btst ($ $arh_disp_bit) (svref atemp0 arh.fixnum $arh_bits))         (move.l (svref atemp0 arh.vect) atemp0)         (bne (top#)))        (getint da)                     ; da = displacement        (getint dy)                     ; dy = length        (if# (eq (cmp.b ($ $v_sstr) db))          (lea (atemp0 da.l $v_data) atemp0)          (move.l dy da)          (bra @sstr-hash)         elseif# (eq (cmp.b ($ $v_xstr) db))          (asl.l 1 da)           (lea (atemp0 da.l $v_data) atemp0)           (move.l dy da)           (bra @xstr-hash)                   else#                          ; A bit vector          (exg da dy)                   ; da=length, dy=displacement          (add.l da dy)                 ; index of last bit+1          (lea (atemp0 (1+ $v_data)) atemp0)          (bra @bitv-hash)))      (set_nargs 1)      (jmp #'%%eqlhash))    (cjmp %%equalhash-aux '11 arg_z)))(defun %%equalhash-aux (&lap limit key)  (lap    @recurse    (if# (le (tst.l arg_y))      (move.l '#.(mixup-hash-code 11) acc)      (rts))    (if# (ne (dtagp arg_z $t_cons))      (if# (eq nilreg arg_z)        (move.l '#.(mixup-hash-code 17) acc)        (rts))      (spush vsp)      (vpush nilreg)                      ; hash-code      (vpush nilreg)                      ; addressp      (vpush nilreg)                      ; ephemeral-p      (sub.l '1 arg_y)      (vpush arg_y)      (move.l arg_z atemp0)      (cdr atemp0 arg_z)      (vpush (car atemp0))      (lea (^ @recurse) atemp0)      (set_nargs 2)      (jsr_subprim $sp-mvpass)      (if# (eq (sub.l ($ 4) nargs))        (vpop arg_x)       elseif# (ne (sub.l ($ 8) nargs))        (dc.w #_debugger)       else#        (vpop acc)                      ; ephemeral-p        (move.l acc (vsp 16))        (vpop acc)                      ; addressp        (if# (ne (cmp.l nilreg acc))          (move_t (vsp 16)))        (vpop arg_x))                   ; hash code      (vpop arg_z)                      ; car of key      (vpop arg_y)                      ; limit      (sub.l '1 arg_y)      (vpush arg_x)      (lea (^ @recurse) atemp0)      (set_nargs 2)      (jsr_subprim $sp-mvpass)      (if# (eq (sub.l ($ 4) nargs))        (vpop acc)       elseif# (ne (sub.l ($ 8) nargs))        (dc.w #_debugger)       else#        (vpop acc)                      ; ephemeral-p        (if# (ne (cmp.l nilreg acc))          (move.l acc (vsp 12)))        (vpop acc)                      ; addressp        (if# (ne (cmp.l nilreg acc))          (move_t (vsp 12)))        (vpop acc))                   ; hash code      (add.l vsp@+ acc)      (rotate-hash-code acc arg_y)      (move.l acc (vsp 8))      (set_nargs 3)      (jmp_subprim $sp-nvalret))    ; EQUAL doesn't descend anything else that might be circular.    ; Pathnames aren't circular.  Are they ?    (set_nargs 1)    (jmp #'%%equalhash))); Same as %%equalhash, but different:;  1) Real numbers are hashed as if they were double-floats.  The real components of complex numbers;     are hashed as double-floats and XORed together.;  2) Characters and strings are hashed in a case-insensitive manner.;  3) Hash tables are hashed based on their size and type.;  4) Structures and CL array types are hashed based on their content.(defun %%equalphash (&lap key)  (lap    (if# (ne (dtagp arg_z $t_fixnum $t_sfloat $t_dfloat))@real      (jsr_subprim $sp-rat2xf)      (fp1-hash)      (rts))    (if# (ne (dtagp arg_z $t_imm))      (if# (eq (cmp.b ($ $t_imm_char) arg_z))        (swap arg_z)        (if# (and (le (cmp.w ($ (char-code #\z)) arg_z))                  (ge (cmp.w ($ (char-code #\a)) arg_z)))          (add.w ($ (- (char-code #\A) (char-code #\a))) arg_z))        (mkint arg_z)        (movereg arg_z acc)        (mixup-hash-code acc)        (rts))      (movereg arg_z acc)      (move.w ($ -8) da)      (and.w da acc)      (mixup-hash-code acc)      (rts))    ; Some array types have to be descended or otherwise special-cased.    (if# (ne (dtagp arg_z $t_vector))      (move.l arg_z atemp0)      (vsubtype atemp0 da)      (if# (or (eq (cmp.b ($ $v_complex) da))               (eq (cmp.b ($ $v_ratio) da)))        (vpush (atemp0 $v_data))        (move.l (atemp0 (+ 4 $v_data)) arg_z)        (vpush arg_z)        (move.l '0.0 arg_y)        (jsr_subprim $sp-eqlregacc)        (if# ne          (add.l ($ 4) vsp)          (move.l @vsp arg_z)          (move.l '0 da)          (move.l da @vsp)         else#          (vpop arg_z)          (bsr @real)          (move.l acc arg_y)          (move.l @vsp arg_z)          (move.l arg_y @vsp))        (bsr @real)        (add.l vsp@+ acc)        (mixup-hash-code acc)        (rts))      (if# (eq (cmp.b ($ $v_bignum) da))        (vpush arg_z)        (ccall <= (special most-negative-double-float) arg_z)        (if# (ne (cmp.l nilreg acc))          (ccall <= @vsp (special most-positive-double-float))          (if# (ne (cmp.l nilreg acc))            (vpop arg_z)            (bra @real)))        (vpop arg_z)        (set_nargs 1)        (jmp #'%%eqlhash))      (if# (or (eq (cmp.b ($ $v_struct) da))               (and (eq (cmp.b ($ $v_istruct) da))                    (ne (if# (eq (progn (move.l 'hash-table db)                                        (move.l arg_z atemp0)                                        (cmp.l (svref atemp0 0) db)))                          (set_nargs 1)                          (jmp #'equalphash-hash-table)))))        (cjmp %%equalphash-structure '11 arg_z))      (if# (eq (cmp.b ($ $v_instance) da))        (set_nargs 1)        (jmp #'%%eqhash))      (cjmp %%equalphash-array '11 arg_z))    (if# (eq (dtagp arg_z $t_cons))      (set_nargs 1)      (jmp #'%%eqlhash))    (cjmp %%equalphash-aux '11 arg_z)))(defun equalphash-hash-table (hash-table)  (let ((hash (%%equalhash "HASH-TABLE"))        addressp ephemeral-p)    (declare (fixnum hash))    (incf hash (the fixnum (%%eqhash (hash-table-count hash-table))))    (multiple-value-bind (h ap ep) (%%eqhash (nhash.comparef hash-table))      (declare (fixnum h))      (incf hash h)      (if ap (setq addressp t))      (if ep (setq ephemeral-p t)))    (multiple-value-bind (h ap ep) (%%eqhash (nhash.keytransF hash-table))      (declare (fixnum h))      (incf hash h)      (if ap (setq addressp t))      (if ep (setq ephemeral-p t)))    (if (or addressp ephemeral-p)      (values hash addressp ephemeral-p)      hash)))(defun %%equalphash-structure (limit key)  (let* ((size (uvsize key))         (hash (mixup-hash-code size))         addressp ephemeral-p)    (declare (fixnum limit size hash))    (dotimes (i size)      (multiple-value-bind (h ap ep) (%%equalphash-aux limit (%svref key i))        (declare (fixnum h))        (setq hash (the fixnum (+ (rotate-hash-code hash) h)))        (if ap (setq addressp t))        (if ep (setq ephemeral-p t)))      (when (<= (decf limit) 0)        (setq hash (the fixnum (+ (rotate-hash-code hash)                                  #.(mixup-hash-code 11))))        (return)))    (if (or addressp ephemeral-p)      (values hash addressp ephemeral-p)      hash)))(defun %%equalphash-array (limit key)  (multiple-value-bind (array offset) (array-data-and-offset key)    (let* ((rank (array-rank key))           (vectorp (eql rank 1))           (size (if vectorp (length key) (array-total-size key)))           (hash (mixup-hash-code rank))           addressp ephemeral-p)      (declare (fixnum size hash limit rank))      (if vectorp        (setq hash              (the fixnum                   (+ (rotate-hash-code hash)                      (the fixnum (mixup-hash-code size)))))        (dotimes (i rank)          (declare (fixnum i))          (setq hash                (the fixnum                      (+ (rotate-hash-code hash)                        (the fixnum                             (mixup-hash-code (array-dimension key i))))))))      (let ((sign (lap-inline ()                    (:variable array)                    (move.l (varg array) atemp0)                    (vsubtype atemp0 da)                    (if# (eq (cmp.b ($ $v_slongv) da))                      (move.l '1 acc)                     elseif# (eq (cmp.b ($ $v_ulongv) da))                      (move.l '-1 acc)                     else#                      (move.l nilreg acc)))))        (if sign          (return-from %%equalphash-array             (%%equalphash-byte32-array hash sign limit array offset size))))      (dotimes (i size)        (declare (fixnum i))        (multiple-value-bind (h ap ep) (%%equalphash-aux limit (uvref array offset))          (declare (fixnum h))          (setq hash (the fixnum (+ (rotate-hash-code hash) h)))          (if ap (setq addressp t))          (if ep (setq ephemeral-p t)))        (when (<= (decf limit) 0)          (setq hash (the fixnum (+ (rotate-hash-code hash)                                    #.(mixup-hash-code 11))))          (return))        (incf offset))      (if (or addressp ephemeral-p)        (values hash addressp ephemeral-p)        hash)))); This is seperate to prevent consing bignums.; equalp should be so careful.(defun %%equalphash-byte32-array (hash sign limit array offset size)  (declare (fixnum hash size limit offset))  (dotimes (i size)    (declare (fixnum i))    (lap-inline ()      (:variable hash array offset limit sign)      (move.l (varg array) atemp0)      (move.l (varg offset) da)      (vscale.l da)      (if# (and (mi (tst.l (varg sign)))                (mi (tst.l (atemp0 da.l $v_data))))        (spush (atemp0 da.l $v_data))        (bclr ($ 7) @sp)        (fmove.l @sp fp1)        (move.l '#.(float #x80000000) atemp0)        (fmove.d (atemp0 (- $t_dfloat)) fp3)        (fadd.x fp3 fp1)        (add.l ($ 4) sp)        else#        (fmove.l (atemp0 da.l $v_data) fp1))      (fp1-hash)      (add.l (varg hash) acc)      (mixup-hash-code acc)      (move.l acc (varg hash)))    (when (<= (decf limit) 0)      (setq hash (lap-inline (#.(mixup-hash-code 11) hash)                   (add.l arg_y arg_z)                   (mixup-hash-code arg_z)                   (movereg arg_z acc)))      (return))    (incf offset))  hash)(defun %%equalphash-aux (&lap limit key)  (lap    @recurse    (if# (le (tst.l arg_y))      (move.l '#.(mixup-hash-code 11) acc)      (rts))    (if# (ne (dtagp arg_z $t_cons))      (if# (eq nilreg arg_z)        (move.l '#.(mixup-hash-code 17) acc)        (rts))      (spush vsp)      (vpush nilreg)                      ; hash-code      (vpush nilreg)                      ; addressp      (vpush nilreg)                      ; ephemeral-p      (sub.l '1 arg_y)      (vpush arg_y)      (move.l arg_z atemp0)      (cdr atemp0 arg_z)      (vpush (car atemp0))      (lea (^ @recurse) atemp0)      (set_nargs 2)      (jsr_subprim $sp-mvpass)      (if# (eq (sub.l ($ 4) nargs))        (vpop arg_x)       elseif# (ne (sub.l ($ 8) nargs))        (dc.w #_debugger)       else#        (vpop acc)                      ; ephemeral-p        (move.l acc (vsp 16))        (vpop acc)                      ; addressp        (if# (ne (cmp.l nilreg acc))          (move_t (vsp 16)))        (vpop arg_x))                   ; hash code      (vpop arg_z)                      ; car of key      (vpop arg_y)                      ; limit      (sub.l '1 arg_y)      (vpush arg_x)      (lea (^ @recurse) atemp0)      (set_nargs 2)      (jsr_subprim $sp-mvpass)      (if# (eq (sub.l ($ 4) nargs))        (vpop acc)       elseif# (ne (sub.l ($ 8) nargs))        (dc.w #_debugger)       else#        (vpop acc)                      ; ephemeral-p        (if# (ne (cmp.l nilreg acc))          (move.l acc (vsp 12)))        (vpop acc)                      ; addressp        (if# (ne (cmp.l nilreg acc))          (move_t (vsp 12)))        (vpop acc))                   ; hash code      (add.l vsp@+ acc)      (mixup-hash-code acc)      (move.l acc (vsp 8))      (set_nargs 3)      (jmp_subprim $sp-nvalret)); If anything other than an (general or n-dim) array or a structure,; %%equalphash won't recurse.    (if# (ne (dtagp arg_z $t_vector))      (move.l arg_z atemp0)      (vsubtype atemp0 da); If $v_struct, $v_istruct and not hash-table call %%equalphash-structure      (if# (or (eq (cmp.b ($ $v_struct) da))               (and (eq (cmp.b ($ $v_istruct) da))                    (ne (if# (eq (progn (move.l 'hash-table db)                                        (cmp.l (svref atemp0 0) db)))                          (set_nargs 1)                          (jmp #'equalphash-hash-table)))))        (set_nargs 2)        (jmp #'%%equalphash-structure))      (if# (and (ge (cmp.b ($ $v_min_arr) da))                (le (cmp.b ($ $v_arrayh) da)))        (set_nargs 2)        (jmp #'%%equalphash-array)))    (set_nargs 1)    (jmp #'%%equalphash)))(defun alist-hash-table (alist &rest hash-table-args)  (declare (dynamic-extent hash-table-args))  (if (typep alist 'hash-table)    alist    (let ((hash-table (apply #'make-hash-table hash-table-args)))      (dolist (cons alist) (puthash (car cons) hash-table (cdr cons)))      hash-table)))(defun %hash-table-equalp (x y)  ; X and Y are both hash tables  (let* ((test (hash-table-test x)))    (and (eq test             (hash-table-test y))         (eql (hash-table-count x)              (hash-table-count y))         (block nil           (let* ((default (cons nil nil))                  (foo #'(lambda (k v)                           (let ((y-value (gethash k y default)))                             (unless (and (neq default y-value)                                          (funcall test v y-value))                               (return nil))))))             (declare (dynamic-extent foo default))             (maphash foo x))           t))))(eval-when (:compile-toplevel :execute)  (declaim (inline strip-tag-to-fixnum))  )(defun strip-tag-to-fixnum (x)  (declare (fixnum x))  ;; logand-2 happens to know how to turn itself into %ilogand2,  ;; but doesn't try to be smart about "-1".  (logand x -1))(eval-when (:compile-toplevel :execute)  (defmacro immediate-p-macro (thing) ; boot weirdness        `(dtagp ,thing (logior (ash 1 $t_fixnum)                           (ash 1 $t_sfloat)                           (ash 1 $t_imm)))))(defun sxhash (s-expr)  "Computes a hash code for S-EXPR and returns it as an integer."  (logand (sxhash-aux s-expr 7 17) most-positive-fixnum))#|(defun sxhash-aux (expr counter key)  ;(declare (fixnum counter key))  (declare (fixnum counter))  ; key often not fixnum  ;(when (bignump key) (print (list 'big key)))  ;(setq key (logand key most-positive-fixnum))  (if (> counter 0)    (typecase expr      ((or string bit-vector number)  (%i+ key (%%equalhash expr)))      ((or pathname logical-pathname)       (dotimes (i (uvsize expr) key)         (declare (fixnum i))         (setq key (%i+ key (sxhash-aux (%svref expr i) (1- counter) key)))))      (symbol (%i+ key (%%equalhash (symbol-name expr))))      (cons (sxhash-aux             (cdr expr)             (the fixnum (1- counter))                          (%i+ key (sxhash-aux (car expr) (the fixnum (1- counter)) key))))      (t (%i+ counter key            (%%equalhash (symbol-name (%type-of expr))))))    key))|#(defun sxhash-aux (expr counter key)  (declare (fixnum counter key))  (declare (fixnum counter))  ; key often not fixnum  ;(when (bignump key) (print (list 'big key)))  ;(setq key (logand key most-positive-fixnum))  (if (> counter 0)    (typecase expr             ((or string bit-vector number)   (%i+ key (%%equalhash expr)))             ((or pathname logical-pathname)              (dotimes (i (uvsize expr) key)                (declare (fixnum i))                (setq key (%i+ key (sxhash-aux (%svref expr i) (1- counter) key)))))      (symbol (%i+ key (%%equalhash (symbol-name expr))))      (cons (sxhash-aux                    (cdr expr)                    (the fixnum (1- counter))                                 (%i+ key (sxhash-aux (car expr) (the fixnum (1- counter)) key))))      (macptr (%i+ key (%%eqlhash expr)))      (t (cond ((immediate-p-macro expr)                (%i+ (rotate-hash-code key) (mixup-hash-code (strip-tag-to-fixnum expr))))               ((or (structurep expr)(istructp expr)) (%i+ (rotate-hash-code key) (sxhash-structure expr counter key)))               ((arrayp expr)(setq key (%i+ (rotate-hash-code key) (sxhash-array expr counter key))))               ((standard-instance-p expr) (%i+ key (sxhash-structure expr counter key)))               (t (%i+ counter key (%%equalhash (symbol-name (%type-of expr))))))))      key))(defun sxhash-structure (expr limit hash)  (let* ((size (uvsize expr)))    (declare (fixnum limit size hash))    (dotimes (i size)      (setq hash (sxhash-aux (%svref expr i) limit hash))      (when (<= (decf limit) 0)        (setq hash (the fixnum (+ (the fixnum (rotate-hash-code hash))                                  #.(mixup-hash-code 11))))        (return)))      hash))(defun sxhash-array (key limit hash)  (declare (fixnum limit hash))  (multiple-value-bind (array offset) (array-data-and-offset key)    (let* ((rank (array-rank key))           (vectorp (eql rank 1))           (size (if vectorp (length key) (array-total-size key))))      (declare (fixnum size hash limit rank))      (setq hash (%i+ hash (mixup-hash-code rank)))      (if vectorp        (setq hash              (the fixnum                (+ (the fixnum (rotate-hash-code hash))                   (the fixnum (mixup-hash-code size)))))        (dotimes (i rank)          (declare (fixnum i))          (setq hash                (the fixnum                   (+ (the fixnum (rotate-hash-code hash))                     (the fixnum                       (mixup-hash-code (array-dimension key i))))))))            (dotimes (i size)        (declare (fixnum i))        (setq hash (sxhash-aux (uvref array offset) limit hash))        (when (<= (decf limit) 0)          (setq hash (the fixnum (+ (the fixnum (rotate-hash-code hash))                                    #.(mixup-hash-code 11))))          (return))        (incf offset))      hash))); Can't compile the LAP in the macro expansion of %needs-rehashing in user code(defun needs-rehashing (hash)  (%needs-rehashing hash))#| ; in lib;hash.lisp(defmethod make-load-form ((hash hash-table))  (let ((rehashF (function-name (nhash.rehashF hash)))        (keytransF (nhash.keytransF hash))        (compareF (nhash.compareF hash))        (vector (nhash.vector hash))        (count (nhash.count hash))        (locked-additions (nhash.locked-additions hash)))    (flet ((convert (f)             (if (or (fixnump f) (symbolp f))               `',f               `(symbol-function ',(function-name f)))))      (values       `(%cons-hash-table         nil nil nil nil ,(nhash.grow-threshold hash) ,(nhash.rehash-ratio hash) ,(nhash.rehash-size hash))       `(%initialize-hash-table ,hash ',rehashF ,(convert keytransF) ,(convert compareF)                                ',vector ,count ',locked-additions)))))(defun %initialize-hash-table (hash rehashF keytransF compareF vector count locked-additions)  (setf (nhash.rehashF hash) (symbol-function rehashF)        (nhash.keytransF hash) keytransF        (nhash.compareF hash) compareF        (nhash.vector hash) vector        (nhash.count hash) count        (nhash.locked-additions hash) locked-additions)  (unless (eq rehashF '%no-rehash)    (needs-rehashing hash)))|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Support for locking hash tables while fasdumping;;#|;; This needs to be updated for processes - OK?;; is it ok if its being rehashed or growing?(defun fasl-lock-hash-table (hash-table)  (setq hash-table (require-type hash-table 'hash-table))  (without-interrupts   (let ((hlock (nhash.lock hash-table)))     (push (cons hash-table hlock) *fcomp-locked-hash-tables*) ; cons not needed     (when  (eq $nhash.lock-map-count-mask (logand hlock $nhash.lock-map-count-mask))       (error "Too many mappers of ~S" hash-table))     (setf (nhash.lock hash-table) (1+ hlock)))))(defun fasl-unlock-hash-tables ()  (dolist (hash-table.lock *fcomp-locked-hash-tables*)    (decf (nhash.lock (car hash-table.lock)))))|#	      #+not-yet(progn;;;;;;;;;;;;;;;;; Replacement for population;;(def-accessors (weak-table) %svref  nil                                   ; 'weak-table  weak-table.vector                     ; a $v_nhash vector  weak-table.index                      ; index for next entry  weak-table.grow-threshold             ; number of entries left in vector  )(defun make-weak-table (&optional (size 20))  (%gvector $v_istruct            'weak-table            (%cons-nhash-vector             size (+ (ash 1 $nhash_weak_bit)))            0            size))(defun weak-table-p (weak-table)  (istruct-typep weak-table 'weak-table))(setf (type-predicate 'weak-table) 'weak-table-p)(defun weak-table-count (weak-table)  (setq weak-table (require-type weak-table 'weak-table))  (- (weak-table.index weak-table)     (nhash.vector.weak-deletions-count (weak-table.vector weak-table))))(defun weak-table-push (key weak-table &optional value)  (setq weak-table (require-type weak-table 'weak-table))  (let ((thresh (weak-table.grow-threshold weak-table))        (vector (weak-table.vector weak-table))        (index (weak-table.index weak-table)))    (declare (fixnum thresh index))    (if (> thresh 0)      (progn        (lap-inline (index)          (:variable vector key value)          (move.l (varg vector) atemp0)          (lea (atemp0 arg_z.l $nhash_data) atemp0)          (move.l (varg key) atemp0@+)          (move.l (varg value) @atemp0))        (setf (weak-table.index weak-table) (the fixnum (1+ index))              (weak-table.grow-threshold weak-table) (the fixnum (1- thresh)))        value)      (let ((deletions (nhash.vector.weak-deletions-count vector)))        (declare (fixnum deletions))        (if (> deletions 0)          ; GC deleted some entries, we can compact the table          (progn            (lap-inline (index)              (:variable vector)              (getint arg_z)            ; length              (move.l (varg vector) atemp0)              (lea (atemp0 $nhash_data) atemp0)              (move.l atemp0 atemp1)              (move.l ($ $undefined) da)              ; Find the first deleted entry              (dbfloop.l arg_z                (if# (ne (cmp.l @atemp0 da))                  (add.l ($ 1) arg_z)                  (bra @move))                (add.w ($ 8) atemp0))              ; copy the rest of the table up              @move              (dbfloop.l arg_z                (move.l atemp0@+ db)                (if# (eq (cmp.l db da))                  (add.w ($ 4) atemp0)                 else#                  (move.l db atemp1@+)                  (move.l atemp0@+ atemp1@+)))              ; Write over the newly emptied part of the table              (while# (ne (cmp.l atemp0 atemp1))                (move.l da @atemp1)                (add.l ($ 8) atemp1)))            (setf (nhash.vector.weak-deletions-count vector) 0                  (weak-table.index weak-table) (the fixnum (- index deletions))                  (weak-table.grow-threshold weak-table) (the fixnum (+ thresh deletions)))            (weak-table-push key weak-table value))          ; table is full.  Grow it by a factor of 1.5          (let* ((new-size (+ index (the fixnum (ash (the fixnum (1+ index)) -1))))                 (new-vector (%cons-nhash-vector new-size (ash 1 $nhash_weak_bit))))            (declare (fixnum new-size))            (lap-inline (index)              (:variable vector new-vector count)              (move.l (varg vector) atemp0)              (move.l (varg new-vector) atemp1)              (lea (atemp0 $nhash_data) atemp0)              (lea (atemp1 $nhash_data) atemp1)              (getint arg_z)            ; table length              (dbfloop.l arg_z                (move.l atemp0@+ atemp1@+)                (move.l atemp0@+ atemp1@+)))            (setf (weak-table.vector weak-table) new-vector                  (weak-table.grow-threshold weak-table) (the fixnum (- new-size index)))            ; It's possible that GC deleted some entries while consing the new vector            (setf (nhash.vector.weak-deletions-count new-vector)                  (nhash.vector.weak-deletions-count vector))            (weak-table-push key weak-table value))))))); function gets two args: key & value(defun map-weak-table (function weak-table)  (setq weak-table (require-type weak-table 'weak-table))  (let* ((vector (weak-table.vector weak-table))         (index (weak-table.index weak-table))         (flags (nhash.vector.flags vector)))    (unwind-protect      (progn        (setf (nhash.vector.flags vector) 0)    ; disable deletion by GC        (lap-inline ()          (:variable function vector index)          (while# (gt (move.l (varg index) da))            (sub.l '1 da)            (move.l da (varg index))            (move.l (varg vector) atemp0)            (move.l (atemp0 da.l $nhash_data) arg_y)            (if# (ne (cmp.w ($ $undefined) arg_y))              (move.l (atemp0 da.l (+ $nhash_data 4)) arg_z)              (set_nargs 2)              (move.l (varg function) atemp0)              (jsr_subprim $sp-funcall))))        nil)      (setf (nhash.vector.flags vector) flags)))); function gets one arg, the key(defun map-weak-table-keys (function weak-table)  (flet ((f (key value)           (declare (ignore value))           (funcall function key)))    (declare (dynamic-extent #'f))    (map-weak-table #'f weak-table)))    )(%include "ccl:lib;hash.lisp")  ; maphash and friends are shared #| ; testing 1 2 3(defvar *p1 nil)(defvar *p2 nil)(defvar *hash nil)(setq *p1  (make-process "P1" :background-p t))(setq *p2 (make-process "P2" :background-p t))(setq *hash (make-hash-table :size 10))(process-preset *p1 #'(lambda ()                           (dotimes (i 20)                             (setq *hash (make-hash-table :size 10))                             (dotimes (i 2000)                               (puthash (gensym) *hash i)                               ;(when (eq 0 (mod i 500)) (gc))                               ))))(process-preset *p2 #'(lambda ()                       (dotimes (i 400)                         (let ((hash *hash))                                                      (setq it nil)                           (let  ((poo 0))                           (maphash #'(lambda (a b)                                           (setq it (cons (cons a b) it))                                           (let ((c (gethash a hash)))                                             (when (neq c b)                                                                                              (format t "~&test failing ~s ~s ~s ~x ~s" a b c                                                        (nhash.lock hash) hash)))                                           (incf poo)                                           (when (eq 0 (mod poo 5))                                             (remhash a hash)))                                      hash))))))    (process-enable *p1)(process-enable *p2)|##|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)