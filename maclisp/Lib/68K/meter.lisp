;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  2 2/17/95  akh  mumble some comments;;  (do not edit before this line!!);; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.;11/20/92 gb  new vector headers; incorporate changes in CDROM release.;-------------- 2.0;09/10/91 gb  coerce _StripAddress a few more times.;--------------- 2.0b3;08/24/91 gb  use new trap syntax.;08/10/91 gb   (a5 $fwdnum) is a fixnum.;05/29/91 gb   new cons-area equates.;02/18/91 gb   %uvsize -> uvsize.;02/07/91 alice ccl; => ccl:;--------------- 2.0b1;10/27/90 gb  Use _StripAddress in segment-start-addresses.  Always defined ?;07/13/90 gb  New find-all-functions.  Sometimes works, sometimes doesn't.;04/30/90 gb  use new lap control structures.  Dunno if it works.;09/24/89 gb  Sort of works again, modulo egc, user mode, etc.;08/24/89 gb  Sort of works again, modulo egc, user mode, etc.;04/07/89 gb  $sp8 -> $sp.(in-package "CCL")#| to use (init-metering)(meter-all-functions)(disable-metering)(meter-results); numbers are time in function, % total-function-time %total-time, ?, ?; again(disable-metering)(meter-all-functions) or:(init-metering)(meter form)(meter-results)|#(eval-when (:execute :compile-toplevel)  (require 'lap)  (require 'lapmacros))(defvar *kernel-table* nil)(defvar *kernel-table-size* 0)(defvar *a5-subprim-table* nil)(defvar *a5-subprim-names* nil)(defvar *a5-subprim-table-size* 0)(defvar *all-metered-functions* nil)(defvar *kernel-table-names* nil)(defvar *low-a5-subprim* nil)(defvar *high-a5-subprim* nil)(defvar *lisp-mapfile* "ccl:lisp-8.map")(defun make-ptr-fn (words)  (let* ((nwords (length words))         (p (#_NewPtr :errchk (+ nwords nwords))))      (declare (fixnum nwords))    (dotimes (i nwords (progn (lap-inline () (jsr_subprim $sp-clrcache)) p))      (%put-word p (pop words) (+ i i)))))(defmacro ptrfun (&body body)  `(make-ptr-fn  ',(%lap-words body))); Jsr someplace that neither conses or trashes registers. I hope.; Return nil, just to be nice.(defun jsr-to (macptr)  (old-lap   (move.l arg_z atemp0)   (jsr_subprim $sp-macptrptr)   (jsr @atemp0)   (move.l nilreg acc)   (lfret)))(defparameter *int-depth* nil)(defparameter *meter-task* nil)(defun remove-meter-task ()  (#_rmvtime :errchk (%inc-ptr *meter-task* 2)))(defun disable-metering ()  (without-interrupts    (when (metering-enabled-p)      (%put-word *meter-task* 0 66)      (remove-meter-task))))(defun metering-enabled-p ()  (neq 0 (%get-word *meter-task* 66)))(defun ensure-metering-disabled ()  (if (metering-enabled-p)    (error "Metering enabled.")))(defun enable-metering ()  (without-interrupts   (unless (metering-enabled-p)     (%put-word *meter-task* -1 66)     (with-macptrs (q)       (%setf-macptr q (%inc-ptr *meter-task* 2))       (%put-ptr q *meter-task* 6)       (#_instime q)       (#_Primetime q 20)))))      (defun find-all-functions ()  ; This is really stupid.  (let* ((v (make-array 1000 :adjustable t :fill-pointer 0)))    (%map-lfuns #'(lambda (f) (vector-push-extend f v)))    (let* ((n (length v))           (p (make-array (lsh n 1) :initial-element 0))           (v0 (displaced-array-p v)))      (dotimes (i n p)        (declare (fixnum i))        (setf (aref p (+ i i)) (aref v0 i))))))(defun meter-all-functions (&optional flag)  (ensure-metering-disabled)  (if (or (null *all-metered-functions*)          (eq flag :new))    (setq *all-metered-functions* (find-all-functions)))  (reset-meter-counts)  (old-lap   (move.l (special *meter-task*) atemp1)   (move.l (atemp1 $v_data) atemp1)   (lea (special *all-metered-functions*) atemp0)    (move.l atemp0 (atemp1 44)))  (enable-metering)  nil)(defun reset-meter-counts ()  (ensure-metering-disabled)  (let ((v 0))    (old-lap     (move.l (special *meter-task*) atemp0)     (jsr_subprim $sp-macptrptr)     (move.l (a0 44) d0)     (if# ne       (move.l d0 a0)       (move.l @a0 (varg v))))    (if (neq v 0)      (dotimes (i (the fixnum (uvsize v)))        (declare (fixnum i))        (if (logbitp 0 i)          (%svset v i 0))))    (%put-long *meter-task* 0 28)    (%put-long *meter-task* 0 32)    (%put-long *meter-task* 0 40)    (%put-long *meter-task* 0 48)    (%put-long *meter-task* 0 68)    (%put-long *meter-task* 0 72)    (%put-long *meter-task* 0 80)    (with-macptrs (p)      (old-lap       (move.l (special *meter-task*) atemp0)       (jsr_subprim $sp-macptrptr)       (move.l (varg p) atemp1)       (move.l (atemp0 60) (atemp1 $v_data)))      (if (neq (%ptr-to-int p) 0)        (dotimes (i *kernel-table-size*)          (declare (fixnum i))          (%put-long p 0 (%i+ 4 (%ilsl 3 i)))))      (old-lap       (move.l (special *meter-task*) atemp0)       (jsr_subprim $sp-macptrptr)       (move.l (varg p) atemp1)       (move.l (atemp0 76) (atemp1 $v_data)))      (if (neq (%ptr-to-int p) 0)        (dotimes (i *a5-subprim-table-size*)          (declare (fixnum i))          (%put-long p 0 (%i+ 4 (%ilsl 3 i))))))))(defun segment-start-addresses ()  (let ((table (make-array 5))        (res nil))    (unwind-protect      (progn        (#_SetResLoad nil)        (dotimes (i (length table) table)          (declare (fixnum i))          (if (handlep (setq res                              (#_Get1Resource "CODE" i)))            (progn              (svset table i (%i+ 4 (%ptr-to-int (#_StripAddress (%get-ptr res)))))))))      (#_SetResLoad t))))(defun kernel-table-names (mapfile)  (let* ((eof (cons nil nil))         (segs (segment-start-addresses))         (nametable (make-array 100 :adjustable t :fill-pointer 0))         (addrtable (make-array 100 :adjustable t :fill-pointer 0))         (a5table (make-array 100 :element-type '(signed-byte 16) :adjustable t :fill-pointer 0))         (a5names (make-array 100 :adjustable t :fill-pointer 0))         (n 0)         (lastaddr nil)         segbase         (lowa5 #x8000)         (higha5 -1)         (nsegs (length segs))         name         seg         addr)    (let* ((*readtable* (copy-readtable))           (*read-base* 16.))      (set-syntax-from-char #\: #\space)      (set-syntax-from-char #\# #\space)      (set-syntax-from-char #\= #\space)      (with-open-file (in mapfile :direction :input)        (loop          ; TMON expects the segment number to be decimal, but cvtmap writes it in hex.          (when (or (eq (let ((*read-base* 10.)) (setq name (read in nil eof))) eof)                    (eq (setq seg (read in nil eof)) eof)                    (eq (setq addr (read in nil eof)) eof))            (return))          (if (> seg 0)            (when (and (< seg nsegs)                       (setq segbase (aref segs seg)))              (setq addr (+ addr segbase))              (if (eq addr lastaddr)                (setf (aref nametable (1- n)) name)                (progn                  (vector-push-extend (setq lastaddr addr) addrtable)                  (vector-push-extend name nametable)                  (setq n (1+ n)))))            (when (> #x8000 addr 0)              (if (< addr lowa5)                (setq lowa5 addr))              (if (> addr higha5)                (setq higha5 addr))              (vector-push-extend name a5names)              (vector-push-extend addr a5table))))))    (let* ((p (#_NewPtr :errchk (%ilsl 3 n)))           (m (length a5table))           (a5p (#_NewPtr :errchk (%ilsl 3 m)))           (a5v (displaced-array-p a5table))           (q 0))      (old-lap       (move.l (varg a5p) atemp0)       (move.l (atemp0 $v_data) atemp0)       (move.l (varg a5v) atemp1)       (add.w ($ $v_data) atemp1)       (move.l (varg m) da)       (getint da)       (bra @dbf)@loop  (move.w atemp1@+ db)       (ext.l db)       (add.l a5 db)       (move.l db atemp0@+)       (clr.l atemp0@+)@dbf   (dbf da @loop))      (dotimes (i n (values p nametable a5p a5names n m lowa5 higha5))        (declare (fixnum i))        (%put-long p (aref addrtable i) q)        (%put-long p 0 (%i+ q 4))        (setq q (%i+ q 8))))))(defun init-metering ()  (setq *int-depth*         (let ((findit                (ptrfun                (bra @around)                @result                (dc.w 0)                @q                (dc.w 0 0 0 0 0 0 0 0 0 0 0 0)                @around                (lea (^ @q) a0)                (lea (^ @handler) a1)                (move.l a1 (a0 6))                (lea (^ @result) a1)                (move.w ($ 1) @a1)                (dc.w #.#_InsTime)                (move.l ($ 20) d0)                (dc.w #.#_PrimeTime)                (clr.w @a1)                (dc.w #x44fc 31) ; (move.w ($ 31) ccr)                @loop              ; @handler looks for this address on stack,                (bra @loop)      ;  adjusts it when found.                @done                (lea (^ @q) a0)                (dc.w #.#_rmvtime)                (rts)                @handler                (lea (^ @q) a0)                (move.l ($ 20) d0)                (dc.w #.#_PrimeTime)                (lea (^ @result) a0)                (move.w @a0 d0)                (if# eq                  (lea (^ @loop) a0)                  (move.l a0 d2)                  (move.l ($ 0) d0)                  (until# (ge (cmp.w ($ 256) d0))                    (move.w (a7 d0.w 0) d1)                    (cmp.b ($ 31) d1)                    (if# eq                      (move.l (a7 d0.w 2) d1)                      (if# (eq d1 d2)                        (add.w ($ 2) d0)                        (add.l ($ 2) (a7 d0.w 0))                        (bra @return)))                    (add.w ($ 2) d0))                  (move.l ($ -1) d0))                @return                (lea (^ @result) a0)                (move.w d0 @a0)                (rts))))          (jsr-to findit)          (prog1 (%get-word findit 2)            (#_DisPosEPtr findit))))  (when (and (boundp '*meter-task*)           (macptrp *meter-task*))    (disable-metering)    (remove-meter-task)    (#_DisPosePtr *meter-task*))  (setq *meter-task*        (ptrfun         @entry         (bsr @doit)         @q ; 2         (dc.w 0 0 0 0 0 0 0 0 0 0 0 0)         @depth ; 26         (dc.w 0)         @total ; 28         (dc.w 0 0)         @lftotal ; 32         (dc.w 0 0)         @ra5 ;36         (dc.w 0 0)         @abovea5 ;40         (dc.w 0 0)         @lfvecaddr ;44         (dc.w 0 0)         @jtabtotal ;48         (dc.w 0 0)         @jtablow ;52         (dc.w 0 0)         @jtabhigh ;56         (dc.w 0 0)         @jtabptr ;60         (dc.w 0 0)         @prime ;64         (dc.w 1)         @enabled ; 66         (dc.w 0)         @symbols ; 68         (dc.w 0 0)         @a5subptotal ; 72         (dc.w 0 0)         @a5subptable ; 76         (dc.w 0 0)         @romtotal ; 80         (dc.w 0 0)         @lowa5subprim ; 84         (dc.w 0)         @higha5subprim ; 86         (dc.w 0)         @doit         (move.l @sp a0)         (move.l a5 @sp)         (move.l (^ @ra5) a5)         (move.l ($ 0) d0)         (move.w (^ @prime) d0)         (move.l d0 d2)         (dc.w #.#_PrimeTime)         ; At least one bucket to tick         (lea (^ @total) a0)         (add.l d2 @a0)         (move.w (^ @depth) d1)         (move.l (sp d1.w 4) d1)                  ; D1.L is interrupted address, sometimes called "Address Interruptus."                  (if# (eq (tst.b (a5 $gcon)))           andif# (ne (move.l (^ @lfvecaddr) d0))           (move.l d0 a0)           (move.l @a0 a0)           (if# (eq (ttagp ($ $t_vector) a0 d0))             (getvect a0 d0)             (if# (cc @a0 d1)               andif# (cs (a0 d0.l -8) d1)               (lea (^ @lftotal) a1)               (add.l d2 @a1)               (lea (a0 d0.l 0) a1)               (mkint d2)               (bra @bsearch))))         (if# (cc (^ @jtablow) d1)          andif# (cs (^ @jtabhigh) d1)          (lea (^ @jtabtotal) a0)          (add.l d2 @a0)          (move.l (^ @jtabptr) d0)          (if# ne            (move.l d0 a0)            (move.l (a0 -8) d0)            (and.l (@w #$lo3bytes) d0)            (lea  (a0 d0.l 0) a1)            (bra @bsearch)))        (if# (cc a5 d1)          (if# (cc (@w #$rombase) d1)            (lea (^ @romtotal) a1)           else#            (lea (^ @abovea5) a1))           (add.l d2 @a1)           (sub.l a5 d1)           (move.w d1 d0)           (ext.l d0)           (if# (and (eq d0 d1)                     (cc (cmp.w (^ @lowa5subprim) d1))                     (cs (cmp.w (^ @higha5subprim) d1)))             (lea (^ @a5subptotal) a1)             (add.l d2 @a1)             (if# (ne (move.l (^ @a5subptable) d0))               (add.l a5 d1)               (move.l d0 a0)               (move.l ($ 15) d3)               (and.b (a0 -8) d3)               (move.l (a0 -8) d0)               (and.l (@w #$lo3bytes) d0)               (sub.l d3 d0)               (lea (a0 d0.l 0) a1)               (bra @bsearch))             else#             (lea (^ @symbols) a1)             (add.l d2 @a1)))@done         (spop a5)         (rts)                  ; look for the bucket containing address interruptus by doing a binary         ; search of the buckets between a0 and a1.  D0.l is the initial distance         ; between a0 and a1; it can be assumed to be a multiple of 8 bytes.         ; each 8-byte entry consists of an address and a counter.         ; This is O(log2 N) instead of O(.5 (log2 N)), 'cause we consider "matching"         ; to mean the same thing as convergence.         @bsearch         (spush a2)          @loop         (move.l a1 d0)         (sub.l a0 d0)         (lsr.l ($ 1) d0)         (and.w ($ #xfff8) d0)         (move.l d0 a2)         (add.l a0 a2)         (cmp.l a0 a2)         (if# eq           (add.l d2 (a2 4))           (spop a2)           (bra @done))         (cmp.l @a2 d1)         (if# mi           (move.l a2 a1)           (bra @loop))         (move.l a2 a0)         (bra @loop)))  (with-macptrs (q)    (%setf-macptr q (%inc-ptr *meter-task* 2))    (%put-ptr q *meter-task* 6)    (%put-word *meter-task* *int-depth* 26)    (%put-ptr *meter-task* (%currenta5) 36))  (when (and (boundp '*kernel-table*)             (macptrp *kernel-table*))    (#_DisPosePtr *kernel-table*))  (when (and (boundp '*a5-subprim-table*)             (macptrp *a5-subprim-table*))    (#_DisPosePtr *a5-subprim-table*))  (multiple-value-setq    (*kernel-table*     *kernel-table-names*     *a5-subprim-table*     *a5-subprim-names*     *kernel-table-size*    *a5-subprim-table-size*    *low-a5-subprim*    *high-a5-subprim*)   (kernel-table-names *lisp-mapfile*))(old-lap   (move.l (special *meter-task*) atemp1)   (move.l (atemp1 $v_data) atemp1)   (move.l (special *kernel-table*) atemp0)   (move.l (atemp0 $v_data) atemp0)   (dc.w #_GetPtrSize)   (move.l @atemp0 (atemp1 52))   (move.l (atemp0 d0.l -8) (atemp1 56))   (move.l atemp0 (atemp1 60))   (move.l (special *a5-subprim-table*) atemp0)   (move.l (atemp0 $v_data) (atemp1 76))   (move.l (special *low-a5-subprim*) dtemp0)   (getint dtemp0)   (move.w dtemp0 (atemp1 84))   (move.l (special *high-a5-subprim*) dtemp0)   (getint dtemp0)   (move.w dtemp0 (atemp1 86)))  nil)(defmacro meter (&body forms)  `(unwind-protect     (progn       (meter-all-functions)       ,@forms)     (disable-metering)))(defun meter-results ()  (let* ((total (%get-long *meter-task* 28)))    (format *debug-io* "~& total ~s msec" total)        (unless (eq 0 total)      (kernel-of-interest (%get-long *meter-task* 48) total)      (lfuns-of-interest (%get-long *meter-task* 32) total)      (format *debug-io* "~&   above a5 ~s msec" (%get-long *meter-task* 40))      (a5-subprims-of-interest (%get-long *meter-task* 72) total)      (format *debug-io* "~&   symbol entrypoints ~s msec" (%get-long *meter-task* 68))      (format *debug-io* "~&   ROM ~s msec" (%get-long *meter-task* 80)))))(defun kernel-of-interest (kernel-total total)  (format *debug-io* "~&   in kernel ~s msec" kernel-total)  (print-meter-results   (let* ((all nil))     (dotimes (i (the fixnum *kernel-table-size*) all)       (let ((count (%get-long *kernel-table* (%i+ 4 (%ilsl 3 i)))))         (unless (eql count 0) (push (cons (aref *kernel-table-names* i) count) all)))))   kernel-total    total))(defun a5-subprims-of-interest (a5-subprims-total total)  (format *debug-io* "~&   a5 subprims ~s msec" a5-subprims-total)  (print-meter-results   (let* ((all nil))     (dotimes (i *a5-subprim-table-size* all)       (declare (fixnum i))       (let ((count (%get-long *a5-subprim-table* (%i+ 4 (%ilsl 3 i)))))         (unless (eql count 0) (push (cons (aref *a5-subprim-names* i) count) all)))))   a5-subprims-total   total))(defun lfuns-of-interest (function-total total)  (format *debug-io* "~&   in lisp functions ~s msec" function-total)  (print-meter-results    (let* ((all nil))     (dotimes (i (the fixnum (floor (uvsize *all-metered-functions*) 2)) all)       (let* ((count (%svref *all-metered-functions* (+ i i 1))))         (unless (eql count 0)           (push (cons (%lfun-vector-lfun                         (%lfun-vector (%svref *all-metered-functions* (+ i i)) t))                       count)                  all)))))    function-total    total))(defun print-meter-results (all function-total total)  (let* ((fcum 0)         (tcum 0))    (dolist (pair (sort all #'> :key #'cdr))      (declare (type cons pair))      (let* ((ftime (cdr pair))             (f (car pair)))        (format t "~& ~D ~D ~D [~D ~D] ~S"                ftime                (floor (* 100 (/ ftime function-total)))                (floor (* 100 (/ ftime total)))                (floor (* 100 (/ (incf fcum ftime) function-total)))                (floor (* 100 (/ (incf tcum ftime) total)))                f)))))