;;;-*-Mode: LISP; Package: CCL -*-;;	Change History (most recent first):;;  7 9/3/96   akh  remove more of the stuff that has moved elsewhere;;  3 12/1/95  akh  get lfun-bits from closure-function in find-applicable-methods;;  2 10/23/95 akh  no concatenate 'base-string in window title;;  16 5/22/95 akh  make-ed-help-items - make string adjustable;;  15 5/7/95  slh  balloon help mods.;;  14 5/4/95  akh  move binding of *gonna-change-pos-and-sel*;;  13 4/24/95 akh  add optional prefix in format-definition-pathname;;  11 4/12/95 akh  fix list definitions dialog - we lost filter-table;;  10 4/10/95 akh  again;;  9 4/10/95  akh  fix mismatch paren;;  7 4/10/95  akh  dont remember;;  5 4/7/95   akh  'character => 'base-character;;  4 4/4/95   akh  c-x c-i is back to just inspect;;  8 3/15/95  akh  dont remember;;  6 3/2/95   akh  use *tool-back-color*;;  4 1/25/95  akh  key-cap has back-color;;                  dialogs more colorful;;  3 1/17/95  akh  use with-event-processing-enabled;;  (do not edit before this line!!)(in-package :ccl); Copyright 1987-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995 Digitool, Inc. The 'tool rules!#|;; Modification History;; 08/23/96 bill  Remove sieve-table. It's in fred-help.lisp now.; -------------  4.0b1;  4/24/96 bill  edit-definition-p does package dwim both before and after removing trailing;                period, comma, or colon. ; -------------- MCL-PPC 3.9;  3/26/96 gb    lowmem accessors.;  6/08/95 slh   help-specs;  4/12/95 slh   moved out arrow-dialog-item classes;  4/06/95 slh   broke out arglist.lisp; macroexpanders will print to window if not LDS;                check other listener dependencies;  3/30/95 slh   merge in base-app changes;--------------  3.0d18; 2/28/95 slh   removed *inspect-history-items* (unused);-------------- 3.0d17;    ?    alice ...; edit-definition-p obeys *current-package-only* for get info; ed-help-window has no zoom box since he doesnt do window-size-parts (snarl); sieve-table does dialog-item-action; i-search-search doesnt call i-search-prompt, callers try to minimize messing with the prompt which; is frequently unchanged or gets one char added, i-search-prompt very slightly less silly.; N.B. run-fred-command does not mess with the mini-buffer when shadowing-comtab is *i-search-comtab*; make-ed-help-items copy-tree => copy-list; dont set-table-sequence in ed-help, do dialog-item-action, dont show window-defs-dialog till done; definitions dialog downcases name and omits period; move method set-table-sequence to arrow-dialog-item;10/24/93 alice in menu-of-defs do go-to-def inline, no more filter-string arg in list-definitions,;		optimize method-position-item a little.;10/20/93 alice add slot last-cell and method set-table-sequence to filtered-arrow-blah, use last-cell in;		update-ed-help-doc;10/11/93 alice nuke edit-anything-result-pos, add defs-select-dialog class, set-view-size of;		menu-of-defs-dialog had a bug;10/08/93 alice defined-in-listener-p is dead code. find-method-by-names defaults missing specs to t,;		making trace more friendly;10/03/93 alice my-string-to-window no longer random, find-applicable-methods was weird with;		partial specializers. edit-definition-spec-lessp - typo if eql specs ;10/02/93 alice parse-definition-spec checks function-spec-p (name), get-source-files-blah gets;		all applicable methods whether or not source file info.;09/26/93 alice sieve-table works better searching backwards;08/27/93 alice sieve-table binds *string-compare-script* to roman, dtrt with non-alpha graphic chars;08/14/93 alice sieve-table and substringp faster, ed-help smaller chunksz in doc view;-------- RIP;;start of added text;08/14/93 alice sieve-table and substringp faster, ed-help smaller chunksz in doc view;-------- RIP;------------- 3.0d1206/19/93 alice make-ed-help-items sorting got broken by new fat chars %code-char of > #xff.06/17/93 alice buffer-current-symbol - tries to dtrt for interactive-arglist and external		vs internal symbols - but what other uses does she have for which this is		brain dead? apparently none. aux-find-symbol now means find it by some		other means and if failure buffer-current-symbol is still in charge.		read-#-prefixed-symbol changes accordingly.		Make a patch for patch 3 of this please.05/21/93 alice edit-definition-spec no longer looks for aborts - he shouldn't have to05/05/93 alice nuke some message dialogs04/29/93 bill  current-process -> *current-process*04/28/93 bill  in make-ed-help-items - make sure we pass a string to stream-write-entire-string04/22/93 bill  (format t ...) -> (message-dialog (format nil ...))               Ask before searching all open windows (do we like this? I do.)               choose-restart doesn't include restarts with no report-function04/21/93 bill  look for aborts in edit-definition-spec. This should be done differently.-------------- 2.1d504/28/93 alice sieve-table for ed-help does select and update doc - is it too slow?04/24/93 alice edit-definition - if no-show don't leap off to single def		(for get-info dialog)04/20/93 alice cell-to-string-function in menu-of-defs-dialog was brain dead		ed-help - double-click does edit-definition04/05/93 alice menu-of-defs-dialog does "contains:" like others, nuke searchable-xxx		cell-to-string-function (filtered-mumble) returns-------------- 2.1d402/15/93 alice use (edit-menu) not *edit-menu*, lots of other stuff too01/24/93 alice get-source-files-with-types&classes - dont find-applicable-methods when no special01/18/93 bill  choose-restart now works with processes11/20/92 gb    do a few things in the "top listener process."  Should do more ...09/18/92 bill   ed-inspect-current-sexp no longer skips over reader macros.08/21/92 bill   (arglist #'(lambda (...) ...) no longer calls arglist-from-help-file04/16/92 bill   i-search-do-keystroke no longer looks at *current-event*.                This makes it possible to do keyboard macros that include c-s or c-r11/27/92 alice edit-definition parses #<standard-method ..>11/26/92 alice arglist-to-stream and mini-buffer-output return t if happy, else nil		ed-arglist (c-x c-a) makes arglist hang out till expr closes.11/23/92 alice source-files-with-types&classes Obeys *direct-methods-only* for edit-anything-dialog11/14/92 alice edit-definition positions window w.r.to *edit-anything-dialog*		documentation-dialog replaced with edit-anything-dialog10/08/92 alice stomp out *emacs-mode*07/02/92 alice stomp out last 2 uses of shift-not-command-key-p06/22/92 clean up a bit, make meta-. error report less verbose and clearer 	tweak to edit-definition-spec-lessp for edit-callers,  make dialog do the same as meta-.06/17/92 fix definition-spec-lessp for (setf ..), show which are setf when both06/17/92 alice if method with specializers find all the applicaple methods sorted by applicability04/16/92 alice fix ed-select-top-level-sexp (c-m-h) when at end by giving ed-current/next... another arg03/06/92 alice search-for-def remove package qualifier in (setf blob)02/20/91 alice def-i-search c-g and backspace - judicious use of (max 0 ...)01/29/91 alice search-method-classes deal with (object t) as well as object when class is t--------------  2.002/22/92 (alice from "post 2.0f2c5:i-search patch") judicious use of (max 0 ...) prevents errors               in C-G, C-Backspace.------------------- 2.0f2c501/07/92 gb    don't require RECORDS.01/02/92 bill  arglist now properly passes the use-help-file to %arglist.12/23/91 bill  arglist-to-stream strips parens around arglist strings.               %arglist-internal doesn't look at uncompile-function result for macros.12/29/91 alice documentation-dialog - adapt to new form of action-function12/17/91 alice c-m-e and c-m-a get shift modifier, ed-top-level-sexp call window-package12/14/91 alice %arglist-internal call find-unencapsulated-definition with method not %method-function - doesn't really matter!------------------- 2.0b411/12/91 bill  add help specs to the menu-of-defs-dialog.11/11/91 alice - gary figured out how to fix timing screws in choose-restart11/04/91 bill  record-arglist saves when (or *save-arglist-info* *save-local-symbols*)10/20/91 alice change arg classes => specializers in edit-definition-p10/10/91 alice search c-y and c-w don't die at buffer end10/09/91 bill  "Enter the name of symbol." -> "Enter the name of a symbol."09/18/91 bill  ed-current-sexp special cases '#_xxx09/17/91 bill  choose-restart no longer fails if called a second time after the first               window is closed10/04/91 alice reverse search wraps correctly09/20/91 alice menu-of-defs-dialog calls menu-update *edit-menu* (gotta be a better way)------------------- 2.0b308/30/91 bill  edit-definition-spec-lessp08/24/91 bill  Option key during button click closes edit-definition dialog08/12/91 bill  add interface-definition-p to edit-definition-p08/02/91 alice choose-restart had lost his eval-enqueue making it difficult to type07/30/91 alice fred-commands window has tabs (what a concept), add listener commands07/29/91 alice fix delete in i-search (account for failed chars in selection)07/26/91 alice c-s c-y snarfs selection if any, documentation-dialog is modeless08/14/91 gb    eval-enqueue in choose-restart, after all.07/21/91 gb    use dynamic-extent; no :elements-per-bucket in hash-tables.07/19/91 alice search-for-def do both (defstruct aaa ...) and (defstruct (aaa ...))07/09/91 alice ed-select-current-sexp - dont change cursor07/02/91 alice better choose-restart07/05/91 bill  format-definition-pathnames can get a list of pathnames               Not done yet: these pathnames need to be split up into multiple entries.07/01/91 bill  window-defs-dialog is a generic-function again so that the               "List Definitions" menu-item will call method-exists-p on it.               Don't blink unmatched double quote characters.06/27/91 bill  ed-eval-or-compile-current-sexp was a copy of window-eval-selection.               ed-eval-current-sexp was almost a copy.06/29/p1 alice add another arg to ed-current-sexp - whether to skip read macros06/28/91 alice reinstate blinking excess right parens06/27/91 alice choose-restart not modal (hoo ha)06/26/91 alice edit-definition dialog is not modal (hooray)		list-definitions has growbox, default-button, selects first item and heeds arrows.06/24/91 alice c-s don't try to move-mark past end of buffer06/20/91 alice add c-m-w to search comtab06/19/91 alice i-search make sure buffers and marks match! nuke *i-search-buffer-size*06/17/91 alice search-for-def-dumb - dont check type (that was the point)		do search-for-def dumber too if known to be defined therein		(search-check-type t) = T, a few defmethod => defun06/07/91 alice search-def-features get em in keyword package; ------------------ 2.0b205/14/91 bill  buffer-current-symbol comes out from in-line in ed-current-symbol05/09/91 bill  support DEFGENERIC in *define-type-alist*05/06/91 bill  ed-edit-definition puts up dialog if error from ed-current-sexp05/01/91 bill  no ignore-errors in ed-current-sexp.  If you ask for an sexp and don't               find one, the most useful feedback is an error04/25/91 bill  ed-current-symbol takes optional start & end args.05/20/91 gb    recognize &restv.  New macro arglist scheme.05/02/91 alice ed-delete-bwd/fwd-delimiters appear to be unused05/02/91 alice i-search-do-keystroke set *default-command-p* = t		& #\rubout doesnt get added to search string04/24/91 alice make-ed-help-items, put all the digits except function-digit at end04/22/91 alice fix i-search-backspace to backup by words correctly, tweak i-search-add-char               to store delta in both cases03/26/91 bill add method-combination & method-combination-evaluator to *define-type-alist*03/20/91 bill arglist-from-map didn't work for method-function's03/15/91 bill buffer-select-blink-pos does the right thing for cursor after #(1 2 3)              ignore-errors around full-pathname in pathname-to-window (window-title              may not be a valid pathname)02/27/91 bill do not specify :cell-size for the car-dialog-item in menu-of-defs-dialog03/12/91 alice ed-edit-definition - if not known to be in a file, then look in all fred-windows03/12/91 alice c-m-e and c-m-h - end of expr to window bottom (instead of top)03/07/91 alice buffer-skip-fwd-reader-macros - special case for #(02/20/91 alice edit-definition - if recorded source file looks pathname-like but         does not exist, let  (ed pathname) get an error stead of looking in listener02/08/91 alice buffer-bwd-sexp - back up one #||#, not over one or many02/08/91 alice edit-definition call probe-file not full-pathname02/07/91 alice&bill pathname-to-window - dont use window-title----------- 2.0b102/05/91 bill ed-start-top-level-sexp & ed-end-top-level-sexp for listener.02/04/91 joe  Make sure ed-current-sexp returns two values.02/04/91 bill ed-eval-or-compile-top-level-sexp works with cursor at beginning              of function def.02/01/91 bill mini-buffer-arglist does terpri if symbol has no arglist.              This makes it work when *clear-mini-buffer* is false01/24/91 bill add over-sharps parameter to buffer-bwd-sexp for ed-transpose-sexps01/30/91 alice c-m-e, c-m-a, c-m-h and friends01/25/91 alice ed-top-level-sexp-start-pos - just look for newline (01/23/91 bill add def"trap" to *define-type-alist*.              ed-current-sexp parses #_symbol & #$symbol specially for meta-.-------------- 2.0a501/03/91 bill an arglist found as (getf (%lfun-info ...) 'arglist) is reported              as coming from the :definition.01/02/91 bill arglist-to-stream prints "??" for macros with no help-file or              user-declared arglist info12/12/90 bill documentation uses the help file.  arglist-string12/06/90 bill arglist-from-help-file11/28/90 alice buffer-bwd-sexp remove the thing that looked back two chars for a #11/26/90 alice nuke *fast-eval*11/14/90 bill add "`" to buffer-bwd-sexp prefix characters.11/06/90 bill buffer-select-blink-pos agrees with the new buffer-bwd-sexp11/02/90 bill view-default-font for menu-of-defs-dialog.  car-dialog-item inherits its font.11/01/90 blll  pathname-to-window-title in format-definition-pathnames10/30/90 bill  ignore-errors in ed-current-sexp               buffer-skip-fwd-reader-macros10/26/90 alice "pos" vice 0 in buffer-bwd-sexp.10/25/90 bill buffer-bwd-sexp skips over #x and any element of "#,'"10/24/90 bill bind package around macroexpand in ed-macroexpand-...10/23/90 bill Only search for FRED-WINDOW's in MY-STRING-TO-WINDOW              Fix (edit-definition '(setf wptr)).  Make edit-definition-p coerce              a function to its name.10/24/90 akh bills fix for meta-. (setf blah) and edit-definition-p for function10/24/90 akh bills fix to my-string-to-window (just look at fred-windows)10/18/90 akh andrews fix for printing methods in edit-definition select table10/15/90 akh dont search inspector windows10/10/90 akh buffer-bwd-sexp - dont match a " or | with beginning of buffer10/10/90 akh dont creep when control-s/r null string10/20/90 bill pull edit-definition-p out of edit-definition09/24/90 bill make arglist-to-stream handle dotted arglists.09/24/90 bill :include-invisibles in pathname-to-window09/21/90 bill successful i-search pushes a mark.              *read-#-dispatch-macros-for-arglist* -> *autoload-traps*10/11/90 gb   arglist-from-map only counts nclosed once.  No more %str-length.  Try to;             snarf arglist string from %lfun-info; needs work.09/13/90 akh fix get-source-files for new info storage08/29/90 akh  do qualifiers and all classes when searching for defmethods              adapt for new way of storing source file info08/25/90 akh  fix search so that *i-search-backup-list* doesnt have odd length08/21/90 akh  bwd-over-semi-comment-or-end is improved08/21/90 akh  make forward blinking work at last08/16/90 akh  fix meta-. for defmethod (setf foo) - tweaks for speed09/14/90 bill remove history stuff from ed-inspect-current-sexp08/29/90 bill make edit-definition do (sort of) the right thing for a method arg              and a function arg.08/23/90 bill fred-start-mark -> fred-display-start-mark, (setf arglist),              ed-macroexpand-1-current-sexp prints at least once.              Fix arglist for closures.08/21/90 bill  arglist-to-stream doesn't print if no function binding.               %ARGLIST takes the temp-cons-p arg, ARGLIST doesn't08/16/90 akh   fix meta-. for defmethod (setf foo) - tweaks for speed08/17/90 bill fix window-scroll when *next-screen-context-lines* is a float.08/16/90 bill Remove consing from arglist-to-stream08/13/90 bill Added arglist.  arglist-to-stream calls arglist with-temporary-consing08/13/90 gb   use %source-files vice gethash.  Yow, abstraction.08/13/90 alms punted string-to-window              ed just calls fred in more cases              edit-definition calls find-symbol instead of intern08/11/90 bill add single-selection? arg to window-enqueue-region calls when applicable08/10/90 bill No package prefix on arguments in arglist-from-map & arglist-from-compiled-def 08/08/90 gb   parameterized search-check-type from Alice.07/31/90 bill  New get-string-from-user arglist.               use next-screen-context-lines function vice *next-screen-context-lines* var07/26/90 bill fix arglist-to-stream for generic-function's, add *help-output*08/06/90 akh  fix pathname-to-window to use window-title if window has no file08/06/90 akh  add function string-to-window, change edit-definition to call when appropriate08/02/90 akh  search-for-fry-def distingush type - e.g. if looking for class require defclass08/01/90 akh  make search-for-fry-def much less idiotic - deal with #+,#-, #||# etc.07/29/90 akh  edit-definition - try with stripped trailing punctuation char if any07/28/90 akh  get-source-files and friend remove nils from list07/06/90 bill arglist-to-stream: remove encapsulation.07/05/90 bill nix wptr-if-bound, arglist-from-map: method's no longer take an extra arg.              *minibuffer-help-output* -> *mini-buffer-help-output*              Make control-x exit out of i-search correctly.06/25/90 bill :table-height -> :table-dimensions06/21/90 bill make pathname-to-window agree with fred-initialize.06/20/90 bill eliminate redundant repetition of last form from              ed-macroexpand-1-current-sexp.06/12/90 bill buffer-current-sexp, current-sexp* -> ed-current-sexp*,              window-start-mark -> fred-start-mark, window-update -> fred-update,              ed-skip-* -> buffer-skip-*06/04/90 gb   isearch changes per alms.05/24/90 bill :window-position & :window-size -> :view-position & :view-size05/23/90 bill ^R in incremental search no longer moves the mark before the              beginning of the buffer.  Still has a glitch that you can't wrap              to end of buffer if there is an instance of what you're looking for              at the beginning.04/30/90 gb   choose-restart.04/11/90 gz   Some ed-xxx fns renamed to buffer-xxx.              word-chars -> *fred-word-constituents*.04/10/90 gz  dialog-item-font -> view-font04/10/90 gz   ed-compile-top-level-sexp -> ed-eval-or-compile-top-level-sexp03/05/90 bill window-key-event-handler => view-key-event-handler03/01/90 bill view-buffer => fred-buffer02/23/90 bill arglist-to-stream does nothing for a symbol with no function definition.02/14/90 bill in ed-select-top-level-sexp: frec-set-sel => set-selection-range              to set the mark so the new ed-kill-region will work.1/3/90    gz   Use '%lambda-list -> %lambda-lists% in arglist-to-stream.12/29/89  gz   Fix in pathname-to-window for dot-less filenames.02/07/90 bill Make menu-of-defs-dialog go away if it's window is closed.              kludgey, but more informative arglist-from-map for generic-functions. 5-Dec-89 Mly  Somwhat debogify arglist code11/18/89  gz  lambda lists, source files in hash tables now.12-Nov-89 Mly ed-skip-bwd-wsp&comments, bwd-over-semi-comment-or-end, buffer-bwd-sexp              ed-eval-current-sexp was calling slot-boundp/value with transposed args10/18/89  gz  use lfun-keyvect in arglist-from-compiled-def28-sep-89 as  added filter option to list-definitions09/28/89 bill Add ed-push-mark to ed-edit-definition & edit-definition;09/27/89 gb simple-string -> ensure-simple-string.09/17/89 gb   remove asks from macroexpand code.  No (f)bound-anywhere               anywhere.09/16/89 bill Remove the last vestiges of object-lisp windows.              There are still a couple of (ask nil ...)'s in the macroexpand09/13/89 bill Convert to CLOS09/11/89 bill arglist-to-stream: function-binding is no more.9/11/89   gz  Use first-selected-cell.09/06/89 bill change window-of-defs-dialog to CLOS              Add method-position-item to create a defmethod description line              for List Definitions.08/30/89 bill search-for-def, search-for-clos-def, search-for-fry-def:              update to search for defmethod for class specificier07/29/89 bill my-dialog => (objvar my-dialog)07/28/89 bill "dialog" => "dialog-object"05/20/89  gz window-update -> window-object-update.04/20/89  as i-search-backspace updates prompt, couple other tweaks03/18/89  gz window-foo -> window-object-foo.  Comtab fixes per as.14-apr-89 as ed-current-symbol, minibuffer arglist stuff             removed ED-BETWEEN-NON-CLOSE-AND-OPEN-PAREN?13-apr-89 as operations on top-level sexp's <compile, start, end, select>9-apr-89  as new incremental search03/09/89 gz symbolic names for lfun bits.7-apr-89  as %str-cat takes rest arg12/30/88  gz New buffers.  Use buffer-read.             my-file-name -> window-filename, full-namestring -> full-pathname.12/25/88  gz Allow obfuns if class=nil in search-for-def.12/16/88  gz ed-lquoted-p -> buffer-lquoted-p             ed-search-unquoted -> buffer-backward-search-unquoted12/11/88  gz mark-position -> buffer-position12/2/88   gz buffer-line -> count-buffer-lines.11/16/88  gz new fred windows. Merged in fred-execute.;10/29/88 gb proclaimed *doc-output* special.8/23/88 gz   declarations 8/16/88 gz  non-hitype comtabs.8/10/88 gz   fred-additions-*.lisp -> fred-additions.lisp. Flushed pre-1.0 edit	     history.  Split off the simpler commands to a new fred-misc file.6/27/88 jaj  ed-get-documentation better for non-symbols6/24/88 as   new syntax for ed-insert-with-style 6/23/88 as   edit-definition-error checks fboundp for macros and special-forms              fixes to ed-arglist6/23/88 as   buffer-insert-with-style -> ed-insert-with-style 6/22/88 as   additions to ed-arglist for compiled defs 6/21/88 jaj  removed call to print-listener-prompt6/16/88 as   incremental-search handles spaces 6/16/88 as   new select-item-from-list return value6/9/88  as   calls to show-documentation don't pass second arg             incremental-search handles tildes, returns, tabs 6/9/88  as   fixes to ed-arglist, et al 6/01/88 as   ~& in edit-definition-error6/01/88 as   new version of ed-inspect-current-sexp 5/31/88 as   mods to ed-edit-definition5/31/88 as   punted front-fred-window, get-selected-string5/29/88 as   call show-documentation instead of documentation 5/29/88 as   style mods to ed-arglist-aux5/26/88 as   yet another get-string-from-user syntax 5/25/88 jaj  added file-modeline-package5/24/88 jaj  added ed-transpose-[sexps|words] 5/22/88 as   mod to edit-definition 5/20/88 as   edit-definition and arglist stuff from Pearl5/20/88 as   new ed-get-documentation, documentation dialog             new get-string-from-user calling sequence             (proclaim '(object-variable edwin))5/19/88 as   changes to incremental search to support new key-decoding             punted insert-killed-string-from-menu dialog 5/13/88 jaj  edwin-select-blink-pos doesn't blink for quoted chars5/12/88 as   added new set of functions2/17/88 cfry fixed get-selected-string which fixes c-x-c-i 2/14/87 gb   moved function-args to backtrace.lisp.1/28/88  as  made get-selected-string not call first-edwin, not take                optional arg01/28/88 as   removed references to fred-menu-p10/15/87 cfry kludged  keystroke-code-string so that a meta-u char would             have a string of "m-U" instead of "m-u"             the shift info is lost before keystroke is put into the comtab10/15/87 jaj moved *next-screen-context-lines* to l1-inits10/13/87 jaj bind *package* for those things that are eval-enqueued9/29/87 jaj moved buffer-line to L1-edcmd.lisp 8/26/87 as   removed excess redrawing from defs-in-buffer7/25/87 gz   check emacs-mode in ed-help7/24/87 cfry fixed fred-help to include c-x cmds.            sped up blinking forward paren.7/16/87 as  ed-help hard-codes size7/16/87 as  ed-help no longer mouse sensitive 7/13/87 jaj init-lists use keywords6/23/87 gz   removed print-listener-prompt, is now in l1-readloop.6/19/87 cfry extended ed-help to handle c-x comtab                     [and any other nested comtabs]6/3/87  gz  changed ed-help for new comtab setup.5/12/87 cfry fixed ed-skip-fwd-vertical-comment5/03/87 cfry *help-position/size* -> *help-window-position/size*        deleted def for FRED since l1-edwin now has all that functionality; 4/19/87 cfry converted from rectangle to pos&size4/18/87 cfry acutized warning message in fred-cmd-action   4/14/87 cfry ed-make-sized-window changed procid to 8 so you get a grow-icon                object-class fred-menu update; 4/6/87 gz removed the wsp etc. defconstants, now in fredenv.|#(defvar *ed-show-setf* nil);; this is a kludge - not for general use - finds any window that does not have;; an associated file - may be "listener" or "new"(defun my-string-to-window (string)  (dolist (w1 (windows :class 'fred-window))    (when (and (not (window-filename w1))               (string-equal string (window-title w1))               )      (return w1))));a patch to this fn from L1-edwin.lisp to make forward blinking chars.;previously named edwin-select-blink-pos and not called by anyone (08/21/90); no doubt because it was brain damaged but it did try to forward blink.; seems to  be called with end = 0 - my my - ignore it(defun buffer-select-blink-pos (w start end &aux pos ch temp-pos pos-1)  "returns non-neg integer to blink or NIL if no char should be blinked."  (declare (ignore start))  (setq pos (buffer-position w))  (setq end (buffer-size w))  (cond ;check for bwd blink first         ((and (> pos 1)               (or (eq (setq ch (buffer-char w (setq pos-1 (- pos 1)))) #\) )                   (eq ch #\"))               (not (buffer-lquoted-p w pos-1))               (setq temp-pos (buffer-bwd-sexp w pos))               (cond ((and (eq temp-pos pos-1) (neq ch #\")) temp-pos) ; we're unbalanced                     ((setq temp-pos (buffer-forward-find-char                               w (if (eq ch #\") #\" #\() temp-pos pos-1))                      (1- temp-pos)))))         ((and (> pos 1)               (eq ch #\#)               (eq (buffer-char w (- pos 2)) #\|)) ;start comment          (buffer-skip-bwd-#comment w 0 (- pos 2)))         ;no bwd blink so check for fwd blink        ((and (< pos end)              (setq ch (buffer-char w pos))              (cond ((eq ch #\()                     (setq temp-pos (buffer-fwd-up-sexp w (%i+ pos 1) end)))                    ((or (eq ch #\")                         (and (eq ch #\#)                              (< (%i+ pos 1) end)                              (eq (buffer-char w (%i+ pos 1)) #\|)))                     (setq temp-pos (buffer-fwd-sexp w pos end ch))))              (not (buffer-lquoted-p w  pos)))                 ;fwd blink paren or double-quote. limit search to next cr-open-paren          (- temp-pos 1))))(defun buffer-char-pos (buf char-or-string &key start end from-end &aux pos)  (setq start (buffer-position buf (or start (if from-end 0)))        end (buffer-position buf (or end (if (not from-end) t))))    (cond ((> start end) (error "start > end: ~S ~S" start end))         (from-end ;search backwards          (buffer-backward-find-char buf char-or-string start end))         (t ;search forward           (setq pos (buffer-forward-find-char buf char-or-string start end))           (if pos                (- pos 1))))); used in sourceserver(defun buffer-string-pos (buf string &key start end from-end &aux pos)  (setq start (buffer-position buf (or start (if from-end 0)))        end (buffer-position buf (or end (if (not from-end) t))))     (cond ((> start end) (error "start > end: ~S ~S" start end))         (from-end ;search backwards          (buffer-backward-search buf string start end))         (t ;search forward           (setq pos (buffer-forward-search buf string start end))           (if pos                (- pos (if (characterp string) 1 (length (string string))))))));this code came from edwcmd and was patched.(defun buffer-bwd-sexp (buf &optional pos over-sharps)  "Returns POSITION that is the beginning of the sexp behind POS."  (when (null pos)(setq pos (buffer-position buf)))  (let ((pos (buffer-skip-bwd-wsp&comments buf 0 pos T))) ; dont skip #||#        (when (or (null pos) (zerop pos))      (return-from buffer-bwd-sexp 0))    (when (and (> pos 1) (buffer-substring-p buf "|#" (- pos 1)))      (return-from buffer-bwd-sexp (buffer-skip-bwd-#comment buf 0 pos)))    (let* ((ch (if (buffer-lquoted-p buf pos) #\A (buffer-char buf pos)))           (pos (case ch                  ((#\))                   (or (buffer-bwd-up-sexp buf pos)                       pos))                  ((#\" #\| )                   (or (buffer-backward-search-unquoted buf ch pos)                       pos))                  (t                   (let ((pos (buffer-backward-search-unquoted                                buf symbol-specials pos)))                     (if pos (1+ pos) 0))))))      (loop        (unless pos (return 0))        (let ((old-pos pos))          (when (and over-sharps                     (>= pos 2)                     (eq (buffer-char buf (- pos 2)) #\#))            (setq pos (- pos 2)))          (setq pos (buffer-backward-find-not-char buf ",@'#`" 0 pos))          (if pos (incf pos))          (when (eq pos old-pos) (return pos)))))))(defun buffer-skip-fwd-reader-macros (buf &optional pos)  (when (null pos) (setq pos (buffer-position buf)))  (let ((size (buffer-size buf)))    (loop      (unless pos (return size))      (let ((old-pos pos))        (when (and (<= (+ pos 2) size) (eq (buffer-char buf pos) #\#))          (if (eq (buffer-char buf (+ pos 1)) #\()            (setq pos (+ pos 1))            (setq pos (+ pos 2))))        (setq pos (buffer-forward-find-not-char buf ",'@`" pos size))        (if pos (decf pos))        (when (eq pos old-pos) (return pos))))))(defun buffer-skip-bwd-wsp&comments (w &optional start end no-sharp)  "Searches back from end [excluding end] to start. Returns pos of first non-white char not in a comment If start is > end, error. If no non-whitespace, non-comment chars from start to END, return NIL. Thus returns NIL or 0 <= returned-value < end. If cursor is inside a comment, this should return pos of the first non-whitespace char, even if that happens to be within that comment."  (when (null start)(setq start (buffer-position w)))  (when (null end)(setq end (buffer-size w)))  (let ((semi-pos (in-semi-comment? w end)))    (when semi-pos      (let ((temp (bwd-over-whitespace-or-end w start end)))        (when (> temp semi-pos)          (return-from buffer-skip-bwd-wsp&comments (1- temp))))))  (do ((pos end))      (nil)    (let* ((temp (bwd-over-whitespace-or-end w start pos)) ;just after non-white           (semi-pos (bwd-over-semi-comment-or-end w start temp))) ;on semi maybe      (setq temp (min temp semi-pos))      (when (null no-sharp)        (setq temp (bwd-over-vertical-comment-or-end                  w start temp)))      (cond ((< temp pos)             (setq pos temp))            ((zerop pos)             (return 0))            (t             (return (- pos 1)))))))(defun bwd-over-whitespace-or-end (w start end &aux result)  "Returns the pos after the first non-whitespace looking backward from END   or, if there is no whitespace in back of END, return END."   (setq result (buffer-backward-find-not-char w wsp&cr start end))   (if result        (+ result 1)       end))(defun bwd-over-semi-comment-or-end (w start end)  "Returns pos of semi-colon or END. If START happens to be >semi position, return START. Start is expected to be <= end."  (let ((result (semi-on-line-pos w end)))    (cond ((or (not result) ;no semi on line               (>= result end)) ;semi is forward of end           end)          ((> start result)           start)          ;; we've got a semi on the line with end on it that is before end          ;; but is it within a string? result is the semi-position          ;; fails if a string containing the ; begins on a prior line          (t (let ((pos (buffer-line-start w end)))               (loop                 (when (>= pos result)(return result))                 (setq pos (buffer-forward-search-unquoted w #\" pos end))                 (cond ((or (null pos)(> pos result))                        (return result)))                                             (setq pos (buffer-forward-search-unquoted w #\" (%i+ pos 1) end))                 (cond ((null pos)(return result))                       ((< result pos)                        (setq result (buffer-forward-search-unquoted w #\; pos end))                        (when (not result)(return end))))                 (setq pos (%i+ pos 1))))))))       (defun bwd-over-vertical-comment-or-end (w start end &aux result)     "if the char just before END is a # and the char before it is a |       then return the pos of the matching # before it or error.      If end is not just in front of a | and # then return end."      "does  handle nested vertical comments, does not work when END      is within a verical comment."      (cond ((and (> end 1)                   (buffer-substring-p w "|#" (- end 2))) ;got #||#             (setq result (buffer-skip-bwd-#comment w start (- end 2)))             (if result                (if (> start result)                    start                    result)                 end))            (t end)))                        (defun in-semi-comment? (buf &optional pos &aux result)  "Returns the position of the semi-colon if POS is within a semi-colon comment.   Otherwise returns NIL.    If the first semi-colon on the line is at pos, returns nil."  (when (null pos)(setq pos (buffer-position buf)))   (setq result (semi-on-line-pos buf pos))   (if (and result (< result pos))       result))(defun semi-on-line-pos (buf &optional pos)  "returns char position of first semi on line or NIL."   (setq pos (buffer-forward-find-char  buf #\;                               (buffer-line-start buf pos)                              (buffer-line-end buf pos)))   (when pos (%i- pos 1)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|            (defmethod window-scroll ((w fred-mixin) &optional pos count)  "count is the number of lines between the first line displayed and   the line that POS is on. If this number is <= 0, then POS will be visible."  (with-slot-values (frec) w    (when (null count)      (setq count (- (next-screen-context-lines (frec-full-lines frec)))))    (frec-set-sel frec pos pos)    (set-mark (fred-display-start-mark w) (frec-screen-line-start frec pos count))    (fred-update w)))|#(defparameter *help-output* *standard-output*)#|(defun ed-current-sexp-start-pos (w &optional pos)  "If a selection, just return the pos of the beginning of the selection.   If no selection, return the pos of the first char in the current sexp,   or NIL if not obviously in a sexp. [cursor surrounded by whitespace]   "  (multiple-value-bind (b e) (frec-get-sel (slot-value w 'frec))    (when (neq b e) (return-from ed-current-sexp-start-pos b)))  (buffer-current-sexp-start (fred-buffer w) pos))|#(defun ed-current-sexp-bounds (w &optional pos)  (multiple-value-bind (b e) (frec-get-sel (slot-value w 'frec))    (if (eq b e)      (buffer-current-sexp-bounds (fred-buffer w) pos)      (values b e))))(defmethod ed-current-sexp ((w fred-mixin) &optional pos dont-skip &aux                            (buf (fred-buffer w)))  (multiple-value-bind (b e) (frec-get-sel (slot-value w 'frec))    (declare (fixnum b e))    (if (or (neq b e)            (setq e t b (buffer-current-sexp-start buf pos)))      (let* ((pkg (window-package w))             (*package* (if (null pkg) *package* (pkg-arg pkg)))             (size (buffer-size buf)))        (when (and (or (eql #\# (buffer-char buf b))                       (and (eql #\' (buffer-char buf b))                            (< (1+ b) size)                            (eql #\# (buffer-char buf (1+ b)))                            (incf b)))                   (< (1+ b) size)                   (%str-member (buffer-char buf (1+ b )) "_$"))          (multiple-value-bind (symbol end-pos)                               (ignore-errors (buffer-read buf b e))            (if symbol              (return-from ed-current-sexp (values symbol end-pos))              (incf b))))        (when (not dont-skip) (setq b (buffer-skip-fwd-reader-macros buf b)))        ; skip from edit-definition, get-doc,        ; dont from read and and macroexpand        (ignore-errors (buffer-read buf b e)))      (values nil nil))))(defmethod ed-read-current-sexp ((w fred-mixin) &optional pos)  (multiple-value-bind (exp endp) (ed-current-sexp w pos t)    (if endp (pprint exp) (ed-beep))))(defmethod ed-inspect-current-sexp ((w fred-mixin) &optional pos)  (multiple-value-bind (form endp) (ed-current-sexp w  pos)    (if (not  endp)      (if (eq w *top-listener*)        (inspect *)        (edit-anything-dialog :inspect))      (inspect form))))(defmethod ed-info-current-sexp ((w fred-mixin))  (multiple-value-bind (b e)(ed-current-sexp-bounds w)    (if (eq b e)(ed-beep)        (inspect (ed-current-sexp w e)))))        ;(edit-anything-dialog nil (buffer-substring (fred-buffer w) b e)(window-package w)))))#|(defparameter %documentation-dialog-string "")(defvar *documentation-dialog* nil)(defun documentation-dialog ()  (if (and *documentation-dialog*           (wptr *documentation-dialog*))    (window-select *documentation-dialog*)    (setq *documentation-dialog*          (get-string-from-user           "Enter the name of a symbol.  The documentation string (if there is one) will be shown."           :initial-string %documentation-dialog-string           :modeless t           :window-title "Documentation"           :action-function           #'(lambda (new-string)                              (setq %documentation-dialog-string new-string)                (show-documentation                 (read-from-string %documentation-dialog-string nil nil)))))))|##|(defun ed-line-start-pos (w &optional pos)  (buffer-line-start w pos))(defun ed-line-end-pos (w &optional pos)  (buffer-line-end w pos))|#;Returns starting postion of the current top level sexp.;ignores region, just looks at current cursor position.;Generally gets sexp that cursor is in.;If cursor is not in a sexp, and cursor is at the beginning of a line,;gets the sexp after the cursor, else gets the one before the cursor.;Returns NIL if can't find top level sexp.#|(defun ed-top-level-sexp-start-pos (w &optional pos)  (when (null pos)(setq pos (buffer-position w)))    (do ((first? t nil)       (pos pos (buffer-bwd-sexp w pos)))      (nil)    (cond ((eq pos 0)           (return 0))          ((%i>= pos (buffer-size w)))          ((and (%i> pos 0) (neq (buffer-char w (%i- pos 1)) #\Newline)))          ((eq (buffer-char w pos) #\()           (return pos)))))|#; backwards (defun ed-top-level-sexp-start-pos (w &optional pos maybe-stationary)  (when (null pos)(setq pos (buffer-position w)))  (when (and maybe-stationary             (< pos (buffer-size w)))    (incf pos))  (let ((ipos (buffer-backward-search w "(" pos)))     (setq ipos       (cond ((not ipos)              (if (and (neq 0 (buffer-size w))(eq (buffer-char w 0) #\()) 0))             (t (1+ ipos))))))#|; anybody use this?(defun ed-top-level-sexp (w &aux pos pkg)  "Return top level sexp or NIL if none. 2nd value is NIL if no top level exp."  (if (setq pos (ed-top-level-sexp-start-pos w))    (let ((*package* (if (setq pkg (window-package w))                       (pkg-arg pkg) *package*)))      (buffer-read w pos))    (values nil nil)))|#; current or preceding(defmethod ed-start-top-level-sexp ((w fred-mixin) &optional select)  ; c-m-a  (let* ((buf (fred-buffer w))         (pos (ed-top-level-sexp-start-pos buf)))    (if pos      (let ((frec (frec w)))        (if (not select)          (frec-set-sel frec pos pos)          (frec-extend-selection frec pos)))      (ed-beep))))(defmethod ed-select-start-top-level-sexp ((w fred-mixin))  (ed-start-top-level-sexp w t))(defmethod ed-current/next-top-level-sexp ((w fred-mixin) &optional current)  (let* ((buf (fred-buffer w))         (old-pos (buffer-position buf))         (start (ed-top-level-sexp-start-pos buf))         (end (and start (buffer-fwd-sexp buf start))))    (when (or (null end)              (if current (< end old-pos)(<= end old-pos)))      (setq start (buffer-forward-search buf "(" (or end old-pos)))      (cond (start (setq start (1- start))                   (setq end (buffer-fwd-sexp buf start)))            (t (setq end nil))))    (values start end)))(defmethod ed-end-top-level-sexp ((w fred-mixin) &optional select) ; c-m-e  (let ((end (nth-value 1 (ed-current/next-top-level-sexp  w))))                           (if (not end)        (ed-beep)        (let ((frec (slot-value w 'frec)))          (if (not select)            (frec-set-sel frec end end)            (frec-extend-selection frec end))          (window-scroll-to-bottom w end)))))(defmethod ed-select-end-top-level-sexp ((w fred-mixin))  (ed-end-top-level-sexp w t))(defmethod ed-select-top-level-sexp ((w fred-mixin)) ; c-m-h  (multiple-value-bind (start end)                       (ed-current/next-top-level-sexp  w t)     (if (not (and start end))        (ed-beep)        (progn          (set-selection-range w start end)          (window-scroll-to-bottom w end)))));This needs to be made more consistent with double-clicking...; No double-clicking needs to be consistent with this - done (08/22/90)(defmethod ed-select-current-sexp ((w fred-mixin))  (unless (selectionp w)    (multiple-value-bind (start end) (ed-current-sexp-bounds w)      (if start        #|(let* ((frec (frec w)) ; like c-m-h               (pos (buffer-position (fr.cursor frec))))          (cond ((< start pos)                 (frec-set-sel frec end start)                 (window-show-cursor w))                (t (frec-set-sel frec start end)                   (window-scroll-to-bottom w))))        |#        (frec-set-sel-simple (frec w) start end) ; like double click        (ed-beep)))))(defmethod ed-indent-sexp ((w fred-mixin))  "leave top line of region in the same place, but indent   everything under it in that sexp."  (multiple-value-bind (start-pos end-pos) (ed-current-sexp-bounds w)    (if start-pos      (ed-indent-for-lisp w start-pos end-pos)      (ed-beep)))) ;;incremental search;;;;;;;;;;;;;;; various state parameters;;(defvar *i-search-search-string* (make-array 12 :element-type 'character                                                :fill-pointer 0                                                :adjustable t))(defparameter *i-search-forward-p* t)(defparameter *i-search-original-pos* 0)(defparameter *i-search-found-p* t)(defparameter *i-search-note-string* "")(defparameter *i-search-backup-list* '())(defparameter *i-search-failed-characters* 0)(defparameter *i-search-started* nil)(defparameter *i-search-start-mark* nil)(defparameter *i-search-end-mark* nil);(defparameter *i-search-buffer-size* 0)(defparameter *i-search-control-q-comtab*  (make-comtab #'(lambda (w)                   (i-search-add-char w *current-character*)                   (i-search-prompt w)                   (install-shadowing-comtab w *i-search-comtab* nil))));;;;;;;;;;;;;;;;; the i-search comtab;;(defparameter *i-search-comtab* (make-comtab 'i-search-do-keystroke))(defun i-search-do-keystroke (w)  (declare (special *default-command-p*))  (let* ((key-code *current-keystroke*)         (char *current-character*))    (if (and (or (%i> key-code 32)                 (eql char #\return)                 (eql char #\tab)                 (eql char #\space))             (neq char #\rubout)             (eql key-code (logand #xff key-code)))      (i-search-add-char w char)      (progn        (ed-push-mark w (car *i-search-original-pos*))        (remove-shadowing-comtab w)        ;(collapse-selection w t) ; I like this but Mac weenies probably wont        (run-fred-command w (keystroke-function w key-code))        (setq *default-command-p* t)        (i-search-all-done w)))))(eval-when (eval compile #-bccl load)  (defmacro def-i-search (keystroke &body body)    `(comtab-set-key *i-search-comtab*                     ',keystroke                     #'(lambda (w)                         ,@body))))(def-i-search (:control #\s)  (let* ((start-mark *i-search-start-mark*)         (pos (buffer-position start-mark))         (foundp *i-search-found-p*))    (if foundp        ;found last time, so we mark the position and search again        (progn           (when (neq pos (cadr *i-search-backup-list*))            (push pos *i-search-backup-list*)            (push 0 *i-search-backup-list*))          (unless (or (eq 0 (length *i-search-search-string*))                      (eq pos (buffer-size start-mark)))            (move-mark start-mark 1)))        ;not found last time, so we wrap if last search was forward        (progn          (when *i-search-forward-p*                      (setq *i-search-note-string* " Wrapping")            (set-mark start-mark 0))))    (setq *i-search-forward-p* t)    (i-search-search w)    (unless (and foundp *i-search-found-p*)(i-search-prompt w))))(def-i-search (:control #\r)  (let* ((start-mark *i-search-start-mark*)         (pos (buffer-position start-mark))         (end-mark *i-search-end-mark*)         (foundp *i-search-found-p*))    (if foundp      ;found last time, so we mark the position and search again      (progn        (when (neq pos (cadr *i-search-backup-list*))           (push pos *i-search-backup-list*)          (push 0 *i-search-backup-list*))          (set-mark end-mark (max 0 (- pos  1)))) ; was 2      ;not found last time, so we wrap if last search was backward      (progn        (unless *i-search-forward-p*          (setq *i-search-note-string* " Wrapping")          (set-mark end-mark (buffer-size start-mark)))))    (setq *i-search-forward-p* nil)    (i-search-search w)    (unless (and foundp *i-search-found-p*)(i-search-prompt w))))(def-i-search #\escape  (collapse-selection w *i-search-forward-p*)  (i-search-all-done w))(def-i-search (:control #\g)  (if (eq *i-search-failed-characters* 0)      (progn        (collapse-selection w *i-search-forward-p*)        (set-mark (fred-buffer w) (car *i-search-original-pos*))        (set-mark (fred-display-start-mark w) (cdr *i-search-original-pos*))        (i-search-all-done w))      (let* ((search-string *i-search-search-string*))        (set-fill-pointer search-string                          (max 0 (%i- (fill-pointer search-string) ; <<                                      *i-search-failed-characters*)))        (setq *i-search-failed-characters* 0)        (i-search-search w)        (i-search-prompt w))))(def-i-search #\backspace  (let* ((search-string *i-search-search-string*)         (start-mark *i-search-start-mark*)         (end-mark *i-search-end-mark*)         delta)    (if *i-search-backup-list*      (progn        (setq delta (or (pop *i-search-backup-list*) 0))        (setf (fill-pointer search-string)              (- (fill-pointer search-string) delta))        (setq *i-search-failed-characters* (max 0 (- *i-search-failed-characters* 1)))        (set-mark start-mark (or (pop *i-search-backup-list*) start-mark))        (set-mark end-mark (max 0 (%i+ (buffer-position start-mark) ; <<                                       (%i- (length search-string) *i-search-failed-characters*))))        (set-mark (fred-buffer w) start-mark)        (set-selection-range w end-mark)        (i-search-prompt w)        (window-show-selection w))      (ed-beep))))(def-i-search (:control #\q)  (set-mini-buffer w "~&Type Quoted Character: ")  (install-shadowing-comtab  w *i-search-control-q-comtab* nil))(def-i-search (:control #\w)  (let* ((start-mark *i-search-start-mark*)         (end-mark *i-search-end-mark*)         (buf (fred-buffer w)))    (unless *i-search-started*      (set-mark end-mark start-mark))    (if (>= (buffer-position end-mark)(buffer-size buf))      (ed-beep)      (let* ((pos (buffer-forward-find-not-char buf                                                *fred-word-constituents*                                                (%i+ 1 (buffer-position end-mark))                                                t)))        (i-search-add-char w (if pos (%i- pos 1)(buffer-size start-mark)))))))(def-i-search (:control :meta #\w)  (let* ((start-mark *i-search-start-mark*)         (end-mark *i-search-end-mark*)         (buf (fred-buffer w)))    (unless *i-search-started*      (set-mark end-mark start-mark))    (let* ((pos (buffer-fwd-sexp buf (%i+ 1 (buffer-position end-mark)))))      (i-search-add-char w (if pos pos (buffer-size start-mark))))))(def-i-search (:control #\y)  (let* ((start-mark *i-search-start-mark*)         (end-mark *i-search-end-mark*)         (buf (fred-buffer w)))    (block nil      (unless *i-search-started*        (multiple-value-bind (b e)(selection-range w)          (cond ((neq b e)                 (set-mark start-mark b)                 (set-mark end-mark b)                 (i-search-add-char w e)                 (return-from nil nil))                (t (set-mark end-mark start-mark)))))      (if (>= (buffer-position end-mark)(buffer-size buf))        (ed-beep)        (let* ((pos (buffer-forward-find-char buf                                              #\return                                              (%i+ 1 (buffer-position end-mark))                                              t)))          (i-search-add-char w (if pos (%i- pos 1) (buffer-size start-mark))))))));;;;;;;;;;;;;;;;;;;;;; i-search functions;;(defmethod ed-i-search-forward ((w fred-mixin))  (if (view-mini-buffer w)    (init-i-search w t)    (ed-beep)))(defmethod ed-i-search-reverse ((w fred-mixin))  (if (view-mini-buffer w)    (init-i-search w nil)    (ed-beep)))(defun init-i-search (w forward-p &aux                          (buf (fred-buffer w)))  (install-shadowing-comtab w *i-search-comtab* nil)  (setq *i-search-forward-p* forward-p        *i-search-original-pos* (cons (buffer-position buf)                                      (buffer-position (fred-display-start-mark w)))        *i-search-found-p* t        *i-search-failed-characters* 0        *i-search-backup-list* (list (length *i-search-search-string*)                                     (buffer-position buf))        *i-search-note-string* ""        *i-search-started* nil        *i-search-start-mark* (make-mark buf)        *i-search-end-mark* (make-mark buf))  (i-search-prompt w))(defmethod i-search-prompt ((view fred-item) &optional init)  (i-search-prompt (view-window view) init))(defmethod i-search-prompt ((w fred-window) &optional init)  (let ((mb (view-mini-buffer w))        (str "i-search"))    (when mb      (let* ((buf (fred-buffer mb))             (pos (buffer-position buf))             (bpos (buffer-line-start buf buf 0)))                                  (cond ((and (not init) bpos (< bpos pos)                      (not (position #\newline *i-search-search-string*))                      (progn                        (if (not (view-status-line w))                         (setq bpos (+ bpos (length (view-package-string w)) 2)))                        (when (< bpos (buffer-size buf))                          (buffer-substring-p buf str bpos))))                 ; works when no pkg preface                 (buffer-delete buf (+ bpos (length str)) (buffer-size buf)))                (t (setq init t)))          (when init             (stream-fresh-line mb)            (buffer-insert buf str))          (buffer-insert buf *i-search-note-string*)          (buffer-insert buf (if *i-search-forward-p* ": " " reverse: "))          (buffer-insert buf *i-search-search-string*)          (fred-update mb)))))(defun i-search-add-char (w char-or-pos)  (let* ((end-mark *i-search-end-mark*)         (pos (buffer-position *i-search-start-mark*))         (search-string *i-search-search-string*)         (started *i-search-started*)         (foundp *i-search-found-p*))    (unless started      (setf (fill-pointer search-string) 0            *i-search-backup-list* ()))    (push pos *i-search-backup-list*)    (if (characterp char-or-pos)        (progn           (push 1 *i-search-backup-list*)          (vector-push-extend char-or-pos search-string))        (progn          (push (- char-or-pos (buffer-position end-mark))                *i-search-backup-list*)          (until (eq (buffer-position end-mark)                     char-or-pos)            (vector-push-extend (buffer-char end-mark)                                search-string)            (move-mark end-mark 1))))    (setq *i-search-note-string* "")        (i-search-search w)    (if (and started foundp (eq 0 (length *i-search-note-string*))(characterp char-or-pos))      (let* ((mb (view-mini-buffer w)))        (stream-tyo mb char-or-pos)        (mini-buffer-show-cursor w)        (fred-update mb))      (i-search-prompt w))))(defun i-search-all-done (w)  (let ((comtab (fred-shadowing-comtab w)))    (when (or (eq comtab *i-search-comtab*)              (null comtab))      (remove-shadowing-comtab w" (Search Complete."))))(defun i-search-search (w)  (setq *i-search-started* t)  (let* ((buf (fred-buffer w))         (search-string *i-search-search-string*)         (forward-p *i-search-forward-p*)         (found-p nil)         (start-mark *i-search-start-mark*)         (end-mark *i-search-end-mark*))    (when (and start-mark (not (same-buffer-p start-mark buf)))      (setq start-mark (setq *i-search-start-mark* (make-mark buf))))    (when (and end-mark (not (same-buffer-p end-mark buf)))      (setq end-mark (setq *i-search-end-mark*  (make-mark buf))))    (setq found-p          (if forward-p              (buffer-forward-search buf                                     search-string                                     start-mark                                     t)              (buffer-backward-search buf                                      search-string                                      (min (1+ (buffer-position end-mark))                                           (buffer-size buf))                                      0)))    (setq *i-search-found-p* found-p)    (let ((w " Wrapping") (fw " Failing wrapping"))      (setq *i-search-note-string*            (if found-p              (if (equal *i-search-note-string* fw) w "")              (if (equal *i-search-note-string* w) fw " Failing"))))    (cond (found-p           (setq *i-search-failed-characters* 0)           (if forward-p             (progn               (set-mark start-mark (- found-p                                       (length search-string)))               (set-mark end-mark found-p))             (progn               (set-mark start-mark found-p)               (set-mark end-mark (+ found-p                                     (length search-string)))))           (set-mark buf start-mark)           (set-selection-range w end-mark)           (window-show-selection w))          ((eq (car *i-search-backup-list*) 0)           (ed-beep))          ((eql (setq *i-search-failed-characters*                      (%i+ *i-search-failed-characters* 1))                1)           (ed-beep)))))#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)