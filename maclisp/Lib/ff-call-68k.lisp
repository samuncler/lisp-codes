;;	Change History (most recent first):;;  4 4/1/96   akh  fixes from bill;;  1 3/28/96  bill 3.1d88 - New file;;  (do not edit before this line!!);; ****************************************************************;;;; Author: Alan Ruttenberg;; email:  alanr-d@media.mit.edu;;#|This does an ff-call compatible with the 68k ff-call. The address of the called procedure isexpected to be a pointer to 68k code. To do this, we use ppc-ff-call, and arrange for all the stackarguments to the foreign function to be passed on the stack. ppc-ff-call actually onlycalls a single routine, *68-k-ff-call-glue-proc*, and it calls that with by passing aroutine-descriptor to the library function CallUniversalProc, which arrangedsfor the mode switch. Non stack arguments are passed by way of a fixed block which the glue can access.Before calling ppc-ff-call, any registers that are to be passed in are stored in thatblock. When the glue executes, it unloads the contents of the block to the 68k registers,messes with the stack a bit, to get rid of the calluniversalproc return address, andthen jumps to the actual 68k code. Upon return, the contents of the 68k registers aresaved back to the block, so that they can be retrieved as return values.Calls to universalprocs need a field called the procinfo, which described what arguments arepassed on the stack. Our glue proc gets as arguments the arguments of the foreign function we arecalling. Since you need to allocate a universalproc for each different set ofargument types, we use a number of routine descriptors which we allocates as necessary.The macro ff-call-68k-macro is intended to take the same arguments and do thesame thing as ff-call did.|#;; Created: Thursday January 25,1996;;;; Modification History:;;;; 05/22/96 bill  def-load-pointers => def-ccl-pointers;; -------------- MCL-PPC 3.9;; 04/09/96 bill  :return-block works well enough to return a float from a deffcfun;;  4/04/96 slh   optimizations: one code block, one fixed regs block whose contents are saved &;;                restored to stack on calls;; 03/29/96 bill  from slh: require-trap in with-routine-descriptor;; 03/28/96 bill  Lose the "Leibniz integration" code. It's part of MCL's ff-call PPC compiler macro now.;;                (#_FlushCodeCache) -> (flush-code-cache);;                call-universal-proc uses MCL's *call-universal-proc-address* instead of doing it itself.;; 03/19/96 slh   final glue movem was backwards; stack-allocate call & glue blocks;;                with-routine-descriptor;; 03/15/96 slh   make ff-call re-entrant;; 03/14/96 slh   translate-ff-68k-arg-type-to-ff-ppc: do creole return type;;                split-ff-args-to-arg-and-return: unquote return form;;                case -> ecase, use :creole-arg instead of nil;;                :creole return is in D0, not stack; see :novalue;;                prepare-68k-ff-call-result: do creole return type;; 03/12/96 slh   ff-call-68k-macro - don't set A5 if :A5 is specified;;                bug in glue code - wasn't setting A5 before foreign call;; ;; ****************************************************************(in-package :ccl)(defvar *all-registers* '(:d0 :d1 :d2 :d3 :d4 :d5 :d6 :d7 :a0 :a1 :a2 :a3 :a4 :a5))(defrecord 68k-ff-call-block  (address :pointer)  (stack-save :pointer)  (d-regs (:array :signed-long 8))  (a-regs (:array :ptr 6))  (registersave (:array :unsigned-long 14)))(defvar *the-68k-ff-call-block*)(defvar *the-68k-ff-glue-proc*)(defconstant max-glue-proc-size 100)    ; was 84 as of 3/19/96(defvar *flush-code-cache-code*)(defun word-list-to-ptr (word-list)  (let* ((word-count (length word-list))         (ptr (#_NewPtr :errchk (* 2 word-count)))         (index 0))    (declare (fixnum word-count index))    (dotimes (i word-count)      (setf (%get-word ptr index) (pop word-list))      (incf index 2))    ptr))(def-ccl-pointers flush-code-cache ()  (setq *flush-code-cache-code*         (word-list-to-ptr '(-24387 20085))      ; (%lap-words '((dc.w #_FlushCodeCache) (rts)))        )); (#_FlushCodeCache) crashes some PPC macs, so run the trap emulated instead(defun flush-code-cache ()  (ff-call *flush-code-cache-code*))#| see make-glue-proc; zap all the registers with the registers being passed(defparameter *glue-proc-lap*  '(;; save all registers    ;(dc.w #xa9ff) ; debugger        ;; save the state of the registers when we enter         (spush a0)    (move.l (:pointer registersave) a0)    (movem.l #(d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3 a4 a5) @a0)    (spop (a0 32))        ;; Now we can do what we want with the registers, before we set them up for the real call.        ;; Save the return address. After that the arguments are at the top of the stack.    (move.l (:pointer stack-save) a0)    (spop @a0)        ;; push the address of where we want to return on the stack.    (pea (^ @return))        ;; Now push the address of where we want to call on the stack.    (move.l (:pointer ff-call-address) a0)    (spush @a0)        ;; Set up the registers for the call    (move.l (:pointer registersptr) a0)    (movem.l @a0 #(d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3 a4 a5))        ;; call the function    (rts)        @return    ;; Write the registers to our block    (spush a0)    (move.l (:pointer registersptr) a0)    (movem.l #(d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3 a4 a5) @a0)    (spop (a0 32))        ;; push back the stack address    (move.l (:pointer stack-save) a0)    (spush @a0)    ;; restore the registers and return to lisp.    (move.l (:pointer registersave) a0)    (movem.l @a0 #(d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3 a4 a5))    (rts)))|#(defun make-glue-proc (proc block &key (debug nil))  ;; the body of this code is made by (lap-words-with-subst *glue-proc-lap*)  ;; which has to be executed in the 68k version of mcl  (let* ((registersptr    (%inc-ptr block (get-field-offset :68k-ff-call-block.d-regs)))         (ff-call-address (%inc-ptr block (get-field-offset :68k-ff-call-block.address)))         (registersave    (%inc-ptr block (get-field-offset :68k-ff-call-block.registersave)))         (stack-save      (%inc-ptr block (get-field-offset :68k-ff-call-block.stack-save)))         (words (LIST 12040             ; spush a0                      8316              ; move.l registersave, a0                      (ASH    (%PTR-TO-INT REGISTERSAVE) -16)                      (LOGAND (%PTR-TO-INT REGISTERSAVE) 65535)                      18640 16383       ; movem.l d0-d7/a0-a5, @a0                      8543 32           ; spop 32(a0)                      8316              ; move.l stacksave, a0                      (ASH    (%PTR-TO-INT STACK-SAVE) -16)                      (LOGAND (%PTR-TO-INT STACK-SAVE) 65535)                      8351              ; spop a0                      18554 22          ; pea 22(pc) ie @return                      8316              ; move.l ffcalladdress, a0                      (ASH    (%PTR-TO-INT FF-CALL-ADDRESS) -16)                      (LOGAND (%PTR-TO-INT FF-CALL-ADDRESS) 65535)                      12048             ; spush a0                      8316              ; move.l registersptr, a0                      (ASH    (%PTR-TO-INT REGISTERSPTR) -16)                      (LOGAND (%PTR-TO-INT REGISTERSPTR) 65535)                      19664 16383       ; movem.l a0, d0-d7/a1-a5                      20085             ; rts                                            ; @return label                      ; -22017          ; _Debugger                      12040             ; spush a0                      8316              ; move.l registersptr, a0                      (ASH    (%PTR-TO-INT REGISTERSPTR) -16)                      (LOGAND (%PTR-TO-INT REGISTERSPTR) 65535)                      18640 16383       ; movem.l d0-d7/a0-a5, a0                      8543 32           ; spop 32(a0)                      8316              ; move.l stacksave, a0                      (ASH    (%PTR-TO-INT STACK-SAVE) -16)                      (LOGAND (%PTR-TO-INT STACK-SAVE) 65535)                      12048             ; spush a0                      8316              ; move.l registersave, a0                      (ASH    (%PTR-TO-INT REGISTERSAVE) -16)                      (LOGAND (%PTR-TO-INT REGISTERSAVE) 65535)                      19664 16383       ; movem.l a0, d0-d7/a0-a5                      20085             ; rts                      )))    (declare (dynamic-extent words))    (when debug (setq words (cons -22017 words)))    (assert (<= (* 2 (length words)) max-glue-proc-size)            () "max-glue-proc-size is too small")    (loop for w in words           for offset from 0 by 2          do (%put-word proc w offset))    (flush-code-cache)))                ; (#_FlushCodeCacheRange proc nbytes) -> error;(defvar *ff-level* 0)(defmacro with-68k-ff-call-block ((block-var) &body body)  (let ((save-block-var (gensym "SAVE-BLOCK")))    `(%stack-block ((,save-block-var #.(record-length :68k-ff-call-block)))       (unwind-protect         (progn (copy-record *the-68k-ff-call-block* :68k-ff-call-block ,save-block-var)                (let ((,block-var *the-68k-ff-call-block*))                  ,@body))         (copy-record ,save-block-var :68k-ff-call-block *the-68k-ff-call-block*)))))(defvar *routine-descriptors-hash* (make-hash-table :test 'eql))(defun get-ff-call-routine-descriptor (procinfo)  (or (gethash procinfo *routine-descriptors-hash*)      (let ((descr (#_NewRoutineDescriptor *the-68k-ff-glue-proc* procinfo #$km68kisa)))        (when (%null-ptr-p descr)          (error "Couldn't allocate routine descriptor for ~S" procinfo))        (setf (gethash procinfo *routine-descriptors-hash*) descr))))(def-ccl-pointers 68k-ff-call ()  (let ((the-block (make-record :68k-ff-call-block))        (the-proc  (#_NewPtr :errchk max-glue-proc-size)))    (make-glue-proc the-proc the-block)    (setq *the-68k-ff-call-block* the-block          *the-68k-ff-glue-proc*  the-proc))  (clrhash *routine-descriptors-hash*))(defun get-ff-call-routine-descriptor (procinfo)  (let ((descr (#_NewRoutineDescriptor *the-68k-ff-glue-proc* procinfo #$km68kisa)))    (when (%null-ptr-p descr)      (error "Couldn't allocate routine descriptor for ~S" procinfo))    descr))(defmacro with-routine-descriptor ((rtn-descr procinfo) &body body)  `(let ((,rtn-descr (get-ff-call-routine-descriptor ,procinfo)))     (unwind-protect       (progn ,@body)       (require-trap #_DisposeRoutineDescriptor ,rtn-descr))))(defun register-access-code (register block &optional always-ptr)  (and (member register *all-registers*)       (let ((register-type (char (string register) 0)))         (assert (or (eql register-type #\A) (eql register-type #\D)) ()                 "Bad return 1 type ~S" register-type)         (assert (and (= (length (string register)) 2)                      (digit-char-p (char (string register) 1))) ()                 "Bad return type 2 ~S" register)         (let ((register-number (- (char-code (char (string register) 1)) #.(char-code #\0))))           (case register-type             (#\A `(pref ,block (:68k-ff-call-block.a-regs ,register-number)))             (#\D (if always-ptr                    (let ((offset (eval `(get-field-offset (:68k-ff-call-block.d-regs ,register-number)))))                      `(%get-ptr ,block ,offset))                    `(pref ,block (:68k-ff-call-block.d-regs ,register-number)))))))))(defun prepare-68k-ff-call-result (block return-type)  (cond ((null return-type) nil)        ((register-access-code return-type block))        ((member return-type '(:long :word :ptr :pointer :longword))         nil)        ((and (listp return-type)              (= (length return-type) 3)              (eq (car return-type) :return-block))         (let* ((return-block (second return-type))                (regs (third return-type))                (setfs (loop for reg in regs                             for offset from 0 by 4                             for access-code = (register-access-code reg block t)                             collect                             (if access-code                               `(setf (%get-ptr ,return-block ,offset) ,access-code)                               (error "~s is not a register" reg)))))           `(progn ,@setfs ,return-block)))        ((and (listp return-type)              (eq (car return-type) :creole))         `(sp-creole-to-lisp           (%get-ptr ,block #.(get-field-offset (:68k-ff-call-block.d-regs 0)))))        (t (error "Bad return type ~S" return-type))))(defun split-ff-args-to-arg-and-return (args)  (if (null args)     nil    (let ((has-return? (oddp (length args))))      (if has-return?        (let* ((return (last args))               (but-return (butlast args))               (return-block (getf but-return :return-block)))          (if return-block            (progn              (remf but-return :return-block)              (values but-return                      `(:return-block ,return-block                                      ,@(if (quoted-form-p (car return))                                          (list (second (car return)))                                          return))))            (let ((return (car (last args))))              (values (butlast args)                      (if (quoted-form-p return)          ; see Ax:LispInterface files                        (second return)                        return)))))        (progn          (assert (and (not (keywordp (car (last args))))                       (not (member :return-block args)))                  ()                  "Improperly formed ff-call arguments ~S" args)          (values args nil))))))(defun ff-args-to-register-args-and-ppc-ffcall-args (args)  (loop for (type value) on args by #'cddr        if (member type *all-registers*) append (list type value) into register-args        else append (list type value) into stack-args        finally (return-from ff-args-to-register-args-and-ppc-ffcall-args                   (values register-args stack-args))))(defun stuff-address-register-code (block register-args)  (loop for (register value) on register-args by #'cddr        for register-number = (- (char-code (char (string register) 1)) #.(char-code #\0))        for register-type = (char (string register) 0)        for valuesym = (gensym "VALUE-")        collect        (case register-type          (#\A `(let ((,valuesym ,value))                  (setf (pref ,block (:68k-ff-call-block.a-regs ,register-number))                         (if (macptrp ,valuesym) ,valuesym (%int-to-ptr ,valuesym)))))          (#\D `(let ((,valuesym ,value))                  (setf (pref ,block (:68k-ff-call-block.d-regs ,register-number))                         (if (macptrp ,valuesym) (%ptr-to-int ,valuesym) ,valuesym)))))));(:address :signed-byte :unsigned-byte :signed-halfword  :unsigned-halfword :signed-fullword )(defun translate-ff-68k-arg-type-to-ff-ppc (type &optional return-p)  (if (and (consp type) (eq (car type) :creole))    (if return-p      :address      :creole-arg)    (ecase type      (:word :unsigned-halfword)      ((:long :longword) :unsigned-fullword)      ((:ptr :pointer) :address)      ((:no-value :novalue :void) :void))))(defun ff-68k-args-to-ff-ppc (args)  (loop for (spec arg) on args by #'cddr        for translated = (translate-ff-68k-arg-type-to-ff-ppc spec)        append         (cond ((eq translated :creole-arg)               `(:address (sp-lisp-to-creole ,arg                                             (load-time-value                                              (creole-base-class-delta-table-index ',(cadr spec))                                              t))))              (t `(,translated ,arg)))))(defun args-to-ff-call-glue-procinfo (args return)   (flet ((type-bytecode (type)           ; ? sometimes return type is quoted: '(:creole <AX-BASE>) from AxBase.lisp           (when (quoted-form-p type)             (setq type (second type)))           (when (and (consp type) (eq (car type) :creole))             (setq type :pointer))           (ecase type             (:word #$kTwoByteCode)             ((:long :pointer :longword :ptr) #$kFourByteCode)             ((:no-value :novalue) #$kNoByteCode))))    (logior #$kPascalStackBased            (if (and return (atom return) (not (member return *all-registers*)))              (ash (type-bytecode return) #$kResultSizePhase)              0)            (loop for (spec nil) on args by #'cddr                  for argcount from 0                  for bytecode = (type-bytecode spec)                  sum (ash bytecode (+ #$kStackParameterPhase (* argcount #$kStackParameterWidth)))))))(defmacro call-universal-proc (routinedescriptor procinfo &rest args)  `(ppc-ff-call     *call-universal-proc-address*      :address ,routinedescriptor    :unsigned-fullword ,procinfo     ,@args))(defmacro ff-call-68k-macro (address &rest args)  (multiple-value-bind (args return) (split-ff-args-to-arg-and-return args)    (multiple-value-bind (register-args stack-args) (ff-args-to-register-args-and-ppc-ffcall-args args)      (let ((transformed-args (ff-68k-args-to-ff-ppc stack-args))            (block (make-symbol "BLOCK"))            (procinfo (make-symbol "PROCINFO"))            (result (make-symbol "RESULT"))            (rtn-descr (make-symbol "RTN-DESCR"))            (cookie (gensym)))        (let ((stack-result? (not (or (null return)                                      (memq return *all-registers*)                                      (memq (if (consp return) (car return))                                            '(:return-block :creole))))))          `(with-68k-ff-call-block (,block)             ,@(when (eq (getf register-args :a5 cookie) cookie)                 `((setf (pref ,block (68k-ff-call-block.a-regs 5))                         (%get-ptr (%int-to-ptr #.$currenta5)))))             ,@(stuff-address-register-code block register-args)             (setf (pref ,block 68k-ff-call-block.address)                   ,(if (and (consp address) (eq (car address) :virtual))                      `(sp-creole-virtual-function                        ,(nth (- (length args) 3) args)                        (load-time-value (creole-base-class-delta-table-index ',(third address)) t)                        ,(second address))                      address))             (let* ((,procinfo ,(args-to-ff-call-glue-procinfo stack-args return))                    (,result (with-routine-descriptor (,rtn-descr ,procinfo)                               (call-universal-proc ,rtn-descr                                                    0 ;; *this* procinfo needs to be 0.                                                    ,@transformed-args                                                    ,(if stack-result?                                                       (translate-ff-68k-arg-type-to-ff-ppc return t)                                                       :void)))))               (declare (ignorable ,result))               ,(if stack-result?                  result                  (prepare-68k-ff-call-result block return)))))))))#|;;; Leibniz integration; lose the PPC compiler macro(setf (ppc-compiler-macro-function 'ff-call) nil); lose the function(fmakunbound 'ff-call); define a nice macro(defmacro ff-call (&whole call &rest args)  `(ff-call-68k-macro ,@args))|##| Tests(def-load-pointers test-68k-ff-call ()  ;(setq *little-lap* (%lap-words '((spop a0) (spop d0) (spop d1) (add.l d1 d0) (spop d1) (add.l d1 d0) (spush a0) (rts)))  (defparameter *little-lap* (word-list-to-ptr '(8287 8223 8735 -12159 8735 -12159 12040 20085))))(defun simpletest ()  ;; should return #x66666666  (format t "~x"          (ff-call *little-lap* :long #x11111111 :long #x22222222 :long #x33333333                   :d0)))|#; end