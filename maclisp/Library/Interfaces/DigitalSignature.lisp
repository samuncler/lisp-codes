(in-package :TRAPS); Generated from #P"HD:CCL3.0d17:Interface Translator:Source interfaces:Pascal Interfaces:DigitalSignature.p"; at Tuesday June 6,1995 2:07:44 pm.; ;  	File:		DigitalSignature.p;  ;  	Contains:	Digital Signature Interfaces.;  ;  	Version:	Technology:	AOCE toolbox 1.02;  				Package:	Universal Interfaces 2.1ß1 in “MPW Prerelease” on ETO #17;  ;  	Copyright:	© 1984-1995 by Apple Computer, Inc.;  				All rights reserved.;  ;  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter;  				stack.  Include the file and version information (from above);  				in the problem description and send to:;  					Internet:	apple.bugs@applelink.apple.com;  					AppleLink:	APPLE.BUGS;  ; #|                                              ; $IFC UNDEFINED UsingIncludes; $SETC UsingIncludes := 0 |#                                             ; $ENDC; $IFC NOT UsingIncludes; $ENDC; $IFC UNDEFINED __DIGITALSIGNATURE__; $SETC __DIGITALSIGNATURE__ := 1; $I+; $SETC DigitalSignatureIncludes := UsingIncludes; $SETC UsingIncludes := 1#|                                              ; $IFC UNDEFINED __TYPES__|#(require-interface 'Types)#|                                              ; $I Types.p |#                                             ; $ENDC; 	ConditionalMacros.p											#|                                              ; $IFC UNDEFINED __MEMORY__|#(require-interface 'Memory)#|                                              ; $I Memory.p |#                                             ; $ENDC; 	MixedMode.p													#|                                              ; $IFC UNDEFINED __FILES__|#(require-interface 'Files)#|                                              ; $I Files.p |#                                             ; $ENDC; 	OSUtils.p													; $PUSH; $ALIGN MAC68K; $LibExport+(defconstant $kSIGNewContext 1900)(defconstant $kSIGDisposeContext 1901)(defconstant $kSIGSignPrepare 1902)(defconstant $kSIGSign 1903)(defconstant $kSIGVerifyPrepare 1904)(defconstant $kSIGVerify 1905)(defconstant $kSIGDigestPrepare 1906)(defconstant $kSIGDigest 1907)(defconstant $kSIGProcessData 1908)(defconstant $kSIGShowSigner 1909)(defconstant $kSIGGetSignerInfo 1910)(defconstant $kSIGGetCertInfo 1911)(defconstant $kSIGGetCertNameAttributes 1912)(defconstant $kSIGGetCertIssuerNameAttributes 1913)(defconstant $kSIGFileIsSigned 2500)(defconstant $kSIGSignFile 2501)(defconstant $kSIGVerifyFile 2502)(defconstant $kSIGCountryCode 0)(defconstant $kSIGOrganization 1)(defconstant $kSIGStreetAddress 2)(defconstant $kSIGState 3)(defconstant $kSIGLocality 4)(defconstant $kSIGCommonName 5)(defconstant $kSIGTitle 6)(defconstant $kSIGOrganizationUnit 7)(defconstant $kSIGPostalCode 8)(def-mactype :signameattributetype (find-mactype ':signed-integer));  ; Certificate status codes returned in SIGCertInfo or SIGSignerInfo from; either SIGGetCertInfo or SIGGetSignerInfo respectively. kSIGValid means that; the certificate is currently valid. kSIGPending means the certificate is; currently not valid - but will be.  kSIGExpired means the certificate has; expired. A time is always associated with a SIGCertStatus.  In each case the; time has a specific interpretation.  When the status is kSIGValid the time is; when the certificate will expire. When the status is kSIGPending the time is; when the certificate will become valid. When the status is kSIGExpired the time; is when the certificate expired. In the SIGCertInfo structure, the startDate; and endDate fields hold the appropriate date information.  In the SIGSignerInfo; structure, this information is provided in the certSetStatusTime field. In the; SIGSignerInfo struct, the status time is actually represented by the SIGSignatureStatus; field which can contain any of the types below. NOTE: The only time you will get ; a kSIGInvalid status is when it pertains to a SIGSignatureStatus field and only when; you get a signature that was created after the certificates expiration date, something; we are not allowing on the Mac but that may not be restricted on other platforms. Also, ; it will not be possible to get a kSIGPending value for SIGSignatureStatus on the Mac but; possibly allowed by other platforms.; ;  Values for SIGCertStatus or SIGSignatureStatus (defconstant $kSIGValid 0)                      ;  possible for either a SIGCertStatus or SIGSignatureStatus (defconstant $kSIGPending 1)                    ;  possible for either a SIGCertStatus or SIGSignatureStatus (defconstant $kSIGExpired 2)                    ;  possible for either a SIGCertStatus or SIGSignatureStatus; 	* possible only for a SIGSignatureStatus (defconstant $kSIGInvalid 3)(def-mactype :sigcertstatus (find-mactype ':signed-integer))(def-mactype :sigsignaturestatus (find-mactype ':signed-integer));  Gestalt selector code - returns toolbox version in low-order word (defconstant $gestaltDigitalSignatureVersion :|dsig|);  Number of bytes needed for a digest record when using SIGDigest (defconstant $kSIGDigestSize 16);; hand-hacked;; (defrecord SIGDigestData (array (array :unsigned-byte (- (- (value 'ksigdigestsize) 1) 0 -1))))(defrecord SIGDigestData (array (array :unsigned-byte 16)))(def-mactype :sigdigestdataptr (find-mactype '(:pointer :unsigned-byte)))(defrecord SIGCertInfo    ;;Changing field startdate from signed-long to unsigned-long to match C header (pretty-darn-sure)   (startDate :unsigned-long)                   ;  cert start validity date    ;;Changing field enddate from signed-long to unsigned-long to match C header (pretty-darn-sure)   (endDate :unsigned-long)                     ;  cert end validity date    (certStatus :signed-integer)                 ;  see comment on SIGCertStatus for definition    ;;Changing field certattributecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (certAttributeCount :unsigned-long)          ;  number of name attributes in this cert    ;;Changing field issuerattributecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (issuerAttributeCount :unsigned-long)        ;  number of name attributes in this certs issuer    (serialNumber (:string 255))                 ;  cert serial number    )(def-mactype :sigcertinfoptr (find-mactype '(:pointer :sigcertinfo)))(defrecord SIGSignerInfo    ;;Changing field signingtime from signed-long to unsigned-long to match C header (pretty-darn-sure)   (signingTime :unsigned-long)                 ;  time of signing    ;;Changing field certcount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (certCount :unsigned-long)                   ;  number of certificates in the cert set    ;;Changing field certsetstatustime from signed-long to unsigned-long to match C header (pretty-darn-sure)   (certSetStatusTime :unsigned-long)           ;  Worst cert status time. See comment on SIGCertStatus for definition    (signatureStatus :signed-integer)            ;  The status of the signature. See comment on SIGCertStatus for definition   )(def-mactype :sigsignerinfoptr (find-mactype '(:pointer :sigsignerinfo)))(defrecord SIGNameAttributesInfo    (onNewLevel :boolean)   (filler1 :boolean)   (attributeType :signed-integer)   (attributeScript :signed-integer)   (attribute (:string 255))   )(def-mactype :signameattributesinfoptr (find-mactype '(:pointer :signameattributesinfo)))(def-mactype :sigcontextptr (find-mactype ':pointer))(def-mactype :sigsignatureptr (find-mactype ':pointer)); ; Certificates are always in order. That is, the signers cert is always 0, the; issuer of the signers cert is always 1 etc… to the number of certificates-1.; You can use this constant for readability in your code.; (defconstant $kSIGSignerCertIndex 0); ; Call back procedure supplied by developer, return false to cancel the current; process.; (def-mactype :sigstatusprocptr (find-mactype ':pointer));  FUNCTION SIGStatus: BOOLEAN; (def-mactype :sigstatusupp (find-mactype ':pointer))(defconstant $uppSIGStatusProcInfo #x10)        ;  FUNCTION : 1 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewSIGStatusProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallSIGStatusProc" ("AOCELib"))  ((userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; ; Resource id's of standard signature icon suite, all sizes and colors are available.; (defconstant $kSIGSignatureIconResID -16800)(defconstant $kSIGValidSignatureIconResID -16799)(defconstant $kSIGInvalidSignatureIconResID -16798);  ——————————————————————————————— CONTEXT CALLS ——————————————————————————————— ; To use the Digital Signature toolbox you will need a SIGContextPtr.  To create; a SIGContextPtr you simply call SIGNewContext and it will create and initialize; a context for you.  To free the memory occupied by the context and invalidate; its internal data, call SIGDisposeContext. An initialized context has no notion; of the type of operation it will be performing however, once you call; SIGSignPrepare SIGVerifyPrepare, or SIGDigestPrepare, the contexts operation; type is set and to switch  to another type of operation will require creating a; new context. Be sure to pass the same context to corresponding toolbox calls; (ie SIGSignPrepare, SIGProcessData, SIGSign)  in other words mixing lets say; signing and verify calls with the same context is not allowed.; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGNewContext" ("AOCELib"))         ((context (:pointer :pointer)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 2 16) 1900) context)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGDisposeContext" ("AOCELib"))         ((context :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 2 16) 1901) context)); $ENDC;  ——————————————————————————————— SIGNING CALLS ——————————————————————————————— ; Once you have created a SIGContextPtr, you create a signature by calling; SIGSignPrepare once, followed by n calls to SIGProcessData, followed by one call; toRcpt SIGSign. To create another signature on different data but for the same; signer, don't dispose of the context and call SIGProcessData for the new data; followed by a call SIGSign again. In this case the signer will not be prompted; for their signer and password again as it was already provided.  Once you call; SIGDisposeContext, all signer information will be cleared out of the context and; the signer will be re-prompted.  The signer file FSSpecPtr should be set to nil; if you want the toolbox to use the last signer by default or prompt for a signer; if none exists.  The prompt parameter can be used to pass a string to be displayed; in the dialog that prompts the user for their password.  If the substring "^1"; (without the quotes) is in the prompt string, then the toolbox will replace it; with the name of the signer from the signer selected by the user.  If an empty; string is passed, the following default string will be sent to the toolbox; "\pSigning as ^1.".  You can call any of the utility routines after SIGSignPrepare; or SIGSign to get information about the signer or certs.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGSignPrepare" ("AOCELib"))         ((context :pointer) (signerFile (:pointer :fsspec)) (prompt (:string 255)) (signatureSize (:pointer :signed-long)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 8 16) 1902) context signerFile prompt signatureSize)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGSign" ("AOCELib"))         ((context :pointer) (signature :pointer) (statusProc :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 6 16) 1903) context signature statusProc)); $ENDC;  ——————————————————————————————— VERIFYING CALLS ——————————————————————————————— ; Once you have created a SIGContextPtr, you verify a signature by calling; SIGVerifyPrepare  once, followed by n calls to SIGProcessData, followed by one; call to SIGVerify. Check the return code from SIGVerify to see if the signature; verified or not (noErr is returned on  success otherwise the appropriate error; code).  Upon successfull verification, you can call any of the utility routines; toRcpt find out who signed the data.; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGVerifyPrepare" ("AOCELib"))         ((context :pointer) (signature :pointer) (signatureSize :signed-long) (statusProc :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 8 16) 1904) context signature signatureSize statusProc)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGVerify" ("AOCELib"))         ((context :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 2 16) 1905) context)); $ENDC;  —————————————————————————————— DIGESTING CALLS —————————————————————————————— ; Once you have created a SIGContextPtr, you create a digest by calling; SIGDigestPrepare once, followed by n calls to SIGProcessData, followed by one; call to SIGDigest.  You can dispose of the context after SIGDigest as the; SIGDigestData does not reference back into it.  SIGDigest returns the digest in; digest.; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGDigestPrepare" ("AOCELib"))         ((context :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 2 16) 1906) context)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGDigest" ("AOCELib"))         ((context :pointer) (digest (:pointer :sigdigestdata)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 4 16) 1907) context digest)); $ENDC;  —————————————————————————————— PROCESSING DATA —————————————————————————————— ; To process data during a digest, sign, or verify operation call SIGProcessData; as many times as necessary and with any sized blocks of data.  The data needs to; be processed in the same order during corresponding sign and verify operations; but does not need to be processed in the same sized chunks (i.e., the toolbox; just sees it as a continuous bit stream).; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGProcessData" ("AOCELib"))         ((context :pointer) (data :pointer) (dataSize :signed-long))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 6 16) 1908) context data dataSize)); $ENDC;  ——————————————————————————————— UTILITY CALLS ——————————————————————————————— ; Given a context that has successfully performed a verification SIGShowSigner; will  display a modal dialog with the entire distinguished name of the person; who signed the data. the prompt (if supplied) will appear at the top of the; dialog.  If no prompt is specified, the default prompt "\pVerification; Successfull." will appear.; ; Given a context that has been populated by calling SIGSignPrepare, SIGSign or a; successful SIGVerify, you can make the remaining utility calls:; ; SIGGetSignerInfo will return the SignerInfo record.  The certCount can be used; toRcpt index into the certificate set when calling SIGGetCertInfo,; SIGGetCertNameAttributes or SIGGetCertIssuerNameAttributes. The signingTime is; only defined if the call is made after SIGSign  or SIGVerify. The certSetStatus; will tell you the best status of the entire certificate set while; certSetStatusTime will correspond to the time associated with that status (see; definitions above).; ; SIGGetCertInfo will return the SIGCertInfo record when given a valid index into; the cert set in  certIndex.  Note: The cert at index kSIGSignerCertIndex is; always the signers certificate.  The  serial number, start date and end date; are there should you wish to display that info.  The  certAttributeCount and; issuerAttributeCount provide the number of parts in the name of that certificate; or that certificates issuer respectively.  You use these numbers to index into; either SIGGetCertNameAttributes or SIGGetCertIssuerNameAttributes to retrieve; the name. The certStatus will tell you the status of the certificate while; certStatusTime will correspond to the time associated with that status (see; definitions above).; ; SIGGetCertNameAttributes and SIGGetCertIssuerNameAttributes return name parts; of the certificate at  certIndex and attributeIndex.  The newLevel return value; tells you wether the name attribute returned is at the same level in the name; hierarchy as the previous attribute.  The type return value tells you  the type; of attribute returned. nameAttribute is the actual string containing the name; attribute.   So, if you wanted to display the entire distinguished name of the; person who's signature was just validated you could do something like this;; ; 	(…… variable declarations and verification code would preceed this sample ……); ; 	error = SIGGetCertInfo(verifyContext, kSIGSignerCertIndex, &certInfo);; 	HandleErr(error);; ; 	for (i = 0; i <= certInfo.certAttributeCount-1; i++); 		(; 		error = SIGGetCertNameAttributes(; 			verifyContext, kSIGSignerCertIndex, i, &newLevel, &type, theAttribute);; 		HandleErr(error);; 		DisplayNamePart(theAttribute, type, newLevel);; 		); ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGShowSigner" ("AOCELib"))         ((context :pointer) (prompt (:string 255)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 4 16) 1909) context prompt)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGGetSignerInfo" ("AOCELib"))         ((context :pointer) (signerInfo (:pointer :sigsignerinfo)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 4 16) 1910) context signerInfo)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGGetCertInfo" ("AOCELib"))         ((context :pointer) (certIndex :signed-long) (certInfo (:pointer :sigcertinfo)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 6 16) 1911) context certIndex certInfo)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGGetCertNameAttributes" ("AOCELib"))         ((context :pointer) (certIndex :signed-long) (attributeIndex :signed-long) (attributeInfo (:pointer :signameattributesinfo)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 8 16) 1912) context certIndex attributeIndex attributeInfo)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGGetCertIssuerNameAttributes" ("AOCELib"))         ((context :pointer) (certIndex :signed-long) (attributeIndex :signed-long) (attributeInfo (:pointer :signameattributesinfo)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 8 16) 1913) context certIndex attributeIndex attributeInfo)); $ENDC;  ——————————————————————————— FILE SIGN & VERIFY CALLS —————————————————————————— ; These calls allow you to detect the presence of a standard signtaure in a file as ; well as sign and verify files in a standard way.  An example of this is the Finder, ; which uses these calls to allow the user to "drop sign" a file.; ; To detect if a file is signed in the standard way, pass the FSSpec of the file to SIGFileIsSigned.; A result of noErr means the file is in fact signed, otherwise, a kSIGNoSignature error will; be returned.; ; Once you have created a SIGContextPtr, you can make calls to either sign or verify a file in; a standard way: ; ; To sign a file, call SIGSignPrepare followed by 'n' number of calls to SIGSignFile,; passing it the file spec for each file you wish to sign in turn.  You supply the context, the signature ; size that was returned from SIGSignPrepare and an optional call back proc.  The call will take care of all; the processing of data and affixing the signature to the file. If a signature already exists in the file, ; it is replaced with the newly created signature.; ; To verify a file that was signed using SIGSignFile, call SIGVerifyFile passing it a new context and ; the file spec.  Once this call has completed, if the verification is successfull, you can pass the context ; to SIGShowSigner to display the name of the person who signed the file.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGFileIsSigned" ("AOCELib"))         ((fileSpec (:pointer :fsspec)))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 2 16) 2500) fileSpec)); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGSignFile" ("AOCELib"))         ((context :pointer) (signatureSize :signed-long) (fileSpec (:pointer :fsspec)) (statusProc :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 8 16) 2501) context signatureSize fileSpec statusProc)); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-longword-in-d0(deftrap ("_SIGVerifyFile" ("AOCELib"))         ((context :pointer) (fileSpec (:pointer :fsspec)) (statusProc :pointer))   (:stack :signed-integer)   (:stack-trap #xAA5D :d0 (+ (ash 6 16) 2502) context fileSpec statusProc)); $ENDC; $ALIGN RESET; $POP; $SETC UsingIncludes := DigitalSignatureIncludes; $ENDC                                         ; __DIGITALSIGNATURE__; $IFC NOT UsingIncludes; $ENDC(provide-interface 'DigitalSignature)