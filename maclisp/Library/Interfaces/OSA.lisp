(in-package :TRAPS); Generated from #P"HD:CCL3.0d17:Interface Translator:Source interfaces:Pascal Interfaces:OSA.p"; at Tuesday June 6,1995 2:04:29 pm.; ;  	File:		OSA.p;  ;  	Contains:	AppleScript Client Interfaces.;  ;  	Version:	Technology:	AppleScript 1.1;  				Package:	Universal Interfaces 2.0 in “MPW Latest” on ETO #17;  ;  	Copyright:	© 1984-1995 by Apple Computer, Inc.;  				All rights reserved.;  ;  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter;  				stack.  Include the file and version information (from above);  				in the problem description and send to:;  					Internet:	apple.bugs@applelink.apple.com;  					AppleLink:	APPLE.BUGS;  ; #|                                              ; $IFC UNDEFINED UsingIncludes; $SETC UsingIncludes := 0 |#                                             ; $ENDC#|                                              ; $IFC NOT UsingIncludes |#                                             ; $ENDC; $IFC UNDEFINED __OSA__; $SETC __OSA__ := 1; $I+; $SETC OSAIncludes := UsingIncludes; $SETC UsingIncludes := 1#|                                              ; $IFC UNDEFINED __ERRORS__|#(require-interface 'Errors)#|                                              ; $I Errors.p |#                                             ; $ENDC; 	ConditionalMacros.p											#|                                              ; $IFC UNDEFINED __APPLEEVENTS__|#(require-interface 'AppleEvents)#|                                              ; $I AppleEvents.p |#                                             ; $ENDC; 	Types.p														; 	Memory.p													; 		MixedMode.p												; 	OSUtils.p													; 	Events.p													; 		Quickdraw.p												; 			QuickdrawText.p										; 	EPPC.p														; 		AppleTalk.p												; 		Files.p													; 		PPCToolbox.p											; 		Processes.p												; 	Notification.p												#|                                              ; $IFC UNDEFINED __AEOBJECTS__|#(require-interface 'AEObjects)#|                                              ; $I AEObjects.p |#                                             ; $ENDC; $IFC UNDEFINED __COMPONENTS__(require-interface 'Components)                 ; $I Components.p; $ENDC; $PUSH; $ALIGN MAC68K; $LibExport+(defconstant $kOSAComponentType :|osa |);  0x73637074 (defconstant $kOSAGenericScriptingComponentSubtype :|scpt|); 	Type of script document files.	;  0x6f736173 (defconstant $kOSAFileType :|osas|); ; 		Suite and event code of the RecordedText event. ; 		(See OSAStartRecording, below.); 	;  0x61736372 (defconstant $kOSASuite :|ascr|);  0x72656364 (defconstant $kOSARecordedText :|recd|);  Selector returns boolean ;  0x6d6f6469 (defconstant $kOSAScriptIsModified :|modi|);  Selector returns boolean ;  0x63736372 (defconstant $kOSAScriptIsTypeCompiledScript :|cscr|);  Selector returns boolean ;  0x76616c75 (defconstant $kOSAScriptIsTypeScriptValue :|valu|);  Selector returns boolean ;  0x636e7478 (defconstant $kOSAScriptIsTypeScriptContext :|cntx|);  Selector returns a DescType which may be passed to OSACoerceToDesc ;  0x62657374 (defconstant $kOSAScriptBestType :|best|); ; 		This selector is used to determine whether a script has source ; 		associated with it that when given to OSAGetSource, the call will not; 		fail.  The selector returns a boolean.; 	;  0x67737263 (defconstant $kOSACanGetSource :|gsrc|)(defconstant $typeOSADialectInfo :|difo|)       ;   0x6469666f   (defconstant $keyOSADialectName :|dnam|)        ;   0x646e616d   (defconstant $keyOSADialectCode :|dcod|)        ;   0x64636f64   (defconstant $keyOSADialectLangCode :|dlcd|)    ;   0x646c6364   (defconstant $keyOSADialectScriptCode :|dscd|)(def-mactype :osaerror (find-mactype ':signed-long));  Under the Open Scripting Architecture all error results are longs (def-mactype :osaid (find-mactype ':signed-long)); ; 		OSAIDs allow transparent manipulation of scripts associated with; 	 	various scripting systems.; 	(defconstant $kOSANullScript 0);  No -script constant. (defconstant $kOSANullMode 0)                   ;  sounds better (defconstant $kOSAModeNull 0)                   ;  tastes consistent ; ; 		Some routines take flags that control their execution.  This constant; 		declares default mode settings are used.; 	(def-mactype :osacreateappleeventprocptr (find-mactype ':pointer));  FUNCTION OSACreateAppleEvent(theAEEventClass: AEEventClass; theAEEventID: AEEventID; (CONST)VAR target: AEAddressDesc; returnID: INTEGER; transactionID: LONGINT; VAR result: AppleEvent; refCon: LONGINT): OSErr; (def-mactype :osacreateappleeventupp (find-mactype ':pointer))(defconstant $uppOSACreateAppleEventProcInfo #xFEFE0);  FUNCTION (4 byte param, 4 byte param, 4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewOSACreateAppleEventProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallOSACreateAppleEventProc" ((theAEEventClass :ostype) (theAEEventID :ostype) (target (:pointer :aedesc)) (returnID :signed-integer) (transactionID :signed-long) (result (:pointer :aedesc)) (refCon :signed-long) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(def-mactype :osasendprocptr (find-mactype ':pointer));  FUNCTION OSASend((CONST)VAR theAppleEvent: AppleEvent; VAR reply: AppleEvent; sendMode: AESendMode; sendPriority: AESendPriority; timeOutInTicks: LONGINT; idleProc: AEIdleUPP; filterProc: AEFilterUPP; refCon: LONGINT): OSErr; (def-mactype :osasendupp (find-mactype ':pointer))(defconstant $uppOSASendProcInfo #x3FEFE0)      ;  FUNCTION (4 byte param, 4 byte param, 4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewOSASendProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallOSASendProc" ((theAppleEvent (:pointer :aedesc)) (reply (:pointer :aedesc)) (sendMode :signed-long) (sendPriority :signed-integer) (timeOutInTicks :signed-long) (idleProc :pointer) (filterProc :pointer) (refCon :signed-long) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC; *************************************************************************; 	Standard Script Errors; **************************************************************************; 	It is recommended that scripting components use the following set of error; 	codes to signal failure when applicable.  This enables applications that; 	use the OSA API to deal with some class of script errors in a less than ; 	ad hoc manner.  Scripting components are of course encouraged to return; 	component-specific errors when these don't apply.; *************************************************************************; 		Dynamic errors:; ; 	These errors result from data-dependent conditions and are typically; 	signaled at runtime.; ; ; 		Signaled when a value can't be coerced to the desired type. Similar; 	  	to errOSATypeError except results from coercion.; 	(defconstant $errOSACantCoerce #$errAECoercionFail);  Signaled when an object is not found in a container (defconstant $errOSACantAccess #$errAENoSuchObject); ; 		Signaled when an object cannot be set in a container.  Same as ; 	  	AERegistry error errAEWriteDenied.; 	(defconstant $errOSACantAssign -10006); ; 		Signaled by user scripts or applications when no actual error code; 	  	is to be returned.  Simply means "an error has occurred".  Most useful; 	  	in conjunction with an error message from the application.; 	(defconstant $errOSAGeneralError -2700);  Signaled when there is an attempt to divide by zero (defconstant $errOSADivideByZero -2701);  Signaled when integer or real value is too large to be represented (defconstant $errOSANumericOverflow -2702); ; 		Signaled when application can't be launched or when it is remote and; 	  	program linking is not enabled.; 	(defconstant $errOSACantLaunch -2703);  Signaled when an application can't respond to AppleEvents (defconstant $errOSAAppNotHighLevelEventAware -2704);  Signaled when an application's terminology resource is not readable (defconstant $errOSACorruptTerminology -2705);  Signaled when the runtime stack overflows (defconstant $errOSAStackOverflow -2706);  Signaled when a runtime internal data structure overflows (defconstant $errOSAInternalTableOverflow -2707); ; 		Signaled when an intrinsic limitation is exceeded for the size of ; 	  	a value or data structure.; 	(defconstant $errOSADataBlockTooLarge -2708)(defconstant $errOSACantGetTerminology -2709)(defconstant $errOSACantCreate -2710); 		Component-specific dynamic script errors:; ; 	The range -2720 thru -2739 is reserved for component-specific runtime errors.; 	(Note that error codes from different scripting components in this range will; 	overlap.); ; 		Static errors:; ; 	These errors comprise what are commonly thought of as parse and compile-; 	time errors.  However, in a dynamic system (e.g. AppleScript) any or all; 	of these may also occur at runtime.; ;  Signaled when data was not the right type and coercion is not allowed (defconstant $errOSATypeError #$errAEWrongDataType);  Signaled when a message was sent to an object that didn't handle it (defconstant $OSAMessageNotUnderstood #$errAEEventNotHandled); ; 		Signaled when a function to be returned doesn't exist.  (Probably only; 	  	useful in languages with first-class functions that distinguish between; 	  	functions and other values (two name spaces). This is different from; 	  	errOSAMessageNotUnderstood, which may be signaled when the method is; 	  	invoked.; 	(defconstant $OSAUndefinedHandler #$errAEHandlerNotFound);  Signaled when a container can never have the requested object (defconstant $OSAIllegalAccess #$errAEAccessorNotFound);  Signaled when index was out of range. Specialization of errOSACantAccess. (defconstant $OSAIllegalIndex #$errAEIllegalIndex);  Signaled when a range is screwy. Specialization of errOSACantAccess. (defconstant $OSAIllegalRange #$errAEImpossibleRange); ; 		Signaled when an object can never be set in a container.  Same as ; 	  	AERegistry error errAENotModifiable.; 	(defconstant $OSAIllegalAssign -10003); ; 		Signaled when a syntax error occurs. (e.g. "Syntax error" or; 	 	"<this> can't go after <that>").; 	(defconstant $OSASyntaxError -2740); ; 		Signaled when another form of syntax was expected. (e.g. "expected; 	  	a <type> but found <this>").; 	(defconstant $OSASyntaxTypeError -2741);  Signaled when a name or number is too long to be parsed (defconstant $OSATokenTooLong -2742); ; 		Signaled when a parameter is missing for a function invocation.  Note; 	  	that in some languages, this error may occur at runtime.; 	(defconstant $OSAMissingParameter #$errAEDescNotFound); ; 		Signaled when function is called with the wrong number of parameters,; 	  	or a parameter pattern cannot be matched.; 	(defconstant $OSAParameterMismatch #$errAEWrongNumberArgs); ; 		Signaled when a formal parameter, local variable, or instance variable; 	  	is specified more than once.; 	(defconstant $OSADuplicateParameter -2750); ; 		Signaled when a formal parameter, local variable, or instance variable; 	  	is specified more than once.; 	(defconstant $OSADuplicateProperty -2751); ; 		Signaled when more than one handler is defined with the same name in ; 	  	a scope where the language doesn't allow it.; 	(defconstant $OSADuplicateHandler -2752);  Signaled when a variable is accessed that has no value (defconstant $OSAUndefinedVariable -2753); ; 		Signaled when a variable is declared inconsistently in the same scope,; 	  	such as both local and global.; 	(defconstant $OSAInconsistentDeclarations -2754); ; 		Signaled when illegal control flow occurs in an application (no catcher; 	  	for throw, non-lexical loop exit, etc.).; 	(defconstant $OSAControlFlowError -2755); 		Component-specific static script errors:; ; 	The range -2760 thru -2779 is reserved for component-specific parsing and; 	compile-time errors. (Note that error codes from different scripting; 	components in this range will overlap.); ; 		Dialect-specific script errors:; ; 	The range -2780 thru -2799 is reserved for dialect specific error codes for; 	scripting components that support dialects. (Note that error codes from; 	different scripting components in this range will overlap, as well as error; 	codes from different dialects in the same scripting component.); ; *************************************************************************; 	OSA Interface Descriptions; **************************************************************************; 	The OSA Interface is broken down into a required interface, and several; 	optional interfaces to support additional functionality.  A given scripting; 	component may choose to support only some of the optional interfaces in; 	addition to the basic interface.  The OSA Component Flags may be used to ; 	query the Component Manager to find a scripting component with a particular; 	capability, or determine if a particular scripting component supports a ; 	particular capability.; *************************************************************************;  OSA Component Flags: (defconstant $kOSASupportsCompiling #x2)(defconstant $kOSASupportsGetSource #x4)(defconstant $kOSASupportsAECoercion #x8)(defconstant $kOSASupportsAESending #x10)(defconstant $kOSASupportsRecording #x20)(defconstant $kOSASupportsConvenience #x40)(defconstant $kOSASupportsDialects #x80)(defconstant $kOSASupportsEventHandling #x100);  Component Selectors: (defconstant $kOSASelectLoad #x1)(defconstant $kOSASelectStore #x2)(defconstant $kOSASelectExecute #x3)(defconstant $kOSASelectDisplay #x4)(defconstant $kOSASelectScriptError #x5)(defconstant $kOSASelectDispose #x6)(defconstant $kOSASelectSetScriptInfo #x7)(defconstant $kOSASelectGetScriptInfo #x8)(defconstant $kOSASelectSetActiveProc #x9)(defconstant $kOSASelectGetActiveProc #xA);  Compiling: (defconstant $kOSASelectScriptingComponentName #x102)(defconstant $kOSASelectCompile #x103)(defconstant $kOSASelectCopyID #x104);  GetSource: (defconstant $kOSASelectGetSource #x201);  AECoercion: (defconstant $kOSASelectCoerceFromDesc #x301)(defconstant $kOSASelectCoerceToDesc #x302);  AESending: (defconstant $kOSASelectSetSendProc #x401)(defconstant $kOSASelectGetSendProc #x402)(defconstant $kOSASelectSetCreateProc #x403)(defconstant $kOSASelectGetCreateProc #x404)(defconstant $kOSASelectSetDefaultTarget #x405);  Recording: (defconstant $kOSASelectStartRecording #x501)(defconstant $kOSASelectStopRecording #x502);  Convenience: (defconstant $kOSASelectLoadExecute #x601)(defconstant $kOSASelectCompileExecute #x602)(defconstant $kOSASelectDoScript #x603);  Dialects: (defconstant $kOSASelectSetCurrentDialect #x701)(defconstant $kOSASelectGetCurrentDialect #x702)(defconstant $kOSASelectAvailableDialects #x703)(defconstant $kOSASelectGetDialectInfo #x704)(defconstant $kOSASelectAvailableDialectCodeList #x705);  Event Handling: (defconstant $kOSASelectSetResumeDispatchProc #x801)(defconstant $kOSASelectGetResumeDispatchProc #x802)(defconstant $kOSASelectExecuteEvent #x803)(defconstant $kOSASelectDoEvent #x804)(defconstant $kOSASelectMakeContext #x805);  scripting component specific selectors are added beginning with this value  (defconstant $kOSASelectComponentSpecificStart #x1001); 		Mode Flags:; ; 	Warning: These should not conflict with the AESend mode flags in; 	AppleEvents.h, because we may want to use them as OSA mode flags too.; ; ; 		This mode flag may be passed to OSALoad, OSAStore or OSACompile to; 	  	instruct the scripting component to not retain the "source" of an; 	  	expression.  This will cause the OSAGetSource call to return the error; 	  	errOSASourceNotAvailable if used.  However, some scripting components; 	  	may not retain the source anyway.  This is mainly used when either space; 	  	efficiency is desired, or a script is to be "locked" so that its; 	  	implementation may not be viewed.; 	(defconstant $kOSAModePreventGetSource #x1); ; 		These mode flags may be passed to OSACompile, OSAExecute, OSALoadExecute; 	  	OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to; 	  	indicate whether or not the script may interact with the user, switch; 	  	layer or reconnect if necessary.  Any AppleEvents will be sent with the; 	  	corresponding AESend mode supplied.; 	(defconstant $kOSAModeNeverInteract #$kAENeverInteract)(defconstant $kOSAModeCanInteract #$kAECanInteract)(defconstant $kOSAModeAlwaysInteract #$kAEAlwaysInteract)(defconstant $kOSAModeDontReconnect #$kAEDontReconnect); ; 		This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute; 	  	OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to; 	  	indicate whether or not AppleEvents should be sent with the; 	  	kAECanSwitchLayer mode flag sent or not. NOTE: This flag is exactly the; 	  	opposite sense of the AppleEvent flag kAECanSwitchLayer.  This is to; 	  	provide a more convenient default, i.e. not supplying any mode; 	  	(kOSAModeNull) means to send events with kAECanSwitchLayer.  Supplying; 	  	the kOSAModeCantSwitchLayer mode flag will cause AESend to be called; 	  	without kAECanSwitchLayer.; 	(defconstant $kOSAModeCantSwitchLayer #x40); ; 		This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute; 	  	OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to; 	  	indicate whether or not AppleEvents should be sent with the kAEDontRecord; 	  	mode flag sent or not. NOTE: This flag is exactly the opposite sense of; 	  	the AppleEvent flag kAEDontRecord.  This is to provide a more convenient; 	  	default, i.e. not supplying any mode (kOSAModeNull) means to send events; 	  	with kAEDontRecord.  Supplying the kOSAModeDoRecord mode flag will ; 	  	cause AESend to be called without kAEDontRecord.; 	(defconstant $kOSAModeDoRecord #x1000); ; 		This is a mode flag for OSACompile that indicates that a context should; 	  	be created as the result of compilation. All handler definitions are; 	  	inserted into the new context, and variables are initialized by; 	  	evaluating their initial values in a null context (i.e. they must be; 	  	constant expressions).; 	(defconstant $kOSAModeCompileIntoContext #x2); ; 		This is a mode flag for OSACompile that indicates that the previous; 	  	script ID (input to OSACompile) should be augmented with any new; 	  	definitions in the sourceData rather than replaced with a new script.; 	  	This means that the previous script ID must designate a context.; 	  	The presence of this flag causes the kOSAModeCompileIntoContext flag; 	  	to be implicitly used, causing any new definitions to be initialized; 	  	in a null context.; 	(defconstant $kOSAModeAugmentContext #x4); ; 		This mode flag may be passed to OSADisplay or OSADoScript to indicate; 	  	that output only need be human-readable, not re-compilable by OSACompile.; 	  	If used, output may be arbitrarily "beautified", e.g. quotes may be left; 	  	off of string values, long lists may have elipses, etc.; 	(defconstant $kOSAModeDisplayForHumans #x8); ; 		This mode flag may be passed to OSAStore in the case where the scriptID; 	  	is a context.  This causes the context to be saved, but not the context's; 	  	parent context.  When the stored context is loaded back in, the parent; 	  	will be kOSANullScript.; 	(defconstant $kOSAModeDontStoreParent #x10000); ; 		This mode flag may be passed to OSAExecuteEvent to cause the event to; 	  	be dispatched to the direct object of the event. The direct object (or; 	  	subject attribute if the direct object is a non-object specifier) will; 	  	be resolved, and the resulting script object will be the recipient of; 	  	the message. The context argument to OSAExecuteEvent will serve as the; 	  	root of the lookup/resolution process.; 	(defconstant $kOSAModeDispatchToDirectObject #x20000); ; 		This mode flag may be passed to OSAExecuteEvent to indicate that; 	  	components do not have to get the data of object specifier arguments.; 	(defconstant $kOSAModeDontGetDataForArguments #x40000); *************************************************************************; 	OSA Basic Scripting Interface; **************************************************************************; 	Scripting components must at least support the Basic Scripting interface.; *************************************************************************; 		Loading and Storing Scripts:; ; 	These routines allow scripts to be loaded and stored in their internal; 	(possibly compiled, non-text) representation.; ;  Resource type for scripts (defconstant $kOSAScriptResourceType #$kOSAGenericScriptingComponentSubtype); ; 		Default type given to OSAStore which creates "generic" loadable script; 	  	data descriptors.; 	(defconstant $typeOSAGenericStorage #$kOSAScriptResourceType); CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSALoad" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptData (:pointer :aedesc)) (modeFlags :signed-long) (resultingScriptID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptData modeFlags resultingScriptID ((+ (ash 12 16) 1) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectLoad, 12);; 	; 		Errors:; 			badComponentInstance		invalid scripting component instance; 			errOSASystemError; 			errOSABadStorageType:		scriptData not for this scripting component; 			errOSACorruptData:			data seems to be corrupt; 			errOSADataFormatObsolete	script data format is no longer supported; 			errOSADataFormatTooNew		script data format is from a newer version; 		; 		ModeFlags:; 			kOSAModePreventGetSource; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAStore" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptID :signed-long) (desiredType :ostype) (modeFlags :signed-long) (resultingScriptData (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptID desiredType modeFlags resultingScriptData ((+ (ash 16 16) 2) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectStore, 16);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSABadStorageType:	desiredType not for this scripting component; 		; 		ModeFlags:; 			kOSAModePreventGetSource; 			kOSAModeDontStoreParent; 	;  Executing Scripts: ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAExecute" ((scriptingComponent (:pointer :componentinstancerecord)) (compiledScriptID :signed-long) (contextID :signed-long) (modeFlags :signed-long) (resultingScriptValueID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent compiledScriptID contextID modeFlags resultingScriptValueID ((+ (ash 16 16) 3) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectExecute, 16);; 		This call runs a script.  The contextID represents the environment; 		with which global variables in the script are resolved.  The constant; 		kOSANullScript may be used for the contextID if the application wishes; 		to not deal with context directly (a default one is associated with each; 		scripting component instance).  The resultingScriptValueID is the ; 		result of evaluation, and contains a value which may be displayed using; 		the OSAGetSource call.  The modeFlags convey scripting component; 		specific information.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSAScriptError:		the executing script got an error; 	; 		ModeFlags:; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	;  Displaying results: ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSADisplay" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptValueID :signed-long) (desiredType :ostype) (modeFlags :signed-long) (resultingText (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptValueID desiredType modeFlags resultingText ((+ (ash 16 16) 4) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectDisplay, 16);; 		This call is used to convert results (script value IDs) into displayable; 		text. The desiredType should be at least typeChar, and modeFlags are; 		scripting system specific flags to control the formatting of the; 		resulting text. This call differs from OSAGetSource in that (1) it; 		always produces at least typeChar, (2) is only works on script values,; 		(3) it may display it's output in non-compilable form (e.g. without; 		string quotes, elipses inserted in long and/or circular lists, etc.) and; 		(4) it is required by the basic scripting interface.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errAECoercionFail:		desiredType not supported by scripting component; 	; 		ModeFlags:; 			kOSAModeDisplayForHumans; 	;  Getting Error Information: ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAScriptError" ((scriptingComponent (:pointer :componentinstancerecord)) (selector :ostype) (desiredType :ostype) (resultingErrorDescription (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent selector desiredType resultingErrorDescription ((+ (ash 12 16) 5) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectScriptError, 12);; 		Whenever script execution returns errOSAExecutionError, this routine; 		may be used to get information about that error.  The selector describes; 		the type of information desired about the error (various selectors are; 		listed below).  The desiredType indicates the data type of the result; 		desired for that selector.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSABadSelector:		selector not supported by scripting component; 			errAECoercionFail:		desiredType not supported by scripting component; 	;  OSAScriptError selectors: ; ; 		This selector is used to determine the error number of a script error.; 		These error numbers may be either system error numbers, or error numbers; 		that are scripting component specific.; 		Required desiredTypes:	; 	  		typeShortInteger; 	(defconstant $kOSAErrorNumber #$keyErrorNumber); ; 		This selector is used to determine the full error message associated; 		with the error number.  It should include the name of the application; 		which caused the error, as well as the specific error that occurred.; 		This selector is sufficient for simple error reporting (but see; 		kOSAErrorBriefMessage, below).; 		Required desiredTypes:; 			typeChar					error message string; 	(defconstant $kOSAErrorMessage #$keyErrorString); ; 		This selector is used to determine a brief error message associated with; 		the error number.  This message and should not mention the name of the; 		application which caused the error, any partial results or offending; 		object (see kOSAErrorApp, kOSAErrorPartialResult and; 		kOSAErrorOffendingObject, below).; 		Required desiredTypes:; 	  		typeChar					brief error message string; 	;   0x65727262  (defconstant $kOSAErrorBriefMessage :|errb|); ; 		This selector is used to determine which application actually got the; 		error (if it was the result of an AESend), or the current application; 		if ....; 		Required desiredTypes:; 	  		typeProcessSerialNumber		PSN of the errant application; 	  		typeChar					name of the errant application; 	;   0x65726170  (defconstant $kOSAErrorApp :|erap|); ; 		This selector is used to determine any partial result returned by an ; 		operation. If an AESend call failed, but a partial result was returned,; 		then the partial result may be returned as an AEDesc.; 		Required desiredTypes:; 	  		typeBest					AEDesc of any partial result; 	;   0x70746c72   (defconstant $kOSAErrorPartialResult :|ptlr|); ; 		This selector is used to determine any object which caused the error; 		that may have been indicated by an application.  The result is an ; 		AEDesc.; 		Required desiredTypes:; 	  		typeBest					AEDesc of any offending object; 	;   0x65726f62   (defconstant $kOSAErrorOffendingObject :|erob|); ; 		This selector is used to determine the type expected by a coercion ; 		operation if a type error occurred.; 	;   0x65727274   (defconstant $kOSAErrorExpectedType :|errt|); ; 		This selector is used to determine the source text range (start and ; 		end positions) of where the error occurred.; 		Required desiredTypes:; 	  		typeOSAErrorRange; 	;   0x65726e67  (defconstant $kOSAErrorRange :|erng|); ; 		An AERecord type containing keyOSASourceStart and keyOSASourceEnd fields; 	    of type short.; 	;   0x65726e67   (defconstant $typeOSAErrorRange :|erng|);  Field of a typeOSAErrorRange record of typeShortInteger ;   0x73726373    (defconstant $keyOSASourceStart :|srcs|);  Field of a typeOSAErrorRange record of typeShortInteger ;   0x73726365   (defconstant $keyOSASourceEnd :|srce|);  Disposing Script IDs: ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSADispose" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptID :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptID ((+ (ash 4 16) 6) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectDispose, 4);; 		Disposes a script or context.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 	;  Getting and Setting Script Information: ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetScriptInfo" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptID :signed-long) (selector :ostype) (value :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptID selector value ((+ (ash 12 16) 7) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetScriptInfo, 12);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSABadSelector:		selector not supported by scripting component; 									or selector not for this scriptID; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetScriptInfo" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptID :signed-long) (selector :ostype) (result (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptID selector result ((+ (ash 12 16) 8) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetScriptInfo, 12);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSABadSelector:		selector not supported by scripting component; 									or selector not for this scriptID; 	;  Manipulating the ActiveProc:; ; 	Scripting systems will supply default values for these procedures if they; 	are not set by the client:; (def-mactype :osaactiveprocptr (find-mactype ':pointer));  FUNCTION OSAActive(refCon: LONGINT): OSErr; (def-mactype :osaactiveupp (find-mactype ':pointer))(defconstant $uppOSAActiveProcInfo #xE0)        ;  FUNCTION (4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewOSAActiveProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallOSAActiveProc" ((refCon :signed-long) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetActiveProc" ((scriptingComponent (:pointer :componentinstancerecord)) (activeProc :pointer) (refCon :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent activeProc refCon ((+ (ash 8 16) 9) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetActiveProc, 8);; 		If activeProc is nil, the default activeProc is used.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetActiveProc" ((scriptingComponent (:pointer :componentinstancerecord)) (activeProc (:pointer :pointer)) (refCon (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent activeProc refCon ((+ (ash 8 16) 10) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetActiveProc, 8);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; *************************************************************************; 	OSA Optional Compiling Interface; **************************************************************************; 	Scripting components that support the Compiling interface have the ; 	kOSASupportsCompiling bit set in it's ComponentDescription.; *************************************************************************; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAScriptingComponentName" ((scriptingComponent (:pointer :componentinstancerecord)) (resultingScriptingComponentName (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent resultingScriptingComponentName ((+ (ash 4 16) 258) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectScriptingComponentName, 4);; 		Given a scripting component, this routine returns the name of that; 		scripting component in a type that is coercable to text (typeChar).; 		The generic scripting component returns the name of the default; 		scripting component.  This name should be sufficient to convey to the; 		user the kind of script (syntax) he is expected to write.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSACompile" ((scriptingComponent (:pointer :componentinstancerecord)) (sourceData (:pointer :aedesc)) (modeFlags :signed-long) (previousAndResultingScriptID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent sourceData modeFlags previousAndResultingScriptID ((+ (ash 12 16) 259) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectCompile, 12);; 		Coerces input desc (possibly text) into a script's internal format.; 		Once compiled, the script is ready to run.  The modeFlags convey; 		scripting component specific information.  The previous script ID; 		(result parameter) is made to refer to the newly compiled script,; 		unless it was originally kOSANullScript.  In this case a new script; 		ID is created and used.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errAECoercionFail:		sourceData is not compilable; 			errOSAScriptError:		sourceData was a bad script (syntax error); 			errOSAInvalidID:		previousAndResultingCompiledScriptID was not; 									valid on input; 	; 		ModeFlags:; 			kOSAModePreventGetSource; 			kOSAModeCompileIntoContext; 			kOSAModeAugmentContext; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSACopyID" ((scriptingComponent (:pointer :componentinstancerecord)) (fromID :signed-long) (toID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent fromID toID ((+ (ash 8 16) 260) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectCopyID, 8);; 		If toID is a reference to kOSANullScript then it is updated to have a; 		new scriptID value.  This call can be used to perform undo or revert; 		operations on scripts. ; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 	; *************************************************************************; 	OSA Optional GetSource Interface; **************************************************************************; 	Scripting components that support the GetSource interface have the ; 	kOSASupportsGetSource bit set in it's ComponentDescription.; *************************************************************************; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetSource" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptID :signed-long) (desiredType :ostype) (resultingSourceData (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptID desiredType resultingSourceData ((+ (ash 12 16) 513) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetSource, 12);; 		This routine causes a compiled script to be output in a form (possibly; 		text) such that it is suitable to be passed back to OSACompile.; ; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSASourceNotAvailable	can't get source for this scriptID; 	; *************************************************************************; 	OSA Optional AECoercion Interface; **************************************************************************; 	Scripting components that support the AECoercion interface have the ; 	kOSASupportsAECoercion bit set in it's ComponentDescription.; *************************************************************************; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSACoerceFromDesc" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptData (:pointer :aedesc)) (modeFlags :signed-long) (resultingScriptID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptData modeFlags resultingScriptID ((+ (ash 12 16) 769) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectCoerceFromDesc, 12);; 		This routine causes script data to be coerced into a script value.; 		If the scriptData is an AppleEvent, then the resultingScriptID is a; 		compiled script ID (mode flags for OSACompile may be used in this case).; 		Other scriptData descriptors create script value IDs.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; 		ModeFlags:; 			kOSAModePreventGetSource; 			kOSAModeCompileIntoContext; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSACoerceToDesc" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptID :signed-long) (desiredType :ostype) (modeFlags :signed-long) (result (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptID desiredType modeFlags result ((+ (ash 16 16) 770) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectCoerceToDesc, 16);; 		This routine causes a script value to be coerced into any desired form.; 		If the scriptID denotes a compiled script, then it may be coerced to ; 		typeAppleEvent.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 	; *************************************************************************; 	OSA Optional AESending Interface; **************************************************************************; 	Scripting components that support the AESending interface have the ; 	kOSASupportsAESending bit set in it's ComponentDescription.; *************************************************************************; ; 	Scripting systems will supply default values for these procedures if they; 	are not set by the client:; ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetSendProc" ((scriptingComponent (:pointer :componentinstancerecord)) (sendProc :pointer) (refCon :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent sendProc refCon ((+ (ash 8 16) 1025) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetSendProc, 8);; 		If sendProc is nil, the default sendProc is used.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetSendProc" ((scriptingComponent (:pointer :componentinstancerecord)) (sendProc (:pointer :pointer)) (refCon (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent sendProc refCon ((+ (ash 8 16) 1026) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetSendProc, 8);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetCreateProc" ((scriptingComponent (:pointer :componentinstancerecord)) (createProc :pointer) (refCon :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent createProc refCon ((+ (ash 8 16) 1027) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetCreateProc, 8);; 		If createProc is nil, the default createProc is used.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetCreateProc" ((scriptingComponent (:pointer :componentinstancerecord)) (createProc (:pointer :pointer)) (refCon (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent createProc refCon ((+ (ash 8 16) 1028) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetCreateProc, 8);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetDefaultTarget" ((scriptingComponent (:pointer :componentinstancerecord)) (target (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent target ((+ (ash 4 16) 1029) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetDefaultTarget, 4);; 		This routine sets the default target application for AE sending.; 		It also establishes the default target from which terminologies come.; 		It is effectively like having an AppleScript "tell" statement around; 		the entire program.  If this routine is not called, or if the target ; 		is a null AEDesc, then the current application is the default target.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; *************************************************************************; 	OSA Optional Recording Interface; **************************************************************************; 	Scripting components that support the Recording interface have the ; 	kOSASupportsRecording bit set in it's ComponentDescription.; *************************************************************************; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAStartRecording" ((scriptingComponent (:pointer :componentinstancerecord)) (compiledScriptToModifyID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent compiledScriptToModifyID ((+ (ash 4 16) 1281) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectStartRecording, 4);; 		Starts recording.  If compiledScriptToModifyID is kOSANullScript, a; 		new script ID is created and returned.  If the current application has; 		a handler for the kOSARecordedText event, then kOSARecordedText events; 		are sent to the application containing the text of each AppleEvent ; 		recorded.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSARecordingIsAlreadyOn; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAStopRecording" ((scriptingComponent (:pointer :componentinstancerecord)) (compiledScriptID :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent compiledScriptID ((+ (ash 4 16) 1282) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectStopRecording, 4);; 		If compiledScriptID is not being recorded into or recording is not; 		currently on, no error is returned.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 	; *************************************************************************; 	OSA Optional Convenience Interface; **************************************************************************; 	Scripting components that support the Convenience interface have the ; 	kOSASupportsConvenience bit set in it's ComponentDescription.; *************************************************************************; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSALoadExecute" ((scriptingComponent (:pointer :componentinstancerecord)) (scriptData (:pointer :aedesc)) (contextID :signed-long) (modeFlags :signed-long) (resultingScriptValueID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent scriptData contextID modeFlags resultingScriptValueID ((+ (ash 16 16) 1537) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectLoadExecute, 16);; 		This routine is effectively equivalent to calling OSALoad followed by; 		OSAExecute.  After execution, the compiled source is disposed.  Only the; 		resulting value ID is retained.; 	; 		Errors:; 			badComponentInstance		invalid scripting component instance; 			errOSASystemError; 			errOSABadStorageType:		scriptData not for this scripting component; 			errOSACorruptData:			data seems to be corrupt; 			errOSADataFormatObsolete	script data format is no longer supported; 			errOSADataFormatTooNew		script data format is from a newer version; 			errOSAInvalidID; 			errOSAScriptError:			the executing script got an error; 	; 		ModeFlags:; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSACompileExecute" ((scriptingComponent (:pointer :componentinstancerecord)) (sourceData (:pointer :aedesc)) (contextID :signed-long) (modeFlags :signed-long) (resultingScriptValueID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent sourceData contextID modeFlags resultingScriptValueID ((+ (ash 16 16) 1538) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectCompileExecute, 16);; 		This routine is effectively equivalent to calling OSACompile followed by; 		OSAExecute.  After execution, the compiled source is disposed.  Only the; 		resulting value ID is retained.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errAECoercionFail:		sourceData is not compilable; 			errOSAScriptError:		sourceData was a bad script (syntax error); 			errOSAInvalidID:		previousAndResultingCompiledScriptID was not; 									valid on input; 			errOSAScriptError:		the executing script got an error; 	; 		ModeFlags:; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSADoScript" ((scriptingComponent (:pointer :componentinstancerecord)) (sourceData (:pointer :aedesc)) (contextID :signed-long) (desiredType :ostype) (modeFlags :signed-long) (resultingText (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent sourceData contextID desiredType modeFlags resultingText ((+ (ash 20 16) 1539) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectDoScript, 20);; 		This routine is effectively equivalent to calling OSACompile followed by; 		OSAExecute and then OSADisplay.  After execution, the compiled source; 		and the resulting value are is disposed.  Only the resultingText; 		descriptor is retained.  If a script error occur during processing, the ; 		resultingText gets the error message of the error, and errOSAScriptError; 		is returned.  OSAScriptError may still be used to extract more ; 		information about the particular error.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errAECoercionFail:		sourceData is not compilable or ; 									desiredType not supported by scripting component; 			errOSAScriptError:		sourceData was a bad script (syntax error); 			errOSAInvalidID:		previousAndResultingCompiledScriptID was not; 									valid on input; 			errOSAScriptError:		the executing script got an error; 	; 		ModeFlags:; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 			kOSAModeDisplayForHumans; 	; *************************************************************************; 	OSA Optional Dialects Interface; **************************************************************************; 	Scripting components that support the Dialects interface have the ; 	kOSASupportsDialects bit set in it's ComponentDescription.; *************************************************************************; ; 	These calls allows an scripting component that supports different dialects; 	to dynamically switch between those dialects.  Although this interface is; 	specified, the particular dialect codes are scripting component dependent.; ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetCurrentDialect" ((scriptingComponent (:pointer :componentinstancerecord)) (dialectCode :signed-integer))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent dialectCode ((+ (ash 2 16) 1793) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetCurrentDialect, 2);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSANoSuchDialect:	invalid dialectCode; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetCurrentDialect" ((scriptingComponent (:pointer :componentinstancerecord)) (resultingDialectCode (:pointer :signed-integer)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent resultingDialectCode ((+ (ash 4 16) 1794) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetCurrentDialect, 4);; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAAvailableDialects" ((scriptingComponent (:pointer :componentinstancerecord)) (resultingDialectInfoList (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent resultingDialectInfoList ((+ (ash 4 16) 1795) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectAvailableDialects, 4);; 		This call return an AEList containing information about each of the; 		currently available dialects of a scripting component.  Each item; 		is an AERecord of typeOSADialectInfo that contains at least the fields; 		keyOSADialectName, keyOSADialectCode, KeyOSADialectLangCode and ; 		keyOSADialectScriptCode.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetDialectInfo" ((scriptingComponent (:pointer :componentinstancerecord)) (dialectCode :signed-integer) (selector :ostype) (resultingDialectInfo (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent dialectCode selector resultingDialectInfo ((+ (ash 10 16) 1796) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetDialectInfo, 10);; 		This call gives information about the specified dialect of a scripting; 		component. It returns an AEDesc whose type depends on the selector ; 		specified. Available selectors are the same as the field keys for a; 		dialect info record. The type of AEDesc returned is the same as the ; 		type of the field that has same key as the selector.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 		 	errOSABadSelector; 			errOSANoSuchDialect:	invalid dialectCode; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAAvailableDialectCodeList" ((scriptingComponent (:pointer :componentinstancerecord)) (resultingDialectCodeList (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent resultingDialectCodeList ((+ (ash 4 16) 1797) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectAvailableDialectCodeList, 4);; 		This is alternative to OSAGetAvailableDialectCodeList. Use this call; 		and  OSAGetDialectInfo to get information on dialects.; 		This call return an AEList containing dialect code for each of the; 		currently available dialects of a scripting component. Each dialect; 		code is a short integer of type typeShortInteger.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; ; 		Type of a dialect info record containing at least keyOSADialectName; 		and keyOSADialectCode fields.; ; 		keys for dialect info record, also used as selectors to OSAGetDialectInfo.; ; 		Field of a typeOSADialectInfo record of typeChar.; 		Field of a typeOSADialectInfo record of typeShortInteger.; 		Field of a typeOSADialectInfo record of typeShortInteger.; 		Field of a typeOSADialectInfo record of typeShortInteger.; 	; *************************************************************************; 	OSA Optional Event Handling Interface; **************************************************************************; 	Scripting components that support the Event Handling interface have the ; 	kOSASupportsEventHandling bit set in it's ComponentDescription.; *************************************************************************; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSASetResumeDispatchProc" ((scriptingComponent (:pointer :componentinstancerecord)) (resumeDispatchProc :pointer) (refCon :signed-long))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent resumeDispatchProc refCon ((+ (ash 8 16) 2049) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectSetResumeDispatchProc, 8);; 		This function is used to set the ResumeDispatchProc that will be used; 		by OSAExecuteEvent and OSADoEvent if either no event handler can be; 		found in the context, or the context event hander "continues" control; 		onward. The two constants kOSAUseStandardDispatch and kOSANoDispatch; 		may also be passed to this routine indicating that the handler registered; 		in the application with AEInstallEventHandler should be used, or no; 		dispatch should occur, respectively.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	(defconstant $kOSAUseStandardDispatch #$kAEUseStandardDispatch); ; 		Special ResumeDispatchProc constant which may be passed to ; 		OSASetResumeDispatchProc indicating that the handler registered; 		in the application with AEInstallEventHandler should be used.; 		; 		NOTE:	Had to remove the cast (AEEventHandlerUPP).  The C compiler; 				doesn't allow pointer types to be assigned to an enum.  All; 				constants must be assigned as enums to translate properly to; 				Pascal.; 	(defconstant $kOSANoDispatch #$kAENoDispatch); ; 		Special ResumeDispatchProc constant which may be passed to ; 		OSASetResumeDispatchProc indicating that no dispatch should occur.; 		; 		NOTE:	Had to remove the cast (AEEventHandlerUPP).  The C compiler; 				doesn't allow pointer types to be assigned to an enum.  All; 				constants must be assigned as enums to translate properly to; 				Pascal.; 	(defconstant $kOSADontUsePhac #x1); ; 		Special refCon constant that may be given to OSASetResumeDispatchProc; 		only when kOSAUseStandardDispatch is used as the ResumeDispatchProc.; 		This causes the standard dispatch to be performed, except the phac; 		handler is not called.  This is useful during tinkerability, when; 		the phac handler is used to lookup a context associated with an event's ; 		direct parameter, and call OSAExecuteEvent or OSADoEvent.  Failure to; 		bypass the phac handler would result in an infinite loop.; 	; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAGetResumeDispatchProc" ((scriptingComponent (:pointer :componentinstancerecord)) (resumeDispatchProc (:pointer :pointer)) (refCon (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent resumeDispatchProc refCon ((+ (ash 8 16) 2050) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectGetResumeDispatchProc, 8);; 		Returns the registered ResumeDispatchProc.  If no ResumeDispatchProc has; 		been registered, then kOSAUseStandardDispatch (the default) is returned.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAExecuteEvent" ((scriptingComponent (:pointer :componentinstancerecord)) (theAppleEvent (:pointer :aedesc)) (contextID :signed-long) (modeFlags :signed-long) (resultingScriptValueID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent theAppleEvent contextID modeFlags resultingScriptValueID ((+ (ash 16 16) 2051) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectExecuteEvent, 16);; 		This call is similar to OSAExecute except the initial command to; 		execute comes in the form of an AppleEvent.  If the contextID; 		defines any event handlers for that event, they are used to process; 		the event.  If no event handler can be found in the context; 		errAEEventNotHandled is returned.  If an event handler is found and; 		the hander "continues" control onward, the ResumeDispatchProc; 		(registered with OSASetResumeDispatchProc, above) is called given the; 		AppleEvent.  The result is returned as a scriptValueID.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errOSAScriptError:		the executing script got an error; 			errAEEventNotHandled:	no handler for event in contextID; 	; 		ModeFlags:; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSADoEvent" ((scriptingComponent (:pointer :componentinstancerecord)) (theAppleEvent (:pointer :aedesc)) (contextID :signed-long) (modeFlags :signed-long) (reply (:pointer :aedesc)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent theAppleEvent contextID modeFlags reply ((+ (ash 16 16) 2052) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectDoEvent, 16);; 		This call is similar to OSADoScript except the initial command to; 		execute comes in the form of an AppleEvent, and the result is an ; 		AppleEvent reply record.  If the contextID defines any event handlers; 		for that event, they are used to process the event.  If no event handler; 		can be found in the context errAEEventNotHandled is returned.  If an; 		event handler is found and the hander "continues" control onward, the; 		ResumeDispatchProc (registered with OSASetResumeDispatchProc, above) is; 		called given the AppleEvent.  The result is returned in the form of an; 		AppleEvent reply descriptor. If at any time the script gets an error, or; 		if the ResumeDispatchProc returns a reply event indicating an error,; 		then the OSADoEvent call itself returns an error reply (i.e. OSADoEvent; 		should never return errOSAScriptError).  Any error result returned by; 		the ResumeDispatchProc will be returned by OSADoEvent.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errAEEventNotHandled:	no handler for event in contextID; 	; 		ModeFlags:; 			kOSAModeNeverInteract; 			kOSAModeCanInteract; 			kOSAModeAlwaysInteract; 			kOSAModeCantSwitchLayer; 			kOSAModeDontReconnect; 			kOSAModeDoRecord; 	; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-longword-on-stack(deftrap "_OSAMakeContext" ((scriptingComponent (:pointer :componentinstancerecord)) (contextName (:pointer :aedesc)) (parentContext :signed-long) (resultingContextID (:pointer :signed-long)))   (:stack :signed-long)   (:stack-trap #xA82A :d0 0 scriptingComponent contextName parentContext resultingContextID ((+ (ash 12 16) 2053) :signed-longint))); $ENDC; ; 		OSAComponentFunctionInline(kOSASelectMakeContext, 12);; 		Makes a new empty context which may be passed to OSAExecute or ; 		OSAExecuteEvent.  If contextName is typeNull, an unnamed context is; 		created. If parentContext is kOSANullScript then the resulting context; 		does not inherit bindings from any other context.; 	; 		Errors:; 			badComponentInstance	invalid scripting component instance; 			errOSASystemError; 			errOSAInvalidID; 			errAECoercionFail:		contextName is invalid; 	; $ALIGN RESET; $POP; $SETC UsingIncludes := OSAIncludes; $ENDC                                         ; __OSA__#|                                              ; $IFC NOT UsingIncludes |#                                             ; $ENDC(provide-interface 'OSA)