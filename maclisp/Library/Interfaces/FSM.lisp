(in-package :TRAPS); Generated from #P"HD:CCL3.0d17:Interface Translator:Source interfaces:Pascal Interfaces:FSM.p"; at Tuesday June 6,1995 2:09:36 pm.; ;  	File:		FSM.p;  ;  	Contains:	HFS External File System Interfaces.;  ;  	Version:	Technology:	System 7.5;  				Package:	Universal Interfaces 2.0 in “MPW Latest” on ETO #17;  ;  	Copyright:	© 1984-1995 by Apple Computer, Inc.;  				All rights reserved.;  ;  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter;  				stack.  Include the file and version information (from above);  				in the problem description and send to:;  					Internet:	apple.bugs@applelink.apple.com;  					AppleLink:	APPLE.BUGS;  ; #|                                              ; $IFC UNDEFINED UsingIncludes; $SETC UsingIncludes := 0 |#                                             ; $ENDC; $IFC NOT UsingIncludes; $ENDC; $IFC UNDEFINED __FSM__; $SETC __FSM__ := 1; $I+; $SETC FSMIncludes := UsingIncludes; $SETC UsingIncludes := 1#|                                              ; $IFC UNDEFINED __FILES__|#(require-interface 'Files)#|                                              ; $I Files.p |#                                             ; $ENDC; 	Types.p														; 		ConditionalMacros.p										; 	MixedMode.p													; 	OSUtils.p													; 		Memory.p												; $PUSH; $ALIGN MAC68K; $LibExport+; 	The new volume mount flags (defconstant $volMountInteractBit 15)           ;  Input to VolumeMount: If set, it's OK for the file system (defconstant $volMountInteractMask #x8000)      ;  to perform user interaction to mount the volume (defconstant $volMountChangedBit 14)            ;  Output from VoumeMount: If set, the volume was mounted, but (defconstant $volMountChangedMask #x4000)       ;  the volume mounting information record needs to be updated. (defconstant $volMountFSReservedMask #xFF)      ;  bits 0-7 are defined by each file system for its own use (defconstant $volMountSysReservedMask #xFF00)   ;  bits 8-15 are reserved for Apple system use ; ;  * The new volume mount info record;  (defrecord VolumeMountInfoHeader    (length :signed-integer)                     ;  length of location data (including self)    (media :ostype)                              ;  type of media (must be registered with Apple)    (flags :signed-integer)                      ;  volume mount flags. Variable length data follows    )(def-mactype :volumemountinfoheaderptr (find-mactype '(:pointer :volumemountinfoheader)))(defconstant $gestaltFSMVersion :|fsm |)(def-mactype :vcbptr (find-mactype '(:pointer :vcb))); ;  * Miscellaneous file system values not in Files.h;  (defconstant $fsUsrCNID 16)                     ;  First assignable directory or file number ; 	File system trap word attribute bits (defconstant $kHFSBit 9)                        ;  HFS call: bit 9 (defconstant $kHFSMask #x200)(defconstant $kAsyncBit 10)                     ;  Asynchronous call: bit 10 (defconstant $kAsyncMask #x400); ;  * HFSCIProc selectCode values;  * Note: The trap attribute bits (the HFS bit and the asynchronous bit);  * may be set in these selectCode values.;  (defconstant $kFSMOpen #xA000)(defconstant $kFSMClose #xA001)(defconstant $kFSMRead #xA002)(defconstant $kFSMWrite #xA003)(defconstant $kFSMGetVolInfo #xA007)(defconstant $kFSMCreate #xA008)(defconstant $kFSMDelete #xA009)(defconstant $kFSMOpenRF #xA00A)(defconstant $kFSMRename #xA00B)(defconstant $kFSMGetFileInfo #xA00C)(defconstant $kFSMSetFileInfo #xA00D)(defconstant $kFSMUnmountVol #xA00E)(defconstant $kFSMMountVol #xA00F)(defconstant $kFSMAllocate #xA010)(defconstant $kFSMGetEOF #xA011)(defconstant $kFSMSetEOF #xA012)(defconstant $kFSMFlushVol #xA013)(defconstant $kFSMGetVol #xA014)(defconstant $kFSMSetVol #xA015)(defconstant $kFSMEject #xA017)(defconstant $kFSMGetFPos #xA018)(defconstant $kFSMOffline #xA035)(defconstant $kFSMSetFilLock #xA041)(defconstant $kFSMRstFilLock #xA042)(defconstant $kFSMSetFilType #xA043)(defconstant $kFSMSetFPos #xA044)(defconstant $kFSMFlushFile #xA045); 	The File System HFSDispatch selectCodes (defconstant $kFSMOpenWD #x1)(defconstant $kFSMCloseWD #x2)(defconstant $kFSMCatMove #x5)(defconstant $kFSMDirCreate #x6)(defconstant $kFSMGetWDInfo #x7)(defconstant $kFSMGetFCBInfo #x8)(defconstant $kFSMGetCatInfo #x9)(defconstant $kFSMSetCatInfo #xA)(defconstant $kFSMSetVolInfo #xB)(defconstant $kFSMLockRng #x10)(defconstant $kFSMUnlockRng #x11)(defconstant $kFSMCreateFileIDRef #x14)(defconstant $kFSMDeleteFileIDRef #x15)(defconstant $kFSMResolveFileIDRef #x16)(defconstant $kFSMExchangeFiles #x17)(defconstant $kFSMCatSearch #x18)(defconstant $kFSMOpenDF #x1A)(defconstant $kFSMMakeFSSpec #x1B); 	The Desktop Manager HFSDispatch selectCodes (defconstant $kFSMDTGetPath #x20)(defconstant $kFSMDTCloseDown #x21)(defconstant $kFSMDTAddIcon #x22)(defconstant $kFSMDTGetIcon #x23)(defconstant $kFSMDTGetIconInfo #x24)(defconstant $kFSMDTAddAPPL #x25)(defconstant $kFSMDTRemoveAPPL #x26)(defconstant $kFSMDTGetAPPL #x27)(defconstant $kFSMDTSetComment #x28)(defconstant $kFSMDTRemoveComment #x29)(defconstant $kFSMDTGetComment #x2A)(defconstant $kFSMDTFlush #x2B)(defconstant $kFSMDTReset #x2C)(defconstant $kFSMDTGetInfo #x2D)(defconstant $kFSMDTOpenInform #x2E)(defconstant $kFSMDTDelete #x2F); 	The AppleShare HFSDispatch selectCodes (defconstant $kFSMGetVolParms #x30)(defconstant $kFSMGetLogInInfo #x31)(defconstant $kFSMGetDirAccess #x32)(defconstant $kFSMSetDirAccess #x33)(defconstant $kFSMMapID #x34)(defconstant $kFSMMapName #x35)(defconstant $kFSMCopyFile #x36)(defconstant $kFSMMoveRename #x37)(defconstant $kFSMOpenDeny #x38)(defconstant $kFSMOpenRFDeny #x39)(defconstant $kFSMGetXCatInfo #x3A)(defconstant $kFSMGetVolMountInfoSize #x3F)(defconstant $kFSMGetVolMountInfo #x40)(defconstant $kFSMVolumeMount #x41)(defconstant $kFSMShare #x42)(defconstant $kFSMUnShare #x43)(defconstant $kFSMGetUGEntry #x44)(defconstant $kFSMGetForeignPrivs #x60)(defconstant $kFSMSetForeignPrivs #x61); ;  * UTDetermineVol status values;  (defconstant $dtmvError 0)                      ;  param error (defconstant $dtmvFullPathame 1)                ;  determined by full pathname (defconstant $dtmvVRefNum 2)                    ;  determined by volume refNum (defconstant $dtmvWDRefNum 3)                   ;  determined by working directory refNum (defconstant $dtmvDriveNum 4)                   ;  determined by drive number (defconstant $dtmvDefault 5)                    ;  determined by default volume ; ;  * UTGetBlock options;  (defconstant $gbDefault 0)                      ;  default value - read if not found ; 	bits and masks (defconstant $gbReadBit 0)                      ;  read block from disk (forced read) (defconstant $gbReadMask #x1)(defconstant $gbExistBit 1)                     ;  get existing cache block (defconstant $gbExistMask #x2)(defconstant $gbNoReadBit 2)                    ;  don't read block from disk if not found in cache (defconstant $gbNoReadMask #x4)(defconstant $gbReleaseBit 3)                   ;  release block immediately after GetBlock (defconstant $gbReleaseMask #x8); ;  * UTReleaseBlock options;  (defconstant $rbDefault 0)                      ;  default value - just mark the buffer not in-use ; 	bits and masks (defconstant $rbWriteBit 0)                     ;  force write buffer to disk (defconstant $rbWriteMask #x1)(defconstant $rbTrashBit 1)                     ;  trash buffer contents after release (defconstant $rbTrashMask #x2)(defconstant $rbDirtyBit 2)                     ;  mark buffer dirty (defconstant $rbDirtyMask #x4)(defconstant $rbFreeBit 3)                      ;  free the buffer (save in the hash) ; ;  *	rbFreeMask (rbFreeBit + rbTrashBit) works as rbTrash on < System 7.0 RamCache;;  *	on >= System 7.0, rbfreeMask overrides rbTrash;  (defconstant $rbFreeMask #xA); ;  * UTFlushCache options;  (defconstant $fcDefault 0)                      ;  default value - just flush any dirty buffers ; 	bits and masks (defconstant $fcTrashBit 1)                     ;  trash buffers after flushing (defconstant $fcTrashMask #x2)(defconstant $fcFreeBit 3)                      ;  free buffers after flushing (defconstant $fcFreeMask #x8)                   ;  fcFreeMask works as fcTrash on < System 7.0 RamCache ; ;  * UTCacheReadIP and UTCacheWriteIP cacheOption;  (defconstant $noCacheBit 5)                     ;  don't cache this please (defconstant $noCacheMask #x20)(defconstant $rdVerifyBit 6)                    ;  read verify (defconstant $rdVerifyMask #x40); ;  * Cache routine internal error codes;  (defconstant $chNoBuf 1)                        ;  no free cache buffers (all in use) (defconstant $chInUse 2)                        ;  requested block in use (defconstant $chnotfound 3)                     ;  requested block not found (defconstant $chNotInUse 4)                     ;  block being released was not in use ; ;  * FCBRec.fcbFlags bits;  (defconstant $fcbWriteBit 0)                    ;  Data can be written to this file (defconstant $fcbWriteMask #x1)(defconstant $fcbResourceBit 1)                 ;  This file is a resource fork (defconstant $fcbResourceMask #x2)(defconstant $fcbWriteLockedBit 2)              ;  File has a locked byte range (defconstant $fcbWriteLockedMask #x4)(defconstant $fcbSharedWriteBit 4)              ;  File is open for shared write access (defconstant $fcbSharedWriteMask #x10)(defconstant $fcbFileLockedBit 5)               ;  File is locked (write-protected) (defconstant $fcbFileLockedMask #x20)(defconstant $fcbOwnClumpBit 6)                 ;  File has clump size specified in FCB (defconstant $fcbOwnClumpMask #x40)(defconstant $fcbModifiedBit 7)                 ;  File has changed since it was last flushed (defconstant $fcbModifiedMask #x80); ;  * ExtFileProc options;  (defconstant $extendFileAllBit 0)               ;  allocate all requested bytes or none (defconstant $extendFileAllMask #x1)(defconstant $extendFileContigBit 1)            ;  force contiguous allocation (defconstant $extendFileContigMask #x2); ;  *	HFS Component Interface constants;  ; ;  * compInterfMask bits specific to HFS component;  (defconstant $hfsCIDoesHFSBit 23)               ;  set if file system supports HFS calls (defconstant $hfsCIDoesHFSMask #x800000)(defconstant $hfsCIDoesAppleShareBit 22)        ;  set if AppleShare calls supported (defconstant $hfsCIDoesAppleShareMask #x400000)(defconstant $hfsCIDoesDeskTopBit 21)           ;  set if Desktop Database calls supported (defconstant $hfsCIDoesDeskTopMask #x200000)(defconstant $hfsCIDoesDynamicLoadBit 20)       ;  set if dynamically loading code resource (defconstant $hfsCIDoesDynamicLoadMask #x100000); 		supported (defconstant $hfsCIResourceLoadedBit 19)        ;  set if code resource already loaded (defconstant $hfsCIResourceLoadedMask #x80000)(defconstant $hfsCIHasHLL2PProcBit 18)          ;  set if FFS' log2PhyProc and Extendfile proc (defconstant $hfsCIHasHLL2PProcMask #x40000)    ;  is written in a high level language. (i.e., uses Pascal calling convention) ; ;  *	Disk Initialization Component Interface constants;  ; ;  * compInterfMask bits specific to Disk Initialization component;  (defconstant $diCIHasExtFormatParamsBit 18)     ;  set if file system needs extended format (defconstant $diCIHasExtFormatParamsMask #x40000); 		parameters (defconstant $diCIHasMultiVolTypesBit 17)       ;  set if file system supports more than one (defconstant $diCIHasMultiVolTypesMask #x20000) ; 		volume type (defconstant $diCIDoesSparingBit 16)            ;  set if file system supports disk sparing (defconstant $diCIDoesSparingMask #x10000)(defconstant $diCILiveBit 0)                    ;  set if file system is candidate for current (defconstant $diCILiveMask #x1)                 ; 		formatting operation (set by PACK2) ; ;  * Disk Initialization Component Function selectors;  (defconstant $diCILoad 1)                       ;  Make initialization code memory resident (defconstant $diCIUnload 2)                     ;  Make initialization code purgeable (defconstant $diCIEvaluateSizeChoices 3)        ;  Evaluate size choices (defconstant $diCIExtendedZero 4)               ;  Write an empty volume directory (defconstant $diCIValidateVolName 5)            ;  Validate volume name (defconstant $diCIGetVolTypeInfo 6)             ;  get volume type info (defconstant $diCIGetFormatString 7)            ;  get dialog format string (defconstant $diCIGetExtFormatParams 8)         ;  get extended format parameters (defconstant $diCIGetDefectList 9)              ;  return the defect list for the indicated disk - reserved for future use ; ;  * Constants used in the DICIEvaluateSizeRec and FormatListRec;  (defconstant $diCIFmtListMax 8)                 ;  maximum number of format list entries in DICIEvaluateSizeRec.numSizeEntries ; 	bits in FormatListRec.formatFlags: (defconstant $diCIFmtFlagsValidBit 7)           ;  set if sec, side, tracks valid (defconstant $diCIFmtFlagsValidMask #x80)(defconstant $diCIFmtFlagsCurrentBit 6)         ;  set if current disk has this fmt (defconstant $diCIFmtFlagsCurrentMask #x40); 	bits in FormatListRec.sizeListFlags: (defconstant $diCISizeListOKBit 15)             ;  set if this disk size usable (defconstant $diCISizeListOKMask #x8000); ;  * DICIGetFormatStringRec.stringKind format strings;  (defconstant $diCIAlternateFormatStr 1)         ;  get alternate format  string (Balloon Help) (defconstant $diCISizePresentationStr 2)        ;  get size presentation string (for dialog) ; ;  * Error codes returned by Disk Sparing;  (defconstant $diCIUserCancelErr 1)              ;  user cancelled the disk init (defconstant $diCICriticalSectorBadErr 20)      ;  critical sectors are bad (hopeless)	(defconstant $diCISparingFailedErr 21)          ;  disk cannot be spared (defconstant $diCITooManyBadSectorsErr 22)      ;  too many bad sectors (defconstant $diCIUnknownVolTypeErr 23)         ;  the volume type passed in diCIExtendedZero paramBlock is not supported (defconstant $diCIVolSizeMismatchErr 24)        ;  specified volume size doesn’t match with formatted disk size (defconstant $diCIUnknownDICallErr 25)          ;  bogus DI function call selector (defconstant $diCINoSparingErr 26)              ;  disk is bad but the target FS doesn't do disk sparing (defconstant $diCINoExtendInfoErr 27)           ;  missing file system specific extra parameter in diCIExtendedZero call (defconstant $diCINoMessageTextErr 28)          ;  missing message text in DIReformat call ; ;  *	File System Manager constants;  ; ;  * Miscellaneous constants used by FSM;  (defconstant $fsdVersion1 1)                    ;  current version of FSD record (defconstant $fsmIgnoreFSID #xFFFE)             ;  this FSID should be ignored by the driver (defconstant $fsmGenericFSID #xFFFF)            ;  unknown foreign file system ID ; ;  * compInterfMask bits common to all FSM components;  (defconstant $fsmComponentEnableBit 31)         ;  set if FSM component interface is enabled (defconstant $fsmComponentEnableMask #x80000000)(defconstant $fsmComponentBusyBit 30)           ;  set if FSM component interface is busy (defconstant $fsmComponentBusyMask #x40000000); ;  * Selectors for GetFSInfo;  (defconstant $fsmGetFSInfoByIndex -1)           ;  get fs info by index (defconstant $fsmGetFSInfoByFSID 0)             ;  get fs info by FSID (defconstant $fsmGetFSInfoByRefNum 1)           ;  get fs info by file/vol refnum ; ;  * InformFSM messages;  (defconstant $fsmNopMessage 0)                  ;  nop (defconstant $fsmDrvQElChangedMessage 1)        ;  DQE has changed (defconstant $fsmGetFSIconMessage 2)            ;  Get FFS's disk icon ; ;  * Messages passed to the fileSystemCommProc;  (defconstant $ffsNopMessage 0)                  ;  nop, should always return noErr (defconstant $ffsGetIconMessage 1)              ;  return disk icon and mask (defconstant $ffsIDDiskMessage 2)               ;  identify the about-to-be-mounted volume (defconstant $ffsLoadMessage 3)                 ;  load in the FFS (defconstant $ffsUnloadMessage 4)               ;  unload the FFS (defconstant $ffsIDVolMountMessage 5)           ;  identify a VolMountInfo record (defconstant $ffsInformMessage 6)               ;  FFS defined message (defconstant $ffsGetIconInfoMessage 7); ;  * Error codes from FSM functions;  (defconstant $fsmFFSNotFoundErr -431)           ;  Foreign File system does not exist - new Pack2 could return this error too (defconstant $fsmBusyFFSErr -432)               ;  File system is busy, cannot be removed (defconstant $fsmBadFFSNameErr -433)            ;  Name length not 1 <= length <= 31 (defconstant $fsmBadFSDLenErr -434)             ;  FSD size incompatible with current FSM vers (defconstant $fsmDuplicateFSIDErr -435)         ;  FSID already exists on InstallFS (defconstant $fsmBadFSDVersionErr -436)         ;  FSM version incompatible with FSD (defconstant $fsmNoAlternateStackErr -437)      ;  no alternate stack for HFS CI (defconstant $fsmUnknownFSMMessageErr -438)     ;  unknown message passed to FSM ; ;  *	HFS Utility routine records;  ; ;  * record used by UTGetPathComponentName;  (defrecord ParsePathRec    (namePtr (:pointer (:string 255)))           ;  pathname to parse    (startOffset :signed-integer)                ;  where to start parsing    (componentLength :signed-integer)            ;  the length of the pathname component parsed    (moreName :signed-byte)                      ;  non-zero if there are more components after this one    (foundDelimiter :signed-byte)                ;  non-zero if parsing stopped because a colon (:) delimiter was found    )(def-mactype :parsepathrecptr (find-mactype '(:pointer :parsepathrec)))(defrecord WDCBRec    (wdVCBPtr (:pointer :vcb))                   ;  Pointer to VCB of this working directory    (wdDirID :signed-long)                       ;  Directory ID number of this working directory    (wdCatHint :signed-long)                     ;  Hint for finding this working directory    (wdProcID :signed-long)                      ;  Process that created this working directory    )(def-mactype :wdcbrecptr (find-mactype '(:pointer :wdcbrec)))(defrecord FCBRec    ;;Changing field fcbflnm from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbFlNm :unsigned-long)                     ;  FCB file number. Non-zero marks FCB used    (fcbFlags :signed-byte)                      ;  FCB flags    (fcbTypByt :signed-byte)                     ;  File type byte    ;;Changing field fcbsblk from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (fcbSBlk :unsigned-word)                     ;  File start block (in alloc size blks)    ;;Changing field fcbeof from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbEOF :unsigned-long)                      ;  Logical length or EOF in bytes    ;;Changing field fcbplen from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbPLen :unsigned-long)                     ;  Physical file length in bytes    ;;Changing field fcbcrps from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbCrPs :unsigned-long)                     ;  Current position within file    (fcbVPtr (:pointer :vcb))                    ;  Pointer to the corresponding VCB    (fcbBfAdr :pointer)                          ;  File's buffer address    ;;Changing field fcbflpos from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (fcbFlPos :unsigned-word)                    ;  Directory block this file is in ;  FCB Extensions for HFS    ;;Changing field fcbclmpsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbClmpSize :unsigned-long)                 ;  Number of bytes per clump    (fcbBTCBPtr :pointer)                        ;  Pointer to B*-Tree control block for file    ;;Changing field fcbextrec from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbExtRec (:array :unsigned-long 3))        ;  First 3 file extents    (fcbFType :ostype)                           ;  File's 4 Finder Type bytes    ;;Changing field fcbcatpos from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbCatPos :unsigned-long)                   ;  Catalog hint for use on Close    ;;Changing field fcbdirid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (fcbDirID :unsigned-long)                    ;  Parent Directory ID    (fcbCName (:string 31))                      ;  CName of open file    )(def-mactype :fcbrecptr (find-mactype '(:pointer :fcbrec))); ;  *	HFS Component Interface records;  (def-mactype :lg2physprocptr (find-mactype ':pointer));  FUNCTION Lg2Phys(fsdGlobalPtr: UNIV Ptr; volCtrlBlockPtr: VCBPtr; fileCtrlBlockPtr: FCBRecPtr; fileRefNum: INTEGER; filePosition: LONGINT; reqCount: LONGINT; VAR volOffset: LONGINT; VAR contiguousBytes: LONGINT): OSErr; (def-mactype :lg2physupp (find-mactype ':pointer))(defconstant $uppLg2PhysProcInfo #x3FEFE0)      ;  FUNCTION (4 byte param, 4 byte param, 4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewLg2PhysProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallLg2PhysProc" ((fsdGlobalPtr :pointer) (volCtrlBlockPtr (:pointer :vcb)) (fileCtrlBlockPtr (:pointer :fcbrec)) (fileRefNum :signed-integer) (filePosition :signed-long) (reqCount :signed-long) (volOffset (:pointer :signed-long)) (contiguousBytes (:pointer :signed-long)) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(def-mactype :hfsciprocptr (find-mactype ':pointer));  FUNCTION HFSCI(theVCB: VCBPtr; selectCode: INTEGER; paramBlock: UNIV Ptr; fsdGlobalPtr: UNIV Ptr; fsid: INTEGER): OSErr; (def-mactype :hfsciupp (find-mactype ':pointer))(defconstant $uppHFSCIProcInfo #xBEE0)          ;  FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param, 2 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewHFSCIProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallHFSCIProc" ((theVCB (:pointer :vcb)) (selectCode :signed-integer) (paramBlock :pointer) (fsdGlobalPtr :pointer) (fsid :signed-integer) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(defrecord HFSCIRec    (compInterfMask :signed-long)                ;  component flags    (compInterfProc :pointer)                    ;  pointer to file system call processing code    (log2PhyProc :pointer)                       ;  pointer to Lg2PhysProc() code    (stackTop :pointer)                          ;  file system stack top    (stackSize :signed-long)                     ;  file system stack size    (stackPtr :pointer)                          ;  current file system stack pointer    (reserved3 :signed-long)                     ;  --reserved, must be zero--    (idSector :signed-long)                      ;  Sector you need to ID a local volume. For networked volumes, this must be -1    (reserved2 :signed-long)                     ;  --reserved, must be zero--    (reserved1 :signed-long)                     ;  --reserved, must be zero--    )(def-mactype :hfscirecptr (find-mactype '(:pointer :hfscirec))); ;  *	Disk Initialization Component Interface records;  (def-mactype :diciprocptr (find-mactype ':pointer));  FUNCTION DICI(whatFunction: INTEGER; paramBlock: UNIV Ptr; fsdGlobalPtr: UNIV Ptr): OSErr; (def-mactype :diciupp (find-mactype ':pointer))(defconstant $uppDICIProcInfo #xFA0)            ;  FUNCTION (2 byte param, 4 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewDICIProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallDICIProc" ((whatFunction :signed-integer) (paramBlock :pointer) (fsdGlobalPtr :pointer) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(defrecord DICIRec    (compInterfMask :signed-long)                ;  component flags    (compInterfProc :pointer)                    ;  pointer to call processing code    (maxVolNameLength :signed-integer)           ;  maximum length of your volume name    ;;Changing field blocksize from signed-integer to unsigned-word to match C header (pretty-sure)   (blockSize :unsigned-word)                   ;  your file system's block size    (reserved3 :signed-long)                     ;  --reserved, must be zero--    (reserved2 :signed-long)                     ;  --reserved, must be zero--    (reserved1 :signed-long)                     ;  --reserved, must be zero--    )(def-mactype :dicirecptr (find-mactype '(:pointer :dicirec))); ;  * FormatListRec as returned by the .Sony disk driver's;  * Return Format List status call (csCode = 6).;  * If the status call to get this list for a drive is not;  * implemented by the driver, then a list with one entry;  * is contructed from the drive queue element for the drive.;  (defrecord FormatListRec    ;;Changing field volsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (volSize :unsigned-long)                     ;  disk capacity in SECTORs    (formatFlags :signed-byte)                   ;  flags    (sectorsPerTrack :signed-byte)               ;  sectors per track side    ;;Changing field tracks from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (tracks :unsigned-word)                      ;  number of tracks    )(def-mactype :formatlistrecptr (find-mactype '(:pointer :formatlistrec))); ;  * SizeListRec built from FormatListRecs as described above.;  (defrecord SizeListRec    (sizeListFlags :signed-integer)              ;  flags as set by external file system    (sizeEntry :formatlistrec)                   ;  disk driver format list record    )(def-mactype :sizelistrecptr (find-mactype '(:pointer :sizelistrec))); ;  * paramBlock for the diCIEvaluateSize call;  (defrecord DICIEvaluateSizeRec    (defaultSizeIndex :signed-integer)           ;  default size for this FS    (numSizeEntries :signed-integer)             ;  number of size entries    (driveNumber :signed-integer)                ;  drive number    (sizeListPtr (:pointer :sizelistrec))        ;  ptr to size entry table    ;;Changing field sectorsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (sectorSize :unsigned-word)                  ;  bytes per sector    )(def-mactype :dicievaluatesizerecptr (find-mactype '(:pointer :dicievaluatesizerec))); ;  * paramBlock for the diCIExtendedZero call;  (defrecord DICIExtendedZeroRec    (driveNumber :signed-integer)                ;  drive number    (volNamePtr (:pointer (:string 255)))        ;  ptr to volume name string    (fsid :signed-integer)                       ;  file system ID    (volTypeSelector :signed-integer)            ;  volume type selector, if supports more than 1 type    ;;Changing field numdefectblocks from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (numDefectBlocks :unsigned-word)             ;  number of bad logical blocks    ;;Changing field defectlistsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (defectListSize :unsigned-word)              ;  size of the defect list buffer in bytes    (defectListPtr :pointer)                     ;  pointer to defect list buffer    ;;Changing field volsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (volSize :unsigned-long)                     ;  size of volume in SECTORs    ;;Changing field sectorsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (sectorSize :unsigned-word)                  ;  bytes per sector    (extendedInfoPtr :pointer)                   ;  ptr to extended info    )(def-mactype :diciextendedzerorecptr (find-mactype '(:pointer :diciextendedzerorec))); ;  * paramBlock for the diCIValidateVolName call;  (defrecord DICIValidateVolNameRec    (theChar :character)                         ;  the character to validate    (hasMessageBuffer :boolean)                  ;  false if no message    (charOffset :signed-integer)                 ;  position of the current character (first char = 1)    (messageBufferPtr (:pointer (:string 255)))  ;  pointer to message buffer or nil    (charByteType :signed-integer)               ;  theChar's byte type (smSingleByte, smFirstByte, or smLastByte)    )(def-mactype :dicivalidatevolnamerecptr (find-mactype '(:pointer :dicivalidatevolnamerec))); ;  * paramBlock for the diCIGetVolTypeInfo call;  (defrecord DICIGetVolTypeInfoRec    ;;Changing field volsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (volSize :unsigned-long)                     ;  size of volume in SECTORs    ;;Changing field sectorsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (sectorSize :unsigned-word)                  ;  bytes per sector    (numVolTypes :signed-integer)                ;  number of volume types supported    (volTypesBuffer (:array (:string 31) 4))     ;  4 string buffers    )(def-mactype :dicigetvoltypeinforecptr (find-mactype '(:pointer :dicigetvoltypeinforec))); ;  * paramBlock for the diCIGetFormatString call;  (defrecord DICIGetFormatStringRec    ;;Changing field volsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (volSize :unsigned-long)                     ;  volume size in SECTORs    ;;Changing field sectorsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (sectorSize :unsigned-word)                  ;  sector size    (volTypeSelector :signed-integer)            ;  volume type selector    (stringKind :signed-integer)                 ;  sub-function = type of string    (stringBuffer (:string 255))                 ;  string buffer    )(def-mactype :dicigetformatstringrecptr (find-mactype '(:pointer :dicigetformatstringrec))); ;  * paramBlock for the diCIGetExtendedFormatParams call;  (defrecord DICIGetExtendedFormatRec    (driveNumber :signed-integer)                ;  drive number    (volTypeSelector :signed-integer)            ;  volume type selector or 0    ;;Changing field volsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (volSize :unsigned-long)                     ;  size of volume in SECTORs    ;;Changing field sectorsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (sectorSize :unsigned-word)                  ;  bytes per sector    (fileSystemSpecPtr (:pointer :fsspec))       ;  pointer to the foreign file system's FSSpec    (extendedInfoPtr :pointer)                   ;  pointer to extended parameter structure    )(def-mactype :dicigetextendedformatrecptr (find-mactype '(:pointer :dicigetextendedformatrec))); ;  *	File System Manager records;  (def-mactype :fsdcommprocptr (find-mactype ':pointer));  FUNCTION FSDComm(message: INTEGER; paramBlock: UNIV Ptr; globalsPtr: UNIV Ptr): OSErr; (def-mactype :fsdcommupp (find-mactype ':pointer))(defconstant $uppFSDCommProcInfo #xFA0)         ;  FUNCTION (2 byte param, 4 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewFSDCommProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallFSDCommProc" ((message :signed-integer) (paramBlock :pointer) (globalsPtr :pointer) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(defrecord FSDRec    (fsdLink (:pointer :fsdrec))                 ;  ptr to next    (fsdLength :signed-integer)                  ;  length of this FSD in BYTES    (fsdVersion :signed-integer)                 ;  version number    (fileSystemFSID :signed-integer)             ;  file system id    (fileSystemName (:string 31))                ;  file system name    (fileSystemSpec :fsspec)                     ;  foreign file system's FSSpec    (fileSystemGlobalsPtr :pointer)              ;  ptr to file system globals    (fileSystemCommProc :pointer)                ;  communication proc with the FFS    (reserved3 :signed-long)                     ;  --reserved, must be zero--    (reserved2 :signed-long)                     ;  --reserved, must be zero--    (reserved1 :signed-long)                     ;  --reserved, must be zero--    (fsdHFSCI :hfscirec)                         ;  HFS component interface       (fsdDICI :dicirec)                           ;  Disk Initialization component interface    )(def-mactype :fsdrecptr (find-mactype '(:pointer :fsdrec)))(defrecord FSMGetIconInfoRec    (theIcon (:array :signed-long 32))           ;  The ICN# structure    (theMask (:array :signed-long 32))           ;  The mask for the icon above    (whereStr (:string 255))   )(def-mactype :fsmgeticoninforecptr (find-mactype '(:pointer :fsmgeticoninforec))); ;  * paramBlock for ffsGetIconMessage and fsmGetFSIconMessage;  (defrecord FSMGetIconRec    (refNum :signed-integer)                     ;  target drive num or volume refnum    (iconBufferPtr (:pointer :fsmgeticoninforec));  pointer to icon buffer    (requestSize :signed-long)                   ;  requested size of the icon buffer    (actualSize :signed-long)                    ;  actual size of the icon data returned    (iconType :signed-byte)                      ;  kind of icon    (isEjectable :boolean)                       ;  true if the device is ejectable    (driveQElemPtr (:pointer :drvqel))           ;  pointer to DQE    (fileSystemSpecPtr (:pointer :fsspec))       ;  pointer to foreign file system's FSSpec    (reserved1 :signed-long)                     ;  --reserved, must be zero--    )(def-mactype :fsmgeticonrecptr (find-mactype '(:pointer :fsmgeticonrec))); ;  *	HFS Utility routine prototypes;  ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTAllocateFCB" ((fileRefNum (:pointer :signed-integer)) (fileCtrlBlockPtr (:pointer (:pointer :fcbrec))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 0 fileRefNum fileCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTReleaseFCB" ((fileRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 1 fileRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTLocateFCB" ((volCtrlBlockPtr (:pointer :vcb)) (fileNum :signed-long) (namePtr (:pointer (:string 255))) (fileRefNum (:pointer :signed-integer)) (fileCtrlBlockPtr (:pointer (:pointer :fcbrec))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 2 volCtrlBlockPtr fileNum namePtr fileRefNum fileCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTLocateNextFCB" ((volCtrlBlockPtr (:pointer :vcb)) (fileNum :signed-long) (namePtr (:pointer (:string 255))) (fileRefNum (:pointer :signed-integer)) (fileCtrlBlockPtr (:pointer (:pointer :fcbrec))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 3 volCtrlBlockPtr fileNum namePtr fileRefNum fileCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTIndexFCB" ((volCtrlBlockPtr (:pointer :vcb)) (fileRefNum (:pointer :signed-integer)) (fileCtrlBlockPtr (:pointer (:pointer :fcbrec))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 4 volCtrlBlockPtr fileRefNum fileCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTResolveFCB" ((fileRefNum :signed-integer) (fileCtrlBlockPtr (:pointer (:pointer :fcbrec))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 5 fileRefNum fileCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTAllocateVCB" ((sysVCBLength (:pointer :signed-integer)) (volCtrlBlockPtr (:pointer (:pointer :vcb))) (addSize :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 6 sysVCBLength volCtrlBlockPtr addSize)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTAddNewVCB" ((driveNum :signed-integer) (vRefNum (:pointer :signed-integer)) (volCtrlBlockPtr (:pointer :vcb)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 7 driveNum vRefNum volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTDisposeVCB" ((volCtrlBlockPtr (:pointer :vcb)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 8 volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTLocateVCBByRefNum" ((refNum :signed-integer) (vRefNum (:pointer :signed-integer)) (volCtrlBlockPtr (:pointer (:pointer :vcb))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 9 refNum vRefNum volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTLocateVCBByName" ((namePtr (:pointer (:string 255))) (moreMatches (:pointer :signed-integer)) (vRefNum (:pointer :signed-integer)) (volCtrlBlockPtr (:pointer (:pointer :vcb))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 10 namePtr moreMatches vRefNum volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTLocateNextVCB" ((namePtr (:pointer (:string 255))) (moreMatches (:pointer :signed-integer)) (vRefNum (:pointer :signed-integer)) (volCtrlBlockPtr (:pointer (:pointer :vcb))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 11 namePtr moreMatches vRefNum volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTAllocateWDCB" ((paramBlock (:pointer :wdpbrec)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 12 paramBlock)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTReleaseWDCB" ((wdRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 13 wdRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTResolveWDCB" ((procID :signed-long) (wdIndex :signed-integer) (wdRefNum :signed-integer) (wdCtrlBlockPtr (:pointer (:pointer :wdcbrec))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 14 procID wdIndex wdRefNum wdCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTFindDrive" ((driveNum :signed-integer) (driveQElementPtr (:pointer (:pointer :drvqel))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 15 driveNum driveQElementPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTAdjustEOF" ((fileRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 16 fileRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTSetDefaultVol" ((nodeHint :signed-long) (dirID :signed-long) (refNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 17 nodeHint dirID refNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTGetDefaultVol" ((paramBlock (:pointer :wdpbrec)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 18 paramBlock)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTEjectVol" ((volCtrlBlockPtr (:pointer :vcb)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 43 volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckWDRefNum" ((wdRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 19 wdRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckFileRefNum" ((fileRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 20 fileRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckVolRefNum" ((vRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 21 vRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckPermission" ((volCtrlBlockPtr (:pointer :vcb)) (modByte (:pointer :signed-integer)) (fileNum :signed-long) (paramBlock (:pointer :paramblockrec)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 22 volCtrlBlockPtr modByte fileNum paramBlock)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckVolOffline" ((vRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 23 vRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckVolModifiable" ((vRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 24 vRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckFileModifiable" ((fileRefNum :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 25 fileRefNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCheckDirBusy" ((volCtrlBlockPtr (:pointer :vcb)) (dirID :signed-long))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 26 volCtrlBlockPtr dirID)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTParsePathname" ((volNamelength (:pointer :signed-integer)) (namePtr (:pointer (:string 255))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 27 volNamelength namePtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTGetPathComponentName" ((parseRec (:pointer :parsepathrec)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 28 parseRec)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTDetermineVol" ((paramBlock (:pointer :paramblockrec)) (status (:pointer :signed-integer)) (moreMatches (:pointer :signed-integer)) (vRefNum (:pointer :signed-integer)) (volCtrlBlockPtr (:pointer (:pointer :vcb))))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 29 paramBlock status moreMatches vRefNum volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTGetBlock" ((refNum :signed-integer) (log2PhyProc :pointer) (blockNum :signed-long) (gbOption :signed-integer) (buffer (:pointer :pointer)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 31 refNum log2PhyProc blockNum gbOption buffer)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTReleaseBlock" ((buffer :pointer) (rbOption :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 32 buffer rbOption)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTFlushCache" ((refNum :signed-integer) (fcOption :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 33 refNum fcOption)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTMarkDirty" ((buffer :pointer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 35 buffer)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTTrashVolBlocks" ((volCtrlBlockPtr (:pointer :vcb)))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 36 volCtrlBlockPtr)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTTrashFileBlocks" ((volCtrlBlockPtr (:pointer :vcb)) (fileNum :signed-long))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 37 volCtrlBlockPtr fileNum)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTTrashBlocks" ((beginPosition :signed-long) (byteCount :signed-long) (volCtrlBlockPtr (:pointer :vcb)) (fileRefNum :signed-integer) (tbOption :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 38 beginPosition byteCount volCtrlBlockPtr fileRefNum tbOption)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCacheReadIP" ((log2PhyProc :pointer) (filePosition :signed-long) (ioBuffer :pointer) (fileRefNum :signed-integer) (reqCount :signed-long) (actCount (:pointer :signed-long)) (cacheOption :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 39 log2PhyProc filePosition ioBuffer fileRefNum reqCount actCount cacheOption)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTCacheWriteIP" ((log2PhyProc :pointer) (filePosition :signed-long) (ioBuffer :pointer) (fileRefNum :signed-integer) (reqCount :signed-long) (actCount (:pointer :signed-long)) (cacheOption :signed-integer))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 40 log2PhyProc filePosition ioBuffer fileRefNum reqCount actCount cacheOption)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_UTBlockInFQHashP" ((vRefNum :signed-integer) (diskBlock :signed-long))   (:stack :signed-integer)   (:stack-trap #xA824 :d0 44 vRefNum diskBlock)); $ENDC; ;  *	File System Manager call prototypes;  ;; Warning: No calling method defined for this trap(deftrap-inline "_InstallFS" ((fsdPtr (:pointer :fsdrec)))   :signed-integer   () );; Warning: No calling method defined for this trap(deftrap-inline "_RemoveFS" ((fsid :signed-integer))   :signed-integer   () );; Warning: No calling method defined for this trap(deftrap-inline "_SetFSInfo" ((fsid :signed-integer) (bufSize :signed-integer) (fsdPtr (:pointer :fsdrec)))   :signed-integer   () );; Warning: No calling method defined for this trap(deftrap-inline "_GetFSInfo" ((selector :signed-integer) (key :signed-integer) (bufSize (:pointer :signed-integer)) (fsdPtr (:pointer :fsdrec)))   :signed-integer   () );; Warning: No calling method defined for this trap(deftrap-inline "_InformFSM" ((theMessage :signed-integer) (paramBlock :pointer))   :signed-integer   () )                                         ; $ALIGN RESET; $POP; $SETC UsingIncludes := FSMIncludes; $ENDC; __FSM__; $IFC NOT UsingIncludes;; Warning: No calling method defined for this trap(deftrap-inline "_InformFFS" ((fsid :signed-integer) (paramBlock :pointer))   :signed-integer   () ); $ENDC(provide-interface 'FSM)