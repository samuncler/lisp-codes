(in-package :TRAPS); Generated from #P"HD:CCL3.0d17:Interface Translator:Source interfaces:Pascal Interfaces:Translation.p"; at Tuesday June 6,1995 2:22:58 pm.; ;  	File:		Translation.p;  ;  	Contains:	Translation Manager (Macintosh Easy Open) Interfaces.;  ;  	Version:	Technology:	Macintosh Easy Open 1.1;  				Package:	Universal Interfaces 2.0 in “MPW Latest” on ETO #17;  ;  	Copyright:	© 1984-1995 by Apple Computer, Inc.;  				All rights reserved.;  ;  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter;  				stack.  Include the file and version information (from above);  				in the problem description and send to:;  					Internet:	apple.bugs@applelink.apple.com;  					AppleLink:	APPLE.BUGS;  ; #|                                              ; $IFC UNDEFINED UsingIncludes; $SETC UsingIncludes := 0 |#                                             ; $ENDC; $IFC NOT UsingIncludes; $ENDC; $IFC UNDEFINED __TRANSLATION__; $SETC __TRANSLATION__ := 1; $I+; $SETC TranslationIncludes := UsingIncludes; $SETC UsingIncludes := 1#|                                              ; $IFC UNDEFINED __TYPES__|#(require-interface 'Types)#|                                              ; $I Types.p |#                                             ; $ENDC; 	ConditionalMacros.p											#|                                              ; $IFC UNDEFINED __FILES__|#(require-interface 'Files)#|                                              ; $I Files.p |#                                             ; $ENDC; 	MixedMode.p													; 	OSUtils.p													; 		Memory.p												#|                                              ; $IFC UNDEFINED __COMPONENTS__|#(require-interface 'Components)#|                                              ; $I Components.p |#                                             ; $ENDC; $IFC UNDEFINED __TRANSLATIONEXTENSIONS__(require-interface 'TranslationExtensions)      ; $I TranslationExtensions.p; $ENDC; 	Quickdraw.p													; 		QuickdrawText.p											; $PUSH; $ALIGN MAC68K; $LibExport+(def-mactype :docopenmethod (find-mactype ':signed-integer))(defconstant $domCannot 0)(defconstant $domNative 1)(defconstant $domTranslateFirst 2)(defconstant $domWildcard 3);  0L terminated array of OSTypes, or FileTypes(defrecord TypesBlock (array (array :ostype 64)))(def-mactype :typesblockptr (find-mactype '(:pointer :ostype)));  Progress dialog resource ID(defconstant $kTranslationScrapProgressDialogID -16555);  block of data that describes how to translate(defrecord FileTranslationSpec    (componentSignature :ostype)   (translationSystemInfo :pointer)   (src :filetypespec)   (dst :filetypespec)   )(def-mactype :filetranslationspecarrayptr (find-mactype '(:pointer :filetranslationspec))); ****************************************************************************************; * ; *   GetFileTypesThatAppCanNativelyOpen; * ; *  This routine returns a list of all FileTypes that an application can open by itself; * ; *  Enter:	appVRefNumHint		volume where application resides (can be wrong, and if is, will be used as a starting point); * 			appSignature		signature (creator) of application; * 			nativeTypes			pointer to a buffer to be filled with up to 64 FileTypes; * ; *  Exit:	nativeTypes			zero terminated array of FileTypes that can be opened by app; ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_GetFileTypesThatAppCanNativelyOpen" ((appVRefNumHint :signed-integer) (appSignature :ostype) (nativeTypes (:pointer :ostype)))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 28 appVRefNumHint appSignature nativeTypes)); $ENDC; ****************************************************************************************; * ; *  ExtendFileTypeList; * ; *  This routine makes a new list of file types that can be translated into a type in the given list; *  Used by StandardFile; * ; *  Enter:	originalTypeList		pointer to list of file types that can be opened; * 			numberOriginalTypes		number of file types in orgTypeList; *  			extendedTypeList		pointer to a buffer to be filled with file types; * 			numberExtendedTypes		max number of file types that can be put in extendedTypeList; * ; *  Exit:	extendedTypeList		buffer filled in with file types that can be translated; * 			numberExtendedTypes		number of file types put in extendedTypeList; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_ExtendFileTypeList" ((originalTypeList (:pointer :ostype)) (numberOriginalTypes :signed-integer) (extendedTypeList (:pointer :ostype)) (numberExtendedTypes (:pointer :signed-integer)))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 9 originalTypeList numberOriginalTypes extendedTypeList numberExtendedTypes)); $ENDC; ****************************************************************************************; * ; * ; *  This routine checks if a file can be opened by a particular application.; *  If so, it returns if it needs to be translated first, and if so then how.; *  The FileTypes that the app can open are specified by nativelyOpenableTypes,; *  or if it is NULL, GetFileTypesThatAppCanNativelyOpen is called.; * ; *  Enter:	targetDocument		document to check if it can be opened; * 			appVRefNumHint		vRefNum of application to open doc ( can be wrong, and if is, will be used as a starting point); * 			appSignature		signature (creator) of application to open doc; * 			nativeTypes			zero terminated list of FileTypes app can open natively, or NULL to use default list; * 			onlyNative			whether to consider if document can be translated before opening; * 			howToOpen			pointer to buffer in which to put how the document can be opened; * 			howToTranslate		pointer to buffer in which to put a FileTranslationSpec record; * ; *  Exit:	howToOpen			whether file needs to be translated to be read; * 			howToTranslate		if file can be translated, buffer filled in with how to translate; * 			returns				noErr, noPrefAppErr; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_CanDocBeOpened" ((targetDocument (:pointer :fsspec)) (appVRefNumHint :signed-integer) (appSignature :ostype) (nativeTypes (:pointer :ostype)) (onlyNative :boolean) (howToOpen (:pointer :signed-integer)) (howToTranslate (:pointer :filetranslationspec)))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 30 targetDocument appVRefNumHint appSignature nativeTypes onlyNative howToOpen howToTranslate)); $ENDC; ****************************************************************************************; * ; *  GetFileTranslationPaths; * ; *  This routine returns a list of all ways a translation can occure to or from a FileType.; *  The app is checked to exist.  The hint for each app is the VRefNum and DTRefNum; * ; *  Enter:	srcDoc			source file or NULL for all matches; * 			dstDoc			destination FileType or NULL for all matches; * 			maxResultCount; * 			resultBuffer; *  Exit:	number of paths; ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_GetFileTranslationPaths" ((srcDocument (:pointer :fsspec)) (dstDocType :ostype) (maxResultCount :signed-integer) (resultBuffer (:pointer :filetranslationspec)))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 56 srcDocument dstDocType maxResultCount resultBuffer)); $ENDC; ****************************************************************************************; * ; *  GetPathFromTranslationDialog; * ; *  This routine, with a given document, application, and a passed typelist will display the; *  Macintosh Easy Open translation dialog allowing the user to make a choice.  The choice; *  made will be written as a preference (so the next call to CanDocBeOpened() will work).; *  The routine returns the translation path information.; * ; *  Enter:	theDocument			FSSpec to document to open; * 			theApplication		FSSpec to application to open document; * 			typeList			Nil terminated list of FileType's (e.g. SFTypeList-like) of types; * 								you would like the documented translated to.  Order most perferred; * 								to least.; * ; *  Exit:	howToOpen			Translation method needed to open document; * 			howToTranslate		Translation specification; * 			returns				Any errors that might occur.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_GetPathFromTranslationDialog" ((theDocument (:pointer :fsspec)) (theApplication (:pointer :fsspec)) (typeList (:pointer :ostype)) (howToOpen (:pointer :signed-integer)) (howToTranslate (:pointer :filetranslationspec)))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 55 theDocument theApplication typeList howToOpen howToTranslate)); $ENDC; ****************************************************************************************; * ; *   TranslateFile; * ; *  This routine reads a file of one format and writes it to another file in another format. ; *  The information on how to translated is generated by the routine CanDocBeOpened.; *  TranslateFile calls through to the TranslateFile Extension's DoTranslateFile routine.  ; *  The destination file must not exist.  It is created by this routine.  ; * ; *  Enter:	sourceDocument			input file to translate; * 			destinationDocument		output file of translation; * 			howToTranslate			pointer to info on how to translate; *  Exit:	returns					noErr, badTranslationSpecErr ; ; CONST                                         ; CONST; CONST; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_TranslateFile" ((sourceDocument (:pointer :fsspec)) (destinationDocument (:pointer :fsspec)) (howToTranslate (:pointer :filetranslationspec)))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 12 sourceDocument destinationDocument howToTranslate)); $ENDC; ****************************************************************************************; * ; *   GetDocumentKindString; * ; *  This routine returns the string the Finder should show for the "kind" of a document; *  in the GetInfo window and in the kind column of a list view.  ; * ; *  Enter:	docVRefNum		The volume containing the document; * 			docType			The catInfo.fdType of the document; * 			docCreator		The catInfo.fdCreator of the document; * 			kindString		pointer to where to return the string; * ; *  Exit:	kindString		pascal string.  Ex: "\pSurfCalc spreadsheet"; * 			returns			noErr, or afpItemNoFound if kind could not be determined; ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_GetDocumentKindString" ((docVRefNum :signed-integer) (docType :ostype) (docCreator :ostype) (kindString (:pointer (:string 63))))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 22 docVRefNum docType docCreator kindString)); $ENDC; ****************************************************************************************; * ; *  GetTranslationExtensionName; * ; *  This routine returns the translation system name from a specified TranslationSpec; * ; *  Enter:	translationMethod	The translation path to get the translation name from; * ; *  Exit:	extensionName		The name of the translation system; * 			returns				Any errors that might occur; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_GetTranslationExtensionName" ((translationMethod (:pointer :filetranslationspec)) (extensionName (:pointer (:string 31))))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 54 translationMethod extensionName)); $ENDC; ****************************************************************************************; * ; *  GetScrapDataProcPtr; * ; *  This is a prototype for the function you must supply to TranslateScrap. It is called to ; *  get the data to be translated.  The first call TranslateScrap will make to this is to; *  ask for the 'fmts' data.  That is a special.   You should resize and fill in the handle; *  with a list all the formats that you have available to be translated, and the length of each.; *  (See I.M. VI 4-23 for details of 'fmts').  It will then be called again asking for one of  ; *  the formats that 'fmts' list said was available.; * ; *  Enter:	requestedFormat			Format of data that TranslateScrap needs.; * 			dataH					Handle in which to put the requested data; * 			srcDataGetterRefCon		Extra parameter for you passed to TranslateScrap; * 			; *  Exit:	dataH					Handle is resized and filled with data in requested format; (def-mactype :getscrapdataprocptr (find-mactype ':pointer));  FUNCTION GetScrapData(requestedFormat: ScrapType; dataH: Handle; srcDataGetterRefCon: UNIV Ptr): OSErr; (def-mactype :getscrapdataupp (find-mactype ':pointer))(defconstant $uppGetScrapDataProcInfo #xFE0)    ;  FUNCTION (4 byte param, 4 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap "_NewGetScrapDataProc" ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline "_CallGetScrapDataProc" ((requestedFormat :ostype) (dataH :handle) (srcDataGetterRefCon :pointer) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(def-mactype :getscrapdata (find-mactype ':pointer)); ****************************************************************************************; * ; *  TranslateScrap; * ; *  This routine resizes the destination handle and fills it with data of the requested format.; *  The data is generated by translated one or more source formats of data supplied by; *  the procedure srcDataGetter.  ; *  This routine is automatically called by GetScrap and ReadEdition.  You only need to call; *  this if you need to translated scrap style data, but are not using the ScrapMgr or EditionMgr.; * ; *  Enter:	sourceDataGetter			Pointer to routine that can get src data; * 			sourceDataGetterRefCon		Extra parameter for dataGetter; * 			destinationFormat			Format of data desired; * 			destinationData				Handle in which to store translated data; * 			; *  Exit:	dstData						Handle is resized and filled with data in requested format; ; $IFC NOT GENERATINGCFM;; Generated by translator moveq-word-to-d0(deftrap "_TranslateScrap" ((sourceDataGetter :pointer) (sourceDataGetterRefCon :pointer) (destinationFormat :ostype) (destinationData :handle) (progressDialogID :signed-integer))   (:stack :signed-integer)   (:stack-trap #xABFC :d0 14 sourceDataGetter sourceDataGetterRefCon destinationFormat destinationData progressDialogID)); $ENDC; $ALIGN RESET; $POP; $SETC UsingIncludes := TranslationIncludes; $ENDC                                         ; __TRANSLATION__; $IFC NOT UsingIncludes; $ENDC(provide-interface 'Translation)