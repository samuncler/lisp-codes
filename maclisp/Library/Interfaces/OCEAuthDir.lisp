(in-package :TRAPS); Generated from #P"HD:CCL3.0d17:Interface Translator:Source interfaces:Pascal Interfaces:OCEAuthDir.p"; at Tuesday June 6,1995 2:03:08 pm.; ;  	File:		OCEAuthDir.p;  ;  	Contains:	Apple Open Collaboration Environment Authentication Interfaces.;  ;  	Version:	Technology:	AOCE Toolbox 1.02;  				Package:	Universal Interfaces 2.1§1 in ÒMPW PrereleaseÓ on ETO #17;  ;  	Copyright:	© 1984-1995 by Apple Computer, Inc.;  				All rights reserved.;  ;  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter;  				stack.  Include the file and version information (from above);  				in the problem description and send to:;  					Internet:	apple.bugs@applelink.apple.com;  					AppleLink:	APPLE.BUGS;  ; #|                                              ; $IFC UNDEFINED UsingIncludes; $SETC UsingIncludes := 0 |#                                             ; $ENDC#|                                              ; $IFC NOT UsingIncludes |#                                             ; $ENDC; $IFC UNDEFINED __OCEAUTHDIR__; $SETC __OCEAUTHDIR__ := 1; $I+; $SETC OCEAuthDirIncludes := UsingIncludes; $SETC UsingIncludes := 1#|                                              ; $IFC UNDEFINED __EVENTS__|#(require-interface 'Events)#|                                              ; $I Events.p |#                                             ; $ENDC; 	Types.p														; 		ConditionalMacros.p										; 	Quickdraw.p													; 		MixedMode.p												; 		QuickdrawText.p											; 	OSUtils.p													; 		Memory.p												#|                                              ; $IFC UNDEFINED __NOTIFICATION__|#(require-interface 'Notification)#|                                              ; $I Notification.p |#                                             ; $ENDC#|                                              ; $IFC UNDEFINED __APPLEEVENTS__|#(require-interface 'AppleEvents)#|                                              ; $I AppleEvents.p |#                                             ; $ENDC; 	Errors.p													; 	EPPC.p														; 		AppleTalk.p												; 		Files.p													; 		PPCToolbox.p											; 		Processes.p												#|                                              ; $IFC UNDEFINED __APPLETALK__|#(require-interface 'AppleTalk)#|                                              ; $I AppleTalk.p |#                                             ; $ENDC#|                                              ; $IFC UNDEFINED __FILES__|#(require-interface 'Files)#|                                              ; $I Files.p |#                                             ; $ENDC#|                                              ; $IFC UNDEFINED __OSUTILS__|#(require-interface 'OSUtils)#|                                              ; $I OSUtils.p |#                                             ; $ENDC#|                                              ; $IFC UNDEFINED __TYPES__|#(require-interface 'Types)#|                                              ; $I Types.p |#                                             ; $ENDC#|                                              ; $IFC UNDEFINED __OCE__|#(require-interface 'OCE)#|                                              ; $I OCE.p |#                                             ; $ENDC; 	Aliases.p													; 	Script.p													; 		IntlResources.p											; $PUSH; $ALIGN MAC68K; $LibExport+(defconstant $kRC4KeySizeInBytes 8)             ;  size of an RC4 key (defconstant $kRefNumUnknown 0)(defconstant $kEnumDistinguishedNameBit 0)(defconstant $kEnumAliasBit 1)(defconstant $kEnumPseudonymBit 2)(defconstant $kEnumDNodeBit 3)(defconstant $kEnumInvisibleBit 4);  Values of DirEnumChoices (defconstant $kEnumDistinguishedNameMask (* 1 (expt 2 #$kEnumDistinguishedNameBit)))(defconstant $kEnumAliasMask (* 1 (expt 2 #$kEnumAliasBit)))(defconstant $kEnumPseudonymMask (* 1 (expt 2 #$kEnumPseudonymBit)))(defconstant $kEnumDNodeMask (* 1 (expt 2 #$kEnumDNodeBit)))(defconstant $kEnumInvisibleMask (* 1 (expt 2 #$kEnumInvisibleBit)))(defconstant $kEnumAllMask (+ 0 (+ #$kEnumDistinguishedNameMask (+ #$kEnumAliasMask (+ #$kEnumPseudonymMask (+ #$kEnumDNodeMask #$kEnumInvisibleMask))))))(def-mactype :direnumchoices (find-mactype ':signed-long));  Values of DirSortOption (defconstant $kSortByName 0)(defconstant $kSortByType 1);  Values of DirSortDirection (defconstant $kSortForwards 0)(defconstant $kSortBackwards 1);  Values of DirMatchWith (defconstant $kMatchAll 0)(defconstant $kExactMatch 1)(defconstant $kBeginsWith 2)(defconstant $kEndingWith 3)(defconstant $kContaining 4)(def-mactype :dirmatchwith (find-mactype ':signed-byte))(defconstant $kCurrentOCESortVersion 1);   Access controls are implemented on three levels:;  *  	DNode, Record, and Attribute Type levels;  *  Some access control bits apply to the container itself, and some apply to its contents.;  *;  *  The Catalog Toolbox supports six functions.  These calls are:;  *  DSGetDNodeAccessControl : to get Access Controls at the DNode level;  *	DSGetRecordAccessControl  : to get Access Controls at the record level;  *  DSGetAttributeAccessControl : to get Access Privileges at the attribute type level;  * ;  *  The GetXXXAccessControl calls will return access control masks for various categories;  *  of users.  Please refer to the access control document for a description of the;  *  categories of users.  In general these are:;  *  	ThisRecordOwner 		- means the identity of the record itself;  *  	Friends 				 - means any one of the assigned friends for the record;  *  	AuthenticatedInDNode     - means any valid user that is an authenticated entity;  *  		in the DNode in which this record is located;  *  	AuthenticatedInDirectory - means any valid authenticated catalog user;  *  	Guest 					 - means an unauthenticated user.;  *  Bit masks for various permitted access controls are defined below.;  *;  *  GetXXXAccessControl calls will return access control masks for various categories of;  *  users for this record. In addition they also return the level of access controls;  *  that the user (who is making the GetXXXAccessControl call) has for the DNode,;  *  record, or attribute type.;  *;  *  For records, the access control granted will be minimum of the DNode access;  *  control and record access control masks.  For example, to add an attribute type to a;  *  record, a user must have access control kCreateAttributeTypes at the record and;  *  DNode levels.  Similarly, at the attribute type level, access controls will be the;  *  minimum of the DNode, record, and attribute type access controls.;  *;  *  ;  ;  access categories bit numbers (defconstant $kThisRecordOwnerBit 0)(defconstant $kFriendsBit 1)(defconstant $kAuthenticatedInDNodeBit 2)(defconstant $kAuthenticatedInDirectoryBit 3)(defconstant $kGuestBit 4)(defconstant $kMeBit 5);  Values of CategoryMask (defconstant $kThisRecordOwnerMask (+ 0 (* 1 (expt 2 #$kThisRecordOwnerBit))))(defconstant $kFriendsMask (+ 0 (* 1 (expt 2 #$kFriendsBit))))(defconstant $kAuthenticatedInDNodeMask (+ 0 (* 1 (expt 2 #$kAuthenticatedInDNodeBit))))(defconstant $kAuthenticatedInDirectoryMask (+ 0 (* 1 (expt 2 #$kAuthenticatedInDirectoryBit))))(defconstant $kGuestMask (+ 0 (* 1 (expt 2 #$kGuestBit))))(defconstant $kMeMask (+ 0 (* 1 (expt 2 #$kMeBit))))(defconstant $kSeeBit 0)(defconstant $kAddBit 1)(defconstant $kDeleteBit 2)(defconstant $kChangeBit 3)(defconstant $kRenameBit 4)(defconstant $kChangePrivsBit 5)(defconstant $kSeeFoldersBit 6);  Values of AccessMask (defconstant $kSeeMask (+ 0 (* 1 (expt 2 #$kSeeBit))))(defconstant $kAddMask (+ 0 (* 1 (expt 2 #$kAddBit))))(defconstant $kDeleteMask (+ 0 (* 1 (expt 2 #$kDeleteBit))))(defconstant $kChangeMask (+ 0 (* 1 (expt 2 #$kChangeBit))))(defconstant $kRenameMask (+ 0 (* 1 (expt 2 #$kRenameBit))))(defconstant $kChangePrivsMask (+ 0 (* 1 (expt 2 #$kChangePrivsBit))))(defconstant $kSeeFoldersMask (+ 0 (* 1 (expt 2 #$kSeeFoldersBit))))(defconstant $kAllPrivs (+ 0 (+ #$kSeeMask (+ #$kAddMask (+ #$kDeleteMask (+ #$kChangeMask (+ #$kRenameMask (+ #$kChangePrivsMask #$kSeeFoldersMask))))))))(defconstant $kNoPrivs 0)(defconstant $kSupportsDNodeNumberBit 0)(defconstant $kSupportsRecordCreationIDBit 1)(defconstant $kSupportsAttributeCreationIDBit 2)(defconstant $kSupportsMatchAllBit 3)(defconstant $kSupportsBeginsWithBit 4)(defconstant $kSupportsExactMatchBit 5)(defconstant $kSupportsEndsWithBit 6)(defconstant $kSupportsContainsBit 7)(defconstant $kSupportsOrderedEnumerationBit 8)(defconstant $kCanSupportNameOrderBit 9)(defconstant $kCanSupportTypeOrderBit 10)(defconstant $kSupportSortBackwardsBit 11)(defconstant $kSupportIndexRatioBit 12)(defconstant $kSupportsEnumerationContinueBit 13)(defconstant $kSupportsLookupContinueBit 14)(defconstant $kSupportsEnumerateAttributeTypeContinueBit 15)(defconstant $kSupportsEnumeratePseudonymContinueBit 16)(defconstant $kSupportsAliasesBit 17)(defconstant $kSupportsPseudonymsBit 18)(defconstant $kSupportsPartialPathNamesBit 19)(defconstant $kSupportsAuthenticationBit 20)(defconstant $kSupportsProxiesBit 21)(defconstant $kSupportsFindRecordBit 22);  values of DirGestalt (defconstant $kSupportsDNodeNumberMask (* 1 (expt 2 #$kSupportsDNodeNumberBit)))(defconstant $kSupportsRecordCreationIDMask (* 1 (expt 2 #$kSupportsRecordCreationIDBit)))(defconstant $kSupportsAttributeCreationIDMask (* 1 (expt 2 #$kSupportsAttributeCreationIDBit)))(defconstant $kSupportsMatchAllMask (* 1 (expt 2 #$kSupportsMatchAllBit)))(defconstant $kSupportsBeginsWithMask (* 1 (expt 2 #$kSupportsBeginsWithBit)))(defconstant $kSupportsExactMatchMask (* 1 (expt 2 #$kSupportsExactMatchBit)))(defconstant $kSupportsEndsWithMask (* 1 (expt 2 #$kSupportsEndsWithBit)))(defconstant $kSupportsContainsMask (* 1 (expt 2 #$kSupportsContainsBit)))(defconstant $kSupportsOrderedEnumerationMask (* 1 (expt 2 #$kSupportsOrderedEnumerationBit)))(defconstant $kCanSupportNameOrderMask (* 1 (expt 2 #$kCanSupportNameOrderBit)))(defconstant $kCanSupportTypeOrderMask (* 1 (expt 2 #$kCanSupportTypeOrderBit)))(defconstant $kSupportSortBackwardsMask (* 1 (expt 2 #$kSupportSortBackwardsBit)))(defconstant $kSupportIndexRatioMask (* 1 (expt 2 #$kSupportIndexRatioBit)))(defconstant $kSupportsEnumerationContinueMask (* 1 (expt 2 #$kSupportsEnumerationContinueBit)))(defconstant $kSupportsLookupContinueMask (* 1 (expt 2 #$kSupportsLookupContinueBit)))(defconstant $kSupportsEnumerateAttributeTypeContinueMask (* 1 (expt 2 #$kSupportsEnumerateAttributeTypeContinueBit)))(defconstant $kSupportsEnumeratePseudonymContinueMask (* 1 (expt 2 #$kSupportsEnumeratePseudonymContinueBit)))(defconstant $kSupportsAliasesMask (* 1 (expt 2 #$kSupportsAliasesBit)))(defconstant $kSupportsPseudonymsMask (* 1 (expt 2 #$kSupportsPseudonymsBit)))(defconstant $kSupportsPartialPathNamesMask (* 1 (expt 2 #$kSupportsPartialPathNamesBit)))(defconstant $kSupportsAuthenticationMask (* 1 (expt 2 #$kSupportsAuthenticationBit)))(defconstant $kSupportsProxiesMask (* 1 (expt 2 #$kSupportsProxiesBit)))(defconstant $kSupportsFindRecordMask (* 1 (expt 2 #$kSupportsFindRecordBit)))(defconstant $kAuthLockLocalIdentityOp 1)(defconstant $kAuthUnlockLocalIdentityOp 2)(defconstant $kAuthLocalIdentityNameChangeOp 3);  Values of AuthLocalIdentityLockAction (defconstant $kAuthLockPending 1)(defconstant $kAuthLockWillBeDone 2);  Values of AuthNotifications (defconstant $kNotifyLockBit 0)(defconstant $kNotifyUnlockBit 1)(defconstant $kNotifyNameChangeBit 2)(defconstant $kNotifyLockMask (* 1 (expt 2 #$kNotifyLockBit)))(defconstant $kNotifyUnlockMask (* 1 (expt 2 #$kNotifyUnlockBit)))(defconstant $kNotifyNameChangeMask (* 1 (expt 2 #$kNotifyNameChangeBit)))(defconstant $kPersonalDirectoryFileCreator :|kl03|)(defconstant $kPersonalDirectoryFileType :|pabt|)(defconstant $kBusinessCardFileType :|bust|)(defconstant $kDirectoryFileType :|dirt|)(defconstant $kDNodeFileType :|dnod|)(defconstant $kDirsRootFileType :|drtt|)(defconstant $kRecordFileType :|rcrd|)(def-mactype :dirsortoption (find-mactype ':signed-integer))(def-mactype :dirsortdirection (find-mactype ':signed-integer))(def-mactype :categorymask (find-mactype ':signed-long))(def-mactype :accessmask (find-mactype ':signed-long))(def-mactype :dirgestalt (find-mactype ':signed-long))(def-mactype :authlocalidentityop (find-mactype ':signed-long))(def-mactype :authlocalidentitylockaction (find-mactype ':signed-long))(def-mactype :authnotifications (find-mactype ':signed-long))(defrecord DNodeID    (dNodeNumber :signed-long)                   ;  dNodenumber     (reserved1 :signed-long)   (name (:pointer :rstring))   (reserved2 :signed-long)   )(defrecord DirEnumSpec    (enumFlag :signed-long)   ;;Changing field indexratio from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (indexRatio :unsigned-word)                  ;  Approx Record Position between 1 and 100 If supported, 0 If not supported    (:variant       (      (recordIdentifier :localrecordid)      )      (      (dNodeIdentifier :dnodeid)      )      )   )(defrecord DirMetaInfo    ;;Changing field info from signed-long to unsigned-long to match C header (pretty-darn-sure)   (info (:array :unsigned-long 4))   )(defrecord SLRV    (script :signed-integer)                     ;    Script code in which entries are sorted    (language :signed-integer)                   ;    Language code in which entries are sorted    (regionCode :signed-integer)                 ;    Region code in which entries are sorted    (version :signed-integer)                    ;   version of oce sorting software    );  Catalog types and operations ;  unique identifier for an identity (def-mactype :authidentity (find-mactype ':signed-long));  Umbrella LocalIdentity (def-mactype :localidentity (find-mactype ':signed-long));  A DES key is 8 bytes of data (defrecord DESKey    ;;Changing field a from signed-long to unsigned-long to match C header (pretty-sure)   (a :unsigned-long)   ;;Changing field b from signed-long to unsigned-long to match C header (pretty-sure)   (b :unsigned-long)   );; hand-hacked;; (defrecord RC4Key (array (array :signed-byte (- (- (value 'krc4keysizeinbytes) 1) 0 -1))))(defrecord RC4Key (array (array :signed-byte 8)))(def-mactype :authkeytype (find-mactype ':signed-long));  key type followed by its data (defrecord AuthKey    (keyType :signed-long)   (:variant       (      (des :deskey)      )      (      (rc4 :rc4key)      )      )   )(def-mactype :authkeyptr (find-mactype '(:pointer :authkey)))(def-mactype :authparamblockptr (find-mactype '(:pointer :authparamblock)))(def-mactype :authiocompletionprocptr (find-mactype ':pointer));  PROCEDURE AuthIOCompletion(paramBlock: AuthParamBlockPtr); (def-mactype :authiocompletionupp (find-mactype ':pointer))(defrecord AuthResolveCreationIDPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userRecord (:pointer :recordid))            ;   --> OCE name(Record) of the user    ;;Changing field bufferlength from signed-long to unsigned-long to match C header (pretty-sure)   (bufferLength :unsigned-long)                ;   --> Buffer Size to hold duplicate Info    (buffer :pointer)                            ;   --> Buffer  to hold duplicate Info    ;;Changing field totalmatches from signed-long to unsigned-long to match C header (pretty-darn-sure)   (totalMatches :unsigned-long)                ;  <--  Total Number of matching names found    ;;Changing field actualmatches from signed-long to unsigned-long to match C header (pretty-darn-sure)   (actualMatches :unsigned-long)               ;  <--  Number of matches returned in the buffer    ); ; kAuthBindSpecificIdentity:; userRecord will contain the user information whose identity has to be; verified. userKey will contain the userKey. An Identity is returned which; binds the key and the userRecord. The identity returned can be used in the 'identity'; field in the header portion (AuthParamHeader) for authenticating the Catalog and; Authentication manager calls.; (defrecord AuthBindSpecificIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;  <--  binding identity    (userRecord (:pointer :recordid))            ;   --> OCE name(Record) of the user    (userKey (:pointer :authkey))                ;   --> OCE Key for the user    ); ; kAuthUnbindSpecificIdentity:; This call will unbind the userRecord and key which were bind earlier.; (defrecord AuthUnbindSpecificIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;   --> identity to be deleted    ); ; kAuthGetSpecificIdentityInfo:; This call will return the userRecord for the given identity. Note: key is not; returned because this would compromise security.; (defrecord AuthGetSpecificIdentityInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;   --> identity of initiator    (userRecord (:pointer :recordid))            ;  <--  OCE name(Record) of the user    ); ; kAuthAddKey:; userRecord will contain the user information whose identity has to be; created. userKey will point to the key to be created. password points to; an RString containing the password used to generate the key.; (defrecord AuthAddKeyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userRecord (:pointer :recordid))            ;   --> OCE name(Record) of the user    (userKey (:pointer :authkey))                ;  <--  OCE Key for the user    (password (:pointer :rstring))               ;   --> Pointer to password string    ); ; kAuthChangeKey:; userRecord will contain the user information whose identity has to be; created. userKey will point to the key to be created. password points to; an RString containing the password used to generate the key.; (defrecord AuthChangeKeyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userRecord (:pointer :recordid))            ;   --> OCE name(Record) of the user    (userKey (:pointer :authkey))                ;  <--  New OCE Key for the user    (password (:pointer :rstring))               ;   -->Pointer to the new password string    ); ; AuthDeleteKey:; userRecord will contain the user information whose Key has to be deleted.; (defrecord AuthDeleteKeyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userRecord (:pointer :recordid))            ;   --> OCE name(Record) of the user    );  AuthPasswordToKey: Converts an RString into a key. (defrecord AuthPasswordToKeyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userRecord (:pointer :recordid))            ;   --> OCE name(Record) of the user    (key (:pointer :authkey))                    ;  <--     (password (:pointer :rstring))               ;   -->Pointer to the new password string    ); ; kAuthGetCredentials:; userRecord will contain the user information whose identity has to be; kMailDeletedMask. keyType (e.g. asDESKey) will indicate what type of key has to; be deleted.; (defrecord AuthGetCredentialsPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;   --> identity of initiator    (recipient (:pointer :recordid))             ;   --> OCE name of recipient    (sessionKey (:pointer :authkey))             ;  <--  session key    (expiry :signed-long)                        ;  <--> desired/actual expiry    ;;Changing field credentialslength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (credentialsLength :unsigned-long)           ;  <--> max/actual credentials size    (credentials :pointer)                       ;  <--  buffer where credentials are returned    ); ; AuthDecryptCredentialsPB:; Changes:; userKey is changed userIdentity.; userRecord is changed to initiatorRecord. User must supply buffer; to hold initiatorRecord.; agentList has changed to agent. There wil be no call back.; User must supply buffer to hold agent Record.; An additional boolean parameter 'hasAgent' is included.; Toolbox will set this if an 'Agent' record is found in the; credentials. If RecordIDPtr is 'nil', no agent record will; be copied. However user can examine 'hasAgent', If true user; can reissue this call with apprpriate buffer for getting a recordID.; agent has changed to intermediary.  User must supply buffer to hold ; intermediary Record.  The toolbox will set 'hasIntermediary' if an; 'intermediary' record is found in the credentials. ; (defrecord AuthDecryptCredentialsPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;   --> user's Identity    (initiatorRecord (:pointer :recordid))       ;  <--  OCE name of the initiator    (sessionKey (:pointer :authkey))             ;  <--  session key    (expiry :signed-long)                        ;  <--  credentials expiry time    ;;Changing field credentialslength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (credentialsLength :unsigned-long)           ;   --> actual credentials size    (credentials :pointer)                       ;   --> credentials to be decrypted    (issueTime :signed-long)                     ;  <--  credentials expiry time    (hasIntermediary :boolean)                   ;  <--  if true, An intermediary Record was found in credentials    (filler1 :boolean)   (intermediary (:pointer :recordid))          ;  <--  recordID of the intermediary    )(defrecord AuthMakeChallengePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (key (:pointer :authkey))                    ;   --> UnEncrypted SessionKey    (challenge :pointer)                         ;  <--  Encrypted Challenge    ;;Changing field challengebufferlength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (challengeBufferLength :unsigned-long)       ;   ->length of challenge buffer    ;;Changing field challengelength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (challengeLength :unsigned-long)             ;   <-length of Encrypted Challenge    )(defrecord AuthMakeReplyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (key (:pointer :authkey))                    ;   --> UnEncrypted SessionKey    (challenge :pointer)                         ;   --> Encrypted Challenge    (reply :pointer)                             ;  <--  Encrypted Reply    ;;Changing field replybufferlength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (replyBufferLength :unsigned-long)           ;   -->length of challenge buffer    ;;Changing field challengelength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (challengeLength :unsigned-long)             ;   --> length of Encrypted Challenge    ;;Changing field replylength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (replyLength :unsigned-long)                 ;  <--  length of Encrypted Reply    )(defrecord AuthVerifyReplyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (key (:pointer :authkey))                    ;   --> UnEncrypted SessionKey    (challenge :pointer)                         ;   --> Encrypted Challenge    (reply :pointer)                             ;   --> Encrypted Reply    ;;Changing field challengelength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (challengeLength :unsigned-long)             ;   --> length of Encrypted Challenge    ;;Changing field replylength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (replyLength :unsigned-long)                 ;   --> length of Encrypted Reply    ); ; kAuthGetUTCTime:; RLI will contain a valid RLI for a cluster server.; UTC(GMT) time from one of the cluster server will be returned.; An 'offSet' from UTC(GMT) to Mac Local Time will also be returned.; If RLI is nil Map DA is used to determine UTC(GMT).; Mac Local Time = theUTCTime + theUTCOffset.; (defrecord AuthGetUTCTimePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pRLI (:pointer :packedrli))                 ;   --> packed RLI of the Node, whose server's UTC is requested    (theUTCTime :signed-long)                    ;  <--  current UTC(GMT) Time utc seconds since 1/1/1904    (theUTCOffset :signed-long)                  ;  <--  offset from UTC(GMT) seconds EAST of Greenwich    ); ; kAuthMakeProxy:; A user represented bu the 'userIdentity' can make a proxy using this call.; 'recipient' is the RecordID of the recipient whom user is requesting proxy.; 'intermediary' is the RecordID of the intermediary holding proxy for the user.; 'firstValid' is time at which proxy becomes valid.; 'expiry' is the time at which proxy must expire.; 'proxyLength' will have the length of the buffer pointed by 'proxy' as input.; When the call completes, it will hold the actual length of proxy. If the; call completes 'kOCEMoreData' error, client can reissue the call with the; buffer size as 'proxyLength' returned.; expiry is a suggestion, and may be adjusted to be earlier by the ADAP/OCE server.; The 'proxy' obtained like this might be used by the 'intermediary' to obtain credentials; for the server using TradeProxyForCredentials call.; authDataLength and authData are intended for possible future work, but are; ignored for now.; (defrecord AuthMakeProxyPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;   --> identity of principal    (recipient (:pointer :recordid))             ;   --> OCE name of recipient    (firstValid :signed-long)                    ;   --> time at which proxy becomes valid    (expiry :signed-long)                        ;   --> time at which proxy expires    ;;Changing field authdatalength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (authDataLength :unsigned-long)              ;   --> size of authorization data    (authData :pointer)                          ;   --> pointer to authorization data    ;;Changing field proxylength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (proxyLength :unsigned-long)                 ;  <--> max/actual proxy size    (proxy :pointer)                             ;  <--> buffer where proxy is returned    (intermediary (:pointer :recordid))          ;   --> RecordID of intermediary    ); ; kAuthTradeProxyForCredentials:; Using this call, intermediary holding a 'proxy' for a recipient may obtain credentials; for that recipient. 'userIdentity' is the identity for the 'intermediary'.; 'recipient' is the RecordID for whom credetials are requested.; 'principal' is the RecordID of the user who created the proxy.; 'proxyLength' is the length of data pointed by 'proxy.; If the call is succesfull, credentials will be returned in the; buffer pointed by 'credentials'. 'expiry' is the desired expiry time at input.; When call succeds this will have expiry time of credentials.; This is very similar to GetCredentials except that we (of course) need the proxy,; but we also need the name of the principal who created the proxy.; (defrecord AuthTradeProxyForCredentialsPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (userIdentity :signed-long)                  ;   --> identity of intermediary    (recipient (:pointer :recordid))             ;   --> OCE name of recipient    (sessionKey (:pointer :authkey))             ;  <--  session key    (expiry :signed-long)                        ;  <--> desired/actual expiry    ;;Changing field credentialslength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (credentialsLength :unsigned-long)           ;  <--> max/actual credentials size    (credentials :pointer)                       ;  <--> buffer where credentials are returned    ;;Changing field proxylength from signed-long to unsigned-long to match C header (pretty-darn-sure)   (proxyLength :unsigned-long)                 ;   --> actual proxy size    (proxy :pointer)                             ;   --> buffer containing proxy    (principal (:pointer :recordid))             ;   --> RecordID of principal    );  API for Local Identity Interface ; ; AuthGetLocalIdentityPB:; A Collaborative application intended to work under the umbrella of LocalIdentity; for the OCE toolbox will have to make this call to obtain LocalIdentity.; If LocalIdentity has not been setup, then application will get; 'kOCEOCESetupRequired.'. In this case application should put the dialog; recommended by the OCE Setup document and guide the user through OCE Setup.; If the OCESetup contains local identity, but user has not unlocked, it will get; kOCELocalAuthenticationFail. In this case application should use SDPPromptForLocalIdentity; to prompt user for the password.; If a backGround application or stand alone code requires LocalIdentity, if it gets the; OSErr from LocalIdentity and can not call SDPPromptForLocalIdentity, it should it self; register with the toolbox using kAuthAddToLocalIdentityQueue call. It will be notified; when a LocalIdentity gets created by a foreground application.; (defrecord AuthGetLocalIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (theLocalIdentity :signed-long)              ;  <--  LocalIdentity    ); ; kAuthUnlockLocalIdentity:; The LocalIdentity can be created using this call.; The userName and password correspond to the LocalIdentity setup.; If the password matches, then collabIdentity will be returned.; Typically SDPPromptForLocalIdentity call will make this call.; All applications which are registered through kAuthAddToLocalIdentityQueue; will be notified.; (defrecord AuthUnlockLocalIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (theLocalIdentity :signed-long)              ;  <--  LocalIdentity    (userName (:pointer :rstring))               ;   --> userName    (password (:pointer :rstring))               ;   -->user password    ); ; kAuthLockLocalIdentity:; With this call existing LocalIdentity can be locked. If the ASDeleteLocalIdetity; call fails with 'kOCEOperationDenied' error, name will contain the application which; denied the operation. This name will be supplied by the application; when it registered through kAuthAddToLocalIdentityQueue call; (defrecord AuthLockLocalIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (theLocalIdentity :signed-long)              ;   --> LocalIdentity    (name (:pointer (:string 255)))              ;  <--  name of the app which denied delete    )(def-mactype :notificationprocptr (find-mactype ':pointer));  FUNCTION Notification(clientData: LONGINT; callValue: AuthLocalIdentityOp; actionValue: AuthLocalIdentityLockAction; identity: LocalIdentity): BOOLEAN; (def-mactype :notificationupp (find-mactype ':pointer))(def-mactype :notificationproc (find-mactype ':pointer)); ; kAuthAddToLocalIdentityQueue:; An application requiring notification of locking/unlocking of the; LocalIdentity can install itself using this call. The function provided; in 'notifyProc' will be called whenever the requested event happens.; When an AuthLockLocalIdentity call is made to the toolbox, the notificationProc; will be called with 'kAuthLockPending'. The application may refuse the lock by returning; a 'true' value. If all the registered entries return 'false' value, locking will be done; successfully. Otherwise 'kOCEOperationDenied' error is returned to the caller. The appName; (registered with the notificationProc) of the application which denied locking is also; returned to the caller making the AuthLockIdentity call.; (defrecord AuthAddToLocalIdentityQueuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (notifyProc :pointer)                        ;   --> notification procedure    (notifyFlags :signed-long)                   ;   --> notifyFlags    (appName (:pointer (:string 255)))           ;   --> name of application to be returned in Delete/Stop    ); ; kAuthRemoveFromLocalIdentityQueue:(defrecord AuthRemoveFromLocalIdentityQueuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (notifyProc :pointer)                        ;   --> notification procedure    ); ; kAuthSetupLocalIdentity:; The LocalIdentity can be Setup using this call.; The userName and password correspond to the LocalIdentity setup.; If a LocalIdentity Setup already exists 'kOCELocalIdentitySetupExists' error; will be returned.; (defrecord AuthSetupLocalIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aReserved :signed-long)                     ;   --     (userName (:pointer :rstring))               ;   --> userName    (password (:pointer :rstring))               ;   -->user password    ); ; kAuthChangeLocalIdentity:; An existing LocalIdentity  Setup can be changed using this call.; The userName and password correspond to the LocalIdentity setup.; If a LocalIdentity Setup does not exists 'kOCEOCESetupRequired' error; will be returned. The user can use  kAuthSetupLocalIdentity call to setit up.; If the 'password' does not correspond to the existing setup, 'kOCELocalAuthenticationFail'; OSErr will be returned. If successful, LocalID will have new name as 'userName' and; password as 'newPassword' and if any applications has installed into ; LocalIdentityQueue with kNotifyNameChangeMask set, it will be notified with ; kAuthLocalIdentityNameChangeOp action value. ; ; (defrecord AuthChangeLocalIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aReserved :signed-long)                     ;   --     (userName (:pointer :rstring))               ;   --> userName    (password (:pointer :rstring))               ;   --> current password    (newPassword (:pointer :rstring))            ;   --> new password    ); ; kAuthRemoveLocalIdentity:; An existing LocalIdentity  Setup can be removed using this call.; The userName and password correspond to the LocalIdentity setup.; If a LocalIdentity Setup does not exists 'kOCEOCESetupRequired' error; will be returned.; If the 'password' does not correspond to the existing setup, 'kOCELocalAuthenticationFail'; OSErr will be returned. If successful, LocalIdentity will be removed from the OCE Setup.; This is a very distructive operation, user must be warned enough before actually making; this call.; (defrecord AuthRemoveLocalIdentityPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aReserved :signed-long)                     ;   --     (userName (:pointer :rstring))               ;   --> userName    (password (:pointer :rstring))               ;   --> current password    ); ; kOCESetupAddDirectoryInfo:; Using this call identity for a catalog can be setup under LocalIdentity umbrella.; ASCreateLocalIdentity should have been done succesfully before making this call.; directoryRecordCID -> is the record creationID obtained when DirAddOCEDirectory or; DirAddDSAMDirectory call was made.; rid-> is the recordID in which the identity for the catalog will be established.; password-> the password associated with the rid in the catalog world.; (defrecord OCESetupAddDirectoryInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryRecordCID :creationid)             ;   --> CreationID for the catalog    (recordID (:pointer :recordid))              ;   --> recordID for the identity    (password (:pointer :rstring))               ;   --> password in the catalog world    ); ; kOCESetupChangeDirectoryInfo:; Using this call an existing identity for a catalog under LocalIdentity umbrella; can be changed.; ASCreateLocalIdentity should have been done succesfully before making this call.; directoryRecordCID -> is the record creationID obtained when DirAddOCEDirectory or; DirAddDSAMDirectory call was made.; rid-> is the recordID in which the identity for the catalog will be established.; password-> the password associated with the rid in the catalog world.; newPassword -> the new password for the catalog; (defrecord OCESetupChangeDirectoryInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryRecordCID :creationid)             ;   --> CreationID for the catalog    (recordID (:pointer :recordid))              ;   --> recordID for the identity    (password (:pointer :rstring))               ;   --> password in the catalog world    (newPassword (:pointer :rstring))            ;   --> new password in the catalog    ); ; kOCESetupRemoveDirectoryInfo:; Using this call an existing identity for a catalog under LocalIdentity umbrella; can be changed.; ASCreateLocalIdentity should have been done succesfully before making this call.; directoryRecordCID -> is the record creationID obtained when DirAddOCEDirectory or; (defrecord OCESetupRemoveDirectoryInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryRecordCID :creationid)             ;   --> CreationID for the catalog    ); ; kOCESetupGetDirectoryInfo:; Using this call info on an existing identity for a particular catalog under LocalIdentity umbrella; can be obtained.; For the specified catalog 'directoryName' and 'discriminator', rid and nativeName will; returned. Caller must provide appropriate buffer to get back rid and nativeName.; 'password' will be returned  for  non-ADAP Catalogs.; (defrecord OCESetupGetDirectoryInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> discriminator for the catalog    (recordID (:pointer :recordid))              ;  <--  rid for the catalog identity    (nativeName (:pointer :rstring))             ;  <--  user name in the catalog world    (password (:pointer :rstring))               ;  <--  password in the catalog world    ); ****************************************************************************; ; ;  		Catalog Manager operations; ; ; ****************************************************************************(def-mactype :dirparamblockptr (find-mactype '(:pointer :dirparamblock)))(def-mactype :diriocompletionprocptr (find-mactype ':pointer));  PROCEDURE DirIOCompletion(paramBlock: DirParamBlockPtr); (def-mactype :diriocompletionupp (find-mactype ':pointer))(defrecord DirAddRecordPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   --> CreationID returned here    (allowDuplicate :boolean)                    ;   -->    (filler1 :boolean)   );  DeleteRecord (defrecord DirDeleteRecordPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    );  aRecord must contain valid PackedRLI and a CreationID. ; ********************************************************************************; ; DirEnumerate:; This call can be used to enumerate both DNodes and records under a specified; DNode. A DNode is specified by the PackedRLIPtr 'aRLI'.; ; startingPoint indicates where to start the enumeration.  Initially,; it should be set to a value of nil.  After some records are enumerated,; the client can issue the call again with the same aRLI and recordName and; typeList. The last received DirEnumSpec in the startingPoint field.  The server; will continue the enumeration from that record on. if user wants to get back the; value specified in the startingRecord also, the Boolean 'includeStartingPoint'; must be set to 'true'. If this is set to 'false', records specified after the; startingPoint record will be returned.; ; sortBy indicates to the server to return the records that match in name-first; or type-first order.  sortDirection indicates to the server to search in forward; or backward sort order for RecordIDs Specified.; ; RecordIDS and Enumeration Criteria:; ; PackedRLIPtr parameter 'aRLI' will be accepted for DNode; specification.; ; One RStringPtr 'nameMatchString' is provided. User is allowed to; specify a wild card in the name. WildCard specification is specified in ; matchNameHow parameter and possible values are defined in DirMatchWith Enum.; ; 'typeCount' parameter indicate how many types are in the 'typeList'.; ; 'typeList' parmeter is a pointer to an RString array of size 'typeCount'.; ; If 'typeCount' is exactly equal to one, a wild card can be specified; for the entity type; otherwise types have to be completely specified.; WildCard specification is specified in  matchNameHow parameter;  and possible values are defined in DirMatchWith Enum.; ; ; A nil value for 'startingPoint' is allowed when sortDirection specified; is 'kSortBackwards'. This was not allowed previously.; ; 'enumFlags' parameter is a bit field. The following bits can be set:; 	kEnumDistinguishedNameMask to get back records in the cluster data base.; 	kEnumAliasMask to get back record aliases; 	kEnumPseudonymMask to get back record pseudonyms; 	kEnumDNodeMask to get back any children dNodes for the DNode specified in the; 	'aRLI' parameter.; 	kEnumForeignDNodeMask to get back any children dNodes which have ForeignDnodes in the; 	dNode specified in the 'aRLI' parameter.; ; 	kEnumAll is combination of all five values and can be used to enumerate; 	everything under a specified DNode.; ; ; ; The results returned for each element will consist of a DirEnumSpec.; The DirEnumSpec contains 'enumFlag' which indicates the type of entity and a; union which will have either DNodeID or LocalRecordID depending on the value of 'enumFlag'.; The 'enumFlag'  will indicate whether the returned element is a; record(kEnumDistinguishedNameMask bit) or a alias(kEnumAliasMask bit) or a; Pseudonym(kEnumPseudonymMask) or a child DNode(kEnumDNodeMask bit).  If the 'enumFlag' value; is kEnumDnodeMask, it indicates the value returned in the union is a DNodeID (i.e. 'dNodeNumber'; is the 'dNodeNumber' of the child dnode(if the catalog supports dNodeNumbers, otherwise; this will be set to zero). The name will be the child dnode name. For other values of the; 'enumFlag', the value in the union will be LocalRecordID. In addition to kEnumDnodeMask it is; possible that kEnumForeignDNodeMask is also set. This is an advisory bit and application must make; it's own decision before displaying these records. If catalog supports kSupportIndexRatioMask, it; may also return the relative position of the record (percentile of total records) in the ; indexRatio field in EnumSpec.; ; ; responseSLRV will contain the script, language, region and version of the oce sorting software.; The results will be collected in the 'getBuffer' supplied by the user.; If buffer can not hold all the data returned 'kOCEMoreData' error will be returned.; ; If user receives 'noErr' or 'kOCEMoreData', buffer will contain valid results. A user; can extract the results in the 'getBuffer' by making DirEnumerateParse' call.; (defrecord DirEnumerateGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRLI (:pointer :packedrli))                 ;   --> an RLI specifying the cluster to be enumerated    (startingPoint (:pointer :direnumspec))      ;   -->    (sortBy :signed-integer)                     ;   -->    (sortDirection :signed-integer)              ;   -->    (dReserved :signed-long)                     ;   --     (nameMatchString (:pointer :rstring))        ;   --> name from which enumeration should start    (typesList (:handle :rstring))               ;   --> list of entity types to be enumerated    ;;Changing field typecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (typeCount :unsigned-long)                   ;   --> number of types in the list    (enumFlags :signed-long)                     ;   --> indicates what to enumerate    (includeStartingPoint :boolean)              ;   --> if true return the record specified in starting point    (padByte :signed-byte)                       ;  Byte    (matchNameHow :signed-byte)                  ;   --> Matching Criteria for nameMatchString    (matchTypeHow :signed-byte)                  ;   --> Matching Criteria for typeList    (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    (responseSLRV :slrv)                         ;   <--  response SLRV    );  The EnumerateRecords call-back function is defined as follows: (def-mactype :foreachdirenumspecprocptr (find-mactype ':pointer));  FUNCTION ForEachDirEnumSpec(clientData: LONGINT; (CONST)VAR enumSpec: DirEnumSpec): BOOLEAN; (def-mactype :foreachdirenumspecupp (find-mactype ':pointer))(def-mactype :foreachdirenumspec (find-mactype ':pointer)); ; EnumerateParse:; After an EnumerateGet call has completed, call EnumerateParse; to parse through the buffer that was filled in EnumerateGet.; ; 'eachEnumSpec' will be called each time to return to the client a; DirEnumSpec that matches the pattern for enumeration. 'enumFlag' indicates the type; of information returned in the DirEnumSpec; The clientData parameter that you pass in the parameter block will be passed; to 'forEachEnumDSSpecFunc'.  You are free to put anything in clientData - it is intended; to allow you some way to match the call-back to the original call (for; example, you make more then one aysynchronous EnumerateGet calls and you want to; associate returned results in some way).; ; The client should return FALSE from 'eachEnumSpec' to continue; processing of the EnumerateParse request.  Returning TRUE will; terminate the EnumerateParse request.; ; For synchronous calls, the call-back routine actually runs as part of the same thread; of execution as the thread that made the EnumerateParse call.  That means that the; same low-memory globals, A5, stack, etc. are in effect during the call-back; that were in effect when the call was made.  Because of this, the call-back; routine has the same restrictions as the caller of EnumerateParse:; if EnumerateParse was not called from interrupt level, then the call-; back routine can allocate memory. For asynchronous calls, call-back routine is; like a ioCompletion except that A5 will be preserved for the application.; (defrecord DirEnumerateParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRLI (:pointer :packedrli))                 ;   --> an RLI specifying the cluster to be enumerated    (bReserved :signed-long)                     ;   --     (cReserved :signed-long)                     ;   --     (eachEnumSpec :pointer)                      ;   -->    (eReserved :signed-long)                     ;   --     (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (iReserved :signed-long)                     ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    (l1Reserved :signed-integer)                 ;   --    (l2Reserved :signed-integer)                 ;   --     (l3Reserved :signed-integer)                 ;   --    (l4Reserved :signed-integer)                 ;   --     ); ;  * FindRecordGet operates similarly to DirEnumerate except it returns a list;  * of records instead of records local to a cluster.; (defrecord DirFindRecordGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (startingPoint (:pointer :recordid))   (reservedA (:array :signed-long 2))   (nameMatchString (:pointer :rstring))   (typesList (:handle :rstring))   ;;Changing field typecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (typeCount :unsigned-long)   (reservedB :signed-long)   (reservedC :signed-integer)   (matchNameHow :signed-byte)   (matchTypeHow :signed-byte)   (getBuffer :pointer)   ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)   (directoryName (:pointer :directoryname))   (discriminator :dirdiscriminator)   );  The FindRecordParse call-back function is defined as follows: (def-mactype :foreachrecordprocptr (find-mactype ':pointer));  FUNCTION ForEachRecord(clientData: LONGINT; (CONST)VAR enumSpec: DirEnumSpec; pRLI: PackedRLIPtr): BOOLEAN; (def-mactype :foreachrecordupp (find-mactype ':pointer))(def-mactype :foreachrecord (find-mactype ':pointer)); ;  * This PB same as DirFindRecordGet except it includes the callback function; (defrecord DirFindRecordParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (startingPoint (:pointer :recordid))   (reservedA (:array :signed-long 2))   (nameMatchString (:pointer :rstring))   (typesList (:handle :rstring))   ;;Changing field typecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (typeCount :unsigned-long)   (reservedB :signed-long)   (reservedC :signed-integer)   (matchNameHow :signed-byte)   (matchTypeHow :signed-byte)   (getBuffer :pointer)   ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)   (directoryName (:pointer :directoryname))   (discriminator :dirdiscriminator)   (forEachRecordFunc :pointer)   ); ; LookupGet:; ; aRecordList is an array of pointers to RecordIDs, each of which must; contain valid PackedRLI and a CreationID.  recordIDCount is; the size of this array.; ; attrTypeList is an array of pointers to AttributeTypes.  attrTypeCount is; the size of this array.; ; staringRecordIndex is the record from which to continue the lookup.; If you want to start from first record in the list, this must be 1 (not zero).; This value must always be <= recordIDCount.; ; startingAttributeIndex is the AttributeType from which we want to continue the lookup.; If you want to start from first attribute in the list, this must be 1 (not zero).; This value must always be <= attrTypeCount.; ; startingAttribute is the value of the attribute value from which we want to; continue lookup. In case of catalogs supporting creationIDs, startingAttribute; may contain only a CID. Other catalogs may require the entire value.; If a non-null cid is given and if an attribute value with that cid is not found, this; call will terminate with kOCENoSuchAttribute error. A client should not make a LookupParse call; after getting this error.; ; 'includeStartingPoint' boolean can be set to 'true' to receive the value specified in the; startingPoint in the results returned. If this is set to 'false', the value; specified in the startingAttribute will not be returned.; ; When LookupGet call fails with kOCEMoreData, the client will be able to find out where the call ended; with a subsequent LookupParse call. When the LookupParse call completes with kOCEMoreData,; lastRecordIndex, lastAttributeIndex and lastValueCID will point to the corresponding; recordID, attributeType and the CreationID of the last value returned successfully. These parameters; are exactly the same ones for the startingRecordIndex, startingAttributeIndex, and startingAttrValueCID; so they can be used in a subsequent LookupGet call to continue the lookup.; ; In an extreme case, It is possible that we had an attribute value that is too large to fit; in the client's buffer. In such cases, if it was the only thing that we tried to fit; into the buffer, the client will not able to proceed further because he will not know the; attributeCID of the attribute to continue with.  Also he does not know how big a buffer; would be needed for the next call to get this 'mondo' attribute value successfully.; ; to support this, LookupParse call will do the following:; ; If LookupGet has failed with kOCEMoreData error, LookupParse will check to make sure that; ForEachAttributeValueFunc has been called at least once. If so, the client has the option; to continue from that attribute CreationID (for PAB/ADAP) in the next LookupGet call.; However, if it was not even called once, then the attribute value may be too big to fit in the; user's buffer. In this case, lastAttrValueCID (lastAttribute) and attrSize are returned in the; parse buffer and the call will fail with kOCEMoreAttrValue. However, it is possible that; ForEachAttributeValue was not called because the user does not have read access to some of; the attributeTypes in the list, and the buffer was full before even reading the creationID of; any of the attribute values.  A kOCEMoreData error is returned.; ; The Toolbox will check for duplicate RecordIDs in the aRecordList. If found, it will return; 'daDuplicateRecordIDErr'.; ; The Toolbox will check for duplicate AttributeTypes in the attrTypeList. If found it will; return 'daDuplicateAttrTypeErr'.; (defrecord DirLookupGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecordList (:handle :recordid))            ;   --> an array of RecordID pointers    (attrTypeList (:handle :attributetype))      ;   --> an array of attribute types    (cReserved :signed-long)                     ;   --     (dReserved :signed-long)                     ;   --     (eReserved :signed-long)                     ;   --     (fReserved :signed-long)                     ;   --     ;;Changing field recordidcount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (recordIDCount :unsigned-long)               ;   -->    ;;Changing field attrtypecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (attrTypeCount :unsigned-long)               ;   -->    (includeStartingPoint :boolean)              ;   --> if true return the value specified by the starting indices    (padByte :signed-byte)                       ;  Byte    (i1Reserved :signed-integer)                 ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    ;;Changing field startingrecordindex from signed-long to unsigned-long to match C header (pretty-darn-sure)   (startingRecordIndex :unsigned-long)         ;   --> start from this record    ;;Changing field startingattrtypeindex from signed-long to unsigned-long to match C header (pretty-darn-sure)   (startingAttrTypeIndex :unsigned-long)       ;   --> start from this attribute type    (startingAttribute :attribute)               ;   --> start from this attribute value    (pReserved :signed-long)                     ;   --     );  The Lookup call-back functions are defined as follows: (def-mactype :foreachlookuprecordidprocptr (find-mactype ':pointer));  FUNCTION ForEachLookupRecordID(clientData: LONGINT; (CONST)VAR recordID: RecordID): BOOLEAN; (def-mactype :foreachlookuprecordidupp (find-mactype ':pointer))(def-mactype :foreachlookuprecordid (find-mactype ':pointer))(def-mactype :foreachattrtypelookupprocptr (find-mactype ':pointer));  FUNCTION ForEachAttrTypeLookup(clientData: LONGINT; (CONST)VAR attrType: AttributeType; myAttrAccMask: AccessMask): BOOLEAN; (def-mactype :foreachattrtypelookupupp (find-mactype ':pointer))(def-mactype :foreachattrtypelookup (find-mactype ':pointer))(def-mactype :foreachattrvalueprocptr (find-mactype ':pointer));  FUNCTION ForEachAttrValue(clientData: LONGINT; (CONST)VAR attribute: Attribute): BOOLEAN; (def-mactype :foreachattrvalueupp (find-mactype ':pointer))(def-mactype :foreachattrvalue (find-mactype ':pointer)); ; LookupParse:; ; After a LookupGet call has completed, call LookupParse; to parse through the buffer that was filled in LookupGet.  The; toolbox will parse through the buffer and call the appropriate call-back routines; for each item in the getBuffer.; ; 'eachRecordID' will be called each time to return to the client one of the; RecordIDs from aRecordList.  The clientData parameter that you; pass in the parameter block will be passed to eachRecordID.; You are free to put anything in clientData - it is intended to allow; you some way to match the call-back to the original call (in case, for; example, you make simultaneous asynchronous LookupGet calls).  If you don't; want to get a call-back for each RecordID (for example, if you're looking up; attributes for only one RecordID), pass nil for eachRecordID.; ; After forEachLocalRecordIDFunc is called, eachAttrType may be called to pass an; attribute type (one from attrTypeList) that exists in the record specified; in the last eachRecordID call.  If you don't want to get a call-back for; each AttributeType (for example, if you're looking up only one attribute type,; or you prefer to read the type from the Attribute struct during the eachAttrValue; call-back routine), pass nil for eachAttrType. However access controls may; prohibit you from reading some attribute types; in that case eachAttrValue; may not be called even though the value exists. Hence the client should; supply this call-back function to see the access controls for each attribute type.; ; This will be followed by one or more calls to eachAttrValue, to pass the; type, tag, and attribute value.  NOTE THIS CHANGE:  you are no longer expected to; pass a pointer to a buffer in which to put the value.  Now you get a pointer to; the value, and you can process it within the call-back routine.; After one or more values are returned, eachAttrType may be called again to pass; another attribute type that exists in the last-specified RecordID.; ; The client should return FALSE from eachRecordID, eachAttrType, and; eachAttrValue to continue processing of the LookupParse request.  Returning TRUE; from any call-back will terminate the LookupParse request.; ; If LookupGet has failed with kOCEMoreData error, LookupParse will check to make sure that; ForEachAttributeValueFunc has been called at least once. If so, the client has the option; to continue from that attribute CreationID (for PAB/ADAP) in the next LookupGet call.; However, if it was not even called once, then the attribute value may be too big to fit in the; user's buffer. In this case, lastAttrValueCID (lastAttribute) and attrSize are returned in the; parse buffer and the call will fail with kOCEMoreAttrValue. However, it is possible that; ForEachAttributeValue was not called because the user does not have read access to some of; the attributeTypes in the list, and the buffer was full before even reading the creationID of; any of the attribute values.  A kOCEMoreData error is returned.; ; For synchronous calls, the call-back routine actually runs as part of the same thread; of execution as the thread that made the LookupParse call.  That means that the; same low-memory globals, A5, stack, etc. are in effect during the call-back; that were in effect when the call was made.  Because of this, the call-back; routine has the same restrictions as the caller of LookupParse:; if LookupParse was not called from interrupt level, then the call-; back routine can allocate memory. For asynchronous calls, call-back routine is; like a ioCompletion except that A5 will be preserved for the application.; (defrecord DirLookupParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecordList (:handle :recordid))            ;   --> must be same from the corresponding Get call    (attrTypeList (:handle :attributetype))      ;   --> must be same from the corresponding Get call    (cReserved :signed-long)                     ;   --     (eachRecordID :pointer)                      ;   -->    (eachAttrType :pointer)                      ;   -->    (eachAttrValue :pointer)                     ;   -->    ;;Changing field recordidcount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (recordIDCount :unsigned-long)               ;   --> must be same from the corresponding Get call    ;;Changing field attrtypecount from signed-long to unsigned-long to match C header (pretty-darn-sure)   (attrTypeCount :unsigned-long)               ;   --> must be same from the corresponding Get call    (iReserved :signed-long)                     ;   --     (getBuffer :pointer)                         ;   --> must be same from the corresponding Get call   ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   --> must be same from the corresponding Get call   ;;Changing field lastrecordindex from signed-long to unsigned-long to match C header (pretty-darn-sure)   (lastRecordIndex :unsigned-long)             ;  <--  last RecordID processed when parse completed    ;;Changing field lastattributeindex from signed-long to unsigned-long to match C header (pretty-darn-sure)   (lastAttributeIndex :unsigned-long)          ;  <--  last Attribute Type processed when parse completed    (lastAttribute :attribute)                   ;  <--  last attribute value (with this CreationID) processed when parse completed    ;;Changing field attrsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (attrSize :unsigned-long)                    ;  <--  length of the attribute we did not return    );  AddAttributeValue (defrecord DirAddAttributeValuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (attr (:pointer :attribute))                 ;   --> AttributeCreationID returned here    ); ; aRecord must contain valid PackedRLI and a CreationID.; ; Instead of passing type, length, and value in three separate; fields, we take a pointer to an Attribute structure that contains; all three, and has room for the AttributeCreationNumber.; The AttributeCreationID will be returned in the attr itself.; ; The AttributeTag tells the catalog service that the attribute is an RString,; binary, or a RecordID.; ; ; DeleteAttributeType:; This call is provided so that an existing AttributeType can be deleted.; If any attribute values exist for this type, they will all be deleted; (if the user has access rights to delete the values) and then the attribute type; will be deleted. Otherwise dsAccessDenied error will be returned.; (defrecord DirDeleteAttributeTypePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (attrType (:pointer :attributetype))         ;   -->    ); ; 	DeleteAttributeValue; (defrecord DirDeleteAttributeValuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   ->    (attr (:pointer :attribute))                 ;   ->    ); ; 	ChangeAttributeValue:; 	currentAttr ==> the attribute to be changed. For ADAS and PAB CreationID is; 	                sufficient; 	newAttr     ==> new value for the attribute. For ADAS and PAB ; 					CreationID field will be set when; 	                the call succeesfully completes; 	; 	aRecord     ==> must contain valid PackedRecordLocationInfo and a CreationID.; ; ; 	; (defrecord DirChangeAttributeValuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   ->    (currentAttr (:pointer :attribute))          ;   ->    (newAttr (:pointer :attribute))              ;   ->    );  VerifyAttributeValue (defrecord DirVerifyAttributeValuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (attr (:pointer :attribute))                 ;   -->    ); ; aRecord must contain valid PackedRLI and a CreationID.; ; The attribute type and value are passed in the attribute structure.  If the; attribute CreationID is non-zero, the server will verify that an attribute with; the specified value and creation number exists in aRecord.  If the attribute; CreationID is zero, the server will verify the attribute by type and value; alone, and return the attribute CreationID in the Attribute struct if the; attribute exists.; ; ; EnumerateAttributeTypesGet:; The following two calls can be used to enumerate the attribute types present in; a specified RecordID.  The first, EnumerateAttributeTypesGet, processes the request; and reads the response into getBuffer, as much as will fit.  A kOCEMoreData error will; be returned if the buffer was not large enough.  After this call completes, the; client can call EnumerateAttributeTypesParse (see below).; ; The user will able to continue from a startingPoint by setting a startingAttrType.; Typically, this should be the last value returned in EnumerateAttributeTypesParse call; when 'kOCEMoreData' is returned.; ; If 'includeStartingPoint' is true when a 'startingAttrType' is specified, the starting value; will be included in the results, if it exists. If this is set to false, this value will not; be included. AttributeTypes following this type will be returned.; (defrecord DirEnumerateAttributeTypesGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (startingAttrType (:pointer :attributetype)) ;   --> starting point    (cReserved :signed-long)                     ;   --     (dReserved :signed-long)                     ;   --     (eReserved :signed-long)                     ;   --     (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (includeStartingPoint :boolean)              ;   --> if true return the attrType specified by starting point    (padByte :signed-byte)                       ;  Byte    (i1Reserved :signed-integer)                 ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    );  The call-back function is defined as follows: (def-mactype :foreachattrtypeprocptr (find-mactype ':pointer));  FUNCTION ForEachAttrType(clientData: LONGINT; (CONST)VAR attrType: AttributeType): BOOLEAN; (def-mactype :foreachattrtypeupp (find-mactype ':pointer))(def-mactype :foreachattrtype (find-mactype ':pointer)); ; EnumerateAttributeTypesParse:; After an EnumerateAttributeTypesGet call has completed, call EnumerateAttributeTypesParse; to parse through the buffer that was filled in EnumerateAttributeTypesGet.  The; toolbox will parse through the buffer and call the call-back routine for; each attribute type in the getBuffer.; ; The client should return false from eachAttrType to continue; processing of the EnumerateAttributeTypesParse request.  Returning true will; terminate the EnumerateAttributeTypesParse request.  The clientData parameter that; you pass in the parameter block will be passed to eachAttrType.; You are free to put anything in clientData - it is intended to allow; you some way to match the call-back to the original call (in case, for; example, you make simultaneous asynchronous calls).; ; For synchronous calls, the call-back routine actually runs as part of the same thread; of execution as the thread that made the EnumerateAttributeTypesParse call.  That means that the; same low-memory globals, A5, stack, etc. are in effect during the call-back; that were in effect when the call was made.  Because of this, the call-back; routine has the same restrictions as the caller of EnumerateAttributeTypesParse.; If EnumerateAttributeTypesParse was not called from interrupt level, then the call-; back routine can allocate memory. For asynchronous calls, call-back routine is; like a ioCompletion except that A5 will be preserved for the application.; (defrecord DirEnumerateAttributeTypesParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   --> Same as DirEnumerateAttributeTypesGetPB    (bReserved :signed-long)                     ;   --     (cReserved :signed-long)                     ;   --     (dReserved :signed-long)                     ;   --     (eachAttrType :pointer)                      ;   -->    (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (iReserved :signed-long)                     ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    ); ; DirAbort:; With this call a user will able to abort an outstanding catalog service call.; A user must pass a pointer to the parameter block for the outstanding call.; In the current version of the product, the toolbox will process this call; for NetSearchADAPDirectoriesGet or FindADAPDirectoryByNetSearch calls and if possible; it will abort. For other calls for ADAP and PAB this will return 'daAbortFailErr'.; For CSAM catalogs, this call will be passed to the corresponding CSAM driver.; The CSAM driver may process this call or may return 'daAbortFailErr'. This call can; be called only in synchronous mode. Since the abort call makes references to fields in; the pb associated with the original call, this pb must not be disposed or or altered if; the original call completes before the abort call has completed.; (defrecord DirAbortPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pb (:pointer :dirparamblock))               ;   --> pb for the call which must be aborted    ); ; AddPseudonym:; An alternate name and type can be added to a given record. If allowDuplicate; is set the name and type will be added even if the same name and type already; exists.; (defrecord DirAddPseudonymPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   --> RecordID to which pseudonym is to be added    (pseudonymName (:pointer :rstring))          ;   --> new name to be added as pseudonym    (pseudonymType (:pointer :rstring))          ;   --> new name to be added as pseudonym    (allowDuplicate :boolean)                    ;   -->    (filler1 :boolean)   ); ; DeletePseudonym:; An alternate name and type for a given record can be deleted.; (defrecord DirDeletePseudonymPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   --> RecordID to which pseudonym to be added    (pseudonymName (:pointer :rstring))          ;   --> pseudonymName to be deleted    (pseudonymType (:pointer :rstring))          ;   --> pseudonymType to be deleted    ); ; 	AddAlias:; 	This call can be used to create an alias  record. The alias; 	can be created either in the same or different cluster. ADAS will not support; 	this call for this release. A new catalog capability flag 'kSupportsAlias' will indicate; 	if the catalog supports this call. PAB's will support this call. For the PAB implementation,; 	this call will create a record with the name and type specified an aRecord.; 	This call works exactly like AddRecord.; 	If 'allowDuplicate' is false and another record with same name and type already exists; 	'daNoDupAllowed' error will be returned.; (defrecord DirAddAliasPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   ->    (allowDuplicate :boolean)                    ;   ->    (filler1 :boolean)   ); ; DirFindValue:; This call can be used to find the occurrence of a value. The value; to be matched is passed in the buffer 'matchingData' field. The current; ADAP/PAB implementation will match a maximum of 32 bytes of data.; For attribute values in the PAB/ADAP implementation, only the first 32 bytes will; be used for comparing the occurrence of data. Search can be restricted to; a particular record and/or attribute type by specifying 'aRecord' or 'aType'.; After finding one occurrence, 'startingRecord' and 'startingAttribute'; can be specified to find the next occurrence of the same value.; 'sortDirection' can be specified with starting values to search forward or backward.; When a matching value is found, the 'recordFound' indicates the reccordID in which the; data occurrence was found, 'attributeFound' indicates the attribute with in which the; matching data was found. ADAP/PAB implementation returns only the type and creationID of; attributes. Catalogs which don't support creationIDs may return the; complete value; hence this call may need a buffer to hold the data. For ADAP/PAB implementations; the user has to make a DirLookup call to get the actual data. 'recordFound' and; 'attributeFound' can be used to initialize 'startingRecord' and 'startingAttribute' to; find the next occurrence of the value.; (defrecord DirFindValuePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRLI (:pointer :packedrli))                 ;   --> an RLI specifying the cluster to be enumerated    (aRecord (:pointer :localrecordid))          ;   --> if not nil, look only in this record    (attrType (:pointer :attributetype))         ;   --> if not nil, look only in this attribute type    (startingRecord (:pointer :localrecordid))   ;   --> record in which to start searching    (startingAttribute (:pointer :attribute))    ;   --> attribute in which to start searching    (recordFound (:pointer :localrecordid))      ;  <--  record in which data was found    (attributeFound :attribute)                  ;  <--  attribute in which data was found    ;;Changing field matchsize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (matchSize :unsigned-long)                   ;   --> length of matching bytes    (matchingData :pointer)                      ;   --> data bytes to be matched in search    (sortDirection :signed-integer)              ;   --> sort direction (forwards or backwards)    ); ; EnumeratePseudonymGet:; This call can be used to enumerate the existing pseudonyms for; a given record specified in 'aRecord'. A starting point can be specified; by 'startingName' and 'startingType'. If the 'includeStartingPoint' boolean; is true and a starting point is specified, the name specified by startingName; and startingType also is returned in the results, if it exists. If this is set to false,; the pseudonym in startingName and Type is not included.; Pseudonyms returned in the 'getBuffer' can be extracted by making an; EnumeratePseudonymParse call. The results will consist of a RecordID with the; name and type of the pseudonym. If the buffer could not hold all the results, then; 'kOCEMoreData' error will be returned. The user will be able to continue the call by; using the last result returned as starting point for the next call.; (defrecord DirEnumeratePseudonymGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (startingName (:pointer :rstring))           ;   -->    (startingType (:pointer :rstring))           ;   -->    (dReserved :signed-long)                     ;   --     (eReserved :signed-long)                     ;   --     (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (includeStartingPoint :boolean)              ;   --> if true return the Pseudonym specified by starting point will be included    (padByte :signed-byte)                       ;  Byte    (i1Reserved :signed-integer)                 ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    );  The call-back function is defined as follows: (def-mactype :foreachrecordidprocptr (find-mactype ':pointer));  FUNCTION ForEachRecordID(clientData: LONGINT; (CONST)VAR recordID: RecordID): BOOLEAN; (def-mactype :foreachrecordidupp (find-mactype ':pointer))(def-mactype :foreachrecordid (find-mactype ':pointer)); ; EnumeratePseudonymParse:; The pseudonyms returned in the 'getBuffer' from the EnumeratePseudonymGet call; can be extracted by using the EnumeratePseudonymParse call. 'eachRecordID'; will be called for each pseudonym.; ; Returning true from any call-back will terminate the EnumeratePseudonymParse call.; ; For synchronous calls, the call-back routine actually runs as part of the same thread; of execution as the thread that made the EnumeratePseudonymParse call.  That means that the; same low-memory globals, A5, stack, etc. are in effect during the call-back; that were in effect when the call was made.  Because of this, the call-back; routine has the same restrictions as the caller of EnumeratePseudonymParse:; if EnumeratePseudonymParse was not called from interrupt level, then the call-; back routine can allocate memory. For asynchronous calls, call-back routine is; like a ioCompletion except that A5 will be preserved for the application.; (defrecord DirEnumeratePseudonymParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   --> same as DirEnumerateAliasesGetPB    (bReserved :signed-long)                     ;   --     (cReserved :signed-long)                     ;   --     (eachRecordID :pointer)                      ;   -->    (eReserved :signed-long)                     ;   --     (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (iReserved :signed-long)                     ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    );  GetNameAndType (defrecord DirGetNameAndTypePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    ); ; aRecord must contain valid RLI and a CreationID.  It; must also contain pointers to maximum-length RStrings (name and type fields); in which will be returned the record's distinguished name and type.; ; ; SetNameAndType:; This call can be used to change a name and type for a record. The record; to be renamed is specified using 'aRecord'.; 'newName' and 'newType' indicate the name and type to be set.; 'allowDuplicate' if true indicates that name is to be set even if another; name and type exactly matches the newName and newType specified.; ; 'newName' and 'newType' are required since the catalogs not supporting; CreationID require name and type fields in the recordID to identify a given; record.; (defrecord DirSetNameAndTypePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (allowDuplicate :boolean)                    ;   -->    (padByte :signed-byte)                       ;  Byte    (newName (:pointer :rstring))                ;   --> new name for the record    (newType (:pointer :rstring))                ;   --> new type for the record    ); ; DirGetMetaRecordInfo: This call can be made to obtain; the MetaRecordInfo for a given record. Information returned; is 16 bytes of OPAQUE information about the record.; (defrecord DirGetRecordMetaInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -->    (metaInfo :dirmetainfo)                      ;  <--     ); ; DirGetDNodeMetaInfo: This call can be made to obtain; the DNodeMetaInfo for a given Packed RLI. Information returned; is 16 bytes of OPAQUE information about the DNode.; (defrecord DirGetDNodeMetaInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pRLI (:pointer :packedrli))                 ;   -->    (metaInfo :dirmetainfo)                      ;  <--     ); ; EnumerateDirectoriesGet:; A user can enumerate all the catalogs installed. This includes installed; ADAP and CSAM catalogs. The user can specify a signature as input to restrict; the results. kDirADAPKind will return only ADAP catalogs, kDirDSAMKind; will return all CSAM catalogs. kDirAllKinds will get both ADAP & CSAM catalogs.; A specific signature (e.g. X.500) may be used to get catalogs with an X.500 signature.; The information for each catalog returned will have directoryName, discriminator and features.; ; If the user receives 'noErr' or 'kOCEMoreData', the buffer will contain valid results. A user; can extract the results in the 'getBuffer' by making an DirEnumerateDirectories call.; ; If 'kOCEMoreData' is received, the user can continue enumeration by using the last catalog and; discriminator as startingDirectoryName and staringDirDiscriminator in the next call.; ; If 'includeStartingPoint' is true and a starting point is specified,; the staring point will be returned in the result. If false, it is not included.; (defrecord DirEnumerateDirectoriesGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryKind :signed-long)                 ;   --> enumerate catalogs bearing this signature    (startingDirectoryName (:pointer :directoryname));   --> staring catalog name    (startingDirDiscriminator :dirdiscriminator) ;   --> staring catalog discriminator    (eReserved :signed-long)                     ;   --     (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (includeStartingPoint :boolean)              ;   --> if true return the catalog specified by starting point    (padByte :signed-byte)                       ;  Byte    (i1Reserved :signed-integer)                 ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    )(def-mactype :foreachdirectoryprocptr (find-mactype ':pointer));  FUNCTION ForEachDirectory(clientData: LONGINT; (CONST)VAR dirName: DirectoryName; (CONST)VAR discriminator: DirDiscriminator; features: DirGestalt): BOOLEAN; (def-mactype :foreachdirectoryupp (find-mactype ':pointer))(def-mactype :foreachdirectory (find-mactype ':pointer)); ; EnumerateDirectoriesParse:; The catalog info returned in 'getBuffer' from the EnumerateDirectoriesGet call; can be extracted using the EnumerateDirectoriesParse call. 'eachDirectory' will; be called for each catalog.; ; Returning true from any call-back will terminate the EnumerateDirectoriesParse call.; ; For synchronous calls, the call-back routine actually runs as part of the same thread; of execution as the thread that made the EnumerateDirectoriesParse call.  That means that the; same low-memory globals, A5, stack, etc. are in effect during the call-back; that were in effect when the call was made.  Because of this, the call-back; routine has the same restrictions as the caller of EnumerateDirectoriesParse:; if EnumerateDirectoriesParse was not called from interrupt level, then the call-; back routine can allocate memory. For asynchronous calls, call-back routine is; like a ioCompletion except that A5 will be preserved for the application.; ; eachDirectory will be called each time to return to the client a; DirectoryName, DirDiscriminator, and features for that catalog.; (defrecord DirEnumerateDirectoriesParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aReserved :signed-long)                     ;   --     (bReserved :signed-long)                     ;   --     (cReserved :signed-long)                     ;   --     (dReserved :signed-long)                     ;   --     (eachDirectory :pointer)                     ;   -->    (fReserved :signed-long)                     ;   --     (gReserved :signed-long)                     ;   --     (hReserved :signed-long)                     ;   --     (iReserved :signed-long)                     ;   --     (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    ); ; The Following five call are specific to ADAP Catalogs. Toolbox; remembers a list of catalogs across boots. If any catalog service; call is intended for a ADAP catalog, then it must be in the list.; In order for managing this list, A client (Probably DE will use these; calls.; DirAddADAPDirectoryPB: Add a new ADAP catalog to the list.; DirRemoveADAPDirectory: Remove a ADAP catalog from the list.; DirNetSearchADAPDirectoriesGet:   search an internet for adas catalogs.; DirNetSearchADAPDirectoriesParse: extract the results obtained NetSearchADAPDirectoriesGet.; DirFindADAPDirectoryByNetSearch: Find a specified catalog through net search.; ; ; NetSearchADAPDirectoriesGet:; This call can be used to make a network wide search for finding ADAP catalogs.; This call will be supported only by 'ADAP' and involve highly expensive; network operations, so the user is advised to use utmost discretion before; making this call. The results will be collected in the 'getbuffer' and can be; extracted using NetSearchADAPDirectoriesParse call. The directoryName,; the directoryDiscriminator, features and serverHint (AppleTalk address for; a PathFinder serving that catalog) are collected for each catalog found; on the network. If buffer is too small to hold all the catalogs found on; the network, a 'kOCEMoreData' error will be returned.; (defrecord DirNetSearchADAPDirectoriesGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    (cReserved :signed-long)                     ;   --     )(def-mactype :foreachadapdirectoryprocptr (find-mactype ':pointer));  FUNCTION ForEachADAPDirectory(clientData: LONGINT; (CONST)VAR dirName: DirectoryName; (CONST)VAR discriminator: DirDiscriminator; features: DirGestalt; serverHint: AddrBlock): BOOLEAN; (def-mactype :foreachadapdirectoryupp (find-mactype ':pointer))(def-mactype :foreachadapdirectory (find-mactype ':pointer)); ; DirNetSearchADAPDirectoriesParse:; This call can be used to extract the results obtained in the 'getBuffer'.; The directoryName, directoryDiscriminator, features and; serverHint (AppleTalk address for a PathFinder serving that catalog) are; returned in each call-back. These values may be used to make an; AddADAPDirectory call.; ; Returning TRUE from any call-back will terminate the NetSearchADAPDirectoriesParse request.; ; For synchronous calls, the call-back routine actually runs as part of the same thread; of execution as the thread that made the DirNetSearchADAPDirectoriesParse call. That means that the; same low-memory globals, A5, stack, etc. are in effect during the call-back; that were in effect when the call was made.  Because of this, the call-back; routine has the same restrictions as the caller of DirNetSearchADAPDirectoriesParse:; if DirNetSearchADAPDirectoriesParse was not called from interrupt level, then the call-; back routine can allocate memory. For asynchronous calls, call-back routine is; like a ioCompletion except that A5 will be preserved for the application.; (defrecord DirNetSearchADAPDirectoriesParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (getBuffer :pointer)                         ;   -->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   -->    (eachADAPDirectory :pointer)                 ;   -->    ); ; DirFindADAPDirectoryByNetSearch:; This call can be used to make a network wide search to find an ADAP catalog.; This call will be supported only by 'ADAP' and involves highly expensive; network operations, so the user is advised to use utmost discretion before; making this call. The catalog is specified using directoryName and discriminator.; If 'addToOCESetup' is true, the catalog will be automatically added to the setup; list and will be visible through the EnumerateDirectories call and also; also a creationID to the directoryRecord will be returned.; If this parameter is set to 'false', the catalog will be added to temporary list; and will be available for making other catalog service calls. The catalogs; which are not in the preference catalog list will not be visible through the; EnumerateDirectories call.; (defrecord DirFindADAPDirectoryByNetSearchPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> discriminate between dup catalog names    (addToOCESetup :boolean)                     ;   --> add this catalog to OCE Setup List    (padByte :signed-byte)                       ;  Byte    (directoryRecordCID :creationid)             ;  <--  creationID for the catalog record    ); ; DirAddADAPDirectory:; The catalog specified by 'directoryName' and 'discriminator' will be; added to the list of catalogs maintained by the Toolbox. Once added,; the catalog is available across boots, until the catalog is removed; explicitly through a DirRemoveADAPDirectory call.; If 'serverHint' is not nil, the address provided will be used; to contact a PathFinder for the catalog specified.; If 'serverHint' is nil or does not point to a valid PathFinder server; for that catalog, this call will fail.; If 'addToOCESetup' is true, the catalog will be automatically added to the setup; catalog list and will be visible through EnumerateDirectories calls and; also a creationID to the directoryRecord will be returned.; If this parameter is set to 'false', catalog will be added to temprary list; and will be available for making other catalog service calls. The catalogs; which are not in the setup  list will not be visible through; EnumerateDirectories call.; (defrecord DirAddADAPDirectoryPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> discriminate between dup catalog names    (addToOCESetup :boolean)                     ;   --> add this catalog to OCE Setup    (padByte :signed-byte)                       ;  Byte    (directoryRecordCID :creationid)             ;  <--  creationID for the catalog record    ); ; GetDirectoryInfo:; DirGetDirectoryInfo will do:; ; If a 'dsRefNum' is non-Zero, the catalog information for; 	the corresponding  PAB will be  returned.;  If 'dsRefNum' is zero and 'serverHint' is non-zero, If the;  'serverHint' points to a valid ADAP Catalog Server(Path Finder),;  the catalog information (i.e. directoryName, discriminator, features);  for that catalog will be returned.; 	If a  valid catalog name and discriminator are provided; 	features (Set of capability flags) for that catalog will be returned.; (defrecord DirGetDirectoryInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;  <--> descriminate between dup catalog names    (features :signed-long)                      ;  <--  capability bit flags    ); ;  * Note on Access Controls:;  * Access control is based on a list model.;  * You can get access controls list which gives dsObject and accMask for each dsObject.;  * GetAccessControl can be limited to currently supplied identity by setting forCurrentUserOnly.;  * There are special DSObjects are defined in ADASTypes.h for each of the category;  * supported in ADAS Catalogs. (kOwner, kFriends, kAuthenticatedToCluster, ;  * kAuthenticatedToDirectory, kGuest) and DUGetActlDSSpec call can be used;  * to obtain appropraiate DSSpec before making set calls to ADAS catalogs.;  *;  ; ; 	GetDNodeAccessControlGet:; 	This call can be done to get back access control list for a DNode.; 	pRLI -> RLI of the DNode whose access control list is sought; 	curUserAccMask -> If this is 'true', Access controls for the user specified by; 	                  the identity parameter will be returned other wise entire list; 					  will be returned.; 	startingDsObj  -> If this is not nil, list should be started after this object.; 	startingPointInclusive -> If staringDsObj is specified, include that in the returned; 	                          results.; 							  ; 	The results will be collected in the 'getBuffer' supplied by the user.; 	If buffer can not hold all the data returned 'daMoreData' error will be returned.; 	 ; 	If user receives 'noErr' or 'daMoreData', buffer will contain valid results. A user; 	can extract the results in the 'getBuffer' by making 'DsGetDNodeAccessControlParse' call.; 	; 	Results returned for each DSObject will contain DSSpecPtr and three sets of access mask. ; ; (defrecord DirGetDNodeAccessControlGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pRLI (:pointer :packedrli))                 ;   -> RLI of the cluster whose access control list is sought     (bReserved :signed-long)                     ;   -- unused    (cReserved :signed-long)                     ;   -- unused    (dReserved :signed-long)                     ;   -- unused    (eResreved :signed-long)                     ;  -->    (forCurrentUserOnly :boolean)                ;  -->     (filler1 :boolean)   (startingPoint (:pointer :dsspec))           ;  --> starting Point    (includeStartingPoint :boolean)              ;   -> if true return the DsObject ; 																specified in starting point    (filler2 :boolean)   (getBuffer :pointer)                         ; 	->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   ->    );  The Access Control call-back function is defined as follows: (def-mactype :foreachdnodeaccesscontrolprocptr (find-mactype ':pointer));  FUNCTION ForEachDNodeAccessControl(clientData: LONGINT; (CONST)VAR dsObj: DSSpec; activeDnodeAccMask: AccessMask; defaultRecordAccMask: AccessMask; defaultAttributeAccMask: AccessMask): BOOLEAN; (def-mactype :foreachdnodeaccesscontrolupp (find-mactype ':pointer))(def-mactype :foreachdnodeaccesscontrol (find-mactype ':pointer)); ; 	GetDNodeAccessControlParse:; 	After an GetDNodeAccessControlGet call has completed, ; 	call GetDNodeAccessControlParse to parse through the buffer that; 	that was filled in GetDNodeAccessControlGet.; 	; 	'eachObject' will be called each time to return to the client a; 	DsObject and a set of three accMasks (three long words) for that object.; 	Acceesmasks returned apply to the dsObject in the callback :; 	1. Currently Active Access mask for the specified DNode.; 	2. Default Access mask for any Record in the DNode; 	3. Default Access mask for any Attribute in the DNode; 	The clientData parameter that you pass in the parameter block will be passed; 	to 'eachObject'.  You are free to put anything in clientData - it is intended; 	to allow you some way to match the call-back to the original call (for; 	example, you make more then one aysynchronous GetDNodeAccessControlGet calls and you want to; 	associate returned results in some way).; 	; 	The client should return FALSE from 'eachObject' to continue; 	processing of the GetDNodeAccessControlParse request.  Returning TRUE will; 	terminate the GetDNodeAccessControlParse request.; ; 	For synchronous calls, the call-back routine actually runs as part of the same thread ; 	of execution as the thread that made the GetDNodeAccessControlParse call.  That means that the; 	same low-memory globals, A5, stack, etc. are in effect during the call-back; 	that were in effect when the call was made.  Because of this, the call-back; 	routine has the same restrictions as the caller of GetDNodeAccessControlParse:; 	if GetDNodeAccessControlParse was not called from interrupt level, then the call-; 	back routine can allocate memory. For asynchronous calls, call-back routine is; 	like a ioCompletion except that A5 will be preserved for the application.; ; ; (defrecord DirGetDNodeAccessControlParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pRLI (:pointer :packedrli))                 ;   -> RLI of the cluster     (bReserved :signed-long)                     ;   -- unused    (cReserved :signed-long)                     ;   -- unused    (dReserved :signed-long)                     ;   -- unused    (eachObject :pointer)                        ;  -->    (forCurrentUserOnly :boolean)                ;  -->     (filler1 :boolean)   (startingPoint (:pointer :dsspec))           ;  --> starting Point    (includeStartingPoint :boolean)              ;   -> if true return the record ; 														specified in starting point    (filler2 :boolean)   (getBuffer :pointer)                         ; 	->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   ->    ); ; 	GetRecordAccessControlGet:; 	This call can be done to get back access control list for a RecordID.; 	aRecord -> RecordID to which access control list is sought; 	curUserAccMask -> If this is 'true', Access controls for the user specified by; 	                  the identity parameter will be returned other wise entire list; 					  will be returned.; 	startingDsObj  -> If this is not nil, list should be started after this object.; 	startingPointInclusive -> If staringDsObj is specified, include that in the returned; 	                          results.; 							  ; 	The results will be collected in the 'getBuffer' supplied by the user.; 	If buffer can not hold all the data returned 'daMoreData' error will be returned.; 	 ; 	If user receives 'noErr' or 'daMoreData', buffer will contain valid results. A user; 	can extract the results in the 'getBuffer' by making 'DsGetDNodeAccessControlParse' call.; 	; 	Results returned for each DSObject will contain DSSpecPtr and accMask. ; ; (defrecord DirGetRecordAccessControlGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -> RecordID to which access control list is sought list is sought     (bReserved :signed-long)                     ;   -- unused    (cReserved :signed-long)                     ;   -- unused    (dReserved :signed-long)                     ;   -- unused    (eResreved :signed-long)                     ;  -->    (forCurrentUserOnly :boolean)                ;  -->     (filler1 :boolean)   (startingPoint (:pointer :dsspec))           ;  --> starting Point    (includeStartingPoint :boolean)              ;   -> if true return the DsObject ; 																specified in starting point    (filler2 :boolean)   (getBuffer :pointer)                         ; 	->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   ->    );  The Access Control call-back function is defined as follows: (def-mactype :foreachrecordaccesscontrolprocptr (find-mactype ':pointer));  FUNCTION ForEachRecordAccessControl(clientData: LONGINT; (CONST)VAR dsObj: DSSpec; activeDnodeAccMask: AccessMask; activeRecordAccMask: AccessMask; defaultAttributeAccMask: AccessMask): BOOLEAN; (def-mactype :foreachrecordaccesscontrolupp (find-mactype ':pointer))(def-mactype :foreachrecordaccesscontrol (find-mactype ':pointer)); ; 	GetRecordAccessControlParse:; 	After an GetRecordAccessControlGet call has completed, ; 	call GetRecordAccessControlParse to parse through the buffer that; 	that was filled in GetRecordAccessControlGet.; 	; 	'eachObject' will be called each time to return to the client a; 	DsObject and a set of three accMasks (three long words) for that object.; 	Acceesmasks returned apply to the dsObject in the callback :; 	1. Active Access mask for the DNode Containing the Record.; 	2. Active Access mask for the Record specified.; 	3. Defualt Access mask for Attributes in the record.; 	The clientData parameter that you pass in the parameter block will be passed; 	to 'eachObject'.  You are free to put anything in clientData - it is intended; 	to allow you some way to match the call-back to the original call (for; 	example, you make more then one aysynchronous GetRecordAccessControlGet calls and you want to; 	associate returned results in some way).; 	; 	The client should return FALSE from 'eachObject' to continue; 	processing of the GetRecordAccessControlParse request.  Returning TRUE will; 	terminate the GetRecordAccessControlParse request.; ; 	For synchronous calls, the call-back routine actually runs as part of the same thread ; 	of execution as the thread that made the GetRecordAccessControlParse call.  That means that the; 	same low-memory globals, A5, stack, etc. are in effect during the call-back; 	that were in effect when the call was made.  Because of this, the call-back; 	routine has the same restrictions as the caller of GetRecordAccessControlParse:; 	if GetRecordAccessControlParse was not called from interrupt level, then the call-; 	back routine can allocate memory. For asynchronous calls, call-back routine is; 	like a ioCompletion except that A5 will be preserved for the application.; ; ; (defrecord DirGetRecordAccessControlParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -> RecordID to which access control list is sought list is sought     (bReserved :signed-long)                     ;   -- unused    (cReserved :signed-long)                     ;   -- unused    (dReserved :signed-long)                     ;   -- unused    (eachObject :pointer)                        ;  -->    (forCurrentUserOnly :boolean)                ;  -->     (filler1 :boolean)   (startingPoint (:pointer :dsspec))           ;  --> starting Point    (includeStartingPoint :boolean)              ;   -> if true return the record ; 														specified in starting point    (filler2 :boolean)   (getBuffer :pointer)                         ; 	->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   ->    ); ; 	GetAttributeAccessControlGet:; 	This call can be done to get back access control list for a attributeType with in a RecordID.; 	aRecord -> RecordID to which access control list is sought; 	aType	-> Attribute Type to which access controls are sought; 	curUserAccMask -> If this is 'true', Access controls for the user specified by; 	                  the identity parameter will be returned other wise entire list; 					  will be returned.; 	startingDsObj  -> If this is not nil, list should be started after this object.; 	startingPointInclusive -> If staringDsObj is specified, include that in the returned; 	                          results.; 							  ; 	The results will be collected in the 'getBuffer' supplied by the user.; 	If buffer can not hold all the data returned 'daMoreData' error will be returned.; 	 ; 	If user receives 'noErr' or 'daMoreData', buffer will contain valid results. A user; 	can extract the results in the 'getBuffer' by making 'DsGetDNodeAccessControlParse' call.; 	; 	Results returned for each DSObject will contain DSSpecPtr and accMask. ; ; (defrecord DirGetAttributeAccessControlGetPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -> RecordID to which access control list is sought list is sought     (aType (:pointer :attributetype))            ;   -> Attribute Type to which access controls are sought             (cReserved :signed-long)                     ;   -- unused    (dReserved :signed-long)                     ;   -- unused    (eResreved :signed-long)                     ;  -->    (forCurrentUserOnly :boolean)                ;  -->     (filler1 :boolean)   (startingPoint (:pointer :dsspec))           ;  --> starting Point    (includeStartingPoint :boolean)              ;   -> if true return the DsObject ; 																specified in starting point    (filler2 :boolean)   (getBuffer :pointer)                         ; 	->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   ->    );  The Access Control call-back function is defined as follows: (def-mactype :foreachattributeaccesscontrolprocptr (find-mactype ':pointer));  FUNCTION ForEachAttributeAccessControl(clientData: LONGINT; (CONST)VAR dsObj: DSSpec; activeDnodeAccMask: AccessMask; activeRecordAccMask: AccessMask; activeAttributeAccMask: AccessMask): BOOLEAN; (def-mactype :foreachattributeaccesscontrolupp (find-mactype ':pointer))(def-mactype :foreachattributeaccesscontrol (find-mactype ':pointer)); ; 	GetAttributeAccessControlParse:; 	After an GetAttributeAccessControlGet call has completed, ; 	call GetAttributeAccessControlParse to parse through the buffer that; 	that was filled in GetAttributeAccessControlGet.; 	; 	'eachObject' will be called each time to return to the client a; 	DsObject and a set of three accMasks (three long words) for that object.; 	Acceesmasks returned apply to the dsObject in the callback :; 	1. Active Access mask for the DNode Containing the Attribute.; 	2. Active Access mask for the Record in the Containing the Attribute.; 	3. Active Access mask for the specified Attribute.; 	The clientData parameter that you pass in the parameter block will be passed; 	to 'eachObject'.  You are free to put anything in clientData - it is intended; 	to allow you some way to match the call-back to the original call (for; 	example, you make more then one aysynchronous GetAttributeAccessControlGet calls and you want to; 	associate returned results in some way).; 	; 	The client should return FALSE from 'eachObject' to continue; 	processing of the GetAttributeAccessControlParse request.  Returning TRUE will; 	terminate the GetAttributeAccessControlParse request.; ; 	For synchronous calls, the call-back routine actually runs as part of the same thread ; 	of execution as the thread that made the GetAttributeAccessControlParse call.  That means that the; 	same low-memory globals, A5, stack, etc. are in effect during the call-back; 	that were in effect when the call was made.  Because of this, the call-back; 	routine has the same restrictions as the caller of GetAttributeAccessControlParse:; 	if GetAttributeAccessControlParse was not called from interrupt level, then the call-; 	back routine can allocate memory. For asynchronous calls, call-back routine is; 	like a ioCompletion except that A5 will be preserved for the application.; ; ; (defrecord DirGetAttributeAccessControlParsePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (aRecord (:pointer :recordid))               ;   -> RecordID to which access control list is sought list is sought     (aType (:pointer :attributetype))            ;   -> Attribute Type to which access controls are sought             (cReserved :signed-long)                     ;   -- unused    (dReserved :signed-long)                     ;   -- unused    (eachObject :pointer)                        ;  -->    (forCurrentUserOnly :boolean)                ;  -->     (filler1 :boolean)   (startingPoint (:pointer :dsspec))           ;  --> starting Point    (includeStartingPoint :boolean)              ;   -> if true return the record ; 														specified in starting point    (filler2 :boolean)   (getBuffer :pointer)                         ; 	->    ;;Changing field getbuffersize from signed-long to unsigned-long to match C header (pretty-darn-sure)   (getBufferSize :unsigned-long)               ;   ->    ); ; MapPathNameToDNodeNumber:; This call maps a given PathName within a catalog to its DNodeNumber.; (defrecord DirMapPathNameToDNodeNumberPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> discriminator    (dNodeNumber :signed-long)                   ;  <--  dNodenumber to the path    (path (:pointer :packedpathname))            ;   --> Path Name to be mapped    ); ; PathName in the path field will be mapped to the cooresponding dNodeNumber and; returned in the DNodeNumber field. directoryName and descriminator Fields are; ignored. DSRefNum is used to identify the catalog.; ; ; MapDNodeNumberToPathName:; This call will map a given DNodeNumber with in a catalog to the; corresponding PathName.; (defrecord DirMapDNodeNumberToPathNamePB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> discriminator    (dNodeNumber :signed-long)                   ;   --> dNodenumber to be mapped    (path (:pointer :packedpathname))            ;  <--  Packed Path Name returned    ;;Changing field lengthofpathname from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (lengthOfPathName :unsigned-word)            ;   --> length of packed pathName structure   ); ; dNodeNumber in the DNodeNumber field will be mapped to the cooresponding; pathName and returned in the PackedPathName field.; lengthOfPathName is to be set the length of pathName structure.; If length of PackedPathName is larger then the lengthOfPathName, kOCEMoreData; OSErr will be returned.; ; ; GetLocalNetworkSpec:; This call will return the Local NetworkSpec. Client should supply; an RString big enough to hold the NetworkSpec.; (defrecord DirGetLocalNetworkSpecPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> discriminator    (networkSpec (:pointer :networkspec))        ;  <--  NetworkSpec    ); ; PathName in the path field must be set to nil. internetName should be large; enough to hold the internetName. InterNetname returned indicates path finder's; local internet (configured by administrator).; ; ; GetDNodeInfo:; This call will return the information (internetName and descriptor); for the given RLI of a DNode.; (defrecord DirGetDNodeInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pRLI (:pointer :packedrli))                 ;   --> packed RLI whose info is requested    (descriptor :signed-long)                    ;  <--  dNode descriptor    (networkSpec (:pointer :networkspec))        ;  <--  cluster's networkSpec if kIsCluster    ); ; If DnodeNumber is set to a non zero value, path should be set to nil.; if DnodeNumber is set to zero, pathName should point to a packed path name.; internetName should be large enough to hold; the internetName. (If the internetName is same as the one got by; GetLocalInternetName call, it indicates cluster is reachable  without; forwarders, --> Tell me if I am wrong); ; ; DirCreatePersonalDirectory:; A new  personal catalog can be created by specifying an FSSpec for; the file. If a file already exists dupFNErr will be returned. This call is; supported 'synchronous' mode only.; (defrecord DirCreatePersonalDirectoryPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (fsSpec (:pointer :fsspec))                  ;   --> FSSpec for the Personal Catalog    (fdType :ostype)                             ;   --> file type for the Personal Catalog    (fdCreator :ostype)                          ;   --> file creator for the Personal Catalog    ); ; DirOpenPersonalDirectory:; An existing personal catalog can be opened using this call.; User can specify the personal catalog by FSSpec for the AddressBook file.; 'accessRequested' field specifies open permissions. 'fsRdPerm'  & 'fsRdWrPerm'; are the only accepted open modes for the address book.; When the call completes successfully, a dsRefNum will be returned. The 'dsRefNum'; field is in the DSParamBlockHeader. In addittion 'accessGranted' indicates; actual permission with personal catalog is opened and 'features' indicate the capabilty flags; associated with the personal catalog.; This call is supported 'synchronous' mode only.; (defrecord DirOpenPersonalDirectoryPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (fsSpec (:pointer :fsspec))                  ;   --> Open an existing Personal Catalog    (accessRequested :character)                 ;   --> Open: permissions Requested(byte)   (accessGranted :character)                   ;   <-- Open: permissions (byte) (Granted)   (features :signed-long)                      ;  <--  features for Personal Catalog    ); ; DirClosePersonalDirectory: This call lets a client close AddressBook opened by DirOpenPersonalDirectory.; The Personal Catalog specified by the 'dsRefNum' will be closed.; This call is supported 'synchronous' mode only.; (defrecord DirClosePersonalDirectoryPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   ); ; DirMakePersonalDirectoryRLI: With this call a client can make an RLI; for a Personal Catalog opened by DirOpenPersonalDirectory Call.; A packed RLI is created for the Personal Catalog specified by the 'dsRefNum'.; If a client has a need to make the AddressBook reference to persistent; acrross boots it should make use of this call. In the current implementaion; PackedRLI has an embeeded System7.0 'alias'. If in later time; If client has a need to make reference to the AddressBook, it must use; ADAPLibrary call 'DUExtractAlias' and resole the 'alias' to 'FSSpec' and; make DirOpenPersonalDirectory call to get a 'dsRefNum'.;   'fromFSSpec'			FSPecPtr from which relative alias to be created. If nil,; 						absolute alias is created.;  'pRLIBufferSize' indicates the size of buffer pointed by 'pRLI';  'pRLISize'	indicates the actual length of 'pRLI'. If the call; 						fails with 'kOCEMoreData' error a client can reissue; 					this call with a larger buffer of this length.;   'pRLI' is pointer to the buffer in which 'PackedRLI' is;   returned.; This call is supported in 'synchronous' mode only.; (defrecord DirMakePersonalDirectoryRLIPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (fromFSSpec (:pointer :fsspec))              ;   --> FSSpec for creating relative alia    ;;Changing field prlibuffersize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (pRLIBufferSize :unsigned-word)              ;   --> Length of 'pRLI' buffer    ;;Changing field prlisize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (pRLISize :unsigned-word)                    ;  <--  Length of actual 'pRLI'    (pRLI (:pointer :packedrli))                 ;  <--  pRLI for the specified AddressBook    ); ****************************************************************************; The calls described below apply only for CSAM Drivers:; ; The following three calls provide capability to Install/Remove a CSAM at RunTime.; 	DirAddDSAM; 	DirRemoveDSAM; 	DirInstantiateDSAM; ; The following two calls provide capability to Install/Remove a CSAM Catalog at RunTime.; 	DirAddDSAMDirectory; 	DirRemoveDirectory; ; DirGetDirectoryIcon call is used by clients to get any special icon associated; with a CSAM catalog.; ; ****************************************************************************; ; DirAddDSAM: This call can be used to inorm the availability of a CSAM file; after discovering the CSAM file.; 	dsamName -> is generic CSAM name e.g. Untitled X.500 directory; 	dsamSignature -> could be generic CSAM kind e.g. 'X500'.; 	fsSpec -> is the FileSpec for the file containing CSAM resources.; If the call is successfull 'DSAMRecordCID' will be returned. If the; call returns 'daDSAMRecordCIDExists', record was already there and; 'dsamRecordCID' will be returned.; This call can be done only in synchronous mode.; (defrecord DirAddDSAMPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (dsamRecordCID :creationid)                  ;  <--  CreationID for the CSAM record    (dsamName (:pointer :rstring))               ;   --> CSAM name    (dsamKind :signed-long)                      ;   --> CSAM kind    (fsSpec (:pointer :fsspec))                  ;   --> FSSpec for the file containing CSAM    ); ; DirInstantiateDSAM: This call should be used by the CSAM driver in response; Driver Open call to indicate the toolbox about the availability of the CSAM.; 	dsamName -> is generic CSAM name e.g. Untitled X.500 directory; 	dsamKind -> could be generic CSAM kind e.g. 'X500'.; 	dsamData -> pointer to private DSAMData. This will be paased back to the CSAM; 	when the CSAM functions (DSAMDirProc,DSAMDirParseProc, DSAMAuthProc) are called.; 	CSAM should already be setup using DirAddDSAM call.; 	DSAMDirProc -> This procedure will be called when  any catalog service; 	call intended for the CSAM (other then parse calls); 	DSAMDirParseProc -> This procedure will be called when any of the parse calls; 	are called.; 	DSAMAuthProc -> This procedure will be called when any of the Authentication Calls; 	are made to the CSAM. If the CSAM does not support authentication, this can be nil.; This call can be done only in synchronous mode.; (def-mactype :dsamdirprocptr (find-mactype ':pointer));  FUNCTION DSAMDir(dsamData: Ptr; paramBlock: DirParamBlockPtr; async: BOOLEAN): OSErr; (def-mactype :dsamdirupp (find-mactype ':pointer))(def-mactype :dsamdirproc (find-mactype ':pointer))(def-mactype :dsamdirparseprocptr (find-mactype ':pointer));  FUNCTION DSAMDirParse(dsamData: Ptr; paramBlock: DirParamBlockPtr; async: BOOLEAN): OSErr; (def-mactype :dsamdirparseupp (find-mactype ':pointer))(def-mactype :dsamdirparseproc (find-mactype ':pointer))(def-mactype :dsamauthprocptr (find-mactype ':pointer));  FUNCTION DSAMAuth(dsamData: Ptr; pb: AuthParamBlockPtr; async: BOOLEAN): OSErr; (def-mactype :dsamauthupp (find-mactype ':pointer))(def-mactype :dsamauthproc (find-mactype ':pointer))(defrecord DirInstantiateDSAMPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (dsamName (:pointer :rstring))               ;   --> dsamName name    (dsamKind :signed-long)                      ;   --> DSAMKind    (dsamData :pointer)                          ;   --> dsamData     (dsamDirProc :pointer)                       ;   --> of type DSAMDirProc: for catalog service calls    (dsamDirParseProc :pointer)                  ;   --> of type DSAMDirParseProc: for catalog service parse calls    (dsamAuthProc :pointer)                      ;   --> of type DSAMAuthProc: for authetication service calls    ); ; DirRemoveDSAM: This call can be used to remove  a CSAM file from the OCE Setup.; 	dsamRecordCID -> is the creationID of the CSAM record.; This call can be made only in synchronous mode.; (defrecord DirRemoveDSAMPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (dsamRecordCID :creationid)                  ;  <--  CreationID for the CSAM record    ); ; DirAddDSAMDirectory: This call can be used to inorm the availability of a CSAM catalog.; 	dsamRecordCID ->  recordID for the CSAM serving this catalog; 	directoryName ->  name of the catalog; 	discriminator -> discriminator for the catalog; 	directoryRecordCID -> If the call is successful, creationID for the record will; 							be returned.; (defrecord DirAddDSAMDirectoryPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (dsamRecordCID :creationid)                  ;   --> CreationID for the CSAM record    (directoryName (:pointer :directoryname))    ;   --> catalog name    (discriminator :dirdiscriminator)            ;   --> catalog discriminator    (features :signed-long)                      ;   --> capabilty flags for the catalog    (directoryRecordCID :creationid)             ;  <--  creationID for the catalog record    ); ; DirRemoveDirectory: This call can be used to inform the toolbox that; catalog specified by 'directoryRecordCID'; (defrecord DirRemoveDirectoryPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (directoryRecordCID :creationid)             ;   --> creationID for the catalog record    ); ;  * DSGetExtendedDirectoriesInfo::  This call can be used to get;  * the information of various foreign catalogs supported.;  * Typically a DE Template  may make this call to create a;  * Address template or a Gateway may make this call to findout;  * catalog name space in which MSAM may would support. ;  * Client will supply a buffer pointed by 'bufferPtr' of size 'bufferLength'. ;  * When the call completes with 'daMoreData' error, client can examine 'totalEntries';  * returned and reissue the call with increaing buffer.;  * Toolbox will findout the private information of each of the Foreign Catalogs;  * by polling CSAM's, Gateways, and MnMServers. The Information returned;  * for each catalog will be packed in the format: ;  * typedef struct EachDirectoryData (;  *  PackedRLI						pRLI;	       //  packed RLI for the catalog;  *  OSType							entnType; 	   //  Entn Type;  *  long							hasMailSlot;   //  If this catalog has mail slot this will be 1 otherwise zero;  *	ProtoRString					RealName;      //  Packed RString for Real Name (padded to even boundary) ;  *	ProtoRString					comment;       //  Packed RString holding any comment for Display (padded to even boundary);  *	long                			length;        //  data length;  *	char                			data[length];  //  data padded to even boundary;  * );;  *;  *;  *;  * typedef struct myData (;  *      EachDirectoryData	data[numberOfEntries];    // data packed in the above format;  *	);;  *;  (defrecord DirGetExtendedDirectoriesInfoPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (buffer :pointer)                            ;   --> Pointer to a buufer where data will be returned    ;;Changing field buffersize from signed-long to unsigned-long to match C header (pretty-sure)   (bufferSize :unsigned-long)                  ;   --> Length of the buffer, Length of actual data will be returned here    ;;Changing field totalentries from signed-long to unsigned-long to match C header (pretty-darn-sure)   (totalEntries :unsigned-long)                ;  <--  Total Number of Catalogs found    ;;Changing field actualentries from signed-long to unsigned-long to match C header (pretty-darn-sure)   (actualEntries :unsigned-long)               ;  <--  Total Number of Catalogs entries returned    ); ; DirGetDirectoryIconPB: With this call a client can find out about; the icons supported by the Catalog.; Both ADAP and Personal Catalog will not support this call for now.; A CSAM can support a call so that DE Extension can use this; call to find appropriate Icons.; ; Returns kOCEBufferTooSmall if icon is too small, but will update iconSize.; (defrecord DirGetDirectoryIconPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (pRLI (:pointer :packedrli))                 ;   --> packed RLI for the catalog    (iconType :ostype)                           ;   --> Type of Icon requested    (iconBuffer :pointer)                        ;   --> Buffer to hold Icon Data    ;;Changing field buffersize from signed-long to unsigned-long to match C header (pretty-sure)   (bufferSize :unsigned-long)                  ;   <-> size of buffer to hold icon data    ); ; DirGetOCESetupRefNum: This call will return 'dsRefnum' for the OCE Setup Personal Catalog; and oceSetupRecordCID for the oceSetup Record.; Clients interested in manipulating OCE Setup Personal Catalog directly should; make this call to get 'dsRefNum'.; 'dsRefNum' will be returned in the standard field in the DirParamHeader.; (defrecord DirGetOCESetupRefNumPB    (qLink :pointer)   (reserved1 :signed-long)   (reserved2 :signed-long)   (ioCompletion :pointer)   (ioResult :signed-integer)   ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)   (saveA5 :unsigned-long)   (reqCode :signed-integer)   (reserved (:array :signed-long 2))   (serverHint :addrblock)   (dsRefNum :signed-integer)   ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)   (callID :unsigned-long)   (identity :signed-long)   (gReserved1 :signed-long)   (gReserved2 :signed-long)   (gReserved3 :signed-long)   (clientData :signed-long)   (oceSetupRecordCID :creationid)              ;  --> creationID for the catalog record    ); ***************************************************************************;  Catalog and Authentication control blocks and operation definitions (defrecord AuthParamBlock    (:variant       (      (qLink :pointer)      (reserved1 :signed-long)      (reserved2 :signed-long)      (ioCompletion :pointer)      (ioResult :signed-integer)      ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)      (saveA5 :unsigned-long)      (reqCode :signed-integer)      (reserved (:array :signed-long 2))      (serverHint :addrblock)      (dsRefNum :signed-integer)      ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)      (callID :unsigned-long)      (identity :signed-long)      (gReserved1 :signed-long)      (gReserved2 :signed-long)      (gReserved3 :signed-long)      (clientData :signed-long)      )      (      (bindIdentityPB :authbindspecificidentitypb)      )      (      (unbindIdentityPB :authunbindspecificidentitypb)      )      (      (resolveCreationIDPB :authresolvecreationidpb)      )      (      (getIdentityInfoPB :authgetspecificidentityinfopb)      )      (      (addKeyPB :authaddkeypb)      )      (      (changeKeyPB :authchangekeypb)      )      (      (deleteKeyPB :authdeletekeypb)      )      (      (passwordToKeyPB :authpasswordtokeypb)      )      (      (getCredentialsPB :authgetcredentialspb)      )      (      (decryptCredentialsPB :authdecryptcredentialspb)      )      (      (makeChallengePB :authmakechallengepb)      )      (      (makeReplyPB :authmakereplypb)      )      (      (verifyReplyPB :authverifyreplypb)      )      (      (getUTCTimePB :authgetutctimepb)      )      (      (makeProxyPB :authmakeproxypb)      )      (      (tradeProxyForCredentialsPB :authtradeproxyforcredentialspb)      )      (      (getLocalIdentityPB :authgetlocalidentitypb)      )      (      (unLockLocalIdentityPB :authunlocklocalidentitypb)      )      (      (lockLocalIdentityPB :authlocklocalidentitypb)      )      (      (localIdentityQInstallPB :authaddtolocalidentityqueuepb)      )      (      (localIdentityQRemovePB :authremovefromlocalidentityqueuepb)      )      (      (setupLocalIdentityPB :authsetuplocalidentitypb)      )      (      (changeLocalIdentityPB :authchangelocalidentitypb)      )      (      (removeLocalIdentityPB :authremovelocalidentitypb)      )      (      (setupDirectoryIdentityPB :ocesetupadddirectoryinfopb)      )      (      (changeDirectoryIdentityPB :ocesetupchangedirectoryinfopb)      )      (      (removeDirectoryIdentityPB :ocesetupremovedirectoryinfopb)      )      (      (getDirectoryIdentityInfoPB :ocesetupgetdirectoryinfopb)      )      )   )(defrecord DirParamBlock    (:variant       (      (qLink :pointer)      (reserved1 :signed-long)      (reserved2 :signed-long)      (ioCompletion :pointer)      (ioResult :signed-integer)      ;;Changing field savea5 from signed-long to unsigned-long to match C header (pretty-sure)      (saveA5 :unsigned-long)      (reqCode :signed-integer)      (reserved (:array :signed-long 2))      (serverHint :addrblock)      (dsRefNum :signed-integer)      ;;Changing field callid from signed-long to unsigned-long to match C header (pretty-darn-sure)      (callID :unsigned-long)      (identity :signed-long)      (gReserved1 :signed-long)      (gReserved2 :signed-long)      (gReserved3 :signed-long)      (clientData :signed-long)      )      (      (addRecordPB :diraddrecordpb)      )      (      (deleteRecordPB :dirdeleterecordpb)      )      (      (enumerateGetPB :direnumerategetpb)      )      (      (enumerateParsePB :direnumerateparsepb)      )      (      (findRecordGetPB :dirfindrecordgetpb)      )      (      (findRecordParsePB :dirfindrecordparsepb)      )      (      (lookupGetPB :dirlookupgetpb)      )      (      (lookupParsePB :dirlookupparsepb)      )      (      (addAttributeValuePB :diraddattributevaluepb)      )      (      (deleteAttributeTypePB :dirdeleteattributetypepb)      )      (      (deleteAttributeValuePB :dirdeleteattributevaluepb)      )      (      (changeAttributeValuePB :dirchangeattributevaluepb)      )      (      (verifyAttributeValuePB :dirverifyattributevaluepb)      )      (      (findValuePB :dirfindvaluepb)      )      (      (enumeratePseudonymGetPB :direnumeratepseudonymgetpb)      )      (      (enumeratePseudonymParsePB :direnumeratepseudonymparsepb)      )      (      (addPseudonymPB :diraddpseudonympb)      )      (      (deletePseudonymPB :dirdeletepseudonympb)      )      (      (addAliasPB :diraddaliaspb)      )      (      (enumerateAttributeTypesGetPB :direnumerateattributetypesgetpb)      )      (      (enumerateAttributeTypesParsePB :direnumerateattributetypesparsepb)      )      (      (getNameAndTypePB :dirgetnameandtypepb)      )      (      (setNameAndTypePB :dirsetnameandtypepb)      )      (      (getRecordMetaInfoPB :dirgetrecordmetainfopb)      )      (      (getDNodeMetaInfoPB :dirgetdnodemetainfopb)      )      (      (getDirectoryInfoPB :dirgetdirectoryinfopb)      )      (      (getDNodeAccessControlGetPB :dirgetdnodeaccesscontrolgetpb)      )      (      (getDNodeAccessControlParsePB :dirgetdnodeaccesscontrolparsepb)      )      (      (getRecordAccessControlGetPB :dirgetrecordaccesscontrolgetpb)      )      (      (getRecordAccessControlParsePB :dirgetrecordaccesscontrolparsepb)      )      (      (getAttributeAccessControlGetPB :dirgetattributeaccesscontrolgetpb)      )      (      (getAttributeAccessControlParsePB :dirgetattributeaccesscontrolparsepb)      )      (      (enumerateDirectoriesGetPB :direnumeratedirectoriesgetpb)      )      (      (enumerateDirectoriesParsePB :direnumeratedirectoriesparsepb)      )      (      (addADAPDirectoryPB :diraddadapdirectorypb)      )      (      (removeDirectoryPB :dirremovedirectorypb)      )      (      (netSearchADAPDirectoriesGetPB :dirnetsearchadapdirectoriesgetpb)      )      (      (netSearchADAPDirectoriesParsePB :dirnetsearchadapdirectoriesparsepb)      )      (      (findADAPDirectoryByNetSearchPB :dirfindadapdirectorybynetsearchpb)      )      (      (mapDNodeNumberToPathNamePB :dirmapdnodenumbertopathnamepb)      )      (      (mapPathNameToDNodeNumberPB :dirmappathnametodnodenumberpb)      )      (      (getLocalNetworkSpecPB :dirgetlocalnetworkspecpb)      )      (      (getDNodeInfoPB :dirgetdnodeinfopb)      )      (      (createPersonalDirectoryPB :dircreatepersonaldirectorypb)      )      (      (openPersonalDirectoryPB :diropenpersonaldirectorypb)      )      (      (closePersonalDirectoryPB :dirclosepersonaldirectorypb)      )      (      (makePersonalDirectoryRLIPB :dirmakepersonaldirectoryrlipb)      )      (      (addDSAMPB :diradddsampb)      )      (      (instantiateDSAMPB :dirinstantiatedsampb)      )      (      (removeDSAMPB :dirremovedsampb)      )      (      (addDSAMDirectoryPB :diradddsamdirectorypb)      )      (      (getExtendedDirectoriesInfoPB :dirgetextendeddirectoriesinfopb)      )      (      (getDirectoryIconPB :dirgetdirectoryiconpb)      )      (      (DirGetOCESetupRefNumPB :dirgetocesetuprefnumpb)      )      (      (abortPB :dirabortpb)      )      )   ); ; pass kThisRecordOwnerMask, kFriendsMask, kAuthenticatedInDNodeMask, kAuthenticatedInDirectoryMask,; kGuestMask, or kMeMask to this routine, and it will return a pointer to a; DSSpec that can be used in the Get or Set Access Controls calls.; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEGetAccessControlDSSpec" ("AOCELib"))         ((categoryBitMask :signed-long))   (:stack (:pointer :dsspec))   (:stack-trap #xAA5C :d0 837 categoryBitMask)); $ENDC(defconstant $uppAuthIOCompletionProcInfo #xC0) ;  PROCEDURE (4 byte param); (defconstant $uppNotificationProcInfo #x3FD0)   ;  FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppDirIOCompletionProcInfo #xC0)  ;  PROCEDURE (4 byte param); (defconstant $uppForEachDirEnumSpecProcInfo #x3D0);  FUNCTION (4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachRecordProcInfo #xFD0)   ;  FUNCTION (4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachLookupRecordIDProcInfo #x3D0);  FUNCTION (4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachAttrTypeLookupProcInfo #xFD0);  FUNCTION (4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachAttrValueProcInfo #x3D0);  FUNCTION (4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachAttrTypeProcInfo #x3D0) ;  FUNCTION (4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachRecordIDProcInfo #x3D0) ;  FUNCTION (4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachDirectoryProcInfo #x3FD0);  FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachADAPDirectoryProcInfo #xFFD0);  FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachDNodeAccessControlProcInfo #xFFD0);  FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachRecordAccessControlProcInfo #xFFD0);  FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppForEachAttributeAccessControlProcInfo #xFFD0);  FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; (defconstant $uppDSAMDirProcInfo #x7E0)         ;  FUNCTION (4 byte param, 4 byte param, 1 byte param): 2 byte result; (defconstant $uppDSAMDirParseProcInfo #x7E0)    ;  FUNCTION (4 byte param, 4 byte param, 1 byte param): 2 byte result; (defconstant $uppDSAMAuthProcInfo #x7E0)        ;  FUNCTION (4 byte param, 4 byte param, 1 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallAuthIOCompletionProc" ("AOCELib"))  ((paramBlock (:pointer :authparamblock)) (userRoutine :pointer))   nil   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallNotificationProc" ("AOCELib"))  ((clientData :signed-long) (callValue :signed-long) (actionValue :signed-long) (identity :signed-long) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallDirIOCompletionProc" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)) (userRoutine :pointer))   nil   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachDirEnumSpecProc" ("AOCELib"))  ((clientData :signed-long) (enumSpec (:pointer :direnumspec)) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachRecordProc" ("AOCELib"))  ((clientData :signed-long) (enumSpec (:pointer :direnumspec)) (pRLI (:pointer :packedrli)) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachLookupRecordIDProc" ("AOCELib"))  ((clientData :signed-long) (RecordID (:pointer :recordid)) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachAttrTypeLookupProc" ("AOCELib"))  ((clientData :signed-long) (attrType (:pointer :attributetype)) (myAttrAccMask :signed-long) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachAttrValueProc" ("AOCELib"))  ((clientData :signed-long) (Attribute (:pointer :attribute)) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachAttrTypeProc" ("AOCELib"))  ((clientData :signed-long) (attrType (:pointer :attributetype)) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachRecordIDProc" ("AOCELib"))  ((clientData :signed-long) (RecordID (:pointer :recordid)) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachDirectoryProc" ("AOCELib"))  ((clientData :signed-long) (dirName (:pointer :directoryname)) (discriminator (:pointer :dirdiscriminator)) (features :signed-long) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachADAPDirectoryProc" ("AOCELib"))  ((clientData :signed-long) (dirName (:pointer :directoryname)) (discriminator (:pointer :dirdiscriminator)) (features :signed-long) (serverHint :addrblock) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachDNodeAccessControlProc" ("AOCELib"))  ((clientData :signed-long) (dsObj (:pointer :dsspec)) (activeDnodeAccMask :signed-long) (defaultRecordAccMask :signed-long) (defaultAttributeAccMask :signed-long) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachRecordAccessControlProc" ("AOCELib"))  ((clientData :signed-long) (dsObj (:pointer :dsspec)) (activeDnodeAccMask :signed-long) (activeRecordAccMask :signed-long) (defaultAttributeAccMask :signed-long) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallForEachAttributeAccessControlProc" ("AOCELib"))  ((clientData :signed-long) (dsObj (:pointer :dsspec)) (activeDnodeAccMask :signed-long) (activeRecordAccMask :signed-long) (activeAttributeAccMask :signed-long) (userRoutine :pointer))   :boolean   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallDSAMDirProc" ("AOCELib"))  ((dsamData :pointer) (paramBlock (:pointer :dirparamblock)) (async :boolean) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallDSAMDirParseProc" ("AOCELib"))  ((dsamData :pointer) (paramBlock (:pointer :dirparamblock)) (async :boolean) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallDSAMAuthProc" ("AOCELib"))  ((dsamData :pointer) (pb (:pointer :authparamblock)) (async :boolean) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewAuthIOCompletionProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewNotificationProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewDirIOCompletionProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachDirEnumSpecProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachRecordProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachLookupRecordIDProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachAttrTypeLookupProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachAttrValueProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachAttrTypeProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachRecordIDProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachDirectoryProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachADAPDirectoryProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachDNodeAccessControlProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachRecordAccessControlProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewForEachAttributeAccessControlProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewDSAMDirProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewDSAMDirParseProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewDSAMAuthProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC(defconstant $kAuthBindSpecificIdentity #x200)(defconstant $kAuthUnbindSpecificIdentity #x201)(defconstant $kAuthResolveCreationID #x202)(defconstant $kAuthGetSpecificIdentityInfo #x203)(defconstant $kAuthGetLocalIdentity #x204)(defconstant $kAuthAddToLocalIdentityQueue #x205)(defconstant $kAuthRemoveFromLocalIdentityQueue #x206)(defconstant $kAuthAddKey #x207)(defconstant $kAuthChangeKey #x208)(defconstant $kAuthDeleteKey #x209)(defconstant $kAuthPasswordToKey #x20A)(defconstant $kAuthGetCredentials #x20B)(defconstant $kAuthDecryptCredentials #x20C)(defconstant $kOCESetupRemoveDirectoryInfo #x20D)(defconstant $kOCESetupGetDirectoryInfo #x20E)(defconstant $kAuthMakeChallenge #x20F)(defconstant $kAuthMakeReply #x210)(defconstant $kAuthVerifyReply #x211)(defconstant $kAuthMakeProxy #x212)(defconstant $kAuthTradeProxyForCredentials #x213)(defconstant $kAuthUnlockLocalIdentity #x214)(defconstant $kAuthLockLocalIdentity #x215)(defconstant $kAuthSetupLocalIdentity #x216)(defconstant $kAuthChangeLocalIdentity #x217)(defconstant $kAuthRemoveLocalIdentity #x218)(defconstant $kOCESetupAddDirectoryInfo #x219)(defconstant $kAuthGetUTCTime #x21A)(defconstant $kOCESetupChangeDirectoryInfo #x21B);  0x100 is used as private command (defconstant $kDirEnumerateParse #x101)(defconstant $kDirLookupParse #x102)(defconstant $kDirEnumerateAttributeTypesParse #x103)(defconstant $kDirEnumeratePseudonymParse #x104)(defconstant $kDirNetSearchADAPDirectoriesParse #x105)(defconstant $kDirEnumerateDirectoriesParse #x106)(defconstant $kDirFindADAPDirectoryByNetSearch #x107)(defconstant $kDirNetSearchADAPDirectoriesGet #x108)(defconstant $kDirAddRecord #x109)(defconstant $kDirDeleteRecord #x10A)(defconstant $kDirAddAttributeValue #x10B)(defconstant $kDirDeleteAttributeValue #x10C)(defconstant $kDirChangeAttributeValue #x10D)(defconstant $kDirVerifyAttributeValue #x10E)(defconstant $kDirAddPseudonym #x10F)(defconstant $kDirDeletePseudonym #x110)(defconstant $kDirEnumerateGet #x111)(defconstant $kDirEnumerateAttributeTypesGet #x112)(defconstant $kDirEnumeratePseudonymGet #x113)(defconstant $kDirGetNameAndType #x114)(defconstant $kDirSetNameAndType #x115)(defconstant $kDirGetRecordMetaInfo #x116)(defconstant $kDirLookupGet #x117)(defconstant $kDirGetDNodeMetaInfo #x118)(defconstant $kDirGetDirectoryInfo #x119)(defconstant $kDirEnumerateDirectoriesGet #x11A)(defconstant $kDirAbort #x11B)(defconstant $kDirAddAlias #x11C)(defconstant $kDirAddDSAM #x11D)(defconstant $kDirOpenPersonalDirectory #x11E)(defconstant $kDirCreatePersonalDirectory #x11F)(defconstant $kDirRemoveDSAM #x120)(defconstant $kDirGetDirectoryIcon #x121)(defconstant $kDirMapPathNameToDNodeNumber #x122)(defconstant $kDirMapDNodeNumberToPathName #x123)(defconstant $kDirGetLocalNetworkSpec #x124)(defconstant $kDirGetDNodeInfo #x125)(defconstant $kDirFindValue #x126)(defconstant $kDirInstantiateDSAM #x127)(defconstant $kDirGetOCESetupRefNum #x128)(defconstant $kDirGetDNodeAccessControlGet #x12A)(defconstant $kDirGetRecordAccessControlGet #x12C)(defconstant $kDirGetAttributeAccessControlGet #x12E)(defconstant $kDirGetDNodeAccessControlParse #x12F)(defconstant $kDirDeleteAttributeType #x130)(defconstant $kDirClosePersonalDirectory #x131)(defconstant $kDirMakePersonalDirectoryRLI #x132)(defconstant $kDirAddDSAMDirectory #x133)(defconstant $kDirGetRecordAccessControlParse #x134)(defconstant $kDirRemoveDirectory #x135)(defconstant $kDirGetExtendedDirectoriesInfo #x136)(defconstant $kDirAddADAPDirectory #x137)(defconstant $kDirGetAttributeAccessControlParse #x138)(defconstant $kDirFindRecordGet #x140)(defconstant $kDirFindRecordParse #x141); $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthBindSpecificIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (512 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthUnbindSpecificIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (513 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthResolveCreationID" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (514 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthGetSpecificIdentityInfo" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (515 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthAddKey" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (519 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthChangeKey" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (520 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthDeleteKey" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (521 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthPasswordToKey" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (522 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthGetCredentials" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (523 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthDecryptCredentials" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (524 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthMakeChallenge" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (527 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthMakeReply" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (528 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthVerifyReply" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (529 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthGetUTCTime" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (538 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthMakeProxy" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (530 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthTradeProxyForCredentials" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (531 :signed-integer))); $ENDC;  Local Identity API ; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthGetLocalIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (516 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthUnlockLocalIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (532 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthLockLocalIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (533 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthAddToLocalIdentityQueue" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (517 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthRemoveFromLocalIdentityQueue" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (518 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthSetupLocalIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (534 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthChangeLocalIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (535 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_AuthRemoveLocalIdentity" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (536 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_OCESetupAddDirectoryInfo" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (537 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_OCESetupChangeDirectoryInfo" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (539 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_OCESetupRemoveDirectoryInfo" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (525 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_OCESetupGetDirectoryInfo" ("AOCELib"))         ((paramBlock (:pointer :authparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (526 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirAddRecord" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (265 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirDeleteRecord" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (266 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumerateGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (273 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumerateParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (257 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirFindRecordGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (320 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirFindRecordParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (321 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirLookupGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (279 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirLookupParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (258 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirAddAttributeValue" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (267 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirDeleteAttributeValue" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (268 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirDeleteAttributeType" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (304 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirChangeAttributeValue" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (269 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirVerifyAttributeValue" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (270 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirFindValue" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (294 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumerateAttributeTypesGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (274 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumerateAttributeTypesParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (259 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirAddPseudonym" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (271 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirDeletePseudonym" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (272 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirAddAlias" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (284 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumeratePseudonymGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (275 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumeratePseudonymParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (260 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetNameAndType" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (276 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirSetNameAndType" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (277 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetRecordMetaInfo" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (278 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetDNodeMetaInfo" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (280 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetDirectoryInfo" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (281 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetDNodeAccessControlGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (298 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetDNodeAccessControlParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (303 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetRecordAccessControlGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (300 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetRecordAccessControlParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (308 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetAttributeAccessControlGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (302 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetAttributeAccessControlParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (312 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumerateDirectoriesGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (282 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirEnumerateDirectoriesParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (262 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirMapPathNameToDNodeNumber" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (290 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirMapDNodeNumberToPathName" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (291 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetLocalNetworkSpec" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (292 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetDNodeInfo" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (293 :signed-integer))); $ENDC;   Trap Dispatchers for Personal Catalog and CSAM Extensions ; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirCreatePersonalDirectory" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x11F #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirOpenPersonalDirectory" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x11E #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirClosePersonalDirectory" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x131 #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirMakePersonalDirectoryRLI" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x132 #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirAddDSAM" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x11D #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirInstantiateDSAM" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x127 #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirRemoveDSAM" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x120 #xAA5E) ); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirAddDSAMDirectory" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (307 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetExtendedDirectoriesInfo" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (310 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetDirectoryIcon" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (289 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirAddADAPDirectory" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (311 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirRemoveDirectory" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (309 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirNetSearchADAPDirectoriesGet" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (264 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirNetSearchADAPDirectoriesParse" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (261 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirFindADAPDirectoryByNetSearch" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (263 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator push-a-constant-word-on-stack(deftrap ("_DirGetOCESetupRefNum" ("AOCELib"))         ((paramBlock (:pointer :dirparamblock)) (async :boolean))   (:stack :signed-integer)   (:stack-trap #xAA5E paramBlock async (296 :signed-integer))); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_DirAbort" ("AOCELib"))  ((paramBlock (:pointer :dirparamblock)))   :signed-integer   (#x7000 #x1F00 #x3F3C #x11B #xAA5E) ); $ENDC; $ALIGN RESET; $POP; $SETC UsingIncludes := OCEAuthDirIncludes; $ENDC                                         ; __OCEAUTHDIR__#|                                              ; $IFC NOT UsingIncludes |#                                             ; $ENDC(provide-interface 'OCEAuthDir)