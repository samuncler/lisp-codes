(in-package :TRAPS); Generated from #P"HD:CCL3.0d17:Interface Translator:Source interfaces:Pascal Interfaces:OCE.p"; at Tuesday June 6,1995 2:02:28 pm.; ;  	File:		OCE.p;  ;  	Contains:	Apple Open Collaboration Environment (AOCE) Interfaces.;  ;  	Version:	Technology:	AOCE Toolbox 1.02;  				Package:	Universal Interfaces 2.1§1 in ÒMPW PrereleaseÓ on ETO #17;  ;  	Copyright:	© 1984-1995 by Apple Computer, Inc.;  				All rights reserved.;  ;  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter;  				stack.  Include the file and version information (from above);  				in the problem description and send to:;  					Internet:	apple.bugs@applelink.apple.com;  					AppleLink:	APPLE.BUGS;  ; #|                                              ; $IFC UNDEFINED UsingIncludes; $SETC UsingIncludes := 0 |#                                             ; $ENDC#|                                              ; $IFC NOT UsingIncludes |#                                             ; $ENDC; $IFC UNDEFINED __OCE__; $SETC __OCE__ := 1; $I+; $SETC OCEIncludes := UsingIncludes; $SETC UsingIncludes := 1; $IFC UNDEFINED __ALIASES__(require-interface 'Aliases)                    ; $I Aliases.p; $ENDC; 	Types.p														; 		ConditionalMacros.p										; 	AppleTalk.p													; 		OSUtils.p												; 			MixedMode.p											; 			Memory.p											; 	Files.p														#|                                              ; $IFC UNDEFINED __APPLEEVENTS__|#(require-interface 'AppleEvents)#|                                              ; $I AppleEvents.p |#                                             ; $ENDC; 	Errors.p													; 	Events.p													; 		Quickdraw.p												; 			QuickdrawText.p										; 	EPPC.p														; 		PPCToolbox.p											; 		Processes.p												; 	Notification.p												; $IFC UNDEFINED __SCRIPT__(require-interface 'Script)                     ; $I Script.p; $ENDC; 	IntlResources.p												#|                                              ; $IFC UNDEFINED __TYPES__|#(require-interface 'Types)#|                                              ; $I Types.p |#                                             ; $ENDC; $PUSH; $ALIGN MAC68K; $LibExport+(defconstant $kOCECopyCreationID 768)(defconstant $kOCECopyDirDiscriminator 769)(defconstant $kOCECopyLocalRecordID 770)(defconstant $kOCECopyPackedDSSpec 771)(defconstant $kOCECopyPackedPathName 772)(defconstant $kOCECopyPackedRLI 773)(defconstant $kOCECopyPackedRecordID 774)(defconstant $kOCECopyRLI 775)(defconstant $kOCECopyRString 776)(defconstant $kOCECopyRecordID 777)(defconstant $kOCECopyShortRecordID 778)(defconstant $kOCEDuplicateRLI 779)(defconstant $kOCEEqualCreationID 780)(defconstant $kOCEEqualDirDiscriminator 781)(defconstant $kOCEEqualDSSpec 782)(defconstant $kOCEEqualLocalRecordID 783)(defconstant $kOCEEqualPackedDSSpec 784)(defconstant $kOCEEqualPackedPathName 785)(defconstant $kOCEEqualPackedRecordID 786)(defconstant $kOCEEqualPackedRLI 787)(defconstant $kOCEEqualRecordID 788)(defconstant $kOCEEqualRLI 789)(defconstant $kOCEEqualRString 790)(defconstant $kOCEEqualShortRecordID 791)(defconstant $kOCEExtractAlias 792)(defconstant $kOCEGetDSSpecInfo 793)(defconstant $kOCEGetIndAttributeType 794)(defconstant $kOCEGetIndRecordType 795)(defconstant $kOCEGetXtnType 796)(defconstant $kOCEIsNullPackedPathName 797)(defconstant $kOCENewLocalRecordID 798)(defconstant $kOCENewRLI 799)(defconstant $kOCENewRecordID 800)(defconstant $kOCENewShortRecordID 801)(defconstant $kOCEPackDSSpec 802)(defconstant $kOCEPackPathName 803)(defconstant $kOCEPackRLI 804)(defconstant $kOCEPackRLIParts 805)(defconstant $kOCEPackRecordID 806)(defconstant $kOCEPackedDSSpecSize 807)(defconstant $kOCEPackedPathNameSize 808)(defconstant $kOCEPackedRLIPartsSize 809)(defconstant $kOCEPackedRLISize 810)(defconstant $kOCEPackedRecordIDSize 811)(defconstant $kOCEDNodeNameCount 812)(defconstant $kOCERelRString 813)(defconstant $kOCESetCreationIDtoNull 814)(defconstant $kOCEUnpackDSSpec 815)(defconstant $kOCEUnpackPathName 816)(defconstant $kOCEUnpackRLI 817)(defconstant $kOCEUnpackRecordID 818)(defconstant $kOCEValidPackedDSSpec 819)(defconstant $kOCEValidPackedPathName 820)(defconstant $kOCEValidPackedRecordID 821)(defconstant $kOCEValidPackedRLI 822)(defconstant $kOCEValidRLI 823)(defconstant $kOCEValidRString 824)(defconstant $kOCECToRString 825)(defconstant $kOCEPToRString 826)(defconstant $kOCERToPString 827)(defconstant $kOCEPathFinderCID 828)(defconstant $kOCEStreamPackedDSSpec 829)(defconstant $kOCENullCID 836)(defconstant $kOCEGetAccessControlDSSpec 837)(defconstant $kOCEGetRootPackedRLI 838)(def-mactype :ocerecordtypeindex (find-mactype ':signed-integer))(def-mactype :oceattributetypeindex (find-mactype ':signed-integer));  For anyone who absolutely needs a define of the body of the standard record or; attribute type, use these below.  CAUTION!  All the types below are assumed to be; in character set 'smRoman'.  If you try to compare these to some RString or; AttributeType variable, you must take the character set code into account.  Future; standard types may be defined using character sets other than 'smRoman'. (defconstant $kUserRecTypeNum 1)                ;  "User" (defconstant $kGroupRecTypeNum 2)               ;  "Group" (defconstant $kMnMRecTypeNum 3)                 ;  "AppleMailª M&M" (defconstant $kMnMForwarderRecTypeNum 4)        ;  "AppleMailª Fwdr" (defconstant $kNetworkSpecRecTypeNum 5)         ;  "NetworkSpec" (defconstant $kADAPServerRecTypeNum 6)          ;  "ADAP Server" (defconstant $kADAPDNodeRecTypeNum 7)           ;  "ADAP DNode" (defconstant $kADAPDNodeRepRecTypeNum 8)        ;  "ADAP DNode Rep" (defconstant $kServerSetupRecTypeNum 9)         ;  "Server Setup" (defconstant $kDirectoryRecTypeNum 10)          ;  "Directory" (defconstant $kDNodeRecTypeNum 11)              ;  "DNode" (defconstant $kSetupRecTypeNum 12)              ;  "Setup" (defconstant $kMSAMRecTypeNum 13)               ;  "MSAM" (defconstant $kDSAMRecTypeNum 14)               ;  "DSAM" (defconstant $kAttributeValueRecTypeNum 15)     ;  "Attribute Value" (defconstant $kBusinessCardRecTypeNum 16)       ;  "Business Card" (defconstant $kMailServiceRecTypeNum 17)        ;  "Mail Service" (defconstant $kCombinedRecTypeNum 18)           ;  "Combined" (defconstant $kOtherServiceRecTypeNum 19)       ;  "Other Service" (defconstant $kAFPServiceRecTypeNum 20)         ;  "Other Service afps" (defconstant $kFirstOCERecTypeNum #$kUserRecTypeNum);  first standard OCE record type (defconstant $kLastOCERecTypeNum #$kAFPServiceRecTypeNum);  last standard OCE record type (defconstant $kNumOCERecTypes (+ 0 (- #$kLastOCERecTypeNum (+ #$kFirstOCERecTypeNum 1))));  Indices for the standard definitions for certain attribute types (OCEAttributeTypeIndex): (defconstant $kMemberAttrTypeNum 1001)          ;  "Member" (defconstant $kAdminsAttrTypeNum 1002)          ;  "Administrators" (defconstant $kMailSlotsAttrTypeNum 1003)       ;  "mailslots" (defconstant $kPrefMailAttrTypeNum 1004)        ;  "pref mailslot" (defconstant $kAddressAttrTypeNum 1005)         ;  "Address" (defconstant $kPictureAttrTypeNum 1006)         ;  "Picture" (defconstant $kAuthKeyAttrTypeNum 1007)         ;  "auth key" (defconstant $kTelephoneAttrTypeNum 1008)       ;  "Telephone" (defconstant $kNBPNameAttrTypeNum 1009)         ;  "NBP Name" (defconstant $kQMappingAttrTypeNum 1010)        ;  "ForwarderQMap" (defconstant $kDialupSlotAttrTypeNum 1011)      ;  "DialupSlotInfo" (defconstant $kHomeNetAttrTypeNum 1012)         ;  "Home Internet" (defconstant $kCoResAttrTypeNum 1013)           ;  "Co-resident M&M" (defconstant $kFwdrLocalAttrTypeNum 1014)       ;  "FwdrLocalRecord" (defconstant $kConnectAttrTypeNum 1015)         ;  "Connected To" (defconstant $kForeignAttrTypeNum 1016)         ;  "Foreign RLIs" (defconstant $kOwnersAttrTypeNum 1017)          ;  "Owners" (defconstant $kReadListAttrTypeNum 1018)        ;  "ReadList" (defconstant $kWriteListAttrTypeNum 1019)       ;  "WriteList" (defconstant $kDescriptorAttrTypeNum 1020)      ;  "Descriptor" (defconstant $kCertificateAttrTypeNum 1021)     ;  "Certificate" (defconstant $kMsgQsAttrTypeNum 1022)           ;  "MessageQs" (defconstant $kPrefMsgQAttrTypeNum 1023)        ;  "PrefMessageQ" (defconstant $kMasterPFAttrTypeNum 1024)        ;  "MasterPF" (defconstant $kMasterNetSpecAttrTypeNum 1025)   ;  "MasterNetSpec" (defconstant $kServersOfAttrTypeNum 1026)       ;  "Servers Of" (defconstant $kParentCIDAttrTypeNum 1027)       ;  "Parent CID" (defconstant $kNetworkSpecAttrTypeNum 1028)     ;  "NetworkSpec" (defconstant $kLocationAttrTypeNum 1029)        ;  "Location" (defconstant $kTimeSvrTypeAttrTypeNum 1030)     ;  "TimeServer Type" (defconstant $kUpdateTimerAttrTypeNum 1031)     ;  "Update Timer" (defconstant $kShadowsOfAttrTypeNum 1032)       ;  "Shadows Of" (defconstant $kShadowServerAttrTypeNum 1033)    ;  "Shadow Server" (defconstant $kTBSetupAttrTypeNum 1034)         ;  "TB Setup" (defconstant $kMailSetupAttrTypeNum 1035)       ;  "Mail Setup" (defconstant $kSlotIDAttrTypeNum 1036)          ;  "SlotID" (defconstant $kGatewayFileIDAttrTypeNum 1037)   ;  "Gateway FileID" (defconstant $kMailServiceAttrTypeNum 1038)     ;  "Mail Service" (defconstant $kStdSlotInfoAttrTypeNum 1039)     ;  "Std Slot Info" (defconstant $kAssoDirectoryAttrTypeNum 1040)   ;  "Asso. Directory" (defconstant $kDirectoryAttrTypeNum 1041)       ;  "Directory" (defconstant $kDirectoriesAttrTypeNum 1042)     ;  "Directories" (defconstant $kSFlagsAttrTypeNum 1043)          ;  "SFlags" (defconstant $kLocalNameAttrTypeNum 1044)       ;  "Local Name" (defconstant $kLocalKeyAttrTypeNum 1045)        ;  "Local Key" (defconstant $kDirUserRIDAttrTypeNum 1046)      ;  "Dir User RID" (defconstant $kDirUserKeyAttrTypeNum 1047)      ;  "Dir User Key" (defconstant $kDirNativeNameAttrTypeNum 1048)   ;  "Dir Native Name" (defconstant $kCommentAttrTypeNum 1049)         ;  "Comment" (defconstant $kRealNameAttrTypeNum 1050)        ;  "Real Name" (defconstant $kPrivateDataAttrTypeNum 1051)     ;  "Private Data" (defconstant $kDirTypeAttrTypeNum 1052)         ;  "Directory Type" (defconstant $kDSAMFileAliasAttrTypeNum 1053)   ;  "DSAM File Alias" (defconstant $kCanAddressToAttrTypeNum 1054)    ;  "Can Address To" (defconstant $kDiscriminatorAttrTypeNum 1055)   ;  "Discriminator" (defconstant $kAliasAttrTypeNum 1056)           ;  "Alias" (defconstant $kParentMSAMAttrTypeNum 1057)      ;  "Parent MSAM" (defconstant $kParentDSAMAttrTypeNum 1058)      ;  "Parent DSAM" (defconstant $kSlotAttrTypeNum 1059)            ;  "Slot" (defconstant $kAssoMailServiceAttrTypeNum 1060) ;  "Asso. Mail Service" (defconstant $kFakeAttrTypeNum 1061)            ;  "Fake" (defconstant $kInheritSysAdminAttrTypeNum 1062) ;  "Inherit SysAdministrators" (defconstant $kPreferredPDAttrTypeNum 1063)     ;  "Preferred PD" (defconstant $kLastLoginAttrTypeNum 1064)       ;  "Last Login" (defconstant $kMailerAOMStateAttrTypeNum 1065)  ;  "Mailer AOM State" (defconstant $kMailerSendOptionsAttrTypeNum 1066);  "Mailer Send Options" (defconstant $kJoinedAttrTypeNum 1067)          ;  "Joined" (defconstant $kUnconfiguredAttrTypeNum 1068)    ;  "Unconfigured" (defconstant $kVersionAttrTypeNum 1069)         ;  "Version" (defconstant $kLocationNamesAttrTypeNum 1070)   ;  "Location Names" (defconstant $kActiveAttrTypeNum 1071)          ;  "Active" (defconstant $kDeleteRequestedAttrTypeNum 1072) ;  "Delete Requested" (defconstant $kGatewayTypeAttrTypeNum 1073)     ;  "Gateway Type" (defconstant $kFirstOCEAttrTypeNum #$kMemberAttrTypeNum);  first standard OCE attr type (defconstant $kLastOCEAttrTypeNum #$kGatewayTypeAttrTypeNum);  last standard OCE attr type (defconstant $kNumOCEAttrTypes (+ 0 (- #$kLastOCEAttrTypeNum (+ #$kFirstOCEAttrTypeNum 1))));  Miscellaneous enums: (defconstant $kRString32Size 32)                ;  max size of the body field in RString32 (defconstant $kRString64Size 64)                ;  max size of the body field in RString64 (defconstant $kNetworkSpecMaxBytes 32)          ;  max size of the body field in NetworkSpec (defconstant $kPathNameMaxBytes 1024)           ;  max size of the data field in PackedPathName (defconstant $kDirectoryNameMaxBytes 32)        ;  max size of the body field in DirectoryName (defconstant $kAttributeTypeMaxBytes 32)        ;  max size of the body field in AttributeType (defconstant $kAttrValueMaxBytes 65536)         ;  max size of any attribute value (defconstant $kRStringMaxBytes 256)             ;  max size (in bytes) of the body field of a recordName or recordType (defconstant $kRStringMaxChars 128)             ;  max size (in chars) of the body field of a recordName or recordType (defconstant $kNULLDNodeNumber 0)               ;  Special value meaning none specified (defconstant $kRootDNodeNumber 2)               ;  DNodeNum corresponding to the root of the tree ;  This enum is used to select the kind of RString in calls such as OCERelRString,; OCEEqualRString, and OCEValidRString.; ; eGenericSensitive and eGenericInsensitive are enumerators that can be used if you; use RStrings for things other than what you see in this file.  If you want them to; be compared in a case- and diacritical-sensitive manner (c ­ C ­ ), use; eGenericSensitive.  If you want them to be compared in a case- and diacritical-; insensitive manner (c = C = ), use eGenericInensitive.; WARNING:  do not use eGenericSensitive and eGenericInsensitive with catalog; names, entity names, pathname parts, entity types, network specs, or attribute; types!  Don't assume that you know how they should be compared!!! (defconstant $kOCEDirName 0)(defconstant $kOCERecordOrDNodeName 1)(defconstant $kOCERecordType 2)(defconstant $kOCENetworkSpec 3)(defconstant $kOCEAttrType 4)(defconstant $kOCEGenericSensitive 5)(defconstant $kOCEGenericInsensitive 6)(def-mactype :rstringkind (find-mactype ':signed-integer));  Values for the signature field in Discriminator (defconstant $kDirAllKinds 0)(defconstant $kDirADAPKind :|adap|)(defconstant $kDirPersonalDirectoryKind :|pdir|)(defconstant $kDirDSAMKind :|dsam|)(def-mactype :ocedirectorykind (find-mactype ':signed-long));  Values returned by GetDSSpecInfo() (defconstant $kOCEInvalidDSSpec #x3F3F3F3F)     ;  could not be determined (defconstant $kOCEDirsRootDSSpec :|root|)       ;  root of all catalogs ("Catalogs" icon) (defconstant $kOCEDirectoryDSSpec :|dire|)      ;  catalog (defconstant $kOCEDNodeDSSpec :|dnod|)          ;  d-node (defconstant $kOCERecordDSSpec :|reco|)         ;  record (defconstant $kOCEentnDSSpec :|entn|)           ;  extensionType is 'entn' (defconstant $kOCENOTentnDSSpec :|not |);  Values for AttributeTag (defconstant $typeRString :|rstr|)(defconstant $typePackedDSSpec :|dspc|)(defconstant $typeBinary :|bnry|);  Bit flag corresponding to the canContainRecords bit.  Use it like this:; 	if (foo & kCanContainRecords); 		then this dNode can contain records!; kForeignNode is used to indicate nodes in the name hierarchy that correspond to; foreign catalogs (meaning ADAP sees no clusters or DNodes beneath it, but; mail routers might be able to route to clusters beneath it. (defconstant $kCanContainRecordsBit 0)(defconstant $kForeignNodeBit 1);  DirNodeKind (defconstant $kCanContainRecords (* 1 (expt 2 #$kCanContainRecordsBit)))(defconstant $kForeignNode (* 1 (expt 2 #$kForeignNodeBit)))(def-mactype :dirnodekind (find-mactype ':signed-long)); *** Toolbox Control ***;  We will have a version number and attributes for toolboxes off the aa5e trap; and the S&F server trap.; ; This includes the OCE toolbox and S&F Server.  [Note: the S&F server will; change to ONLY service ServerGateway calls Ñit will then be necessary to run; it coÐresident with an OCE toolbox].; ; The high order word will represent the S&F Server version number.  The low; order word will represent the OCE toolbox version number.  These will be zero; until the component is up and running.  It is not possible to know these; aÐpriori. Note: there will not be a seperate version numbers for each component; in the OCE toolbox or S&F server.; ; The above is consistent with the standard System 7.0 usage of Gestalt.; ; The oce tb attribute gestaltOCETBPresent implies the existence of OCE on a; machine.; ; The OCE TB attribute gestaltOCETBAvailable implies the availablity of OCE calls.; ; The attribute gestaltOCESFServerAvailable implies the availablity of OCE calls; available through the S&F server. This are essentially the server gateway calls.; ; Any (future) remaining OCE attributes may not be established correctly until; the attribute gestaltOCETBAvailable is set.; ; The gestalt selectors and values are listed below: (defconstant $gestaltOCEToolboxVersion :|ocet|) ;  OCE Toolbox version (defconstant $gestaltOCEToolboxAttr :|oceu|);  version includes:;  *  dirtb;  *  authtb;  *  mailtb;  *  ipmtb;  *  personal catalog;  *  ADSPSecure;  * e.g. all interfaces dependent on the aa5e trap. (defconstant $gestaltOCETB #x102)               ;  OCE Toolbox version 1.02 (defconstant $gestaltSFServer #x100)            ;  S&F Server version 1.0 (defconstant $gestaltOCETBPresent #x1)          ;  OCE toolbox is present, not running (defconstant $gestaltOCETBAvailable #x2)        ;  OCE toolbox is running and available (defconstant $gestaltOCESFServerAvailable #x4)  ;  S&F Server is running and available (defconstant $gestaltOCETBNativeGlueAvailable #x10);  Native PowerPC Glue routines are availible ; 	Constants used for Transitions. (defconstant $ATTransIPMStart :|ipms|)(defconstant $ATTransIPMShutdown :|ipmd|)(defconstant $ATTransDirStart :|dirs|)(defconstant $ATTransDirShutdown :|dird|)(defconstant $ATTransAuthStart :|auts|)(defconstant $ATTransAuthShutdown :|autd|)(defconstant $ATTransSFStart :|s&fs|)(defconstant $ATTransSFShutdown :|s&fd|);  Some definitions for time-related parameters: ;  Interpreted as UTC seconds since 1/1/1904 (def-mactype :utctime (find-mactype ':signed-long));  seconds EAST of Greenwich (def-mactype :utcoffset (find-mactype ':signed-long));  This is the same as the ScriptManager script. (def-mactype :characterset (find-mactype ':signed-integer)); *** RString ***;  struct RString is a maximum-sized structure.  Allocate one of these and it will; hold any valid RString. (defrecord RString    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (body (:array :signed-byte (- (- #$kRStringMaxBytes 1) 0 -1)));  Byte ;  place for characters    );  struct ProtoRString is a minimum-sized structure.  Use this for a variable-length RString. (defrecord ProtoRString    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   )(def-mactype :rstringptr (find-mactype '(:pointer :rstring)))(def-mactype :rstringhandle (find-mactype '(:handle :rstring)))(def-mactype :protorstringptr (find-mactype '(:pointer :protorstring)))(defrecord RString64    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (body (:array :signed-byte (- (- #$kRString64Size 1) 0 -1)));  Byte    )(defrecord RString32    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (body (:array :signed-byte (- (- #$kRString32Size 1) 0 -1)));  Byte    );  Standard definitions for the entity type field and attribute type; have been moved to the end of the file. ;  Copies str1 to str2.  str2Length is the size of str2, excluding header.; A memFull error will be returned if that is not as large as str1->dataLength. ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyRString" ("AOCELib"))         ((str1 (:pointer :rstring)) (str2 (:pointer :rstring)) (str2Length :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 776 str1 str2 str2Length)); $ENDC; 	Make an RString from a C string.  If the c string is bigger than rStrLength,; only rStrLength bytes will be copied. (rStrLength does not include the header size) ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECToRString" ("AOCELib"))         ((cStr :pointer) (charSet :signed-integer) (rStr (:pointer :rstring)) (rStrLength :signed-integer))   nil   (:stack-trap #xAA5C :d0 825 cStr charSet rStr rStrLength)); $ENDC; 	Make an RString from a Pascal string.  If the Pascal string is bigger than rStrLength,; only rStrLength bytes will be copied. (rStrLength does not include the header size) ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPToRString" ("AOCELib"))         ((pStr (:string 255)) (charSet :signed-integer) (rStr (:pointer :rstring)) (rStrLength :signed-integer))   nil   (:stack-trap #xAA5C :d0 826 pStr charSet rStr rStrLength)); $ENDC; 	Make a Pascal string from an RString.  It's up to you to check the char set of; the RString, or if the length of the RString is greater than 255 (the Pascal string's; length will simply be the lower byte of the RString's length).  The StringPtr that is; returned will point directly into the RString (no memory will be allocated). ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCERToPString" ("AOCELib"))         ((rStr (:pointer :rstring)))   (:stack (:pointer (:string 255)))   (:stack-trap #xAA5C :d0 827 rStr)); $ENDC; 	Check the relative equality of two RStrings.  Determines if str1 is greater than,; equal to, or less than str2.  Result types for OCERelRString are defined in <OSUtils.h>; (same as for RelString). ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCERelRString" ("AOCELib"))         ((str1 :pointer) (str2 :pointer) (kind :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 813 str1 str2 kind)); $ENDC; 	Check for equality of two RStrings. Returns true if equal. ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualRString" ("AOCELib"))         ((str1 :pointer) (str2 :pointer) (kind :signed-integer))   (:stack :boolean)   (:stack-trap #xAA5C :d0 790 str1 str2 kind)); $ENDC; 	Check the validity of an RString.  Returns true if the RString is valid ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEValidRString" ("AOCELib"))         ((str :pointer) (kind :signed-integer))   (:stack :boolean)   (:stack-trap #xAA5C :d0 824 str kind)); $ENDC; *** CreationID ***(defrecord CreationID    ;;Changing field source from signed-long to unsigned-long to match C header (pretty-darn-sure)   (source :unsigned-long)                      ;  Fields definitions and usage are not defined    ;;Changing field seq from signed-long to unsigned-long to match C header (pretty-darn-sure)   (seq :unsigned-long)   )(%define-record :attributecreationid (find-record-descriptor :creationid));  Returns a pointer to a null CreationID . ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCENullCID" ("AOCELib"))         ()   (:stack :creationid)   (:stack-trap #xAA5C :d0 836)); $ENDC;  Returns a pointer to a special CreationID used within the PathFinder. ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPathFinderCID" ("AOCELib"))         ()   (:stack :creationid)   (:stack-trap #xAA5C :d0 828)); $ENDC;  Sets the CreationID to a null value. ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCESetCreationIDtoNull" ("AOCELib"))         ((cid (:pointer :creationid)))   nil   (:stack-trap #xAA5C :d0 814 cid)); $ENDC;  Copies the value of cid1 to cid2. ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyCreationID" ("AOCELib"))         ((cid1 (:pointer :creationid)) (cid2 (:pointer :creationid)))   nil   (:stack-trap #xAA5C :d0 768 cid1 cid2)); $ENDC;  Check the equality of two CreationIDs. ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualCreationID" ("AOCELib"))         ((cid1 (:pointer :creationid)) (cid2 (:pointer :creationid)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 780 cid1 cid2)); $ENDC; *** NetworkSpec ***;  For the record, a NetworkSpec is an RString with a smaller maximum size.; I don't just typedef it to an RString, because I want the definition of the NetworkSpec; struct to contain the max length.  But it should be possible to typecast any; NetworkSpec to an RString and use all the RString utilities on it. (defrecord NetworkSpec    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (body (:array :signed-byte (- (- #$kNetworkSpecMaxBytes 1) 0 -1)));  Byte ;  always fixed at the max size    )(def-mactype :networkspecptr (find-mactype '(:pointer :networkspec))); *** PackedPathName ***;  struct PackedPathName is a maximum-sized structure.  Allocate one of; these and it will hold any valid packed pathname. (defrecord PackedPathName    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (data (:array :signed-byte (- (- #$kPathNameMaxBytes 1) 0 -1)));  Byte    );  struct ProtoPackedPathName is a minimum-sized structure.  Use this; for a variable-length packed PathName. (defrecord ProtoPackedPathName    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   )(def-mactype :packedpathnameptr (find-mactype '(:pointer :packedpathname)))(def-mactype :protopackedpathnameptr (find-mactype '(:pointer :protopackedpathname))); ; Copy the contents of path1 to path2.  path2Length is the size of path2, and must; be large enough to hold a copy of path1.  A memFull error will be returned if that; is not the case.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyPackedPathName" ("AOCELib"))         ((path1 (:pointer :packedpathname)) (path2 (:pointer :packedpathname)) (path2Length :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 772 path1 path2 path2Length)); $ENDC; ; Returns true if packed path pointer is nil, or is of zero length, or is of; length 2 and nParts of zero.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEIsNullPackedPathName" ("AOCELib"))         ((path (:pointer :packedpathname)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 797 path)); $ENDC; ; OCEUnpackPathName breaks apart the path into its component RStrings, writing string; pointers into the array 'parts', which the client asserts can hold as many as; 'nParts' elements. The number of parts actually found is returned.  Strings are; placed in the array in order from lowest to highest.  The first pathName element; beneath the root appears last.  NOTE THAT THE UNPACKED STRUCT CONTAINS POINTERS INTO; THE PACKED STRUCT - DON'T DELETE OR REUSE THE PACKED STRUCT UNTIL YOU ARE FINISHED; WITH THE UNPACKED STRUCT AS WELL; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEUnpackPathName" ("AOCELib"))         ((path (:pointer :packedpathname)) (parts (:pointer (:pointer :rstring))) (nParts :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 816 path parts nParts)); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackedPathNameSize" ("AOCELib"))         ((parts (:pointer (:pointer :rstring))) (nParts :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 808 parts nParts)); $ENDC; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEDNodeNameCount" ("AOCELib"))         ((path (:pointer :packedpathname)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 812 path)); $ENDC; ; OCEPackPathName packs the parts into the storage provided as 'path'.  path must be; large enough to hold the packed pathname.  A memFull error will be returned if; pathLength is too small.  parts[0] should contain the deepest pathName element,; and parts[nParts - 1] should contain the name of the first pathName element beneath; the root. ; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackPathName" ("AOCELib"))         ((parts (:pointer (:pointer :rstring))) (nParts :signed-integer) (path (:pointer :packedpathname)) (pathLength :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 803 parts nParts path pathLength)); $ENDC; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualPackedPathName" ("AOCELib"))         ((path1 (:pointer :packedpathname)) (path2 (:pointer :packedpathname)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 785 path1 path2)); $ENDC; ; OCEValidPackedPathName checks that the packed PathName is internally consistent.; Returns true if it's ok.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEValidPackedPathName" ("AOCELib"))         ((path (:pointer :packedpathname)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 820 path)); $ENDC; *** DirDiscriminator ***(defrecord DirDiscriminator    (signature :signed-long)   ;;Changing field misc from signed-long to unsigned-long to match C header (pretty-sure)   (misc :unsigned-long)   );  Copies the value of disc1 to disc2. ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyDirDiscriminator" ("AOCELib"))         ((disc1 (:pointer :dirdiscriminator)) (disc2 (:pointer :dirdiscriminator)))   nil   (:stack-trap #xAA5C :d0 769 disc1 disc2)); $ENDC;  Check the equality of two DirDiscriminators. ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualDirDiscriminator" ("AOCELib"))         ((disc1 (:pointer :dirdiscriminator)) (disc2 (:pointer :dirdiscriminator)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 781 disc1 disc2)); $ENDC; ; This structure is called RLI because it really contains all the info you; need to locate a record within the entire name space.  It contains four fields.; The first two are the name of the catalog and a catalog discriminator.  These; two fields are used to indicate to which catalog a given record belongs.  The; discriminator is used to distinguish between two different catalogs that have; the same name.; ; The other two fields in the RLI structure are used to indicate a particular; catalog node within the catalog specified by the directoryName and; discriminator fields.  These fields are exactly analagous to the dirID and; pathname used in HFS.  It is possible to specify a dNode just by dNodeNumber; (pathname is nil), or just by pathname (dNodeNumber is set to kNULLDNodeNumber),; or by a combination of the two.  The latter is called a 'partial pathname', and; while it is valid in the Catalog Manager API, it is not supported by ADAP; catalogs in Release 1.; ; Note that the path parameter does not include the catalog name, but holds; the names of all the nodes on the path to the desired catalog node, starting; with the catalog node and working its way up the tree.; ; *** RLI ***(defrecord DirectoryName    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (body (:array :signed-byte (- (- #$kDirectoryNameMaxBytes 1) 0 -1)));  Byte ;  space for catalog name    )(def-mactype :directorynameptr (find-mactype '(:pointer :directoryname)));  Catalog node number (def-mactype :dnodenum (find-mactype ':signed-long))(defrecord RLI    (directoryName (:pointer :directoryname))    ;  pointer to the name of the catalog root    (discriminator :dirdiscriminator)            ;  used to discriminate between dup catalog names    (dNodeNumber :signed-long)                   ;  number of the node    (path (:pointer :packedpathname))            ;  old-style RLI    )(def-mactype :rliptr (find-mactype '(:pointer :rli))); ; Create a new RLI from the catalog name, discriminator, DNode number, and; PackedPathName.  You must allocate the storage for the RLI and pass in a pointer; to it.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCENewRLI" ("AOCELib"))         ((newRLI (:pointer :rli)) (dirName (:pointer :directoryname)) (discriminator (:pointer :dirdiscriminator)) (dNodeNumber :signed-long) (path (:pointer :packedpathname)))   nil   (:stack-trap #xAA5C :d0 799 newRLI dirName discriminator dNodeNumber path)); $ENDC; ; Duplicate the contents of rli1 to rli2.  No errors are returned. This; simply copies the pointers to the catalog name and path, wiping out any pointer; that you might have had in there.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEDuplicateRLI" ("AOCELib"))         ((rli1 (:pointer :rli)) (rli2 (:pointer :rli)))   nil   (:stack-trap #xAA5C :d0 779 rli1 rli2)); $ENDC; ; Copy the contents of rli1 to rli2.  rli2 must already contain; pointers to structures large enough to hold copies of the corresponding; fields from rli1.  A memFull error will be returned if that is not the case.; So if you allocate a brand new empty destination, you must at least set up; its length fields.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyRLI" ("AOCELib"))         ((rli1 (:pointer :rli)) (rli2 (:pointer :rli)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 775 rli1 rli2)); $ENDC; ; Check the equality of two RLIs.  This will take into account differences; in the case and diacriticals of the directoryName and the PathName.; NOTE THAT THIS WILL FAIL IF rli1 CONTAINS A DNODENUMBER AND A NIL PATHNAME,; AND rli2 CONTAINS kNULLDNodeNumber AND A NON-NIL PATHNAME.  IN OTHER WORDS,; THE TWO rlis MUST BE OF THE SAME FORM TO CHECK FOR EQUALITY.; The one exception is that if the pathname is nil, a dNodeNumber of zero and; kRootDNodeNumber will be treated as equal.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualRLI" ("AOCELib"))         ((rli1 (:pointer :rli)) (rli2 (:pointer :rli)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 789 rli1 rli2)); $ENDC; ; Check the validity of an RLI.  This checks that the catalog name length; is within bounds, and the packed pathname (if specified) is valid.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEValidRLI" ("AOCELib"))         ((theRLI (:pointer :rli)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 823 theRLI)); $ENDC; *** PackedRLI ***; ; struct PackedRLI is a maximum-sized structure.  Allocate one of; these and it will hold any valid packed pathname.; (defconstant $kRLIMaxBytes (+ 0 (+ (record-length :rstring) (+ (record-length :dirdiscriminator) (+ (record-length :dnodenum) #$kPathNameMaxBytes)))))(defrecord PackedRLI    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (data (:array :signed-byte (- (- #$kRLIMaxBytes 1) 0 -1)));  Byte    ); ; struct ProtoPackedRLI is a minimum-sized structure.  Use this; for a variable-length packed RLI.; (defrecord ProtoPackedRLI    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   )(def-mactype :packedrliptr (find-mactype '(:pointer :packedrli)))(def-mactype :protopackedrliptr (find-mactype '(:pointer :protopackedrli))); ; Copy the contents of prli1 to prli2.  prli2Length is the size of prli2, and must; be large enough to hold a copy of prli1.  A memFull error will be returned if that; is not the case.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyPackedRLI" ("AOCELib"))         ((prli1 (:pointer :packedrli)) (prli2 (:pointer :packedrli)) (prli2Length :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 773 prli1 prli2 prli2Length)); $ENDC; ; OCEUnpackRLI breaks apart the prli into its components, writing pointers into; the rli structure.  NOTE THAT THE UNPACKED STRUCT CONTAINS POINTERS INTO THE; PACKED STRUCT - DON'T DELETE OR REUSE THE PACKED STRUCT UNTIL YOU ARE FINISHED; WITH THE UNPACKED STRUCT AS WELL; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEUnpackRLI" ("AOCELib"))         ((prli (:pointer :packedrli)) (theRLI (:pointer :rli)))   nil   (:stack-trap #xAA5C :d0 817 prli theRLI)); $ENDC; ; OCEPackedRLISize computes the number of bytes of memory needed to hold a; PackedRLI manufactured from an RLI.  This length; includes the length of the length field of PackedRLI, so it; is safe to do a NewPtr (OCEPackedRLISize(...)).; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackedRLISize" ("AOCELib"))         ((theRLI (:pointer :rli)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 810 theRLI)); $ENDC; ; OCEPackRLI packs the RLI into the storage provided as 'prli'.  prli must be; large enough to hold the packed RLI.  A memFull error will be returned if; prliLength is too small.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackRLI" ("AOCELib"))         ((theRLI (:pointer :rli)) (prli (:pointer :packedrli)) (prliLength :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 804 theRLI prli prliLength)); $ENDC; ; OCEPackedRLIPartsSize computes the number of bytes of memory needed to hold a; PackedRLI manufactured from the parts of an RLI.  This length; includes the length of the length field of PackedRLI, so it; is safe to do a NewPtr (OCEPackedRLIPartsSize(...)).; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackedRLIPartsSize" ("AOCELib"))         ((dirName (:pointer :directoryname)) (parts (:pointer (:pointer :rstring))) (nParts :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 809 dirName parts nParts)); $ENDC; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackRLIParts" ("AOCELib"))         ((dirName (:pointer :directoryname)) (discriminator (:pointer :dirdiscriminator)) (dNodeNumber :signed-long) (parts (:pointer (:pointer :rstring))) (nParts :signed-integer) (prli (:pointer :packedrli)) (prliLength :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 805 dirName discriminator dNodeNumber parts nParts prli prliLength)); $ENDC; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualPackedRLI" ("AOCELib"))         ((prli1 (:pointer :packedrli)) (prli2 (:pointer :packedrli)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 787 prli1 prli2)); $ENDC; ; Check the validity of a packed RLI.  This checks that the catalog name length; is within bounds, and the packed pathname (if specified) is valid.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEValidPackedRLI" ("AOCELib"))         ((prli (:pointer :packedrli)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 822 prli)); $ENDC; ; If this packed RLI describes a Personal Catalog, this call will return a pointer; to an alias record that can be used to find the actual file.  Otherwise, it returns nil.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEExtractAlias" ("AOCELib"))         ((prli (:pointer :packedrli)))   (:stack (:pointer :aliasrecord))   (:stack-trap #xAA5C :d0 792 prli)); $ENDC; ; This call returns a pointer to a packed RLI that represents the "Catalogs" icon, or; the root of all catalogs.  It is used in the CollabPack.; ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEGetDirectoryRootPackedRLI" ("AOCELib"))         ()   (:stack :packedrli)   (:stack-trap #xAA5C :d0 838)); $ENDC; *** LocalRecordID ***(defrecord LocalRecordID    (cid :creationid)   (recordName (:pointer :rstring))   (recordType (:pointer :rstring))   )(def-mactype :localrecordidptr (find-mactype '(:pointer :localrecordid)));  Create a LocalRecordID from a name, type, and CreationID ; CONST                                         ; CONST; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCENewLocalRecordID" ("AOCELib"))         ((recordName (:pointer :rstring)) (recordType (:pointer :rstring)) (cid (:pointer :creationid)) (lRID (:pointer :localrecordid)))   nil   (:stack-trap #xAA5C :d0 798 recordName recordType cid lRID)); $ENDC; ; Copy LocalRecordID lRID1 to LocalRecordID lRID2.  lRID2 must already contain; pointers to RString structures large enough to hold copies of the corresponding; fields from lRID1.  A memFull error will be returned if that is not the case.; So if you allocate a brand new empty destination, you must at least set up; its length field.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyLocalRecordID" ("AOCELib"))         ((lRID1 (:pointer :localrecordid)) (lRID2 (:pointer :localrecordid)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 770 lRID1 lRID2)); $ENDC; ; Check the equality of two local RIDs.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualLocalRecordID" ("AOCELib"))         ((lRID1 (:pointer :localrecordid)) (lRID2 (:pointer :localrecordid)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 783 lRID1 lRID2)); $ENDC; *** ShortRecordID ***(defrecord ShortRecordID    (rli (:pointer :packedrli))   (cid :creationid)   )(def-mactype :shortrecordidptr (find-mactype '(:pointer :shortrecordid)));  Create a ShortRecordID from an RLI struct and a CreationID ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCENewShortRecordID" ("AOCELib"))         ((theRLI (:pointer :packedrli)) (cid (:pointer :creationid)) (sRID (:pointer :shortrecordid)))   nil   (:stack-trap #xAA5C :d0 801 theRLI cid sRID)); $ENDC; ; Copy ShortRecordID sRID1 to ShortRecordID sRID2.  sRID2 must already contain; pointers to structures large enough to hold copies of the corresponding; fields from sRID1.  A memFull error will be returned if that is not the case.; So if you allocate a brand new empty destination, you must at least set up; its length fields.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyShortRecordID" ("AOCELib"))         ((sRID1 (:pointer :shortrecordid)) (sRID2 (:pointer :shortrecordid)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 778 sRID1 sRID2)); $ENDC; ; Check the equality of two short RIDs.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualShortRecordID" ("AOCELib"))         ((sRID1 (:pointer :shortrecordid)) (sRID2 (:pointer :shortrecordid)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 791 sRID1 sRID2)); $ENDC; *** RecordID ***(defrecord RecordID    (rli (:pointer :packedrli))                  ;  pointer to a packed rli structure    (local :localrecordid)   )(def-mactype :recordidptr (find-mactype '(:pointer :recordid))); 	Create a RecordID from a packed RLI struct and a LocalRecordID.; This doesn't allocate any new space; the RecordID points to the same; packed RLI struct and the same name and type RStrings. ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCENewRecordID" ("AOCELib"))         ((theRLI (:pointer :packedrli)) (lRID (:pointer :localrecordid)) (rid (:pointer :recordid)))   nil   (:stack-trap #xAA5C :d0 800 theRLI lRID rid)); $ENDC; ; Copy RecordID RID1 to RecordID RID2.  RID2 must already contain; pointers to structures large enough to hold copies of the corresponding; fields from lRID1.  A memFull error will be returned if that is not the case.; So if you allocate a brand new empty destination, you must at least set up; its length fields.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyRecordID" ("AOCELib"))         ((rid1 (:pointer :recordid)) (rid2 (:pointer :recordid)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 777 rid1 rid2)); $ENDC; 	Check the equality of two RIDs. ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualRecordID" ("AOCELib"))         ((rid1 (:pointer :recordid)) (rid2 (:pointer :recordid)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 788 rid1 rid2)); $ENDC; *** PackedRecordID ***; ; struct PackedRecordID is a maximum-sized structure.  Allocate one of; these and it will hold any valid packed RecordID.; (defconstant $kPackedRecordIDMaxBytes (+ 0 (+ #$kPathNameMaxBytes (+ (record-length :dnodenum) (+ (record-length :dirdiscriminator) (+ (record-length :creationid) (* 3 (record-length :rstring))))))))(defrecord PackedRecordID    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (data (:array :signed-byte (- (- #$kPackedRecordIDMaxBytes 1) 0 -1)));  Byte    ); ; struct ProtoPackedRecordID is a minimum-sized structure.  Use this; for a variable-length packed RecordID.; (defrecord ProtoPackedRecordID    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   )(def-mactype :packedrecordidptr (find-mactype '(:pointer :packedrecordid)))(def-mactype :protopackedrecordidptr (find-mactype '(:pointer :protopackedrecordid))); ; Copy PackedRecordID pRID1 to PackedRecordID pRID2.  pRID2 must already contain; pointers to structures large enough to hold copies of the corresponding; fields from pRID1.  A memFull error will be returned if that is not the case.; pRID2Length is the number of bytes that can be put into pRID2, not counting the; packed RecordID header.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyPackedRecordID" ("AOCELib"))         ((pRID1 (:pointer :packedrecordid)) (pRID2 (:pointer :packedrecordid)) (pRID2Length :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 774 pRID1 pRID2 pRID2Length)); $ENDC; ; Create a RecordID from a PackedRecordID.; NOTE THAT THE UNPACKED STRUCT CONTAINS POINTERS INTO THE PACKED STRUCT - DON'T DELETE; OR REUSE THE PACKED STRUCT UNTIL YOU ARE FINISHED WITH THE UNPACKED STRUCT AS WELL; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEUnpackRecordID" ("AOCELib"))         ((pRID (:pointer :packedrecordid)) (rid (:pointer :recordid)))   nil   (:stack-trap #xAA5C :d0 818 pRID rid)); $ENDC; ; Create a PackedRecordID from a RecordID.  pRID must be large enough to contain; the packed RecordID.  A memFull error will be returned if that is not the case.; packedRecordIDLength is the number of bytes that can be put into pRID, not; counting the header.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackRecordID" ("AOCELib"))         ((rid (:pointer :recordid)) (pRID (:pointer :packedrecordid)) (packedRecordIDLength :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 806 rid pRID packedRecordIDLength)); $ENDC; ; Compute the number of bytes of memory needed to hold a RecordID when packed. This; length includes the length of the length field of PackedRecordID, so it; is safe to do a NewPtr (OCEPackedRecordIDSize(...)).; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackedRecordIDSize" ("AOCELib"))         ((rid (:pointer :recordid)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 811 rid)); $ENDC; ; Check the equality of two packed RIDs.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualPackedRecordID" ("AOCELib"))         ((pRID1 (:pointer :packedrecordid)) (pRID2 (:pointer :packedrecordid)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 786 pRID1 pRID2)); $ENDC;  OCEValidPackedRecordID checks the validity of a packed record ID. ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEValidPackedRecordID" ("AOCELib"))         ((pRID (:pointer :packedrecordid)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 821 pRID)); $ENDC; *** DSSpec ***(defrecord DSSpec    (entitySpecifier (:pointer :recordid))   (extensionType :ostype)   ;;Changing field extensionsize from signed-integer to unsigned-word to match C header (pretty-darn-sure)   (extensionSize :unsigned-word)   (extensionValue :pointer)   )(def-mactype :dsspecptr (find-mactype '(:pointer :dsspec))); ; struct PackedDSSpec is NOT a maximum-sized structure.  Allocate one of; these and it will hold any valid packed RecordID, but not necessarily any additional; data.; (defconstant $kPackedDSSpecMaxBytes (+ 0 (+ (record-length :packedrecordid) (+ (record-length :ostype) (record-length :uint16)))))(defrecord PackedDSSpec    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (data (:array :signed-byte (- (- #$kPackedDSSpecMaxBytes 1) 0 -1)));  Byte    ); ; struct ProtoPackedDSSpec is a minimum-sized structure.  Use this; for a variable-length packed DSSpec.; (defrecord ProtoPackedDSSpec    ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   )(def-mactype :packeddsspecptr (find-mactype '(:pointer :packeddsspec)))(def-mactype :protopackeddsspecptr (find-mactype '(:pointer :protopackeddsspec))); ; Copy PackedDSSpec pdss1 to PackedDSSpec pdss2.  pdss2 must already contain; pointers to structures large enough to hold copies of the corresponding; fields from pdss1.  A memFull error will be returned if that is not the case.; pdss2Length is the number of bytes that can be put into pdss2, not counting the; packed DSSpec header.; ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCECopyPackedDSSpec" ("AOCELib"))         ((pdss1 (:pointer :packeddsspec)) (pdss2 (:pointer :packeddsspec)) (pdss2Length :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 771 pdss1 pdss2 pdss2Length)); $ENDC; ; Create a DSSpec from a PackedDSSpec.; NOTE THAT THE UNPACKED STRUCT CONTAINS POINTERS INTO THE PACKED STRUCT - DON'T DELETE; OR REUSE THE PACKED STRUCT UNTIL YOU ARE FINISHED WITH THE UNPACKED STRUCT AS WELL.; A pointer to the extension is returned in dss->extensionValue, and the length of that; extension is returned in dss->extensionSize.  If there is no extension, dss->extensionValue will; be set to nil.  This routine will unpack the RecordID (if any) into rid, unpack the rest; into dss, and set dss->entitySpecifier to rid.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEUnpackDSSpec" ("AOCELib"))         ((pdss (:pointer :packeddsspec)) (dss (:pointer :dsspec)) (rid (:pointer :recordid)))   nil   (:stack-trap #xAA5C :d0 815 pdss dss rid)); $ENDC; ; Create a PackedDSSpec from a DSSpec.  pdss must be large enough to; contain the packed RecordID and any extension.  A memFull error will be returned if that; is not the case.  pdssLength is the number of bytes that can be put into pdss,; not counting the header.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackDSSpec" ("AOCELib"))         ((dss (:pointer :dsspec)) (pdss (:pointer :packeddsspec)) (pdssLength :signed-integer))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 802 dss pdss pdssLength)); $ENDC; ; Compute the number of bytes of memory needed to hold a DSSpec when packed. This; length includes the length of the length field of PackedDSSpec, so it; is safe to do a NewPtr (OCEPackedDSSpecSize(...)).; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEPackedDSSpecSize" ("AOCELib"))         ((dss (:pointer :dsspec)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 807 dss)); $ENDC; 	Check the equality of two DSSpecs.  This compares all fields, even the; extension (unless extensionSize == 0).  The extensions are compared in a case-insensitive and; diacrit-insensitive manner. ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualDSSpec" ("AOCELib"))         ((pdss1 (:pointer :dsspec)) (pdss2 (:pointer :dsspec)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 782 pdss1 pdss2)); $ENDC; 	Check the equality of two PackedDSSpecs.  This compares all fields, even the; extension (unless extensionSize == 0).  The extensions are compared in a case-insensitive and; diacrit-insensitive manner. ; CONST                                         ; CONST; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEEqualPackedDSSpec" ("AOCELib"))         ((pdss1 (:pointer :packeddsspec)) (pdss2 (:pointer :packeddsspec)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 784 pdss1 pdss2)); $ENDC; ; Check the validity of a PackedDSSpec.  If extensionType is; 'entn', pdss must contain a valid entitySpecifier.  For all other extensionTypes, a nil; entitySpecifier is valid, but if non-nil, it will be checked for validity.  No check; is made on the extension.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEValidPackedDSSpec" ("AOCELib"))         ((pdss (:pointer :packeddsspec)))   (:stack :boolean)   (:stack-trap #xAA5C :d0 819 pdss)); $ENDC; ; Return info about a DSSpec.  This routine does not check validity.  If the; DSSpec has no extension, we determine whether it represents the root of all; catalogs, a single catalog, a DNode, or a Record.  Else it is invalid.; If the DSSpec has an extension, we simply return the extension type.; ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEGetDSSpecInfo" ("AOCELib"))         ((spec (:pointer :dsspec)))   (:stack :ostype)   (:stack-trap #xAA5C :d0 793 spec)); $ENDC;  OCEGetExtensionType returns the extensionType imbedded in the PackedDSSpec. ; CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEGetExtensionType" ("AOCELib"))         ((pdss (:pointer :packeddsspec)))   (:stack :ostype)   (:stack-trap #xAA5C :d0 796 pdss)); $ENDC; ; OCEStreamPackedDSSpec streams (flattens) a catalog object a little at a time by; calling the DSSpecStreamer routine that you provide.; (def-mactype :dsspecstreamerprocptr (find-mactype ':pointer));  FUNCTION DSSpecStreamer(buffer: UNIV Ptr; count: LONGINT; eof: BOOLEAN; userData: LONGINT): OSErr; (def-mactype :dsspecstreamerupp (find-mactype ':pointer))(defconstant $uppDSSpecStreamerProcInfo #x37E0) ;  FUNCTION (4 byte param, 4 byte param, 1 byte param, 4 byte param): 2 byte result; ; $IFC NOT GENERATINGCFM ;; Generated by translator basic-stack-trap(deftrap ("_NewDSSpecStreamerProc" ("AOCELib"))         ((userRoutine :pointer))   (:stack :pointer)   (:stack-trap #x2E9F)); $ENDC; $IFC NOT GENERATINGCFM;; Inline instructions called as foreign function(deftrap-inline ("_CallDSSpecStreamerProc" ("AOCELib"))  ((buffer :pointer) (count :signed-long) (eof :boolean) (userData :signed-long) (userRoutine :pointer))   :signed-integer   (#x205F #x4E90) ); $ENDC(def-mactype :dsspecstreamer (find-mactype ':pointer)); CONST                                         ; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEStreamPackedDSSpec" ("AOCELib"))         ((dss (:pointer :dsspec)) (stream :pointer) (userData :signed-long) (actualCount (:pointer :signed-long)))   (:stack :signed-integer)   (:stack-trap #xAA5C :d0 829 dss stream userData actualCount)); $ENDC; *** AttributeType ***; ; For the record, an AttributeType is an RString with a smaller maximum size.; I don't just typedef it to an RString, because I want the definition of the AttributeType; struct to contain the max length, because I need to include it in the Attribute struct; below.  But it should be possible to typecast any AttributeType to an RString and use; all the RString utilities on it.; (defrecord AttributeType    (charSet :signed-integer)   ;;Changing field datalength from signed-integer to unsigned-word to match C header (pretty-sure)   (dataLength :unsigned-word)   (body (:array :signed-byte (- (- #$kAttributeTypeMaxBytes 1) 0 -1)));  Byte ;  always fixed at the max size    )(def-mactype :attributetypeptr (find-mactype '(:pointer :attributetype)));  Miscellaneous defines:  (these cannot be made into enums) (defconstant $kMinPackedRStringLength (+ 0 (record-length :protorstring)))(defconstant $kMinPackedRLISize (+ 0 (+ (record-length :protopackedrli) (+ (record-length :dirdiscriminator) (+ (record-length :dnodenum) (+ #$kMinPackedRStringLength (record-length :protopackedpathname)))))))(def-mactype :attributetag (find-mactype ':ostype))(defrecord AttributeValue    (tag :ostype)   ;;Changing field datalength from signed-long to unsigned-long to match C header (pretty-sure)   (dataLength :unsigned-long)   (bytes :pointer)   )(def-mactype :attributevalueptr (find-mactype '(:pointer :attributevalue))); *** Attribute ***(defrecord Attribute    (AttributeType :attributetype)   (cid :creationid)   (value :attributevalue)   )(def-mactype :attributeptr (find-mactype '(:pointer :attribute))); $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEGetIndRecordType" ("AOCELib"))         ((stringIndex :signed-integer))   (:stack :rstring)   (:stack-trap #xAA5C :d0 795 stringIndex)); $ENDC; $IFC NOT GENERATINGCFM;; Generated by translator put-a-constant-word-in-d0(deftrap ("_OCEGetIndAttributeType" ("AOCELib"))         ((stringIndex :signed-integer))   (:stack :attributetype)   (:stack-trap #xAA5C :d0 794 stringIndex)); $ENDC(defconstant _oceTBDispatch #xAA5E); $ALIGN RESET; $POP; $SETC UsingIncludes := OCEIncludes; $ENDC                                         ; __OCE__#|                                              ; $IFC NOT UsingIncludes |#                                             ; $ENDC(provide-interface 'OCE)