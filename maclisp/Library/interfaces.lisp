;;-*- Mode: Lisp; Package: TRAPS -*-;; Macintosh Common Lisp interfaces to some "Not in ROM" routines.;; Copyright 1989-1994 Apple Computer, Inc.;; Copyright 1995 Digitool, Inc.;;;;;;;;;;;;;;;;; Modification History;;;; 03/26/96 gb   lowmem accessors.;; 12/10/95 slh  update trap calls for PPC;;  6/01/95 slh  :str255 -> (:string 255);;  5/19/95 slh  clikloop -> clickloop;; 07/29/93 bill getindstring moves to l1-utils. Stub stays here.;; ------------- 3.0d12;; 11/25/92 bill pb-control-0 & pb-control-1 moved to;;               "ccl:lib;resident-interfaces.lisp";; 10/02/92 bill getvol fixed. setvol, unmountvol, eject, & flushvol;;               now a little easier to make sense of.;; 08/10/92 bill gopmag, gopmagp, c2pstr, p2cstr moved to;;               "ccl:lib;resident-interfaces.lisp";; ------------- 2.0;; 02/18/92 bill numerous corrections and additions from Mike Engber;; ------------- 2.0f2;; 12/18/91 bill getfpos & setfpos;; 12/13/91 bill fix create & FSWrite (thanx to Engber).;;               with-pstring-arg.;; 12/12/91 bill #_LoadResource after #_GetResource;; ------------- 2.0b4;; 11/05/91 bill Engber's fix to openDriver;; 10/31/91 bill Move the memory referencers back to autoloading. ;;               Finish up what Gary got bored with (and who could blame him?);; 08/23/91 bill add killio;; 08/20/91 bill It compiles now;;;;;;;;;;;;;;;;; Still undone, may need to ff-load them:;; startsound, stopsound;(in-package "TRAPS")(defmacro with-pstring-arg ((name string-arg) &body body)  (let ((fn (gensym)))    `(let ((,fn #'(lambda (,name) ,@body)))       (declare (dynamic-extent ,fn))       (call-with-pstring-arg ,fn ,string-arg))))(defun call-with-pstring-arg (fn string)  (cond ((stringp string)         (ccl::with-pstrs ((ps string))           (funcall fn ps)))        ((ccl::macptrp string)         (funcall fn string))        (t (ccl::%badarg string '(or string macptr)))))(defun screenres ()  (values (#_LMGetScrHRes) (#_LMGetScrVRes))); returns two values; 1) refnum or NIL if error; 2) error code(defun openXpp ()  (ccl:with-pstrs ((name ".XPP"))    (ccl:rlet ((pb :paramblockrec))      (setf (ccl:rref pb :paramblockrec.ionameptr) name            (ccl:rref pb :paramblockrec.ioPermssn) 0)      (let ((err (#_PBOpenSync pb)))        (values         (if (eql err #$noErr)           (ccl:rref pb :paramblockrec.iorefnum))         err))))); There isn't a real #_LMGetUnitTableEntryCount, but it's probably; best to "emulate" this.(defun getdctlentry (refnum)  (declare (type (signed-byte 16) refnum))  (setq refnum (- -1 refnum))  (if (>= refnum (the fixnum (#_LMGetUnitTableEntryCount)))    (ccl::%null-ptr)    (ccl::%get-ptr (#_LMGetUTableBase) (ash refnum 2))))(defun opendriver (name)  (with-pstring-arg (namep name)    (ccl:rlet ((pb :hparamblockrec                   :ioCompletion (ccl:%null-ptr)                   :ioNamePtr namep                   :ioPermssn #$fsCurPerm))      (let* ((error (#_PBOpenSync pb)))        (values (if (eql #$noErr error)                  (ccl:pref pb :hparamblockrec.iorefnum))                error)))))(defun fsclose (refnum)  (ccl:rlet ((pb :hparamblockrec))    (setf (ccl:rref pb :hparamblockrec.iorefnum) refnum)    (#_PBCloseSync pb)))(setf (symbol-function 'closedriver) #'fsclose); The volname arg can take three types of values:; 1) T        - the default. Return the volume number as a Lisp string; 2) A macptr - Pointer to at least 256 bytes. The volume name;               will be returned there as a Pascal string.; 3) NIL      - The volume name will be returned as NIL.;               Use this if you're only interested in the vRefnum.; Returns three values:; 1) The name of the default volume in the form described above.; 2) The volume reference number of the default volume; 3) error code.(defun getvol (&optional (volname t) &aux macptrp)  (ccl:rlet ((volname-string (:string 255)))    (ccl:with-macptrs ((volnameP volname-string))      (when (ccl:macptrp volname)        (setq macptrp t)        (ccl:%setf-macptr volnameP volname))      (ccl:rlet ((pb :paramblockrec :ioNamePtr volnameP))        (let ((err (#_GetVol pb)))          (if (eql err #$noerr)            (values             (cond (macptrp volname)                   (volname (ccl:%get-string volnameP))                   (t nil))             (ccl:pref pb :paramblockrec.iovrefnum)             err)            (values nil nil err))))))); setvol, unmountvol, eject, & flushvol all take either; a volume name or a vrefnum. Specify NIL for the volname, if; you want to specify a vrefnum. volname must be a lisp or pascal; string with a colon (":") as the last character.; e.g. (traps::flushvol "hd:")(defmacro with-volume-pb ((pb volname vrefnum) &body body)  (let ((thunk (gensym)))    `(let ((,thunk #'(lambda (nameP)                       (ccl:rlet ((,pb :HParamBlockRec                                      :ioNamePtr nameP                                      :iovRefNum (or ,vrefnum 0)))                         ,@body))))       (call-with-volname-arg ,thunk ,volname))))(defun call-with-volname-arg (thunk volname)  (if volname    (call-with-pstring-arg thunk volname)    (ccl:with-macptrs ((null-ptr (ccl:%null-ptr)))      (funcall thunk null-ptr))))(defun setvol (volname &optional vrefnum)  (with-volume-pb (pb volname vrefnum)    (#_SetVol pb)))(defun unmountvol (volname &optional vrefnum)  (with-volume-pb (pb volname vrefnum)    (#_UnMountVol pb)))(defun eject (volname &optional vrefnum)  (with-volume-pb (pb volname vrefnum)    (#_Eject pb)))(defun flushvol (volname &optional vrefnum)  (with-volume-pb (pb volname vrefnum)    (#_FlushVol pb)))(defun fsdelete (filename vrefnum)  (with-pstring-arg (filename filename)    (ccl:rlet ((pb :hparamblockrec))      (setf (ccl:rref pb :hparamblockrec.ionameptr) filename            (ccl:rref pb :hparamblockrec.iovrefnum) vrefnum            (ccl:rref pb :hparamblockrec.ioVersNum) 0)      (#_PBDeleteSync pb)))); not Life As We Know It at all ...(defun control (refnum cscode csParamPtr)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum)    (setf (ccl:rref pb :paramblockrec.cscode) cscode)    (unless (ccl:%null-ptr-p csParamPtr)      (#_BlockMove csParamPtr (ccl:pref pb :ParamBlockRec.csParam) 22))    (#_Control pb)))(defun status (refnum cscode csParamPtr)  (ccl:rlet ((pb :ParamBlockRec             :ioVRefNum 0             :ioRefNum  refNum             :csCode    csCode))    (prog2     ;Status actually needs to fill in csParam - see TN#262     (#_BlockMove csParamPtr (ccl:pref pb :ParamBlockRec.csParam) 22)     (#_Status pb)     (#_BlockMove (ccl:pref pb :ParamBlockRec.csParam) csParamPtr 22))))(defun killio (refnum)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum)    (setf (ccl:rref pb :paramblockrec.ioCompletion) (ccl:%null-ptr))    (#_KillIO pb))) (defun setchooseralert (flag)  (declare (type fixnum flag))  (let* ((bits (#_LMGetHiliteMode)))    (declare (type (signed-byte 8) bits))    (#_LMSetHiliteMode (if (not flag)                          (logand bits (lognot (ash 1 6)))                         (logior bits (ash 1 6))))    (logbitp 6 bits))); Returns two values instead of taking a var parameter; 1) The refnum or NIL if error; 2) The error code.(defun fsopen (filename vrefnum)  (with-pstring-arg (namep filename)    (ccl:rlet ((pb :hparamblockrec))      (setf (ccl:rref pb :hparamblockrec.ionameptr) namep            (ccl:rref pb :hparamblockrec.iovrefnum) vrefnum            (ccl:rref pb :hparamblockrec.ioMisc) (ccl:%null-ptr)            (ccl:rref pb :hparamblockrec.ioPermssn) 0            (ccl:rref pb :hparamblockrec.ioVersNum) 0)      (let* ((err (ccl:register-trap #xA060 :a0 pb :d0 26 (:signed-integer :d0)))             refnum)        (if (eql err -50)          (setq err (#_PBOpenSync pb)))        (setq refnum (ccl:rref pb :hparamblockrec.iorefnum))        (values (unless (eql refnum -1) refnum) err)))))(defun fsread (refnum countP buffer)  (ccl:rlet ((pb :hparamblockrec))       (setf (ccl:rref pb :hparamblockrec.iorefnum) refnum             (ccl:rref pb :hparamblockrec.ioBuffer) buffer             (ccl:rref pb :hparamblockrec.ioReqCount) (%get-long countp)             (ccl:rref pb :hparamblockrec.ioposmode) #$FSAtMark)       (prog1 (#_PBReadSync pb)         (%put-long countP (ccl:rref pb :hparamblockrec.ioActCount)))))(defun fswrite (refnum countP buffer)  (ccl:rlet ((pb :hparamblockrec                 :iorefnum refnum                 :ioBuffer buffer                 :ioReqCount (%get-long countp)                 :ioPosMode #$FSAtMark))    (prog1 (ccl:register-trap #xA003 :a0 pb (:signed-integer :d0))      (%put-long countP (ccl:rref pb :hparamblockrec.ioActCount))))); Returns two values instead of using a var parameter:; 1) the position; 2) the error code.(defun getfpos (refnum)  (ccl:rlet ((pb :hparamblockrec :ioRefNum refnum))    (let ((errcode (#_GetFPos pb)))      (values (if (eql 0 errcode)                (ccl:pref pb :HParamBlockRec.ioPosOffset))              errcode))))(defun setfpos (refnum posmode posoffset)  (ccl:rlet ((pb :hparamblockrec                 :ioRefNum refnum                 :ioPosMode posmode                 :ioPosOffset posoffset))    (#_SetFpos pb)))(defun getvinfo (drvnum volname vrefnum freebytes)   (with-pstring-arg (volname volname)    (ccl:rlet ((pb :hparamblockrec                   :ioVolIndex 0                   :ionameptr volname                   :iovrefnum drvnum))      (prog1 (ccl:register-trap #xA207 :a0 pb (:signed-integer :d0))        (%put-word vrefnum (ccl:rref pb :hparamblockrec.iovrefnum))        (%put-long freebytes                   (ash (* (ash (ccl:rref pb :hparamblockrec.ioVAlBlkSiz) -9)                           (ccl:rref pb :hparamblockrec.ioVFrBlk))                        9))))))(defun getfinfo (filename vrefnum finderinfoP)  (with-pstring-arg (filename filename)    (ccl:rlet ((pb :hparamblockrec))      (setf (ccl:rref pb :hparamblockrec.ionameptr) filename            (ccl:rref pb :hparamblockrec.iovrefnum) vrefnum            (ccl:rref pb :hparamblockrec.ioFversnum) 0            (ccl:rref pb :hparamblockrec.ioFDirIndex) 0)      (prog1 (ccl:register-trap #xA00C :a0 pb (:signed-integer :d0))        (ccl:register-trap #xA02E                            :a0 (%inc-ptr pb (ccl:get-field-offset :HParamBlockRec.ioFlFndrInfo))                           :a1 finderinfoP                           :d0 16)))))(defun create (filename vrefnum creator filetype)  (with-pstring-arg (filename filename)    (ccl:rlet ((pb :hparamblockrec))      (setf (ccl:rref pb :hparamblockrec.ionameptr) filename            (ccl:rref pb :hparamblockrec.iovrefnum) vrefnum            (ccl:rref pb :hparamblockrec.ioVersNum) 0)      (let ((err (#_Create pb)))        (when (eql err 0)          (when (eql (setq err (#_GetFinfo pb)) 0)            (setf (ccl:rref pb :HParamBlockRec.ioFlFndrInfo.fdCreator) creator                  (ccl:rref pb :HParamBlockRec.ioFlFndrInfo.fdType) filetype                  (ccl:rref pb :HParamBlockRec.ioFlFndrInfo.fdFlags) 0                  (ccl:rref pb :HParamBlockRec.ioFlFndrInfo.fdLocation) #@(0 0)                  (ccl:rref pb :HParamBlockRec.ioFlFndrInfo.fdFldr) 0)            ; _SetFInfo            (setq err (#_SetFinfo pb))))        err)))); Returns two values:; 1) actual count of bytes allocated or NIL if error; 2) error code(defun AllocContig (refNum count)  (ccl::rlet ((pb :ParamBlockRec             :ioRefNum refNum             :ioReqCount count))    (let ((err (#_AllocContig pb)))      (values       (if (eql err #$noErr)         (ccl::pref pb :ParamBlockRec.ioActCount)         err))))); Returns two values:; 1) createdDirID or NIL if error; 2) error code(defun DirCreate (vRefNum parentDirID directoryName)  (ccl:rlet ((pb :HParamBlockRec                   :ioNamePtr directoryName                  :ioVRefNum vRefNum                  :ioDirID parentDirID))    (let ((err  (#_DirCreate pb)))      (values       (if (eql err #$noErr)         (ccl:pref pb :HParamBlockRec.ioDirID))       err))))(defun CatMove (vRefNum dirID oldName newDirID newName)  (with-pstring-arg (old oldName)    (with-pstring-arg (new newName)      (ccl:rlet ((pb :CMovePBRec                     :ioNamePtr old                     :ioVRefNum vRefNum                     :ioNewName new                     :ioNewDirId newDirID                     :ioDirID dirID))        (#_CatMove pb))))); Returns two values:; 1) wdRefNum or NIL if error; 2) error code(defun OpenWD (vRefNum dirID procID)  (ccl:rlet ((pb :WDPBRec                 :ioNamePtr (ccl:%null-ptr)                 :ioVRefNum vRefNum                 :ioWDProcID procID                 :ioWDDirID dirID))    (let ((err (#_OpenWD pb)))      (values       (if (eql err #$noErr)         (ccl:pref pb :WDPBRec.ioVRefNum))       err))))(defun CloseWD (wdRefNum)  (ccl:rlet ((pb :WDPBRec                 :ioVRefNum wdRefNum))    (#_CloseWD pb))); Returns four values:; 1) vRefnum or NIL if error; 2) dirID or NIL if error; 3) procId or NIL if error; 4) error code(defun GetWDInfo (wdRefNum)  (ccl:rlet ((pb :WDPBRec                 :ioNamePtr (ccl:%null-ptr)                 :ioVRefNum wdRefNum                 :ioWDIndex 0                 :ioWDProcID 0                 :ioWDVRefNum 0))    (let ((err (#_GetWDInfo pb)))      (if (eql err #$noErr)        (values (ccl:pref pb :WDPBRec.ioWDVRefNum)                (ccl:pref pb :WDPBRec.ioWDDirID)                (ccl:pref pb :WDPBRec.ioWDProcID)                err)        (values nil nil nil err)))))(defun HCreate (vRefNum dirID fileName creator fileType)  (with-pstring-arg (fileName fileName)    (ccl:rlet ((fi :FInfo                   :fdType fileType                    :fdCreator creator                   :fdFlags 0                   :fdLocation 0                   :fdFldr 0)               (pb :HParamBlockRec                   :ioNamePtr fileName                   :ioVRefNum vRefNum                   :ioFVersNum 0                   :ioFDirIndex 0                   :ioDirID dirID))      (prog1        (#_HCreate pb)        (#_HGetFInfo pb )        (setf (ccl:pref pb :HParamblockRec.ioFlFndrInfo) fi)        (setf (ccl:pref pb :HParamblockRec.ioDirID) dirID)      ;GetFInfo trashes this field        (#_HSetFInfo pb))))); Returns two values:; 1) refnum or NIL if error; 2) error code(defun HOpen (vRefNum dirID fileName permission)  (ccl:rlet ((pb :HParamBlockRec                  :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioPermssn permission                 :ioMisc (ccl:%null-ptr)                 :ioDirID dirID))    (let ((err (#_HOpen pb)))      (values       (if err (ccl:pref pb :HParamBlockRec.ioRefNum))       err)))); Returns two values:; 1) refnum or NIL if error; 2) error code(defun HOpenRF (vRefNum dirID fileName permission)  (ccl:rlet ((pb :HParamBlockRec                  :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioPermssn permission                 :ioMisc (ccl:%null-ptr)                 :ioDirID dirID))    (let ((err (#_HOpenRF pb)))      (values       (if err (ccl:pref pb :HParamBlockRec.ioRefNum))       err))))(defun HDelete (vRefNum dirID fileName)  (ccl:rlet ((pb :HParamBlockRec                  :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioDirID dirID))    (#_HDelete pb)))(defun HSetFlock (vRefNum dirID fileName)  (ccl:rlet ((pb :HParamBlockRec                 :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioDirID dirID))    (#_HSetFlock pb)))(defun HRstFlock (vRefNum dirID fileName)  (ccl:rlet ((pb :HParamBlockRec                 :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioDirID dirID))    (#_HRstFlock pb)))(defun HRename (vRefNum dirID oldName newName)  (ccl:rlet ((pb :HParamBlockRec                 :ioNamePtr oldName                 :ioVRefNum vRefNum                 :ioMisc newName                 :ioDirID dirID))    (#_HRename pb)))(defun HGetFInfo (vRefNum dirID fileName fndrInfo)  (ccl:rlet ((pb :HParamBlockRec                 :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioFDirIndex 0                 :ioDirID dirID))    (prog1      (#_HGetFInfo pb)      (ccl:copy-record (ccl:pref pb :HParamblockRec.ioFlFndrInfo)                        (:finfo :storage :pointer)                       fndrInfo))))(defun HSetFInfo (vRefNum dirID fileName fndrInfo)  (ccl:rlet ((pb :HParamBlockRec                 :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioFDirIndex 0                 :ioDirID dirID))    (prog1      (#_HGetFInfo pb)      (ccl:copy-record fndrInfo (:finfo :storage :pointer)                   (ccl:pref pb :HParamblockRec.ioFlFndrInfo))      (#_HSetFInfo pb)))); returns three values:; 1) vRefnum or NIL if error; 2) dirID or NIL if error; 3) error code(defun HGetVol (volName)  (ccl:rlet ((pb :WDPBRec                 :ioNamePtr volName))    (let ((err (#_HGetVol pb)))      (if (eql err #$noErr)        (values (ccl:pref pb :WDPBRec.ioWDVRefNum)                (ccl:pref pb :WDPBRec.ioWDDirID)                err)        (values nil nil err)))));HSetVol - omitted from IM VI - see TN#140 & IM VI p. 25-7;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; High Level Data Fork Opening Routines - IM VI p. 25.34; Returns two values:; 1) refnum or NIL if error; 2) error code(defun HOpenDF (vRefNum dirID fileName permission)  (ccl:rlet ((pb :HParamBlockRec                  :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioPermssn permission                 :ioDirID dirID))    (let ((err (#_HOpenDF pb)))      (values       (if (eql err #$noErr)         (ccl:pref pb :HParamBlockRec.ioRefNum))       err)))); Returns two values:; 1) refnum or NIL if error; 2) error code(defun OpenDF (fileName vRefNum)  (ccl:rlet ((pb :ParamBlockRec                  :ioNamePtr fileName                 :ioVRefNum vRefNum                 :ioPermssn #$fsCurPerm))    (let ((err (#_OpenDF pb)))      (values       (if (eql err #$noErr)         (ccl:pref pb :ParamBlockRec.ioRefNum))       err)))); Returns two values:; 1) rom; 2) machine(defun environs ()  (let* ((magic-word (ccl::%get-unsigned-word (#_LMGetRomBase) 8))         (high (ash magic-word -8))         (low (logand #xff magic-word)))    (declare (fixnum low high magic-word))    (if (eql #xff low)      (values high 0)      (values low             (logand #xff (the fixnum (1+ high)))))))(defun getitemstyle (themenu item)  (ccl:rlet ((style :signed-integer))    (ccl:Stack-trap #xA941 :ptr themenu :word item :ptr style)    (%get-unsigned-byte style 1)))(defun iustringorder (pstr0 pstr1 ascript bscript alang blang)  (with-pstring-arg (pstr0 pstr0)    (with-pstring-arg (pstr1 pstr1)      (#_IUTextOrder       (ccl:%inc-ptr pstr0)        (ccl:%inc-ptr pstr1)       (ccl:%get-unsigned-byte pstr0)       (ccl:%get-unsigned-byte pstr1)       ascript       bscript       alang       blang))))(defun disablewutime ()  (ccl::%stack-block ((whatever 12))    (%put-word whatever #x82)    (%put-word whatever 0 2)    (%put-long whatever 0 4)    (ccl:register-trap #xa085 :a0 whatever :d0 0 (:signed-integer :d0))))(defun getwutime (wutimep wuflagp)  (ccl::%stack-block ((whatever 12))    (%put-word whatever #x88)    (%put-word whatever 0 2)    (%put-long whatever 0 4)    (%put-long whatever 0 8)    (prog1 (ccl:register-trap #xa085 :a0 whatever :d0 0 (:signed-integer :d0))      (let* ((huh (%get-ptr whatever 8)))        (declare (dynamic-extent huh))        (dotimes (i 4)          (declare (fixnum i))          (%put-byte wutimep (%get-byte huh i) i))        (%put-byte wuflagp (%get-byte whatever 4))))))(defun setwutime (wutime)  (ccl::%stack-block ((whatever 12))    (%put-word whatever #x80)    (%put-word whatever 4 2)    (%put-long whatever wutime 4)    (ccl:register-trap #xa085 :a0 whatever :d0 0 (:signed-integer :d0)))); Returns two values:; 1) status or NIL if error; 2) power or NIL if error; 3) error code(defun batterystatus ()  (ccl::%stack-block ((whatever 12))    (%put-word whatever #x68)    (%put-word whatever 0 2)    (%put-long whatever 0 4)    (%put-long whatever 0 8)    (let ((err (ccl:register-trap #xa085 :a0 whatever :d0 0 (:signed-integer :d0))))      (if (eql err #$noErr)        (values (%get-byte (%get-ptr whatever 8) 0)                (%get-byte whatever 4)                err)        (values nil nil err))))); returns two values:; 1) status or NIL if error; 2) error code(defun modemstatus ()  (ccl::%stack-block ((whatever 12))    (%put-word whatever #x58)    (%put-word whatever 0 2)    (%put-long whatever 0 4)    (%put-long whatever 0 8)    (let ((err (ccl:register-trap #xa085 :a0 whatever :d0 0 (:signed-integer :d0))))      (values       (if (eql err #$noErr) (%get-byte (%get-ptr whatever 8)))       err))))                    (defun drvr-control-0 (refnum code)  (ccl:rlet ((pb :hparamblockrec))    (pb-control-0 pb refnum code 0)))(defun drvr-control-1 (refnum code param)  (ccl:rlet ((pb :paramblockrec))    (pb-control-1 pb refnum code param 0)))(defun drvr-control-1L (refnum code param)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum          (ccl:rref pb :paramblockrec.cscode) code)    (%put-long pb param (ccl:get-field-offset :paramblockrec.csparam))    (ccl:register-trap #xa004 :a0 pb (:signed-integer :d0))))(defun drvr-control-1-immed (refnum code param)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum          (ccl:rref pb :paramblockrec.cscode) code          (ccl:rref pb (:paramblockrec.csparam 0)) param)    (ccl:register-trap #xa004 :trap-modifier-bits #x0200 :a0 pb (:signed-integer :d0))))(defun drvr-control-2L (refnum code param0 param1)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum          (ccl:rref pb :paramblockrec.cscode) code)    (%put-long pb param0 28)    (%put-long pb param1 32)    (ccl:register-trap #xa004 :a0 pb (:signed-integer :d0))))(defun drvr-status-1L (refnum code param)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum          (ccl:rref pb :paramblockrec.cscode) code          (ccl:rref pb (:paramblockrec.csparam 0)) param)    (let* ((error (#_Status pb)))      (values (%get-long pb 28) error))))(defun drvr-status-6P (refnum code resp)  (ccl:rlet ((pb :paramblockrec))    (setf (ccl:rref pb :paramblockrec.iorefnum) refnum          (ccl:rref pb :paramblockrec.cscode) code)    (prog1 (ccl:register-trap #xa004 :a0 pb (:signed-integer :d0))      (%put-long resp (%get-long pb 28))      (%put-word resp (%get-word pb 32) 4)))); Returns two values:; 1) count; 2) message or NIL if count is 0(defun countAppFiles ()  (let ((h (#_LMGetAppParmHandle)))    (declare (dynamic-extent h))    (if (<= (the fixnum (#_GetHandleSize h)) 0)      0      (values       (ccl::%hget-word h)       (ccl::%hget-word h 2)))))(defun getAppFiles (index pAppfile)  (declare (fixnum index))  (setf (ccl:rref pAppfile :appfile.fType) 0)  (let ((h (#_LMGetAppParmHandle)))    (declare (dynamic-extent h))    (unless (and (> (the fixnum (#_GetHandleSize h)) 0)                 (<= 1 index (ccl::%hget-unsigned-word h 2)))      (let* ((offset 4))        (declare (fixnum offset))        (dotimes (i (1- index))          (declare (fixnum i))          (incf offset                 (the fixnum                      (+ 8 (logand -2 (the fixnum (+ 2 (ccl::%hget-unsigned-byte h (+ offset 8)))))))))        (setf (ccl:rref pAppFile :appFile.vrefNum) (ccl::%hget-word h offset)              (ccl:rref pAppfIle :appFile.fTYpe) (ccl::%hget-ostype h (incf offset 2))              (ccl:rref pAppFile :appFile.versnUm) (ccl::%hget-word h (incf offset 4)))        (let* ((src (%inc-ptr (%get-ptr h) (+ 2 offset))))          (declare (dynamic-extent src))        (#_BlockMove          src          (%inc-ptr PappFile (ccl:get-field-offset :appfile.fname))          (1+ (%get-unsigned-byte src))))))))(defun clrAppFiles (index)  (declare (fixnum index))  (let ((h (#_LMGetAppParmHandle)))    (declare (dynamic-extent h))    (unless (and (> (the fixnum (#_GetHandleSize h)) 0)                 (<= 1 index (ccl::%hget-unsigned-word h 2)))      (let* ((offset 4))        (declare (fixnum offset))        (dotimes (i (1- index))          (declare (fixnum i))          (incf offset                 (the fixnum                      (+ 8 (logand -2 (the fixnum (+ 2 (ccl::%hget-unsigned-byte h (+ offset 8)))))))))        (ccl::%hput-long h 0 (+ offset 2)))))); Note that this returns a (possibly 0-length) string.(defun getindstring (resourceID index)  (or (ccl::getindstring resourceID index)      (make-string 0)))(defun getindpattern (resultpattern resourceID index)  (let* ((patH (#_GetResource "PAT#" resourceID)))    (declare (dynamic-extent patH))    (unless (or (ccl:%null-ptr-p patH)                (<= index 0)                (progn                  (#_LoadResource patH)                  (> index (ccl::%hget-unsigned-word patH 0))))      (let* ((offset (+ 2 (* 8 (1- index)))))        (declare (fixnum offset))        (%put-ptr resultpattern (ccl::%hget-ptr patH offset))        (%put-ptr resultpattern (ccl::%hget-ptr patH (+ offset 4)))))))(defun tefromscrap ()  (let* ((error 0))    (ccl:rlet ((scraph :handle)               (offset :longint))      (%put-long offset 0)      (%put-ptr scraph (ccl:%null-ptr))      (if (<= 0 (setq error (#_GetScrap scraph :TEXT offset)))        (if (> error 32000)          (setq error #$teScrapSizeErr)          (progn            (#_LMSetTEScrpHandle scraph)            (%put-long offset 0)            (if (>= 0 (setq error (#_GetScrap scraph :TEXT offset)))              (setq error 0))            (#_LMSetTEScrpLength error)))))      error))(defun tetoscrap ()  (let* ((scrapH (#_LMGetTEScrpHandle))         (error 0))    (declare (dynamic-extent scrapH)             (fixnum error))    (#_Hlock scrapH)    (setq error (#_PutScrap                  (%get-unsigned-word (%int-to-ptr #xAB0))                 :TEXT                  (%get-ptr scrapH)))    (#_HUnlock scrapH)    error)); The "clikproc" should be defined with Assembler (vice Pascal) calling; sequence.(defun setclickloop (clickproc hte)  (setf (ccl:href hte terec.clickloop) clickproc)); The "wbrkproc" should be defined with Assembler (vice Pascal) calling; sequence.(defun setwordbreak (wbrkproc hte)  (setf (ccl:href hte terec.wordbreak) wbrkproc))(defun setsoundvol (level)  (drvr-control-1 -4 2 level))(defun getsoundvol ()  (logand (the fixnum (#_LMGetSdVolume)) #xff))(defun sounddone ()  (let* ((pb (%get-long (%int-to-ptr #x0AE8))))    (or (eql pb -1)        (<= (the fixnum (%get-signed-word (%get-ptr (%int-to-ptr pb) #x10))) 0))))(defun serreset (refnum serconfig)  (drvr-control-1 refnum 8 serconfig))(defun sersetbuf (refnum serbptr serblen)  (drvr-control-2L refnum 9 (ccl:%ptr-to-int serbptr) serblen))(defun serhshake (refnum flags)  (drvr-control-2L refnum 10 (%get-long flags) (%get-long flags 4)))(defun sersetbrk (refnum)  (drvr-control-0 refnum 12))(defun serclrbrk (refnum)  (drvr-control-0 refnum 11))(defun sergetbuf (refnum)  (drvr-status-1L refnum 2 0))(defun serstatus (refnum statusp)  (drvr-status-6P refnum 8 statusp))#|	Change History (most recent last):	2	12/29/94	akh	merge with d13|# ;(do not edit past this line!!)