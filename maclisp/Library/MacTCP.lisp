;-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: ccl -*-;;	Change History (most recent first):;;  6 1/22/97  akh  comments;;  (do not edit before this line!!);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; MacTCP.Lisp; Copyright 1991-1994 Apple Computer, Inc.; Copyright 1995-96 Digitool, Inc.;; TCP streams.;; OPEN-TCP-STREAM creates a stream that does its I/O through a TCP port.;; Modification History;; 10/04/96 bill %word-to-int on the ff-call results in %open-resolver & %tcp-str-to-addr; ------------- 4.0b2; 09/10/96 bill %load-resolver-code uses cpdirid with cpvrefnum; ------------- 4.0b1; ------------- 3.9;  3/09/96 jcma Wrap memerrchk & errchk in eval-when;  3/01/96 bill Rainer Joswig's fix to tcp-host-cname;  2/26/96 bill Merge the cl-http "xmactcp.lisp" into this file.;  2/26/96 bill Revert to using FF-CALL. It does the right thing now.;  2/12/96 bill Update for new traps, wrap UPP's around calls to the resolver code.;  2/04/96 jcma replaced all calls to slot value with faster accessors.;  2/04/96 jcma & gb add %pb-copy and use to avoid PB collisions in print-object and tcp-connection-state;  7/11/95 jcma handle some AppleTalk configuration errors, export all conditions.;  6/09/95 jcma signal unknown-mactcp-error in %tcp-err-disp for unknown error codes;  6/09/95 jcma handled remaining conditions;  6/05/95 jcma installed TCP condition system;  6/05/95 jcma fixed tcp-stream-conn and stream-listen;  6/05/95 jcma fixed stream-close and  new note-stream-closed;  6/01/95 slh  :str255 -> (:string 255);  5/27/95 slh  no :errchk for _sysenvirons;  3/28/95 slh  gestalt not external;  3/11/95 slh  use gestalt bitnum arg;  3/02/95 akh  say element-type 'base-character;  2/15/95 slh  Poeck & JCMa's improved stream-close, %tcp-control; ------------- 3.0d17; 05/17/93 bill #_HOpenResFile doesn't exist in System 6. Replace it;               with hairy working directory wrapper around #_OpenResFile,;               if it doesn't exist.; ------------- 3.0d8; 01/22/93 bill Steve Weyer's fix to make stream-tyi return NIL at EOF.; 06/05/92 bill remove (dbg length); 05/05/92 bill Narinder Singh's mods to add a timeout value for passive opens.;-------------- 2.0; 03/20/92 bill format string needed arg in (initialize-instance (binary-tcp-stream)); 02/27/92 bill Derek's mods to ease subclassing of tcp-stream.; -----------   2.0f3; 02/05/92 gb   change record defs to more nearly match TCPPB.h, etc.; 01/20/92 gb   minimal support for binary i/o.; 12/24/91 gb   fix some bugs; look harder for the resolver.;--------- 2.0b4; 08/20/91 bill %get-cstr -> %get-cstring; 05/20/91 gb   Still needs work.; 01/10/91 bill Remove LAP; 05/08/90 gz   Released;;;------------------------------------------------------------------- ;;;;;; DEFINITIONS;;;(in-package :ccl) (eval-when (:compile-toplevel :load-toplevel :execute)  (export '(open-tcp-stream))(unless (fboundp 'errchk)(defmacro errchk (form)  (let ((res (gensym)))    `(let ((,res ,form))       (unless (eql 0 ,res) (%err-disp ,res))       ,res)))); This is here because :errchk doesn't work correctly; in MCL 3.0 for inline traps, e.g. #_NewPtrClear(unless (fboundp 'memerrchk) (defmacro memerrchk (form)  (let ((res (gensym))        (err-code (gensym)))    `(let ((,res ,form)           (,err-code (require-trap #_memerror)))       (unless (eql 0 ,err-code)         (%err-disp ,err-code))       ,res)))))(load-trap '#_memerror);TCP csCodes(defconstant $ipctlGetAddr 15)(defconstant $TCPCreate 30)(defconstant $TCPPassiveOpen 31)(defconstant $TCPActiveOpen 32)(defconstant $TCPSend 34)(defconstant $TCPNoCopyRcv 35)(defconstant $TCPRcvBfrReturn 36)(defconstant $TCPRcv 37)(defconstant $TCPClose 38)(defconstant $TCPAbort 39)(defconstant $TCPStatus 40)(defconstant $TCPExtendedStat 41)(defconstant $TCPRelease 42)(defconstant $TCPGlobalInfo 43)(defconstant $TCPCtlMax 49);TCP event codes(defconstant $TCPClosing 1)(defconstant $TCPULPTimeout 2)(defconstant $TCPTerminate 3)(defconstant $TCPDataArrival 4)(defconstant $TCPUrgent 5)(defconstant $TCPICMPReceived 6);TCP termination reasons(defconstant $TCPRemoteAbort 2)(defconstant $TCPNetworkFailure 3)(defconstant $TCPSecPrecMismatch 4)(defconstant $TCPULPTimeoutTerminate 5)(defconstant $TCPULPAbort 6)(defconstant $TCPULPClose 7)(defconstant $TCPServiceError 8);ValidityFlags(defconstant $TCPtimeoutValue #x80)(defconstant $TCPtimeoutAction #x40)(defconstant $TCPtypeOfService #x20)(defconstant $TCPprecedence #x10);TOSFlags(defconstant $TCPlowDelay #x01)(defconstant $TCPthroughPut #x02)(defconstant $TCPreliability #x04); error codes(defconstant $TCPTimeout -23016)(eval-when (:compile-toplevel :load-toplevel :execute)  (defrecord IPParamBlock  (qLink pointer)  (qType integer)  (ioTrap integer)  (ioCmdAddr pointer)  (ioCompletion pointer)  (ioResult integer)  (ioNamePtr pointer)  (ioVRefNum integer)  (ioCRefNum integer)  (csCode integer)  (ourAddress unsigned-long)  (ourNetMask unsigned-long))(defrecord tcpCreatePB  (rcvBuff pointer)  (rcvBuffLen longint)                 ; should be unsigned.  (notifyProc pointer)  (userDataPtr pointer))(defrecord tcpReleasePB  (rcvBuff pointer)  (rcvBuffLen longint))(defrecord tcpOpenPB  (ulpTimeoutValue byte)  (ulpTimeoutAction byte)  (validityFlags byte)  (commandTimeoutValue byte)  (remoteHost unsigned-long)  (remotePort integer)  (localHost unsigned-long)  (localPort integer)  (tosFlags byte)  (precedence byte)  (dontFrag byte)  (timeToLive byte)  (security byte)  (optionCnt byte)  (options (string 39))  (userDataPtr pointer))(defrecord tcpSendPB  (ulpTimeoutValue byte)  (ulpTimeoutAction byte)  (validityFlags byte)  (pushFlag byte)  (urgentFlag byte)  (fill byte)  (wdsPtr pointer)  (sendFree longint)                    ; unsigned  (sendLength unsigned-integer)  (userDataPtr pointer))(defrecord tcpReceivePB  (commandTimeoutValue byte)  (fill byte)  (markFlag byte)  (urgentFlag byte)  (rcvBuff pointer)  (rcvBuffLen unsigned-integer)  (rdsPtr pointer)  (rdsLength unsigned-integer)  (secondTimeStamp unsigned-integer)  (userDataPtr pointer))(defrecord tcpClosePB  (ulpTimeoutValue byte)  (ulpTimeoutAction byte)  (validityFlags byte)  (fill byte)  (userDataPtr pointer))(defrecord tcpAbortPB  (userDataPtr pointer))(defrecord tcpStatusPB  (ulpTimeoutValue byte)  (ulpTimeoutAction byte)  (fill1 longint)  (remoteHost unsigned-long)  (remotePort unsigned-integer)  (localHost unsigned-long)  (localPort unsigned-integer)  (tosFlags byte)  (precedence byte)  (connectionState byte)  (fill2 byte)  (sendWindow unsigned-integer)  (rcvWindow unsigned-integer)  (amtUnackedData unsigned-integer)  (amtUnreadData unsigned-integer)  (securityLevelPtr pointer)  (sendUnacked longint)  (sendNext longint)  (congestionWindow longint)  (rcvNext longint)  (srtt longint)  (lastRTT longint)  (sendMaxSegSize longint)  (connStatPtr pointer)  (userDataPtr pointer))(defrecord tcpGlobalInfoPB  (tcpParamPtr pointer)  (tcpStatsPtr pointer)  (tcpCDBTable pointer)  (userDataPtr pointer))(defrecord tcpIOPB  (qLink pointer)  (qType integer)  (ioTrap integer)  (ioCmdAddr pointer)  (ioCompletion pointer)  (ioResult integer)  (ioNamePtr pointer)  (ioVRefNum integer)  (ioCRefNum integer)  (csCode integer)  (StreamPtr pointer)  (variant   ((create tcpCreatePB))   ((release tcpReleasePB))   ((open tcpOpenPB))   ((send tcpSendPB))   ((receive tcpReceivePB))   ((close tcpClosePB))   ((abort tcpAbortPB))   ((status tcpStatusPB))   ((globalinfo tcpGlobalInfoPB))))(defrecord hostinfo  (rtnCode longint)  (cname (string 255))  (addr1 unsigned-long)  (addr2 unsigned-long)  (addr3 unsigned-long)  (addr4 unsigned-long)  ;This is our own extension...  (result integer))) ;defrecord eval-when(defconstant $cacheFault -23042)(defconstant $tcpPBsize (record-length :tcpioPB));;;------------------------------------------------------------------- ;;;;;; MacTCP.Lisp ;;;(defvar *use-resolver* t)(defparameter *service-name-number-alist*  '(("echo" . 7)    ("discard" . 9)                     ; sink null    ("systat" . 11)    ("daytime" . 13)    ("netstat"	. 15)    ("ftp-data" . 20)    ("ftp" . 21)    ("telnet" . 23)    ("smtp" . 25)    ("time" . 37)    ("name" . 32)                       ; (udp only)    ("whois" . 43)                      ; usually to sri-nic    ("domain" . 53)    ("hostnames" . 101)                 ; usually to sri-nic    ("http" . 80)    ("sunrpc" . 111)    ("rje" . 77)    ("finger" . 79)    ("link" . 87)                       ; ttylink    ("supdup" . 95)    ("iso-tsap" . 102)    ;("x400" . 103)                      ; # ISO Mail    ("dictionary" . 103)    ("x400-snd" . 104)    ("csnet-ns" . 105)    ("pop" . 109)    ("uucp-path" . 117)    ("nntp" . 119)    ("ntp" . 123)    ("NeWS" . 144)    ; UNIX specific services    ;these are NOT officially assigned    ("exec" . 512)    ("login" . 513)    ("shell" . 514)    ("printer" . 515)                   ; spooler	# experimental    ("courier" . 530)                   ; rpc		# experimental    ("biff" . 512)                      ; (udp only) comsat    ("who" . 513)                       ; (udp only)    ("syslog" .	514)                    ; (udp only)    ("talk" . 517)                      ; (udp only)    ("route" . 520)                     ; (udp only)    ("new-rwho" . 550)                  ; (udp only)	# experimental    ("rmonitor" . 560)                  ; (udp only) 	# experimental    ("monitor" . 561)                   ; (udp only)	# experimental    ("ingreslock" . 1524)    ("imap" . 143)))(defvar *tcp-driver-refnum* nil)(defvar %resolver-code% nil)(defvar %tcp-set-result-proc% nil)(defvar %hinfo-record% nil)(defvar *open-tcp-streams* nil)(def-load-pointers tcp ()  (let* ((code '(#x225f                  ; spop a1                 #x584f                  ; addq #4,sp                 #x205f                  ; spop a0                 #x3168 #x0002 #x0114    ; move.w 2(a0),hostinfo.result(a0)                 #x4ed1))                ; jmp (a1)         (codelen (length code)))    (setq *tcp-driver-refnum* nil)    (setq %resolver-code% nil)    (setq %tcp-set-result-proc% (let ((ptr (#_NewPtr (+ codelen codelen))))                                  (dotimes (i codelen ptr)                                    (%put-word ptr (pop code) (+ i i)))))    (setq %hinfo-record% (make-record :hostinfo))))(defun tcp-driver-refnum ()  (or *tcp-driver-refnum*      (with-pstrs ((name ".ipp"))        (rlet ((pb hparamblockrec))          (setf (rref pb hparamblockrec.ionameptr) name                (rref pb hparamblockrec.iocompletion) (%null-ptr)                (rref pb hparamblockrec.ioPermssn) 0)          (errchk (#_PBOpenSync pb))          (setq *tcp-driver-refnum* (rref pb hparamblockrec.ioRefNum))))));;;------------------------------------------------------------------- ;;;;;;  %TCP-CONTROL: THE PRIMARY INTERFACE TO MACTCP;;; (defun %tcp-control (pb code &optional ignore-error-p ignore-timeout)  (setf (rref pb tcpioPB.csCode) code        (rref pb tcpioPB.ioCompletion) (%null-ptr))  (let ((err nil))    (loop (when (eql (setq err (#_PBControlAsync pb)) 0)            (unless (eql code $TCPPassiveOpen) ; added 2/15/95              (let* ((*interrupt-level* 0))                (while (> (setq err (rref pb tcpioPB.ioResult)) 0)))))          (return))    (unless (or ignore-error-p                (eql err 0)                (and ignore-timeout (eql err $TCPTimeout)))      (%tcp-err-disp err))    err));;;------------------------------------------------------------------- ;;;;;;  DEBUGGING %TCP-CONTROL;;;;;; Date: Tue, 30 Jan 1996 05:50:06 -0800 (PST);;; From: gb@digitool.com;;;  ;;; In the situation that I -have- been able to reproduce, the Mac OS is looping because its queue of ;;; outstanding asynchronous I/O requests has become corrupted. The elements of that queue are, of ;;; course, the parameter blocks used to make the asynchronous calls, and the "corruption" in question ;;; is a self-referential (circular) entry. In short, a parameter block has been used while there are still ;;; asynchronous requests pending, and this can't work. ;;;  ;;; I made the following changes to the %TCP-CONTROL function in "xmactcp.lisp" in order to ;;; approximate (in the list *ACTIVE-TCP-CONTROL-PBS*) the set of I/O requests in the OS's queue. ;;; (It's approximate because some requests may complete before being enqueued and some requests ;;; may be dequeued by interrupt-level code.) It didn't take much server activity to trigger the BREAK ;;; call in this case. ;;; ;;; Note that because all of the callers of %TCP-CONTROL use the same parameter block - created when ;;; the tcp-connection was established - the restriction on the (re-)use of a PB when asynchronous I/O ;;; requests are outstanding effectively means that only one call to %TCP-CONTROL can be outstanding ;;; on a connection at any time. I don't know enough about the architecture of CL-HTTP to know why ;;; this condition is not being met, but as things stand there seems to be a resource-contention problem ;;; here, and if "bad timing" is bad enough, that problem can cause the OS to lock up in some low-level ;;; asynchronous I/O code. ;;; ;;; It's not too hard to change %TCP-CONTROL's callers to pass unique (stack- allocated) parameter ;;; blocks to it, plucking the connection-specific fields out of the "global" PB as needed. Since there's ;;; other connection-specific state (buffer addresses and such) involved, having multiple pending ;;; asynchronous calls on the same connection would still raise resource- contention issues, but they ;;; might be much less insidious issues.#|(defparameter *active-tcp-control-pbs* ())(defun %tcp-control (pb code &optional ignore-error-p ignore-timeout)   (when (member pb *active-tcp-control-pbs*)       (break "I/O request still pending on ~s" pb))   (setf (rref pb tcpioPB.csCode) code            (rref pb tcpioPB.ioCompletion) (%null-ptr))   (let ((err nil))      (loop         (when (eql (setq err (#_PBControlAsync pb )) 0)             (unless (eql code $TCPPassiveOpen) ; added 2/15/95                (without-interrupts (push pb *active-tcp-control-pbs*))                (let* ((*interrupt-level* 0))                   (while (> (setq err (rref pb tcpioPB.ioResult)) 0))                   (without-interrupts                      (setq *active-tcp-control-pbs*                               (delete pb *active-tcp-control-pbs*))))))         (return))      (unless (or ignore-error-p                        (eql err 0)                        (and ignore-timeout (eql err $TCPTimeout)))         (%tcp-err-disp err))      err))|# ;;;------------------------------------------------------------------- ;;;;;;  CONTINUE CODE;;;;Timeout should be an arg...(defun tcp-active-open (address port &optional (bufsize 8192) notify-routine)  (let ((pb nil))    (unwind-protect      (progn        (setq pb (memerrchk (#_NewPtrClear (+ bufsize $tcpPBSize))))        (%tcp-create pb (%inc-ptr pb $tcpPBSize) bufsize notify-routine)        (%tcp-active-open pb address port)        (prog1 pb (setq pb nil)))      (when pb        (unless (%null-ptr-p (rref pb tcpioPB.streamPtr))          (setf (rref pb tcpioPB.csCode) $TCPRelease)          (#_PBControlSync pb))        (#_DisposePtr pb)))))(defun %tcp-create (pb RcvBuff RcvBuffLen notifyProc)  (setf (rref pb tcpioPB.ioCRefNum) (tcp-driver-refnum)        (rref pb tcpioPB.create.RcvBuff) RcvBuff        (rref pb tcpioPB.create.RcvBuffLen) RcvBuffLen        (rref pb tcpioPB.create.notifyProc) (or notifyProc (%null-ptr)))  (%tcp-control pb $TCPCreate)); Wait for a connection (from any host, port) to us.(defun %tcp-passive-open (pb port &optional (timeout 30))  (setf (rref pb tcpioPB.open.validityFlags) 0        (rref pb tcpioPB.open.commandTimeoutValue) timeout        (rref pb tcpioPB.open.localPort) port        (rref pb tcpioPB.open.optionCnt) 0        (rref pb tcpioPB.open.remoteHost) 0        (rref pb tcpioPB.open.remotePort) 0        (rref pb tcpioPB.open.timeToLive) 0)      ; time-to-live = 60 hops  (%tcp-control pb $TCPPassiveOpen nil t))(defun %tcp-active-open (pb address port)  (setf (rref pb tcpioPB.open.validityFlags) 0   ; let timeouts, etc default.        (rref pb tcpioPB.open.localPort) 0       ; default our port        (rref pb tcpioPB.open.timeToLive) 0      ; time-to-live = 60 hops        (rref pb tcpioPB.open.optionCnt) 0       ; What are TCP options?        (rref pb tcpioPB.open.localHost) (%tcp-getaddr)        (rref pb tcpioPB.open.remoteHost) address        (rref pb tcpioPB.open.remotePort) port)  (%tcp-control pb $TCPActiveOpen))(defun %tcp-getaddr ()  (rlet ((pb :IPParamBlock))    (setf (rref pb IPParamBlock.ioCRefNum) (tcp-driver-refnum))    (%tcp-control pb $ipctlGetAddr)    (values (rref pb IPParamBlock.ourAddress)            (rref pb IPParamBlock.ourNetMask))))(defun %tcp-send (pb bufptr buflen push-p)  (when (%i> buflen #xFFFF) (report-bad-arg buflen '(integer 0 #xFFFF)))  (%stack-block ((wds 8))    (%put-word wds buflen 0)    (%put-ptr wds bufptr 2)    (%put-word wds 0 6)    (setf (rref pb tcpioPB.send.wdsPtr) wds          (rref pb tcpioPB.send.pushFlag) (if push-p -1 0)          (rref pb tcpioPB.send.urgentFlag) 0          (rref pb tcpioPB.send.validityFlags) 0)    (%tcp-control pb $TCPSend)))(defun tcp-send (pb string push-p)  (if (<= (length string) 1024)    (with-cstr (buf string)      (%tcp-send pb buf (length string) push-p))    (multiple-value-bind (sstr start end) (get-sstring string)      (declare (type fixnum start end))      (%stack-block ((buf 1024))        ; This code is untested because nobody calls TCP-SEND        (let ((sstr-ptr (%null-ptr))              len)          (declare (dynamic-extent sstr-ptr)                   (type macptr sstr-ptr)                   (type fixnum len))          (loop            (setq len (- end start))            (if (<= len 0) (return))            (if (< 1024 len) (setq len 1024))            (without-interrupts             (%address-to-macptr sstr sstr-ptr)             (#_BlockMove (%inc-ptr sstr-ptr (+ 7 start))  buf  len))            (setq start (+ start 1024))            (%tcp-send pb buf len (and push-p (>= start end)))))))))(defun %address-to-macptr (address &optional (macptr (%null-ptr)))  (%setf-macptr macptr (%int-to-ptr (%address-of address))))(defun %tcp-rcv (pb ptr len timeout)  (setf (rref pb tcpioPB.Receive.commandTimeoutValue) timeout        (rref pb tcpioPB.Receive.rcvBuff) ptr        (rref pb tcpioPB.Receive.rcvBuffLen) (require-type len '(integer 0 #xFFFF)))  (%tcp-control pb $TCPRcv)  (rref pb tcpioPB.Receive.rcvBuffLen))(defun %tcp-bfrreturn (pb rds)  (setf (rref pb tcpioPB.Receive.rdsPtr) rds)  (%tcp-control pb $TCPRcvBfrReturn))(defun %tcp-nocopyrcv (pb rdsptr rdslen timeout)  (setf (rref pb tcpioPB.Receive.commandTimeoutValue) timeout        (rref pb tcpioPB.Receive.rdsPtr) rdsptr        (rref pb tcpioPB.Receive.rdsLength) (require-type rdslen '(integer 0 #xFFFF)))  (%tcp-control pb $TCPNoCopyRcv))(defun %tcp-close (pb)  (setf (rref pb tcpioPB.close.validityFlags) 0)  (%tcp-control pb $TCPClose))(defun %tcp-abort (pb)  (%tcp-control pb $TCPAbort))(defun %tcp-release (pb)                ; This does a TCPAbort...  (unless (%null-ptr-p (rref pb tcpioPB.StreamPtr))    (%tcp-control pb $TCPRelease)    (setf (rref pb tcpioPB.StreamPtr) (%null-ptr)))  nil)(defun tcp-release (pb)  (unless (%null-ptr-p pb)    (%tcp-release pb)    (%setf-macptr pb (%null-ptr))))(defun %pb-deallocate (pb)  (unless (ccl:%null-ptr-p (rref pb tcpioPB.StreamPtr))    (%tcp-control pb $TCPRelease T))  (#_DisposePtr pb));;;------------------------------------------------------------------- ;;;;;; RESOLVER ;;;(defconstant $openresolver 1)(defconstant $closeresolver 2)(defconstant $strtoaddr 3)(defconstant $addrtostr 4)(defconstant $enumcache 5)(defconstant $addrtoname 6) (defun find-system-folder ()  (let* ((wdrefnum           (rlet ((info :SysEnvRec))            (#_SysEnvirons 1 info)            (rref info SysEnvRec.sysVRefNum))))    (rlet ((pb :hparamblockrec)           (nameptr (:string 31)))      (setf (rref pb :hparamblockrec.ioWDIndex) 0            (rref pb :hparamblockrec.ionameptr) nameptr            (rref pb :hparamblockrec.ioVrefNum) wdrefnum            (rref pb :hparamblockrec.ioWDProcID) 0)      (if (eql #$noErr (#_PBGetWDInfoSync pb))        (values (rref pb :hparamblockrec.ioWDVrefNum)                (rref pb :hparamblockrec.ioWDDirID))        (values nil nil)))))(defun find-control-panels-folder ()  (let* ((vrefnum nil)         (dirID nil))    (when (ccl::gestalt #$gestaltFindFolderAttr #$gestaltFindFolderPresent)      (rlet ((vrefnumP :signed-integer)             (diridP :signed-long))        (when (eql #$noErr                    (#_FindFolder                     #$kOnSystemDisk                     #$kControlPanelFolderType                    #$kDontCreateFolder                    vRefNumP                    dirIDP))          (setq vrefnum (%get-signed-word vrefnump)                dirid (%get-signed-long diriDP)))))    (values vrefnum dirID)))(defun %load-resolver-code ()  (or %resolver-code%      (multiple-value-bind (sysvrefnum sysdirid) (find-system-folder)        (multiple-value-bind (cpvrefnum cpdirid) (find-control-panels-folder)          (setq %resolver-code%                (or                  (%find-dnr "cdev" "ztcp" cpvrefnum cpdirid)    ; 1.1                 (%find-dnr "cdev" "mtcp" sysvrefnum sysdirid)  ; 1.0.x in system folder                 (%find-dnr "cdev" "mtcp" cpvrefnum cpdirid)    ; 1.0.x in control panels folder                 (error "Can't load MacTCP Domain Name Resolver")))))))#+ppc-target(eval-when (:compile-toplevel :execute)(let ((*warn-if-redefine* nil))(defmacro traps::_StripAddress (x) x)))(defun %find-dnr (type creator vrefnum dirid)  ; Returns detached handle to DNRP resource or NIL.  (when vrefnum    (rlet ((name (:string 255))           (pb :hparamblockrec))      (setf (rref pb :hparamblockrec.ionameptr) name            (rref pb :hparamblockrec.iovrefnum) vrefnum            (rref pb :hparamblockrec.ioDirID) dirid            (rref pb :hparamblockrec.ioFDirIndex) 1)      (do* ()           ((not (eql #$noErr (#_PBHGetFinfoSync pb))) nil)        (if (and (string= (rref pb :hparamblockrec.ioFlFndrInfo.fdType) type)                 (string= (rref pb :hparamblockrec.ioFlFndrInfo.fdCreator) creator))          (let* ((refnum (HOpenResFile vrefnum dirid name #$fsRdPerm)))            (if (eql refnum -1)              (return nil)              (unwind-protect                (let* ((dnrp (#_Get1IndResource "dnrp" 1)))                  (unless (%null-ptr-p dnrp)                    (#_DetachResource dnrp)                    (#_HLock dnrp)                    (%setf-macptr dnrp (#_StripAddress (%get-ptr dnrp)))                    (return dnrp)))                (#_CloseResFile refnum))))          (progn            (setf (rref pb :hparamblockrec.ioDirID) dirid)        ; clobbered by _PBHGetFinfoSync            (incf (rref pb :hparamblockrec.ioFDirIndex))))))))(defun set-vrefnum (vrefnum)  (rletZ ((pb :paramblockrec))    (setf (pref pb :paramblockrec.iovrefnum) vrefnum)    (errchk (#_PBSetVolSync pb))    vrefnum))(defun get-vrefnum ()  (rletZ ((pb :paramblockrec))    (errchk (#_PBGetVolSync pb))    (pref pb :paramblockrec.iovrefnum)))(defmacro with-vrefnum (vrefnum &body body)  (let ((saved-vrefnum (gensym)))    `(let ((,saved-vrefnum (get-vrefnum)))       (unwind-protect         (progn           (set-vrefnum ,vrefnum)           ,@body)         (set-vrefnum ,saved-vrefnum)))))#-ppc-target; Don't need this on the PPC since #_HOpenResFile always exists there(progn; trap-available-p algorithm comes from the Think Reference(defun num-toolbox-traps ()  (with-macptrs (p1 p2)    (if (eql (%setf-macptr p1 (#_NGetTrapAddress :tool #_InitGraf))             (%setf-macptr p2 (#_NGetTrapAddress :tool (+ #_InitGraf #x200))))      #x0200      #x0400)))(defmacro tool-trap-p (theTrap)  `(not (eql 0 (logand ,theTrap #x800))))(defconstant _unimplemented #xa89f)(defun trap-available-p (theTrap)  (with-macptrs (p1 p2)    (if (tool-trap-p theTrap)      (unless (>= (setq theTrap (logand theTrap #x07ff)) (num-toolbox-traps))        ; The %setf-macptr's here are to prevent consing        (not (eql (%setf-macptr p1 (#_NGetTrapAddress :tool thetrap))                  (%setf-macptr p2 (#_NGetTrapAddress :tool _UnImplemented)))))      (not (eql (%setf-macptr p1 (#_NGetTrapAddress thetrap))                (%setf-macptr p2 (#_NGetTrapAddress :tool _UnImplemented)))))))(defvar *hopenresfile-available-p* nil)(def-load-pointers *hopenresfile-available-p* ()  (setq *hopenresfile-available-p* (trap-available-p #_HOpenResFile))))  ; end of #-ppc-target progn#-ppc-target(defun HOpenResFile (vrefnum dirid name permission)  (if *HOpenResFile-available-p*    (#_HOpenResFile vrefnum dirid name permission)    (rletZ ((pb :WDPBRec))      (setf (pref pb :WDPBRec.ioWDDirID) dirid            (pref pb :WDPBRec.ioWDProcID) :ccl2            (pref pb :WDPBRec.ioVRefnum) vrefnum)      (let ((err -1))        (unwind-protect          (progn            (setq err (#_PBOpenWDSync pb))            (unless (eql 0 err)              (%err-disp err))            (with-vrefnum (pref pb :WDPBRec.ioVRefnum)              (#_OpenResFile name)))          (when (eql 0 err) (#_PBCloseWDSync pb)))))))#+ppc-target(defun HOpenResFile (vrefnum dirid name permission)  (#_HOpenResFile vrefnum dirid name permission))(defun %open-resolver (&optional hosts-file)  (unless %resolver-code%    (let* ((err -1))      (unwind-protect        (progn          (%load-resolver-code)          (with-cstr (np (or hosts-file ""))            (when (null hosts-file) (%setf-macptr np (%null-ptr)))            (setq err (%word-to-int (ff-call %resolver-code% :ptr np :long $openresolver :d0))))          (unless (eql err 0) (%tcp-err-disp err)))        (unless (eql err 0) (%dispose-resolver))))))(defun %close-resolver ()  (when %resolver-code%    (ff-call %resolver-code% :long $closeresolver :d0)     (%dispose-resolver)))(defun %dispose-resolver ()  (when %resolver-code%    (let ((code %resolver-code%))      (setq %resolver-code% nil)      (%setf-macptr code (#_RecoverHandle code))      (#_HUnlock code)      (#_DisposeHandle :errchk code))))(defun %tcp-enum-cache (resultproc userdataptr)  (%open-resolver)  (ff-call %resolver-code% :ptr userdataptr :ptr resultproc  :long $enumcache :d0))(defun %tcp-addr-to-name (addr hostinfoptr resultproc userdataptr)  (%open-resolver)  (ff-call %resolver-code%           :ptr (or userdataptr (%null-ptr))           :ptr (or resultproc (%null-ptr))           :ptr hostinfoptr           :long addr           :long $addrtoname           :d0))(defun tcp-addr-to-name (addr)  (setf (rref %hinfo-record% hostinfo.result) 1)  (let ((err (%tcp-addr-to-name addr %hinfo-record% %tcp-set-result-proc% nil)))    (when (eq err $cacheFault)      (while (eq (setq err (rref %hinfo-record% hostinfo.result)) 1)))    err))(defun %tcp-str-to-addr (host-name hostinfoptr resultproc userdataptr)  (%open-resolver)  (with-cstr (np host-name)    (%word-to-int     (ff-call %resolver-code%              :ptr (or userdataptr (%null-ptr))              :ptr (or resultproc (%null-ptr))              :ptr hostinfoptr              :ptr np              :long $strtoaddr              :d0))))(defun tcp-str-to-addr (host-name)  (setf (rref %hinfo-record% hostinfo.result) 1)  (let ((err (%tcp-str-to-addr host-name %hinfo-record% %tcp-set-result-proc% nil)))    (when (eq err $cacheFault)      (while (eq (setq err (rref %hinfo-record% hostinfo.result)) 1)))    err))#|(defun %tcp-addr-to-str (addr strptr)  (%open-resolver)  (ff-call %resolver-code% :ptr strptr :long addr :long $addrtostr :d0))(defun tcp-addr-to-str (addr)  (%stack-block ((str 16))    (%tcp-addr-to-str addr str)    (%get-cstring str)))|#(defun tcp-addr-to-str (addr)  (format nil "~D.~D.~D.~D"          (ldb (byte 8 24) addr)          (ldb (byte 8 16) addr)          (ldb (byte 8 8) addr)          (ldb (byte 8 0) addr)))(defun tcp-ip-str-to-addr (ip-string)  (loop with answer = 0        with start = 0        for pos in '(24 16 8 0)        for dot = (position #\. ip-string :start start)        for number = (parse-integer ip-string :start start                                     :radix 10                                    :end (or dot (length ip-string)))        do (setq answer (dpb number (byte 8 pos) answer)                 start (and dot (1+ dot)))        finally (return answer)))(defun tcp-host-address (host-name)  (if (integerp host-name)    host-name    (if (and (stringp host-name) (eql 0 (length host-name)))      (values (%tcp-getaddr))      (if *use-resolver*        (let ((err (tcp-str-to-addr host-name)))          (unless (eql err 0) (%tcp-err-disp err))          (rref %hinfo-record% hostinfo.addr1))        (tcp-ip-str-to-addr host-name)))))(defun tcp-host-cname (host-address)  (unless (integerp host-address)    (setq host-address (tcp-host-address host-address)))  (if *use-resolver*    (let ((err (tcp-addr-to-name host-address)))      (unless (eql err 0) (%tcp-err-disp err))      ;(break "foo")      (%get-cstring %hinfo-record% 4))    (tcp-addr-to-str host-address)))(defun tcp-host-info (host-name)  (when (integerp host-name)    (setq host-name (tcp-addr-to-str host-name)))  (let ((err (tcp-str-to-addr host-name)))    (unless (eql err 0) (%tcp-err-disp err))    (values (%get-cstring %hinfo-record% 4)            (rref %hinfo-record% hostinfo.addr1)            (rref %hinfo-record% hostinfo.addr2)            (rref %hinfo-record% hostinfo.addr3)            (rref %hinfo-record% hostinfo.addr4)))) ;;;------------------------------------------------------------------- ;;;;;; Error and condition handling;;;(defparameter *tcp-error-strings*  '((-23000 . "Bad network configuration")    (-23001 . "bad IP configuration")    (-23002 . "Missing IP or LAP configuration")    (-23003 . "Error loading MacTCP")    ;#define ipBadAddr -23004 /* error in getting address */    (-23005 . "TCP connection closing")    ;#define invalidLength -23006    (-23007 . "Request conflicts with existing connection")    (-23008 . "Connection does not exist")    (-23009 . "Insufficient resources to perform TCP request")    ;#define invalidStreamPtr		-23010    ;#define streamAlreadyOpen		-23011    (-23012 . "Connection terminated")    ;#define invalidBufPtr  -23013    ;#define invalidRDS     -23014    ;#define invalidWDS	    -23014    (-23015 . "TCP open failed")    (-23016 . "TCP command timeout")    ;#define duplicateSocket  -23017    ;#define ipDontFragErr  -23032  /* Packet too large to send w/o fragmenting */    (-23033 . "Destination host is not responding")    ;#define ipNoFragMemErr -23036 /* no memory to send fragmented pkt */    ;#define ipRouteErr  -23037 /* can't route packet off-net */    (-23041 . "Syntax error in host name")    ;#define cacheFault -23042    ;#define noResultProc  -23043    (-23044 . "No name server can be found for the specified domain name")    (-23045 . "Domain name does not exist")    (-23046 . "None of the known name servers are responding")    (-23047 . "The domain name server has returned an error")    ;#define outOfMemory  -23048    )) ;;;------------------------------------------------------------------- ;;;;;; CONDITIONS FOR MACTCP John C. Mallery (JCMa@AI.MIT.EDU);;;;;; This hierarchy of network conditions is modelled on the lisp machine's;;; condition system.;;;;;; It was written for MCL 2.0.1 based on the code in ccl:library;MACTCP.lisp;;; 1/18/95 -- JCMa.;;;;;; 1. Are there more TCP conditions that we should be handling?;;;;;; 2. Do the hierarchies make sense for MACTCP ?(network documentation was;;; unavailable at the moment this was written);;;;;; 3. What was in this the previous signalling system that could lead to;;; untyped errors?;;;;;; 4. Some conditions should accept more state information (e.g, host) and;;; this should be passed in by the calling code, meaning that MACTCP should;;; be upgraded to signal TCP errors by including calls directly in the code;;; wherever paramaters would be needed by the condition signalled. ;;;------------------------------------------------------------------- ;;;;;; MAPPING TCP ERROR CODES TO MACTCP CONDITIONS;;;;; #-200 error signalled when running on DUO with MACTCP configured for ethernet.-- JCMa 2/3/1995.;; This error code signalled again in MCL3.0b4 and MAC CL-HTTP 0.6.2 (26.2) -- JCMa 6/3/1995.(defparameter *tcp-error-class-alist*  '((-23000 . tcp-bad-network-connection)    (-23001 . tcp-bad-ip-configuration)    (-23002 . tcp-missing-ip-or-lap-configuration)    (-23003 . error-loading-mactcp)    (-23004 . tcp-bad-ip-address)    (-23005 . tcp-connection-closed)    (-23006 . tcp-invalid-ip-packet-length)    (-23007 . tcp-connection-conflict)    (-23008 . tcp-connection-does-not-exist)    (-23009 . tcp-insufficient-resources)    (-23010 . tcp-invalid-stream-pointer)    (-23011 . tcp-stream-already-open)    (-23012 . tcp-connection-reset)    (-23013 . tcp-invalid-buffer-pointer)    (-23014 . tcp-invalid-data-structure)    (-23015 . tcp-connection-refused)    (-23016 . tcp-command-timeout)    (-23017 . tcp-duplicate-socket)    (-23032 . tcp-ip-packet-too-large)    (-23033 . tcp-host-stopped-responding)    (-23036 . tcp-insufficient-memory-for-packet-size)    (-23037 . tcp-insufficient-memory-for-packet-size)    (-23041 . tcp-syntax-error)    (-23042 . tcp-domain-cache-fault)    ;;#define noResultProc  -23043    (-23044 . tcp-domain-server-not-found)    (-23045 . tcp-unknown-domain-name)    (-23046 . tcp-no-response-from-domain-server)    (-23047 . domain-resolver-error)    (-23048 . tcp-out-of-memory)    ;; AppleTalk errors follow    (-97 . appletalk-port-already-in-use)    (-98 . appletalk-inactive)))(defun %tcp-err-disp (error-number)  (let* ((error-code (%word-to-int error-number))         (entry (assoc error-code *tcp-error-class-alist* :test #'eq))         (error-fn #'error))			; want to tail-call...    (declare (type list entry))    (if entry      ;; call our own TCP error.      (funcall error-fn (cdr entry))      ;;formerly called standard error signalling code in MCL (%err-disp error-number)      ;;now signals unknown error class -- JCMa 6/9/1995.      (funcall error-fn 'unknown-mactcp-error :error-code error-code)))) ;;;------------------------------------------------------------------- ;;;;;; TCP CONDITION CLASSES;;;;; These error classes are intended to support multiple network protocols.;; All TCP specific errors are prefixed with TCP-.  All AppleTalk errors are;; prefixed with appletalk-. Generic error classes have no prefix(define-condition mactcp-error (error))  ; yes(define-condition mactcp-error-code-mixin                  (mactcp-error)  ((error-code :initarg :error-code ::reader tcp-error-code               :allocation :class)   (error-message :initarg :error-message :reader tcp-error-message :allocation :class))  (:report report-mactcp-error))(defmethod report-mactcp-error ((error mactcp-error-code-mixin) stream)  (with-slots (error-message) error    (write-string "MACTCP: " stream)    (write-string error-message stream)    (write-char #\.  stream)))(define-condition unknown-mactcp-error ; no                  (mactcp-error-code-mixin mactcp-error)  ((error-code :initarg :error-code :reader tcp-error-code :allocation :instance)   (error-message :initform "-- No entry in ccl::*TCP-Error-Class-Alist*.")))(defmethod report-mactcp-error ((error unknown-mactcp-error) stream)  (with-slots (error-code error-message) error    (write-string "MACTCP: Unknown Error Code " stream)     (write error-code :stream stream :base 10)    (write-char #\space stream)    (write-string error-message stream)    (write-char #\.  stream)))(define-condition network-error (error)) ; yes(define-condition domain-error (mactcp-error network-error)) ; yes(define-condition unknown-host-name (mactcp-error network-error)) ; yes(define-condition tcp-domain-server-not-found ; yes                  (mactcp-error-code-mixin domain-error)  ((error-code :initform -23044 :allocation :class)   (error-message :initform "No name server can be found for the specified domain name"                  :allocation :class)))(define-condition tcp-unknown-domain-name  ; yes                  (mactcp-error-code-mixin domain-error unknown-host-name)  ((error-code :initform -23045 :allocation :class)   (error-message :initform "Domain name does not exist":allocation :class)))(define-condition tcp-no-response-from-domain-server ; no                  (mactcp-error-code-mixin domain-error)  ((error-code :initform -23046 :allocation :class)   (error-message :initform "None of the known name servers are responding"                  :allocation :class)))(define-condition domain-resolver-error ; hmm - not really                  (mactcp-error-code-mixin domain-error)  ((error-code :initform -23047 :allocation :class)   (error-message :initform "The domain name server has returned an error"                  :allocation :class)))(define-condition local-network-error (network-error) ()) ;; hmm not really(define-condition unknown-address (local-network-error) ())  ; hmm not really;; these errors may be internal errors or ones that were so poorly;; documented that it is hard to tell where they fit in the condition;; hierarchy.  Please advise if any should be moved elsewhere.(define-condition tcp-internal-error (local-network-error) ())(define-condition tcp-insuffucient-memory-error (tcp-internal-error) ()) ; no(define-condition tcp-ip-packet-error (tcp-internal-error) ()) ; no(define-condition tcp-bad-ip-address                  (mactcp-error-code-mixin tcp-ip-packet-error)  ((error-code :initform -23004 :allocation :class)   (error-message :initform "Internal Error: Error getting address" :allocation :class)))(define-condition tcp-invalid-ip-packet-length                  (mactcp-error-code-mixin tcp-ip-packet-error)  ((error-code :initform -23006 :allocation :class)   (error-message :initform "Internal Error: Invalid IP packet length." :allocation :class)))(define-condition tcp-ip-packet-too-large                  (mactcp-error-code-mixin tcp-ip-packet-error)  ((error-code :initform -23032 :allocation :class)   (error-message :initform "Internal Error: Packet too large to send without fragmenting." :allocation :class)))(define-condition tcp-insufficient-memory-for-packet-size                  (mactcp-error-code-mixin tcp-ip-packet-error tcp-insuffucient-memory-error)  ((error-code :initform -23036 :allocation :class)   (error-message :initform "Internal Error: Packet too large for available memory." :allocation :class)))(define-condition tcp-ip-routing-error                  (mactcp-error-code-mixin tcp-ip-packet-error)  ((error-code :initform -23037 :allocation :class)   (error-message :initform "Internal Error: Unable to route packet off the network." :allocation :class)))(define-condition tcp-invalid-stream-pointer                  (mactcp-error-code-mixin tcp-internal-error)  ((error-code :initform -23010 :allocation :class)   (error-message :initform "Internal Error: Invalid stream pointer." :allocation :class)))(define-condition tcp-stream-already-open                  (mactcp-error-code-mixin tcp-internal-error)  ((error-code :initform -23011 :allocation :class)   (error-message :initform "Internal Error: Stream already open." :allocation :class)))(define-condition tcp-invalid-buffer-pointer                  (mactcp-error-code-mixin tcp-internal-error)  ((error-code :initform -23013 :allocation :class)   (error-message :initform "Internal Error: Invalid buffer pointer." :allocation :class)))(define-condition tcp-invalid-data-structure                  (mactcp-error-code-mixin tcp-internal-error)  ((error-code :initform -23014 :allocation :class)   (error-message :initform "Internal Error: Invalid datastructure." :allocation :class)))(define-condition tcp-duplicate-socket                  (mactcp-error-code-mixin tcp-internal-error)  ((error-code :initform -23017 :allocation :class)   (error-message :initform "Internal Error: Duplicate socket" :allocation :class))) (define-condition tcp-out-of-memory                  (mactcp-error-code-mixin tcp-insuffucient-memory-error)  ((error-code :initform -23048 :allocation :class)   (error-message :initform "Internal Error: Out of memory." :allocation :class)))(define-condition interface-not-working (local-network-error) ());; not clear if this is a transient on the MAC.(define-condition tcp-bad-network-connection                  (mactcp-error-code-mixin interface-not-working)  ((error-code :initform -23000 :allocation :class)   (error-message :initform "Bad network configuration" :allocation :class)))(define-condition tcp-bad-ip-configuration                  (mactcp-error-code-mixin interface-not-working)  ((error-code :initform -23001 :allocation :class)   (error-message :initform "Bad IP configuration" :allocation :class)))(define-condition tcp-missing-ip-or-lap-configuration                  (mactcp-error-code-mixin interface-not-working)  ((error-code :initform -23002 :allocation :class)   (error-message :initform "Missing IP or LAP configuration" :allocation :class)))(define-condition error-loading-mactcp                  (mactcp-error-code-mixin interface-not-working)  ((error-code :initform -23003 :allocation :class)   (error-message :initform "Error loading MacTCP" :allocation :class)))(define-condition network-resources-exhausted (local-network-error) ())(define-condition tcp-insufficient-resources                  (mactcp-error-code-mixin network-resources-exhausted)  ((error-code :initform -23009 :allocation :class)   (error-message :initform "Insufficient resources to perform TCP request"                  :allocation :class)))(define-condition network-domain-cache-fault (local-network-error) ())(define-condition tcp-domain-cache-fault                  (mactcp-error-code-mixin network-domain-cache-fault)  ((error-code :initform -23042 :allocation :class)   (error-message :initform "Domain cache fault." :allocation :class)))(define-condition remote-network-error (network-error) ())(define-condition host-not-responding (remote-network-error) ())(define-condition bad-connection-state (remote-network-error) ())(define-condition tcp-connection-does-not-exist                  (mactcp-error-code-mixin bad-connection-state)  ((error-code :initform -23008 :allocation :class)   (error-message :initform "Connection does not exist" :allocation :class)))(define-condition tcp-connection-conflict                  (mactcp-error-code-mixin bad-connection-state)  ((error-code :initform -23007 :allocation :class)   (error-message :initform "Request conflicts with existing connection"                  :allocation :class)))(define-condition connection-closed (bad-connection-state) ())(define-condition tcp-connection-closed                  (mactcp-error-code-mixin connection-closed)  ((error-code :initform -23005 :allocation :class)   (error-message :initform "TCP connection closed" :allocation :class)))(define-condition connection-lost (connection-closed))(define-condition tcp-connection-reset                  (mactcp-error-code-mixin connection-lost)  ((error-code :initform -23012 :allocation :class)   (error-message :initform "Connection terminated" :allocation :class)))(define-condition host-stopped-responding                  (host-not-responding remote-network-error) ())(define-condition tcp-host-stopped-responding                  (mactcp-error-code-mixin host-stopped-responding)  ((error-code :initform -23033 :allocation :class)   (error-message :initform "Destination host is not responding" :allocation :class)))(define-condition connection-error (remote-network-error) ())(define-condition connection-refused (connection-error) ());; uncertain that this error code actually maps correctly.(define-condition tcp-connection-refused                  (mactcp-error-code-mixin connection-refused)  ((error-code :initform -23015 :allocation :class)   (error-message :initform "TCP open failed" :allocation :class)))(define-condition protocol-timeout (remote-network-error) ())(define-condition tcp-command-timeout                  (mactcp-error-code-mixin protocol-timeout)  ((error-code :initform -23016 :allocation :class)   (error-message :initform "TCP command timeout" :allocation :class)))(define-condition network-parse-error (error) ())(define-condition tcp-syntax-error                  (mactcp-error-code-mixin network-parse-error)  ((error-code :initform -23041 :allocation :class)   (error-message :initform "Syntax error in host name" :allocation :class))) ;;;------------------------------------------------------------------- ;;;;;; APPLETALK ERRORS;;;(define-condition appletalk-error (error) ())(define-condition appletalk-driver-open-error (interface-not-working appletalk-error) ())(define-condition appletalk-port-already-in-use                  (mactcp-error-code-mixin appletalk-driver-open-error)  ((error-code :initform -97 :allocation :class)   (error-message :initform "AppleTalk unable to initialize; port already in use." :allocation :class)))(define-condition appletalk-inactive                  (mactcp-error-code-mixin appletalk-driver-open-error)  ((error-code :initform -98 :allocation :class)   (error-message :initform "AppleTalk inactive; parameter RAM not configured for this connection"                  :allocation :class))) ;;;------------------------------------------------------------------- ;;;;;; EXPORT CONDITIONS;;;(export '(bad-connection-state          connection-closed          connection-error          connection-lost          connection-refused          domain-error          domain-resolver-error          error-loading-mactcp          host-not-responding          host-stopped-responding          interface-not-working          local-network-error          mactcp-error          network-domain-cache-fault          network-error          network-parse-error          network-resources-exhausted          protocol-timeout          remote-network-error          tcp-bad-ip-address          tcp-bad-ip-configuration          tcp-bad-network-connection          tcp-command-timeout          tcp-connection-closed          tcp-connection-conflict          tcp-connection-does-not-exist          tcp-connection-refused          tcp-connection-reset          tcp-domain-cache-fault          tcp-domain-server-not-found          tcp-duplicate-socket          tcp-host-stopped-responding          tcp-insufficient-memory-for-packet-size          tcp-insufficient-resources          tcp-insuffucient-memory-error          tcp-internal-error          tcp-invalid-buffer-pointer          tcp-invalid-data-structure          tcp-invalid-ip-packet-length          tcp-invalid-stream-pointer          tcp-ip-packet-error          tcp-ip-packet-too-large          tcp-ip-routing-error          tcp-missing-ip-or-lap-configuration          tcp-no-response-from-domain-server          tcp-out-of-memory          tcp-stream-already-open          tcp-syntax-error          tcp-unknown-domain-name          unknown-address          unknown-mactcp-error          ;;; Appletalk errors          appletalk-driver-open-error          appletalk-error          appletalk-inactive          appletalk-port-already-in-use)        :ccl);;;------------------------------------------------------------------- ;;;;;;  CONTINUE CODE;;; (defclass tcp-stream (input-stream output-stream)  ((conn :initform nil :accessor %tcp-stream-conn)))(defclass binary-tcp-stream (tcp-stream io-binary-stream) ())(defmethod initialize-instance ((s binary-tcp-stream)                                &key (element-type '(unsigned-byte 8) element-type-p))  (unless (or (not element-type-p)              (eq element-type 'unsigned-byte)          ; Shorthand ...              (and (subtypep element-type '(unsigned-byte 8))                   (subtypep '(unsigned-byte 8) element-type)))    (error "element-type ~S not supported." element-type))  ; no supertype cares about :element-type  (call-next-method))(defstruct conn         ; Don't bother doing slot-value for every little thing...  pb  write-buffer  write-bufsize  write-count  read-timeout  untyi-char  rds  rds-entries  rds-offset                         ; offset in rds to next buffer  read-count  read-bufptr) ;; This abstraction is for copying the PB on the stack to avoid collisions ;; with assynchronous calls to %TCP-CONTROL, which is a good way to crash. (defun %tcp-pb-copy (src dest)  ; I will RTFM after I finish downloading TFM.  ; Some of the fields in src are "persistent"; copy all of  ; them, for now  (#_BlockMoveData src dest $tcpPBSize)); This assumes that "conn-pb" is non-null(defmacro with-pb-copy ((pb conn-pb) &body body)  `(%stack-block ((,pb $tcpPBSize))     (%tcp-pb-copy ,conn-pb ,pb)     ,@body))(defmethod print-object ((self tcp-stream) stream)  (let* ((type (type-of self))         (conn (%tcp-stream-conn self))         (conn-pb (when conn (conn-pb conn))))    (if conn-pb      (with-pb-copy (pb conn-pb)        (let ((err (%tcp-control pb $TCPStatus t)))          (case err            ((0)             (format stream "#<~S ~S -> ~A@~A>"                     type                     (tcp-state-name (rref pb tcpioPB.status.connectionState))                     (tcp-service-name (rref pb tcpioPB.status.remotePort))                     (tcp-addr-to-str (rref pb tcpioPB.status.remoteHost))))            (-23008                     ; connection doesn't exist.             (format stream "#<~S ~S>" type :closed))            (t (%tcp-err-disp err)))))      (format stream "#<~S ~S>" type :closed))))(defun tcp-connection-state (stream)  (let* ((conn (%tcp-stream-conn stream))         (conn-pb (and conn (conn-pb conn))))    (if conn-pb      (with-pb-copy (pb conn-pb)        (if (eq 0 (%tcp-control pb $TCPStatus t))          (rref pb tcpioPB.status.connectionState)          0))      0)))(defun tcp-state-name (state)  (or (cdr (assq state                 '((0 . :closed)                   (2 . :listen)                   (4 . :syn-received)                   (6 . :syn-sent)                   (8 . :established)                   (10 . :fin-wait-1)                   (12 . :fin-wait-2)                   (14 . :close-wait)                   (16 . :closing)                   (18 . :closing-last-ack)                   (20 . :closing-time-ack))))      state))(defun tcp-service-name (port)  (or (car (rassoc port *service-name-number-alist*))      port))(defun tcp-stream-conn (s)  (or (%tcp-stream-conn s) (%tcp-err-disp -23005)))     ; connection closed.(defmethod stream-tyo ((s tcp-stream) char &aux (conn (tcp-stream-conn s)))  (without-interrupts   (let* ((count (conn-write-count conn)))     (when (eq count (conn-write-bufsize conn))       (tcp-stream-force-output conn nil)       (setq count (conn-write-count conn)))     (setf (conn-write-count conn) (1+ count))     (ccl:%put-byte (conn-write-buffer conn) (char-code char) count))))(defmethod stream-force-output ((s tcp-stream))  (tcp-stream-force-output (tcp-stream-conn s) t))(defun tcp-stream-force-output (conn push-p)  (without-interrupts   (unless (eql (conn-write-count conn) 0)     (%tcp-send (conn-pb conn) (conn-write-buffer conn) (conn-write-count conn) push-p))   (setf (conn-write-count conn) 0)))(defmethod stream-write-vector ((s binary-tcp-stream) v start end)  (locally    (declare (fixnum start end))    (multiple-value-bind (vector offset) (array-data-and-offset v)      (declare (fixnum offset))      (setq start (+ start offset))      (do* ((conn (tcp-stream-conn s))            (writebuf (conn-write-buffer conn))            (bufsize (conn-write-bufsize conn))            (length (- (+ end offset ) start) (- length room-in-buffer))            (bufpos (conn-write-count conn) 0)            (room-in-buffer (- bufsize bufpos) bufsize))           ((<= length room-in-buffer)            (dotimes (i length (progn (incf (conn-write-count conn) length) (tcp-stream-force-output conn t)))              (ccl::%put-byte writebuf (ccl::uvref vector start) bufpos)              (setq start (1+ start) bufpos (1+ bufpos))))        (declare (fixnum length bufpos bufsize room-in-buffer))        (dotimes (i room-in-buffer)          (ccl::%put-byte writebuf (ccl::uvref vector start) bufpos)          (setq start (1+ start) bufpos (1+ bufpos)))        (setf (conn-write-count conn) bufsize)        (tcp-stream-force-output conn t)))))(defmethod stream-read-vector ((s binary-tcp-stream) v start end)  (locally    (declare (fixnum start end))    (multiple-value-bind (vector offset) (array-data-and-offset v)      (declare (fixnum offset))      (setq start (+ start offset))      (let* ((length (- (+ end offset ) start))             (conn (tcp-stream-conn s))             (untyi-char (conn-untyi-char conn)))        (declare (fixnum length))        (if (and (> length 0) untyi-char)          (progn            (setf (ccl::uvref vector start) (char-code untyi-char)                  (conn-untyi-char conn) nil                  start (1+ start)                  length (1- length))))        (do* ((pb (conn-pb conn))              (rds (conn-rds conn)))             ((zerop length))          (when (eql (conn-read-count conn) 0)            (%tcp-nocopyrcv pb rds (conn-rds-entries conn) (conn-read-timeout conn))            (when (eql 0 (setf (conn-read-count conn) (ccl:%get-word rds)))              (tcp-stream-bfr-return conn)              (when (tcp-stream-eofp conn)    ;Can't get a character.                (return-from stream-read-vector nil))              (error "Can't read a character from ~S" s))            (ccl:%setf-macptr (conn-read-bufptr conn) (ccl:%get-ptr rds 2))            (setf (conn-rds-offset conn) 6))          (setf (ccl::uvref vector start) (ccl::%get-unsigned-byte (conn-read-bufptr conn)))          (incf start)          (ccl:%incf-ptr (conn-read-bufptr conn))          (decf length)          (when (eql (setf (conn-read-count conn) (1- (conn-read-count conn))) 0)            (let* ((rds (conn-rds conn))                   (nextbuf (conn-rds-offset conn))                   (bufptr (conn-read-bufptr conn)))              (if (eql (setf (conn-read-count conn) (ccl:%get-word rds nextbuf)) 0)                (tcp-stream-bfr-return conn)                (progn                  (ccl:%setf-macptr bufptr (ccl:%get-ptr rds (+ nextbuf 2)))                  (setf (conn-rds-offset conn) (+ nextbuf 6)))))))))))(defmethod stream-tyi ((s tcp-stream) &aux (conn (tcp-stream-conn s)))  (without-interrupts   (if (conn-untyi-char conn)     (prog1 (conn-untyi-char conn) (setf (conn-untyi-char conn) nil))     (progn       (when (eql (conn-read-count conn) 0)         (when (tcp-stream-eofp conn)           (return-from stream-tyi nil))         (let* ((pb (conn-pb conn))                (rds (conn-rds conn)))           (%tcp-nocopyrcv pb rds (conn-rds-entries conn) (conn-read-timeout conn))           (when (eql 0 (setf (conn-read-count conn) (ccl:%get-word rds)))             (tcp-stream-bfr-return conn)             (when (tcp-stream-eofp conn)               (return-from stream-tyi nil))             (error "Can't read a character from ~S" s))           (ccl:%setf-macptr (conn-read-bufptr conn) (ccl:%get-ptr rds 2))           (setf (conn-rds-offset conn) 6)))       (prog1 (code-char (ccl:%get-byte (conn-read-bufptr conn)))         (ccl:%incf-ptr (conn-read-bufptr conn))         (when (eql (setf (conn-read-count conn) (1- (conn-read-count conn))) 0)           (let* ((rds (conn-rds conn))                  (nextbuf (conn-rds-offset conn))                  (bufptr (conn-read-bufptr conn)))             (if (eql (setf (conn-read-count conn) (ccl:%get-word rds nextbuf)) 0)               (tcp-stream-bfr-return conn)               (progn                 (ccl:%setf-macptr bufptr (ccl:%get-ptr rds (+ nextbuf 2)))                 (setf (conn-rds-offset conn) (+ nextbuf 6))))))))))) (defmethod stream-read-byte ((s binary-tcp-stream))  (let* ((char (stream-tyi s)))    (if char      (locally (declare (type character char)) (char-code char)))))(defmethod stream-write-byte ((s binary-tcp-stream) b)  (stream-tyo s (code-char (logand #xff b))))(defun tcp-stream-bfr-return (conn)  (ccl:%setf-macptr (conn-read-bufptr conn) (ccl:%null-ptr))  (setf (conn-read-count conn) 0)        ; Usually redundant except in clear-input..  (%tcp-bfrreturn (conn-pb conn) (conn-rds conn))) ;; Blowing out due to a partially openned connection.;; Added conditional handling, but it would be better if the MACTCP code;; respected the ignore errors switch. -- JCMa 4/18/1995.(defmethod stream-listen ((s tcp-stream))  (handler-case    (let ((conn (tcp-stream-conn s)))      (or (conn-untyi-char conn)          (not (eql (conn-read-count conn) 0))          (let ((pb (conn-pb conn)))            (and (eql (%tcp-control pb $TCPStatus T) 0)                 (> (rref pb tcpioPB.status.amtUnreadData) 0)))))    (bad-connection-state () nil))) (defmethod stream-untyi ((s tcp-stream) char)  (setf (conn-untyi-char (tcp-stream-conn s)) char))(defmethod stream-eofp ((s tcp-stream))  (let* ((conn (tcp-stream-conn s)))    (and (null (conn-untyi-char conn))         (eql (conn-read-count conn) 0)         (tcp-stream-eofp conn))))(defun tcp-stream-eofp (conn)  (let* ((pb (conn-pb conn))         (err (%tcp-control pb $TCPStatus t)))    (or (eq err -23008)                 ; connection doesn't exist        (if (eql err 0)          (memq (rref pb tcpioPB.status.connectionState)                '(0                           ; Closed                  14                          ; Close Wait                  16                          ; Closing                  18                          ; Last Ack                  20))                        ; Time Wait          (%tcp-err-disp err)))))(proclaim '(inline note-stream-closed));; atomically note stream closure.(defun note-stream-closed (stream)  (flet ((closed-stream-p (s)           (or (eq s stream)               (zerop (tcp-connection-state s)))))    (declare (dynamic-extent #'closed-stream-p))    (without-interrupts     (setq *open-tcp-streams* (delete-if #'closed-stream-p ccl::*open-tcp-streams*)))));; MCL 2.0.1 from ccl:library;MACTCP.lisp;Kind of bogus, but most of the protocols don't depend on a reliable close anyhow...(defmethod stream-close ((s tcp-stream) &aux (conn (%tcp-stream-conn s)))  (when conn    (let ((state (tcp-connection-state s)))      (unless (zerop state)        (stream-clear-input s))      ;; orginal code calls the function on stream rather than conn.      ;; can get errors trying to output to on a closed stream.-- JCMa 2/27/1995.      (unless (member state '(0 2 20.) :test #'=)        (tcp-stream-force-output conn t))      (let ((pb (conn-pb conn)))        (setf (rref pb tcpioPB.close.validityFlags) 0)        (unless (zerop state)          (%tcp-control pb $TCPClose T))     ; Ok if fails (bogus)        ;;;;we should get the following sequence -- Karsten  2/16/1995.        ;;; Can hang indefinitely so wait for :CLOSING-TIME-ACK -- Reti 2/17/1995.        ;;  No -57 error with Netscape. MacWeb and Mosaic work fine.        ;;;:FIN-WAIT-1 (10)        ;;;:FIN-WAIT-2 (12)        ;;;:CLOSING-TIME-ACK (20)        ;;;:CLOSED (0)        (loop with end-time = (+ (#_tickcount) (* 60  (max (conn-read-timeout conn) 20)))              for state = state then (tcp-connection-state s)              until (or (member state '(0 20) :test #'eql)                        (> (#_tickcount) end-time))              finally (%tcp-release pb))        (#_DisposePtr pb)        (setf (%tcp-stream-conn s) nil))))  ;; moved outside the when-- JCMa 5/6/1995.  (note-stream-closed s)  (call-next-method)) (defmethod stream-abort ((s tcp-stream)) ;called before stream-close for abort.   (unless (zerop (tcp-connection-state s))     ; don't error trying to close a closed stream    (stream-clear-input s)    (%tcp-control (conn-pb (tcp-stream-conn s)) $tcpAbort T)))       ; Ok if fails(defmethod stream-clear-input ((s tcp-stream))  (let ((conn (tcp-stream-conn s)))    (setf (conn-untyi-char conn) nil)    (unless (eql 0 (conn-read-count conn))      (tcp-stream-bfr-return conn)))) (defmethod initialize-instance ((s tcp-stream) &key                                host                                port                                (tcpbufsize 8192)                                (rdsentries 6)                                (writebufsize 1024)                                notify-proc                                (commandtimeout 30))  (call-next-method)  (let (pb)    (unless (integerp port)      (setq port (or (cdr (assoc (require-type port '(or string symbol))                                 *service-name-number-alist* :test #'string-equal))                     (error "Unknown port ~S" port))))    (when host      (setq host (tcp-host-address host)))    (unwind-protect      (progn        (setq pb (memerrchk (#_NewPtrClear (+ $tcpPBSize tcpbufsize writebufsize (+ (* 6 rdsentries) 2)))))        (%tcp-create pb (ccl:%inc-ptr pb $tcpPBSize) tcpbufsize notify-proc)        (if host          (%tcp-active-open pb host port)          (%tcp-passive-open pb port commandtimeout))        (setf (%tcp-stream-conn s)              (make-conn :pb pb                         :write-buffer (ccl:%inc-ptr pb (+ $tcpPBSize tcpbufsize))                         :write-bufsize writebufsize                         :write-count 0                         :read-timeout (* 20 commandtimeout)                         :untyi-char nil                         :rds (ccl:%inc-ptr pb (+ $tcpPBSize tcpbufsize writebufsize))                         :rds-entries rdsentries                         :rds-offset 0                         :read-count 0                         :read-bufptr (ccl:%null-ptr)))        (setq pb nil)        #+ignore (when (member s *open-tcp-streams*)                   (Break "Second initialize instance for ~S" s))        (without-interrupts          (pushnew s *open-tcp-streams*))      ; streams were appearing multiply when talking to yourself        s)      (when pb        (%pb-deallocate pb)))))(defun open-tcp-stream (host port &key (element-type 'base-character)                             (tcpbufsize 8192)                             (rdsentries 6)                             (writebufsize 1024)                             notify-proc                             (commandtimeout 30))  (if (subtypep element-type 'character)    (make-instance 'tcp-stream      :host host :port port      :tcpbufsize tcpbufsize      :rdsentries rdsentries      :writebufsize writebufsize       :notify-proc notify-proc      :commandtimeout commandtimeout)    (make-instance 'binary-tcp-stream      :element-type element-type      :host host :port port      :tcpbufsize tcpbufsize      :rdsentries rdsentries      :writebufsize writebufsize       :notify-proc notify-proc      :commandtimeout commandtimeout))) ;;Useful little functions: read & write CRLF-terminated lines from a "clear text" ;; connection.(defun telnet-read-line (stream)  "Read a CRLF-terminated line"  (unless (stream-eofp stream)    (let ((line (Make-Array 10 :Element-Type 'base-Character :Adjustable T :Fill-Pointer 0))          (char nil))      (do () ((or (null (setq char (stream-tyi stream)))                  (and (eq char #\CR) (eq (stream-peek stream) #\LF)))              (when char (stream-tyi stream))              (values line (null char)))        (vector-push-extend char line)))))(defun telnet-write-line (stream string &rest args)  "Write a CRLF-terminated line"  (declare (dynamic-extent args))  (apply #'format stream string args)  (write-char #\CR stream)  (write-char #\LF stream)  (force-output stream));; Before quitting ...(defun cleanup-after-mactcp ()  (do* ()       ((null *open-tcp-streams*))    (close (car *open-tcp-streams*)))  (%close-resolver))(pushnew #'cleanup-after-mactcp *lisp-cleanup-functions* :key #'function-name :test #'eq)(provide "MACTCP")