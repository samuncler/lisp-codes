@Chapter{A User-Centered Meta-Formalism for Morphology}Marc Domenig*°, Thomas Domenig*, Dieter Holz°, Alain Hsiung°, Sandro Pedrazzini°*Institut für Informatik der Universität ZürichWinterthurerstr. 190, CH-8057 Zürich°Institut für Informatik der Universität BaselPetersgraben 51, CH-4051 Basel@Section{Abstract} This paper presents a formalism for morphology. It focuses on the needs of the linguist who is specifying knowledge rather than the goal that the specified knowledge be directly interpretable by an efficient algorithm. We call it a meta-formalism because it superimposes one level of abstraction over formalisms based on rewriting rules. Efficient interpretation is possible on a lower level because the rules can be compiled into rewriting rules. The formalism has been implemented and tested in several prototyping cycles. Specifications of Italian, German, English, and French morphologies have shown that the system is particularly promising for the formalization of word-formation.@Section{Introduction} Computational morphology has developed rapidly during the past few years. Roughly a decade ago, finite-state morphology has been drawn to the center of attention by the success of Koskenniemi's two-level model @Index{Koskenniemi}@Link{ "(Koskenniemi 1983)" | "references" }@Label{ "ref Koskenniemi 1983" }. This served as a basis for a number of systems, all of which tried to overcome some of the original's shortcomings. Most of them attempted to increase the model's expressiveness in order to improve its capacity to handle different natural languages. @Link{ "Bear (1986,'88)" | "references" }@Label{ "ref Bear 1986" }@Index{Bear}@Label{ "ref Bear 1988" }, @Link{ "Russell/Pulman/Ritchie/Black (1986)" | "references" }@Index{Russell} @Index{Pulman} @Index{Ritchie} @Index{Black}@Label{ "ref Russell/Pulman/Ritchie/Black 1986" }, @Link{ "Görz/Paulus (1988)" | "references" }@Label{ "ref Görz/Paulus 1988" } @Index{Görz} @Index{Paulus}, and @Link{ "Trost (1990)" | "references" } @Index{Trost}@Label{ "ref Trost 1990" }, for instance, proposed to increase the model's expressiveness by replacing the finite-state framework of the two-level model's lexicon system by a more powerful, feature-based morphosyntactic grammar. @Link{ "Kay  (1987)" | "references" }@Label{ "ref kay 1987" } @Index{kay}proposed to use a multi-tape finite-state transducer for the modeling of autosegmental phonological association. The common denominator of all these systems is that they are hybrid in the sense that they use two separate but interacting formalisms: one for the specification of morphophonological rules, and one for morphosyntactic rules.Towards the end of the eighties, @Link{ "Evans/Gazdar (1989a,b)" | "references" }@Label{ "ref Evans/Gazdar 1989a" }@Label{ "ref Evans/Gazdar 1989b" }  devised a radically different system with a homogenous formalism. This system, called DATR, can be @Index{Evans} @Index{Gazdar} @Index{DATR}characterized as a semantic network with a default inheritance mechanism. Its objective goes beyond the modelling of morphology in that it provides a single representation language for lexical knowledge in general (including syntactic and semantic knowledge).The system described here, Word Manager, can be viewed as a successor of the two-level model. As described elsewhere @Link{ "(Domenig 1989,'90)" | "references" },it was originally @Index{Word Manager}designed to improve the system's data management capabilities. It therefore pursued a quite different goal than most of the other models inspired by Koskenniemi's system which focussed on extending the formalism's expressiveness for a wider coverage of languages. This means that Word Manager was designed with criteria like redundancy control, consistency control, feasibility of different views, etc. These were considered equally important as the well-known 'criteria for designing computer facilities for linguistic analysis' proposed by @Link{ "Shieber (1985):" | "references" } @Label{ "ref Shieber 1985" }linguistic felicity, expressiveness, and computational effectiveness. @Index{Shieber}The application of these design criteria led to a system which is large and was expensive to develop: the first fully operational prototype, completed in 1989, comprised 30'000 lines of Lisp code. @Index{Lisp}In the meantime, there have been three major redesigns of the formalism and the code has increased. The reasons for the large size are the following:@Item client/server model: Word Manager follows a client/server model where a server handles the data/knowledge management and different clients handle data access - including all user interfacing.@End-Item @Itemfocus on reusability: Word Manager maintains a large network of knowledge which can be accessed in various ways (see below). The purpose of this approach is to render the database reusable: it must be accessible by all kinds of applications requiring morphological knowledge. Hence, it is not only tuned to the analysis and generation of word forms - like the two-level model - but for many additional knowledge structuring and management tasks.@End-Item   @Itemdistinction between rule and entry knowledge: a sharp distinction is made between the specification of rule and entry knowledge. Rule knowledge has to be specified first, before entry knowledge can be added. The system distinguishes separate user interface clients for the specification of the two kinds of knowledge: they are called linguist interface  and lexicographer interface, respectively.@End-Item The interesting aspect of  this 'expensive approach' is that it resulted in a new kind of formalism with two prominent advantages: firstly, the formalism turned out to be remarkably user-centered, i.e. it is easy to handle by linguists. Secondly, it abstracts away from rewriting formalisms by introducing a meta-level. The following two sections will discuss these two features.@Section{User-Centeredness}Since Word Manager follows a @Index{client/server approach} client/server approach, different kinds of users can be distinguished: in principle, each client can be considered a user of the database. Thus, the entire architecture of the system is designed for the distinction of different users, which is an excellent starting point for the implementation of dedicated, user-centered clients.Let us exemplify this by presenting the client realizing the user interface for the linguist responsible for the specification of morphological rules. This is the client which provides full access to Word Manager's knowledge specification formalism. There are several characteristics which illustrate that the user's needs were clearly at the forefront of our minds when we designed the system.@SubSection{Document metaphor}One database corresponds to one document which can be manipulated only from within a dedicated 'knowledge engineering environment'. This environment provides dedicated text and graphics-oriented editors for the subformalisms distinguished (see @Link{ "Domenig 1989,'90" | "references" })@Label{ "ref Domenig 1989" }@Label{ "ref Domenig 1990" }. The user does not need to handle a multitude of interdependent files with different functionalities.@SubSection{Structuring}The user can structure the rules hierarchically into so-called inflection units and word-formation units. The structuring can be conceived in a similar way as in a traditional grammar. Experience has shown that linguists invariably use this option and create specifications which are easy to understand because of their familiar structuring. The implementation of a comprehensive Italian morphology @Index{Italian morphology}@Link{ "(Bopp 1991)" | "references" }@Label{ "ref Bopp 1991" }, for instance, resulted in the specification of 20 inflection units and 18 word-formation units. Their structuring is outlined in Fig. 1.1.@Figure{ "Outline structure of inflection and word-formation units" | "128" | 300  | 200 }                                                              @SubSection{Limitation of scope}The scope of rules can be effectively restricted: implicit restrictions are defined by the hierarchical structuring, as the inflection units and word-formation units mentioned are largely independent. This enables the user to 'think locally', i.e. to factor his specification into modules with limited complexity and limited interfaces to other modules.Explicit restrictions can be made very 'tight' in those rules for which it is desirable to have the potential of global scope, viz. in spelling rules. Consider the rule which adds an @Verbatim "h" @End-Verbatim  to Italian verb stems of the first conjugation when they are ending in @Verbatim "c" @End-Verbatim  or @Verbatim "g" @End-Verbatim  and are followed by either a verb infix/suffix @Verbatim "+e" @End-Verbatim  or @Verbatim "+i" @End-Verbatim (the rule will insert an @Verbatim "h" @End-Verbatim  for @Verbatim "manch+e+rò", "manch+iamo", "pagh+e+rebbe",    "pagh+i" @End-Verbatim ,  etc.):@Example{A typical ISRule}@Verbatim (ISRule [cg]+are-Insert-h)	"(.*[cg])/\1h" (ICat V-Base.1st)  "+e|+i.*" (ICat V-Infix)|(ICat V-Suffix)@End-Verbatim @End-Example The example shows that the formalism used for spelling offers restrictions on the features of the formatives combined as well as restrictions on the strings. Problems with conflicting rules as they occur in two-level systems (see @Link{ "Karttunen/Koskenniemi/Kaplan 1987" | "references" }, @Label{ "ref Karttunen/Koskenniemi/Kaplan 1987" }@Link{ "Black/Ritchie/Pulman/Russell 1987" | "references" }) @Label{ "ref Black/Ritchie/Pulman/Russell 1987" }can therefore be largely avoided. @Index{Karttunen} @Index{Koskenniemi} @Index{Kaplan} @SubSection{Support of specification/compilation/test cycle}The system supports a specification/compilation/test cycle which permits users to experiment and to conceive their rules step by step. An incremental compiler takes advantage of the limitation of scope mentioned and ensures that compile times are short when the user works 'locally'.@SubSection{Uniform identification of entities by features}All entities distinguished by the system are identified by feature sets. A predefined set of attribute names is reserved for specific purposes: @Verbatim "RIRule"@End-Verbatim,for instance, identifies regular inflectional rules, @Verbatim "IIRule" @End-Verbatim   irregular inflectional rules, @Verbatim "RWFRule"@End-Verbatim  regular word-formation rules, etc. Moreover, a set of restrictions ensures that the use of features is limited in certaincases, so that particular entities must be identified by specific features. Thus, a regular word-formation rule must be identified solely by @Verbatim "RWFRule" @End-Verbatim  features.@Example{A typical example for a rule name}@Verbatim ((RWFRule Derivation)									 	 (RWFRule N-To-A)										 (RWFRule Suffixing)										 (RWFRule Target-+o/+a/+i/+e))@End-Verbatim @End-Example Given restrictions of this kind, the system can offer syntactic sugar. @Example{The rule name rewritten:}@Verbatim (RWFRule Derivation.N-To-A.Suffixing.Target-+o/+a/+i/+e)@End-Verbatim @End-Example The concept that all entities are identified by feature sets is convenient for two reasons: firstly, it facilitates the search for perspicuous names for entities, because names are not atomic but factored into parts: this enables the user to employ feature values like @Verbatim "N-To-A"@End-Verbatim, @Verbatim "Suffixing"@End-Verbatim, or@Verbatim "Prefixing" @End-Verbatim as partial names for several rules and formatives. Secondly, this concept permits the construction of hierarchical views, where parent nodes represent features shared by daughter nodes. Experience with linguists has shown that tree structures of this kind are rapidly understood and a great help during the knowledge specification process (@Link{ "Bopp 1988,'91," | "references" } @Link{ "Brunner 1991" | "references" }, @Link{ "Gupta 1988" | "references" }, @Link{ "Garcia 1991" | "references" }).@SubSection{Browsing}@Label{ "Browsing" }In order to support the user in the task of specifying knowledge, sophisticated browsing options were realized. These offer the possibility to view and access the knowledge specified from different perspectives.@SubSubSection{Outline Editor}This is the primary browser for the viewing and editing of rules in a hierarchical structure which can be displayed entirely or partially (Fig. 1.1).@SubSubSection{Lexeme Browser}This browser is specially designed for testing purposes. It can be invoked when the user analyzes a string which is identified as a word–form known to the system (each specification of rule knowledge includes a number of so-called hard-coded entries, which serve two purposes: either as example entries for particular lexeme classes or for the hard-coding of lexemes considered irregular). It enables the user to view the word-forms generated by a lexeme (Fig. 1.2). @Figure{ "Generation of word-forms and destructuring into formatives" |                "129" | 300 | 200 }A further option displays the word-formation dependencies of the lexeme and the string manipulation rules applied during the generation of the word-forms (Fig. 1.3).@Figure{ "Word-formation dependencies and string manipulation rules applied" |                "130" | 300  |  200}  By clicking into the respective lexeme identifiers, the user can 'walk through' all dependencies between lexemes (Fig. 1.4).@Figure{ "Step by step browsing of word-formation dependencies" |                "131" | 522 |  361 }@SubSubSection{General Entity Browser}@Label{ "entity browser" }@Application-Link{ "This browser" | "WordManager:xf-browser-window" } permits the user to browse the entire network of entities: in two pop-up menus, he can specify a restriction for the entities to be retrieved, both by directly indicating the kind of @Application-Link{ "entity" | "WordManager:xf-browser-window-entity-restriction" }(left menu, Fig. 1.5), and by indicating a restriction on the @Application-Link{ "features" | "WordManager:xf-browser-window-feature-restriction" } qualifying the entities (right menu, Fig. 1.6). @Figure{ "Entity selection in a hierarchical menu" |                "132" | 415 | 140 }@Figure{ "Feature restriction in a context-sensitive hierarchical menu: a previous entity selection restricts the features displayed to those qualifying the entity" |                "133" | 415 |  140}If he pushes the @Application-Link{ "Retrieve Button" | "wordmanager:xf-browser-window-retrieve-button" }below the pop-up menus, the system will get the corresponding entities from the server and display them in a @Application-Link{ "table" | "wordmanager:xf-browser-window-table" } (Fig. 1.7). @Figure{ "Entity browser with RIRule selection for nouns" |               "134" | 400 |  270}Each of these entities can then be further explored: when any of them is selected in the table, the pop-up menu @Application-Link{ "Aspects" | "wordmanager:xf-browser-window-aspects-menu" } will be enabled, where each of the commands available will retrieve a set of related entities from the server. The aspects available are different, of course, for different kinds of entities. Since the retrieval of further entities results in their being collected and displayed in the table from which the 'original' entity was selected, this procedure of selection and retrieval can be repeated indefinitely (Fig. 1.8, 1.9). @Figure{ "The 'Aspects' menu serves for the retrieval of entities related to the one chosen from the table: the highlighted menu selection retrieves all entries inflecting with (RIRule NO-UMLAUT.+[E]S/+E)" |                "135" | 450 | 130 }@Figure{ "The 'Aspects' menu is context-sensitive: notice that the menu choices for this entry selection differ from those for the RIRule above" |                "136" | 450 | 100 }	                                                       Moreover, the user can 'go back' to any previous point in his searchand pursue a different search path from that point onwards: the@Application-Link{ "History menu" |"wordmanager:xf-browser-window-history-menu" } maintains thecomplete 'forest' of search actions (Fig. 1.10).@Figure{ "By selecting this option from the 'History' menu, the user can 'go back' to the point displayed in Fig. 1.7 and begin a new search path" | "137" | 400 | 70}		                                                         @SubSection{On-line help and documentation}Finally, a context-sensitive on-line help as well as an on-linedocumentation system with hypertext capabilities are integratedinto the system. It is called @Application-Link{ "GoMan" |"GoMan:destination-window" } and is described in detail in the@Document-Link{ "GoMan Manual." | "GoMan Texts:GoMan Manual;Manual" | "Introduction" } @Index{GoMan} @Index{on-line help}@Section{The Meta-Formalism}The description of the browsing options in the previous section hasillustrated that @Index{Meta-Formalism} the system is capable ofcreating a large number of different views of the knowledge.Evidently, this functionality must be provided by the server. For thatpurpose, it maintains a large network of meta-knowledge, i.e.knowledge about the structure and type of knowledge stored in thedatabase. The compilation of this meta-knowledge, in turn, ispossible largely because the formalism of Word Manager can beconsidered a meta-formalism: it abstracts away from the underlyingmachine-oriented processing in order to provide a user-centeredview. Before explaining in which respect it can be considered 'meta',let us present the formalism with a set of informally explainedexamples taken from our specification of German word-formation (adetailed description of the formalism is given in @Link{ "Domenig(1989)" | "references" }).@SubSection{Noun to noun prefixing}@Example{A RWFRule for noun to noun prefexing}@Verbatim (RWFRule To-N.Derivation.N-To-N.Prefix)          source          1     (WFCat Prefix)          (Cat N) (RIRule ?) >	entry-features (Gender >)               2     (ICat N-Stem)          target          (?IRule ?)               1 2     (ICat N-Stem)@End-Verbatim @End-Example This rule generalizes over all noun to noun prefixing processes("Wald" > "Urwald"): all noun stems (ICat N-Stem) belonging to alllexeme classes defined by the inflectional rules for regular nouns(Cat N) (RIRule ?) can be prefixed with all formatives qualified bythe feature (WFCat Prefix) (specified within the same word-formation unit). The prefixes and the noun stems are combined intonew noun stems in the order defined by the digits representing themin the target. The lexeme classes of the newly created nouns andtheir gender are propagated (indicated by ">") from the sourcelexemes matched.@SubSection{Verb to noun suffixing with 'ung'}@Example{A RWFRule for verb-to-noun suffixing}@Verbatim (RWFRule To-N.Derivation.V-To-N.Suffix)        source        (Cat V) (?IRule ?)             1     (ICat V-Stem)        2     "ung" (WFCat Suffix)         target     added-features (Gender F)         (RIRule No-Umlaut.+0/+[E]N)        1 2     (ICat N-Stem)@End-Verbatim @End-Example This rule generalizes over all verb to noun suffixing processes with "ung" ("ordnen" > "Ordnung"): all verb stems (ICat V-Stem) belonging to all lexeme classes defined by the inflectional rules for verbs (Cat V) (?IRule ?) can be suffixed with "ung". The suffix and the verb stems are combined into new noun stems. The lexeme class of the newly created nouns is (RIRule No-Umlaut.+0/+[E]N) and their gender is feminine.@SubSection{Noun to noun compounding}@Example{RWFRule for noun to noun compounding}@Verbatim (RWFRule To-N.Compounding.N-To-N.Umlaut)        source        (Cat N) (?IRule ?)           1      (ICat N-Stem)        2     (WFCat Linking-Element)        (Cat N) (?IRule ?) >     entry-features (Gender >)        3     (ICat N-Stem)        target        (?IRule ?)             (Umlaut 1) 2 3     (ICat N-Stem)@End-Verbatim @End-Example This rule generalizes over all noun to noun compounding processes where the first noun is umlauted ("Frucht+Schale" > "Früchteschale"): all noun stems @Verbatim (ICat N-Stem) @End-Verbatim  belonging to all lexeme classes defined by the inflectional rules for nouns @Verbatim (Cat N) (?IRule ?)@End-Verbatim  can be combined with all other noun stems.Two stems and a linking element - the rule assumes that a null-element is defined as well as an "s", "en", etc. - are combined in order to create a new stem. The lexeme classes of the newly created nouns and their gender are propagated (indicated by ">") from the second of the source lexemes matched.@Example{Generalized RWFRule for noun to noun compounding}@Verbatim (RWFRule To-N.Compounding.N-To-N.Convert)        source        (Cat N) (?IRule ?)             1     (ICat N-Stem)        2     (WFCat Linking-Element)        (Cat N)     (?IRule ?)     >     entry-features (Gender >)             3     (ICat N-Stem)        target        (?IRule ?)             (Convert 1) 2 3     (ICat N-Stem)@End-Verbatim @End-Example This rule generalizes over all noun to noun compounding processes where the first noun is not umlauted ("Frucht+Saft" > "Fruchtsaft"): the rule is identical to the previous one except for the target specification, where (Umlaut 1) is replaced by (Convert 1) . This difference has to do with the way umlaut is handled in our German morphology: umlauting characters are represented by special characters "A", "O", or "U" on the lexical level and transformed appropriately on the surface by string manipulation rules when inflectional rules are fired. Therefore, the lexical string @Verbatim "frUcht"+"sAft"@End-Verbatim  has to be transformed into @Verbatim "frucht"+"sAft"@End-Verbatim , while @Verbatim "frUcht"+"e"+"schale"@End-Verbatim  has to be converted into @Verbatim "früchteschale"@End-Verbatim , which is exactly what (Convert 1)  and (Umlaut 1)  will do. Given these assumptions about the specification of lexical strings, the two word-formation rules cover all possible cases of German noun compounding.@SubSection{Discussion}The examples are intended to show why linguists understand this formalism after a relatively short period of learning: they can employ a familiar terminology and knowledge factoring. This is reflected by the fact that it is a straightforward task to describe the rules in prose.In addition, the examples illustrate why we call the formalism 'meta', viz. because these rules can be compiled into rewriting rules:  roughly speaking, the target specifications define left-hand sides representing stems, the source specifications right-hand sides representing stems and affixes. It is beyond the scope of this paper to discuss how the rules are best compiled. For our purpose here it is sufficient to state that in principle, there is an unlimited number of alternatives, i.e. the rules can be converted into a primitive monadic grammar as well as an elaborate feature-based grammar. This is an extraordinary advantage for the following reasons:@Itemthe user does not need to know anything about rewriting rules or the parsing algorithm employed. He does not need to know which kind of rules can be parsed efficiently and which cannot. The system can incorporate all this knowledge. It can analyze the meta-rules and the terminal symbols they work on, can select a parsing algorithm according to this analysis and compile an 'optimal' set of rules for that parsing algorithm.@End-Item @Itemthe internal set of rules as well as the interpretation algorithm can be changed as the database grows. This is important because typically, a system will start out with what we called rule knowledge in Word Manager, i.e. knowledge encoding rules for regular morphology, and rules as well as entries for irregular morphology. In terms of a rewriting grammar, this means that it starts out with a set of rules and a small number of terminal symbols representing formatives. As the database grows, instances of formative-classes implementing regular word stems will grow rapidly while those implementing irregular word stems and affixes remain constant. If a meta-formalism is used, the internal set of rules can be adapted dynamically to these changes.@End-Item  @Itemthe system can adapt to the usage of the database: typically, certain words are looked up more frequently than others. Given a meta-formalism, the system can take this into account and adapt its rule set and interpretation algorithm accordingly.@End-Item @Section{Conclusion}We have presented a system we consider as a successor of the two-level model. As aforementioned, we have followed a different approach than others who modified and extended the ideas of the original model: instead of concentrating on extending the formalism's expressiveness to achieve a wider coverage of languages, we started out on a set of design criteria focussing on data-management capabilities, viz. criteria like redundancy control, consistency control, and feasibility of different views. This resulted in the construction of a large system with a client/server architecture whose morphology formalism has two features we believe to be particularly promising: user-centeredness and the introduction of a meta-level which abstracts away from rewriting rules.Experience with the system has shown that the user-centeredness is a bonus: it enables linguists with little knowledge in computer science to conceive comprehen-sive implementations of morphology @Link{ "(Bopp 1988,'91)" | "references" } @Label{ "ref Bopp 1988" }@Link{ "(Brunner 1991)" | "references" } @Label{ "ref Brunner 1991" }@Link{ "(Garcia 1991)" | "references" } @Label{ "ref Garcia 1991" }@Link{ "(Gupta 1988)" | "references" }@Label{ "ref gupta 1988" }.The introduction of a meta-level carries great potential in several respects. Firstly, it provides increased control over expressive power: as described elsewhere @Link{ "(Domenig 1989,'90)" | "references" }@Label{ "ref Domenig 1989" }@Label{ "ref Domenig 1990" }, it allowed us, for instance, to distinguish between inflectional and word-formation rules in a way not feasible with a rewriting formalism. This permitted us to model all inflectional and productive word-formation processes of Italian in a manner we believe to be more comprehensive and accurate than an implementation with a two-level system could be @Link{ "(Bopp 1991)" | "references" }.The second reason we believe in the potential of designing meta-formalisms is that they create distance between the knowledge specification and the use of the knowledge, thereby reducing the dependency between the two. This increases the potential for reusability and facilitates the compilation of meta-knowledge. As the browsing examples illustrate, it is possible to design a system which can dynamically combine and format its knowledge in an almost infinite number of ways.Finally, the distance between knowledge specification and use opens new opportunities for optimizations: an example would be an optimizing and dynami-cally adapting compilation of Word Manager's word-formation rules into rewriting rules. Even though we have not realized such a compilation, we believe that it is a track worth following: experiments with a system offering different parsing strate-gies @Link{ "(Russi 1990)" | "references" }@Label{ "ref Russi 1990" } have been promising.To sum up: we are convinced that user-centered design and the introduction of (a) meta-level(s) improves formalisms for morphology substantially. Word Manager proves that this is true for the two-level model. We postulate, though, that systems like DATR or other NLP formalisms could profit from similar design principles.@Section{References}@Label{ "References" }@Link{ "Bear J. (1986):" | "ref Bear 1986" } "A Morphological Recognizer with Syntactic and Phonological Rules." In Proceedings of the 11th International Conference on Computational Linguistics, COLING-86, Bonn. @Index{Bear}@Link{ "Bear J. (1988):" | "ref Bear 1988" } "Morphology with Two-Level Rules and Negative Rule Features." In Proceedings of the 12th International Conference on Computational Linguistics, COLING-88, Budapest.@Link{ "Black A., Ritchie G., Pulman S., Russell G. (1987):" | "ref Black/Ritchie/Pulman/Russell 1987" } "Formalisms for Morphographemic Description." In Proceedings of the 3rd Conference of the European Chapter of the Association for Computational Linguistics, Copenhagen. @Index{Black} @Index{Ritchie} @Index{Pulman} @Index{Russell}@Link{ "Bopp S. (1988):" | "ref Bopp 1988" } "Tentativo di formalizzazione computazionale della morfologia flessionale dell'italiano." Lizentiatsarbeit an der Philosophischen Fakultät I der Universität Zürich.@Index{Bopp}@Link{ "Bopp S. (1991):" | "ref Bopp 1991" } "Computerimplementation der italienischen Flexions- und Wortbildungs-morphologie", PhD thesis at the University of Zurich. To be published by Olms Verlag, Hildesheim, Reihe Informatik und Sprache.@Link{ "Brunner C. (1991):" | "ref Brunner 1991" } "An Implementation of English Morphology using the program Word Manager. "Lizentiatsarbeit an der Philosophischen Fakultät I der Universität Zürich.@Link{ "Domenig M. (1989):" | "ref Domenig 1989" } Word Manager, A System for the Specification, Use and Maintenance of Morphological Knowledge, Habilitationsschrift, University of Zurich.@Index{Brunner}@Link{ "Domenig M. (1990):" | "ref Domenig 1990" } "Lexeme-Based Morphology: A Computationally Expensive Approach Intended for a Server-architecture." In Proceedings of the 13th International Conference on Computational Linguistics, COLING-90, Helsinki.@Index{Domenig}@Link{ "Evans R., Gazdar G. (1989a):" | "ref Evans/Gazdar 1989a" } "The Semantics of DATR." In A. Cohn (ed.) AISB89, Proceedings of the Seventh Conference of the Society for the Study of Artificial Intelligence and Simulation of Behaviour. London: Pitman.@Index{Evans} @Index{Gazdar}@Link{ "Evans R., Gazdar G. (1989b):" | "ref Evans/Gazdar 1989b" } "Inference in DATR." In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics. Manchester.Garcia C. (1991): Computerimplementation der deutschen Morphologie, Lizentiatsarbeit an der Philosophischen Fakultät I der Universität Zürich.@Link{ "Görz G., Paulus D. (1988):" | "ref Görz/Paulus 1988" } "A Finite State Approach to German Verb Morphology." In Proceedings of the 12th International Conference on Computational Linguistics, COLING-88, Budapest.@Index{Görz} @Index{Paulus}@Link{ "Gupta A. (1988):" | "ref Gupta 1988" } "La formalisation de la morfologie française sur la base du système Word Manager." Lizentiatsarbeit an der Philosophischen Fakultät I der Universität Zürich.Kay M. (1987): "Nonconcatenative Finite-State Morphology." In Proceedings of the Third Conference of the European Chapter of the Association for Computational Linguistics, Copenhagen, April 1-3.@Index{Gupta}@Link{ "Karttunen L., Koskenniemi K., Kaplan R. (1987):" | "ref Karttunen/Koskenniemi/Kaplan 1987" }"TWOL: A Compiler for Two-level Phonological Rules." In "Tools for Morphological Analysis", Center for the Study of Language and Information, Report No. CLSI-87-108.@Index{Karttunen} @Index{Koskenniemi} @Index{Kaplan}@Link{ "Koskenniemi K. (1983):" | "ref Koskenniemi 1983" } "Two-Level-Morphology: A General Computational Model for Word-Form Recognition and Production", doctoral thesis at the University of Helsinki, Publications Nº 11.@Link{ "Russell G., Ritchie G., Pulman S. G., Black A. (1986):" | "ref Russell/Pulman/Ritchie/Black 1986" } "A Dictionary and Morphological Analyser for English." In Proceedings of the 11th International Conference on Computational Linguistics, COLING-86, Bonn.@Link{ "Russi T. (1990):" | "ref Russi 1990" } "A Syntactic and Morphological Analyzer for a Text-to-Speech System. In Proceedings of the 13th International Conference on Computational Linguistics, COLING-90, Helsinki.@Index{Russi}@Link{ "Shieber S. M. (1985):" | "ref Shieber 1985" } "Criteria for Designing Computer Facilities for Linguistic Analysis." In Linguistics 23, p.189-211.@Index{Shieber}@Link{ "Trost H. (1990):" | "ref Trost 1990" } "The application of two-level morphology to non-concatenative German morphology." In Proceedings of the 13th International Conference on Computational Linguistics, COLING-90, Helsinki.@Index{Trost}