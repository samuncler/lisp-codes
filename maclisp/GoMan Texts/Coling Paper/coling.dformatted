          1. A User-Centered Meta-Formalism for    Morphology      Marc Domenig*°, Thomas Domenig*, Dieter Holz°, Alain Hsiung°,      Sandro Pedrazzini°      *Institut für Informatik der Universität Zürich Winterthurerstr.      190, CH-8057 Zürich      °Institut für Informatik der Universität Basel Petersgraben 51,      CH-4051 Basel      1.1. Abstract      This paper presents a formalism for morphology. It focuses on      the needs of the linguist who is specifying knowledge rather      than the goal that the specified knowledge be directly      interpretable by an efficient algorithm. We call it a      meta-formalism because it superimposes one level of      abstraction over formalisms based on rewriting rules. Efficient      interpretation is possible on a lower level because the rules can      be compiled into rewriting rules. The formalism has been      implemented and tested in several prototyping cycles.      Specifications of Italian, German, English, and French      morphologies have shown that the system is particularly      promising for the formalization of word-formation.      1.2. Introduction      Computational morphology has developed rapidly during the past      few years. Roughly a decade ago, finite-state morphology has      been drawn to the center of attention by the success of      Koskenniemi's two-level model (Koskenniemi 1983)   . This      served as a basis for a number of systems, all of which tried to      overcome some of the original's shortcomings. Most of them      attempted to increase the model's expressiveness in order to      improve its capacity to handle different natural languages. Bear      (1986,'88)   , Russell/Pulman/Ritchie/Black (1986)   ,      Görz/Paulus (1988)   , and Trost (1990)   , for instance,      proposed to increase the model's expressiveness by replacing the      finite-state framework of the two-level model's lexicon system      by a more powerful, feature-based morphosyntactic grammar.      Kay (1987)   proposed to use a multi-tape finite-state      transducer for the modeling of autosegmental phonological      association. The common denominator of all these systems is      that they are hybrid in the sense that they use two separate but      interacting formalisms: one for the specification of      morphophonological rules, and one for morphosyntactic rules.      Towards the end of the eighties, Evans/Gazdar (1989a,b)        devised a radically different system with a homogenous      formalism. This system, called DATR, can be characterized as a      semantic network with a default inheritance mechanism. Its      objective goes beyond the modelling of morphology in that it      provides a single representation language for lexical knowledge      in general (including syntactic and semantic knowledge). The      system described here, Word Manager, can be viewed as a      successor of the two-level model. As described elsewhere      (Domenig 1989,'90)   , it was originally designed to improve the      system's data management capabilities. It therefore pursued a      quite different goal than most of the other models inspired by      Koskenniemi's system which focussed on extending the      formalism's expressiveness for a wider coverage of languages.      This means that Word Manager was designed with criteria like      redundancy control, consistency control, feasibility of different      views, etc. These were considered equally important as the      well-known 'criteria for designing computer facilities for      linguistic analysis' proposed by Shieber (1985):   linguistic      felicity, expressiveness, and computational effectiveness. The      application of these design criteria led to a system which is      large and was expensive to develop: the first fully operational      prototype, completed in 1989, comprised 30'000 lines of Lisp      code. In the meantime, there have been three major redesigns of      the formalism and the code has increased. The reasons for the      large size are the following:         •  client/server model: Word Manager follows a             client/server model where a server handles the             data/knowledge management and different clients             handle data access - including all user interfacing.         •  focus on reusability: Word Manager maintains a large             network of knowledge which can be accessed in various             ways (see below). The purpose of this approach is to             render the database reusable: it must be accessible by             all kinds of applications requiring morphological             knowledge. Hence, it is not only tuned to the analysis             and generation of word forms - like the two-level             model - but for many additional knowledge structuring             and management tasks.         •  distinction between rule and entry knowledge: a sharp             distinction is made between the specification of rule             and entry knowledge. Rule knowledge has to be specified             first, before entry knowledge can be added. The system             distinguishes separate user interface clients for the             specification of the two kinds of knowledge: they are             called linguist interface and lexicographer interface,             respectively.      The interesting aspect of this 'expensive approach' is that it      resulted in a new kind of formalism with two prominent      advantages: firstly, the formalism turned out to be remarkably      user-centered, i.e. it is easy to handle by linguists. Secondly, it      abstracts away from rewriting formalisms by introducing a      meta-level. The following two sections will discuss these two      features.      1.3. User-Centeredness      Since Word Manager follows a client/server approach, different      kinds of users can be distinguished: in principle, each client can      be considered a user of the database. Thus, the entire      architecture of the system is designed for the distinction of      different users, which is an excellent starting point for the      implementation of dedicated, user-centered clients. Let us      exemplify this by presenting the client realizing the user      interface for the linguist responsible for the specification of      morphological rules. This is the client which provides full      access to Word Manager's knowledge specification formalism.      There are several characteristics which illustrate that the      user's needs were clearly at the forefront of our minds when we      designed the system.      1.3.1. Document metaphor      One database corresponds to one document which can be      manipulated only from within a dedicated 'knowledge engineering      environment'. This environment provides dedicated text and      graphics-oriented editors for the subformalisms distinguished      (see Domenig 1989,'90   ) . The user does not need to handle a      multitude of interdependent files with different functionalities.      1.3.2. Structuring      The user can structure the rules hierarchically into so-called      inflection units and word-formation units. The structuring can      be conceived in a similar way as in a traditional grammar.      Experience has shown that linguists invariably use this option      and create specifications which are easy to understand because      of their familiar structuring. The implementation of a      comprehensive Italian morphology (Bopp 1991)   , for instance,      resulted in the specification of 20 inflection units and 18      word-formation units. Their structuring is outlined in Fig. 1.1.      Figure 1.1 Outline structure of inflection and word-formation units          1.3.3. Limitation of scope      The scope of rules can be effectively restricted: implicit      restrictions are defined by the hierarchical structuring, as the      inflection units and word-formation units mentioned are largely      independent. This enables the user to 'think locally', i.e. to factor      his specification into modules with limited complexity and      limited interfaces to other modules. Explicit restrictions can be      made very 'tight' in those rules for which it is desirable to have      the potential of global scope, viz. in spelling rules. Consider the      rule which adds an "h" to Italian verb stems of the first      conjugation when they are ending in "c" or "g" and are followed      by either a verb infix/suffix "+e" or "+i" (the rule will insert      an "h" for "manch+e+rò", "manch+iamo", "pagh+e+rebbe",    "pagh+i" , etc.):      Example 1.1 A typical ISRule             (ISRule [cg]+are-Insert-h)	"(.*[cg])/\1h" (ICat V-Base.1st)  "+e|+i.*" (ICat V-Infix)|(ICat V-Suffix)                                                                                                 ◊     The example shows that the formalism used for spelling offers      restrictions on the features of the formatives combined as well      as restrictions on the strings. Problems with conflicting rules      as they occur in two-level systems (see      Karttunen/Koskenniemi/Kaplan 1987   ,      Black/Ritchie/Pulman/Russell 1987   ) can therefore be largely      avoided.      1.3.4. Support of specification/compilation/test cycle      The system supports a specification/compilation/test cycle      which permits users to experiment and to conceive their rules      step by step. An incremental compiler takes advantage of the      limitation of scope mentioned and ensures that compile times      are short when the user works 'locally'.      1.3.5. Uniform identification of entities by features      All entities distinguished by the system are identified by      feature sets. A predefined set of attribute names is reserved for      specific purposes: "RIRule", for instance, identifies regular      inflectional rules, "IIRule" irregular inflectional rules, "RWFRule"     regular word-formation rules, etc. Moreover, a set of      restrictions ensures that the use of features is limited in      certain cases, so that particular entities must be identified by      specific features. Thus, a regular word-formation rule must be      identified solely by "RWFRule" features.      Example 1.2 A typical example for a rule name             ((RWFRule Derivation)									 	 (RWFRule N-To-A)										 (RWFRule Suffixing)										 (RWFRule Target-+o/+a/+i/+e))                                                                                                 ◊     Given restrictions of this kind, the system can offer syntactic      sugar.      Example 1.3 The rule name rewritten:             (RWFRule Derivation.N-To-A.Suffixing.Target-+o/+a/+i/+e)                                                                                                 ◊     The concept that all entities are identified by feature sets is      convenient for two reasons: firstly, it facilitates the search for      perspicuous names for entities, because names are not atomic      but factored into parts: this enables the user to employ feature      values like "N-To-A", "Suffixing", or "Prefixing" as partial      names for several rules and formatives. Secondly, this concept      permits the construction of hierarchical views, where parent      nodes represent features shared by daughter nodes. Experience      with linguists has shown that tree structures of this kind are      rapidly understood and a great help during the knowledge      specification process ( Bopp 1988,'91,   Brunner 1991   ,      Gupta 1988   , Garcia 1991   ).      1.3.6. Browsing      In order to support the user in the task of specifying knowledge,      sophisticated browsing options were realized. These offer the      possibility to view and access the knowledge specified from      different perspectives.      1.3.6.1. Outline Editor      This is the primary browser for the viewing and editing of rules      in a hierarchical structure which can be displayed entirely or      partially (Fig. 1.1).      1.3.6.2. Lexeme Browser      This browser is specially designed for testing purposes. It can be      invoked when the user analyzes a string which is identified as a      word– form known to the system (each specification of rule      knowledge includes a number of so-called hard-coded entries,      which serve two purposes: either as example entries for      particular lexeme classes or for the hard-coding of lexemes      considered irregular). It enables the user to view the      word-forms generated by a lexeme (Fig. 1.2).      Figure 1.2 Generation of word-forms and destructuring into formatives     A further option displays the word-formation dependencies of      the lexeme and the string manipulation rules applied during the      generation of the word-forms (Fig. 1.3).      Figure 1.3 Word-formation dependencies and string manipulation rules applied     By clicking into the respective lexeme identifiers, the user can      'walk through' all dependencies between lexemes (Fig. 1.4).      Figure 1.4 Step by step browsing of word-formation dependencies          1.3.6.3. General Entity Browser      This browser   permits the user to browse the entire network of      entities: in two pop-up menus, he can specify a restriction for      the entities to be retrieved, both by directly indicating the kind      of entity   (left menu, Fig. 1.5), and by indicating a restriction      on the features   qualifying the entities (right menu, Fig. 1.6).      Figure 1.5 Entity selection in a hierarchical menu          Figure 1.6 Feature restriction in a context-sensitive hierarchical menu: a previous entity selection restricts the features displayed to those qualifying the entity     If he pushes the Retrieve Button   below the pop-up menus, the      system will get the corresponding entities from the server and      display them in a table   (Fig. 1.7).      Figure 1.7 Entity browser with RIRule selection for nouns     Each of these entities can then be further explored: when any of      them is selected in the table, the pop-up menu Aspects   will be      enabled, where each of the commands available will retrieve a      set of related entities from the server. The aspects available are      different, of course, for different kinds of entities. Since the      retrieval of further entities results in their being collected and      displayed in the table from which the 'original' entity was      selected, this procedure of selection and retrieval can be      repeated indefinitely (Fig. 1.8, 1.9).      Figure 1.8 The 'Aspects' menu serves for the retrieval of entities related to the one chosen from the table: the highlighted menu selection retrieves all entries inflecting with (RIRule NO-UMLAUT.+[E]S/+E)          Figure 1.9 The 'Aspects' menu is context-sensitive: notice that the menu choices for this entry selection differ from those for the RIRule above     Moreover, the user can 'go back' to any previous point in his      search and pursue a different search path from that point      onwards: the History menu   maintains the complete 'forest' of      search actions (Fig. 1.10).      Figure 1.10 By selecting this option from the 'History' menu, the user can 'go back' to the point displayed in Fig. 1.7 and begin a new search path          1.3.7. On-line help and documentation      Finally, a context-sensitive on-line help as well as an on-line      documentation system with hypertext capabilities are integrated      into the system. It is called GoMan   and is described in detail in      the GoMan Manual.        1.4. The Meta-Formalism      The description of the browsing options in the previous section      has illustrated that the system is capable of creating a large      number of different views of the knowledge. Evidently, this      functionality must be provided by the server. For that purpose, it      maintains a large network of meta-knowledge, i.e. knowledge      about the structure and type of knowledge stored in the database.      The compilation of this meta-knowledge, in turn, is possible      largely because the formalism of Word Manager can be      considered a meta-formalism: it abstracts away from the      underlying machine-oriented processing in order to provide a      user-centered view. Before explaining in which respect it can be      considered 'meta', let us present the formalism with a set of      informally explained examples taken from our specification of      German word-formation (a detailed description of the formalism      is given in Domenig (1989)   ).      1.4.1. Noun to noun prefixing           Example 1.4 A RWFRule for noun to noun prefexing             (RWFRule To-N.Derivation.N-To-N.Prefix)          source          1     (WFCat Prefix)          (Cat N) (RIRule ?) >	entry-features (Gender >)               2     (ICat N-Stem)          target          (?IRule ?)               1 2     (ICat N-Stem)                                                                                                 ◊     This rule generalizes over all noun to noun prefixing processes (      "Wald " > "Urwald "): all noun stems (ICat N-Stem) belonging to      all lexeme classes defined by the inflectional rules for regular      nouns (Cat N) (RIRule ?) can be prefixed with all formatives      qualified by the feature (WFCat Prefix) (specified within the      same word- formation unit). The prefixes and the noun stems are      combined into new noun stems in the order defined by the digits      representing them in the target. The lexeme classes of the newly      created nouns and their gender are propagated (indicated by "> ")      from the source lexemes matched.      1.4.2. Verb to noun suffixing with 'ung'           Example 1.5 A RWFRule for verb-to-noun suffixing             (RWFRule To-N.Derivation.V-To-N.Suffix)        source        (Cat V) (?IRule ?)             1     (ICat V-Stem)        2     "ung" (WFCat Suffix)         target     added-features (Gender F)         (RIRule No-Umlaut.+0/+[E]N)        1 2     (ICat N-Stem)                                                                                                 ◊     This rule generalizes over all verb to noun suffixing processes      with "ung " ( "ordnen " > "Ordnung "): all verb stems      (ICat V-Stem) belonging to all lexeme classes defined by the      inflectional rules for verbs (Cat V) (?IRule ?) can be suffixed      with "ung ". The suffix and the verb stems are combined into new      noun stems. The lexeme class of the newly created nouns is      (RIRule No-Umlaut.+0/+[E]N) and their gender is feminine.      1.4.3. Noun to noun compounding           Example 1.6 RWFRule for noun to noun compounding             (RWFRule To-N.Compounding.N-To-N.Umlaut)        source        (Cat N) (?IRule ?)           1      (ICat N-Stem)        2     (WFCat Linking-Element)        (Cat N) (?IRule ?) >     entry-features (Gender >)        3     (ICat N-Stem)        target        (?IRule ?)             (Umlaut 1) 2 3     (ICat N-Stem)                                                                                                 ◊     This rule generalizes over all noun to noun compounding      processes where the first noun is umlauted ( "Frucht+Schale " >      "Früchteschale "): all noun stems (ICat N-Stem) belonging to all      lexeme classes defined by the inflectional rules for nouns (Cat N) (?IRule ?)     can be combined with all other noun stems. Two stems and a      linking element - the rule assumes that a null-element is      defined as well as an "s ", "en ", etc. - are combined in order to      create a new stem. The lexeme classes of the newly created      nouns and their gender are propagated (indicated by "> ") from the      second of the source lexemes matched.      Example 1.7 Generalized RWFRule for noun to noun compounding             (RWFRule To-N.Compounding.N-To-N.Convert)        source        (Cat N) (?IRule ?)             1     (ICat N-Stem)        2     (WFCat Linking-Element)        (Cat N)     (?IRule ?)     >     entry-features (Gender >)             3     (ICat N-Stem)        target        (?IRule ?)             (Convert 1) 2 3     (ICat N-Stem)                                                                                                 ◊     This rule generalizes over all noun to noun compounding      processes where the first noun is not umlauted ( "Frucht+Saft " >      "Fruchtsaft "): the rule is identical to the previous one except for      the target specification, where (Umlaut 1) is replaced by      (Convert 1) . This difference has to do with the way umlaut is      handled in our German morphology: umlauting characters are      represented by special characters "A ", "O ", or "U " on the lexical      level and transformed appropriately on the surface by string      manipulation rules when inflectional rules are fired. Therefore,      the lexical string "frUcht"+"sAft"has to be transformed into "frucht"+"sAft"     , while "frUcht"+"e"+"schale"has to be converted into "früchteschale"     , which is exactly what (Convert 1) and (Umlaut 1) will do.      Given these assumptions about the specification of lexical      strings, the two word-formation rules cover all possible cases      of German noun compounding.      1.4.4. Discussion      The examples are intended to show why linguists understand this      formalism after a relatively short period of learning: they can      employ a familiar terminology and knowledge factoring. This is      reflected by the fact that it is a straightforward task to      describe the rules in prose. In addition, the examples illustrate      why we call the formalism 'meta', viz. because these rules can be      compiled into rewriting rules: roughly speaking, the target      specifications define left-hand sides representing stems, the      source specifications right-hand sides representing stems and      affixes. It is beyond the scope of this paper to discuss how the      rules are best compiled. For our purpose here it is sufficient to      state that in principle, there is an unlimited number of      alternatives, i.e. the rules can be converted into a primitive      monadic grammar as well as an elaborate feature- based      grammar. This is an extraordinary advantage for the following      reasons:         •  the user does not need to know anything about rewriting             rules or the parsing algorithm employed. He does not             need to know which kind of rules can be parsed             efficiently and which cannot. The system can             incorporate all this knowledge. It can analyze the             meta-rules and the terminal symbols they work on, can             select a parsing algorithm according to this analysis             and compile an 'optimal' set of rules for that parsing             algorithm.         •  the internal set of rules as well as the interpretation             algorithm can be changed as the database grows. This is             important because typically, a system will start out             with what we called rule knowledge in Word Manager,             i.e. knowledge encoding rules for regular morphology,             and rules as well as entries for irregular morphology. In             terms of a rewriting grammar, this means that it starts             out with a set of rules and a small number of terminal             symbols representing formatives. As the database             grows, instances of formative- classes implementing             regular word stems will grow rapidly while those             implementing irregular word stems and affixes remain             constant. If a meta- formalism is used, the internal set             of rules can be adapted dynamically to these changes.         •  the system can adapt to the usage of the database:             typically, certain words are looked up more frequently             than others. Given a meta-formalism, the system can             take this into account and adapt its rule set and             interpretation algorithm accordingly.           1.5. Conclusion      We have presented a system we consider as a successor of the      two-level model. As aforementioned, we have followed a      different approach than others who modified and extended the      ideas of the original model: instead of concentrating on      extending the formalism's expressiveness to achieve a wider      coverage of languages, we started out on a set of design criteria      focussing on data-management capabilities, viz. criteria like      redundancy control, consistency control, and feasibility of      different views. This resulted in the construction of a large      system with a client/server architecture whose morphology      formalism has two features we believe to be particularly      promising: user-centeredness and the introduction of a      meta-level which abstracts away from rewriting rules.      Experience with the system has shown that the      user-centeredness is a bonus: it enables linguists with little      knowledge in computer science to conceive comprehen- sive      implementations of morphology (Bopp 1988,'91)        (Brunner 1991)   (Garcia 1991)   (Gupta 1988)   . The      introduction of a meta-level carries great potential in several      respects. Firstly, it provides increased control over expressive      power: as described elsewhere (Domenig 1989,'90)   , it allowed      us, for instance, to distinguish between inflectional and      word-formation rules in a way not feasible with a rewriting      formalism. This permitted us to model all inflectional and      productive word-formation processes of Italian in a manner we      believe to be more comprehensive and accurate than an      implementation with a two-level system could be (Bopp 1991)   .      The second reason we believe in the potential of designing      meta-formalisms is that they create distance between the      knowledge specification and the use of the knowledge, thereby      reducing the dependency between the two. This increases the      potential for reusability and facilitates the compilation of      meta-knowledge. As the browsing examples illustrate, it is      possible to design a system which can dynamically combine and      format its knowledge in an almost infinite number of ways.      Finally, the distance between knowledge specification and use      opens new opportunities for optimizations: an example would be      an optimizing and dynami- cally adapting compilation of Word      Manager's word-formation rules into rewriting rules. Even though      we have not realized such a compilation, we believe that it is a      track worth following: experiments with a system offering      different parsing strate- gies (Russi 1990)   have been      promising. To sum up: we are convinced that user-centered      design and the introduction of (a) meta-level(s) improves      formalisms for morphology substantially. Word Manager proves      that this is true for the two-level model. We postulate, though,      that systems like DATR or other NLP formalisms could profit      from similar design principles.      1.6. References      Bear J. (1986):     "A Morphological Recognizer with Syntactic      and Phonological Rules. " In Proceedings of the 11th International      Conference on Computational Linguistics, COLING-86, Bonn.      Bear J. (1988):     "Morphology with Two-Level Rules and      Negative Rule Features. " In Proceedings of the 12th      International Conference on Computational Linguistics,      COLING-88, Budapest.      Black A., Ritchie G., Pulman S., Russell G. (1987):        "Formalisms for Morphographemic Description. " In Proceedings      of the 3rd Conference of the European Chapter of the Association      for Computational Linguistics, Copenhagen.      Bopp S. (1988):     "Tentativo di formalizzazione      computazionale della morfologia flessionale dell'italiano. "      Lizentiatsarbeit an der Philosophischen Fakultät I der      Universität Zürich.      Bopp S. (1991):   "Computerimplementation der italienischen      Flexions- und Wortbildungs- morphologie ", PhD thesis at the      University of Zurich. To be published by Olms Verlag, Hildesheim,      Reihe Informatik und Sprache.      Brunner C. (1991):   "An Implementation of English Morphology      using the program Word Manager. " Lizentiatsarbeit an der      Philosophischen Fakultät I der Universität Zürich.      Domenig M. (1989):   Word Manager, A System for the      Specification, Use and Maintenance of Morphological Knowledge,      Habilitationsschrift, University of Zurich.      Domenig M. (1990):   "Lexeme-Based Morphology: A      Computationally Expensive Approach Intended for a      Server-architecture. " In Proceedings of the 13th International      Conference on Computational Linguistics, COLING-90, Helsinki.      Evans R., Gazdar G. (1989a):     "The Semantics of DATR. " In A.      Cohn (ed.) AISB89, Proceedings of the Seventh Conference of the      Society for the Study of Artificial Intelligence and Simulation of      Behaviour. London: Pitman.      Evans R., Gazdar G. (1989b):     "Inference in DATR. " In      Proceedings of the Fourth Conference of the European Chapter of      the Association for Computational Linguistics. Manchester.      Garcia C. (1991): Computerimplementation der deutschen      Morphologie, Lizentiatsarbeit an der Philosophischen Fakultät I      der Universität Zürich.      Görz G., Paulus D. (1988):     "A Finite State Approach to      German Verb Morphology. " In Proceedings of the 12th      International Conference on Computational Linguistics,      COLING-88, Budapest.      Gupta A. (1988):     "La formalisation de la morfologie      française sur la base du système Word Manager. "      Lizentiatsarbeit an der Philosophischen Fakultät I der      Universität Zürich. Kay M. (1987): "Nonconcatenative      Finite-State Morphology. " In Proceedings of the Third Conference      of the European Chapter of the Association for Computational      Linguistics, Copenhagen, April 1-3.      Karttunen L., Koskenniemi K., Kaplan R. (1987):   "TWOL: A      Compiler for Two-level Phonological Rules. " In "Tools for      Morphological Analysis ", Center for the Study of Language and      Information, Report No. CLSI-87-108.      Koskenniemi K. (1983):   "Two-Level-Morphology: A General      Computational Model for Word-Form Recognition and Production      ", doctoral thesis at the University of Helsinki, Publications Nº      11.      Russell G., Ritchie G., Pulman S. G., Black A. (1986):     "A      Dictionary and Morphological Analyser for English. " In      Proceedings of the 11th International Conference on      Computational Linguistics, COLING-86, Bonn.      Russi T. (1990):     "A Syntactic and Morphological Analyzer for      a Text-to-Speech System. In Proceedings of the 13th      International Conference on Computational Linguistics,      COLING-90, Helsinki.      Shieber S. M. (1985):   "Criteria for Designing Computer      Facilities for Linguistic Analysis. " In Linguistics 23, p.189-211.      Trost H. (1990):     "The application of two-level morphology to      non-concatenative German morphology. " In Proceedings of the      13th International Conference on Computational Linguistics,      COLING-90, Helsinki.  