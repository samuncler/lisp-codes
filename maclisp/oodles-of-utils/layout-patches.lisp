; vertikales Layout eines Graphen ;---------------------------------------------------------------------------------------;--------------------------------------------------------------------------------------; in File DAG.Lisp:;;; -*- Mode: LISP; Syntax: Common-Lisp; package: LAYOUT  -*- ;;; ********************************************************************;;; Layout *************************************************************;;; ********************************************************************;;; Written by Michael Hussmann, adapted by Ralf Moeller;;; University of Hamburg, Computer Science Department, December 1991.;;; Copyright (c) 1991 by Michael Hussmann and Ralf Moeller. All rights reserved.;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted, so long as the following;;; conditions are met:;;;      o no fees or compensation are charged for use, copies, or;;;        access to this software;;;      o this copyright notice is included intact.;;; This software is made available AS IS, and no warranty is made about ;;; the software or its performance. ;;; Please send bug reports, comments and suggestions to;;; moeller@informatik.uni-hamburg.de(in-package :layout)(locally  (declare (optimize (safety 0)                      (speed 3)                      (space 3)                     (compilation-speed 0)                     (debug 0)))(defstruct (node (:print-function print-node)                 (:copier nil))   reference   (daughters nil)   (mothers nil)   (mark nil)   top   (left 0)   width   height   (global-top nil)   global-bottom   left-point   right-point   box-item   layouted-items)(defun print-node (n stream depth)  (declare (ignore depth))  (print-unreadable-object (n stream :type t :identity t)))(defvar *node-distance* 4)(defun filter-cyclic-nodes (x vis-nodes appl-successors)  (remove-if #'(lambda (successor)                 (let ((n (assoc successor                                  vis-nodes)))                   (and n                        (< (node-left (cdr n)) x))))             appl-successors))(defun build-dag-structures (roots                             left top                             successor-fcn                             map-fcn                             n-expansions                             expansion-predicate                             &optional (node-equal-predicate #'eql)                             (layout-scheme ':horizontal))  (let ((nodes nil))    (labels ((build-dag (n x n-expansions                           &aux (a-node (cdr (assoc n nodes                                                    :test node-equal-predicate))))                        (cond (a-node                               (when (> x (node-left a-node))                                 (re-adjust a-node (- x (node-left a-node))))                               a-node)                              (t (let* ((a-node (make-node :reference n                                                           :left x))                                        (box-item (funcall map-fcn                                                           (node-reference a-node)                                                           (= 1 n-expansions)))                                        (width (ecase layout-scheme                                                 (:horizontal (point-h (box-item-size box-item)))                                                 (:vertical (point-v (box-item-size box-item)))))                                        (height (ecase layout-scheme                                                 (:horinzontal (point-v (box-item-size box-item)))                                                 (:vertical (point-h (box-item-size box-item))))))                                   (setf (node-width a-node) width)                                   (setf (node-height a-node) height)                                   (push (cons n a-node) nodes)                                   (setf (node-box-item a-node) box-item)                                   (if (and (> n-expansions 1)                                            (funcall expansion-predicate n))                                     (build-daughter-dags (filter-cyclic-nodes                                                           x                                                           nodes                                                            (remove-if-not                                                             expansion-predicate                                                            (funcall successor-fcn                                                                      n                                                                     box-item)))                                                          a-node                                                          (1- n-expansions)                                                          x                                                          width                                                          height))                                   a-node))))            (build-daughter-dags (daughters a-node n-expansions x width height)               (let* ((right (+ x width))                      (x (+ right                            (truncate (* height                                         (max (length daughters) 2)                                         0.3)))))                     (connect-nodes a-node                                    (mapcar #'(lambda (d) (build-dag d x n-expansions))                                            daughters))))            (re-adjust (a-node diff)               (setf (node-left a-node) (+ (node-left a-node) diff))               (dolist (d (node-daughters a-node)) (re-adjust d diff)))            (connect-nodes (a-node daughters)               (setf (node-daughters a-node) daughters)               (dolist (daughter daughters)                  (pushnew a-node (node-mothers daughter)))))      (let ((dags             (sort-dags                 (mapcar #'(lambda (r) (build-dag r left n-expansions)) roots))))        (traverse-dags           dags           top           layout-scheme)        dags))));*--------------------------------------------------------------------------*;*                                                                          *;*                          ENTFLECHTEN DES GRAPHEN                         *;*                          graph decartelization                           *;*                                                                          *;*--------------------------------------------------------------------------*(defun sort-dags (roots)   (labels ((traverse (a-node)               (unless (singlep (node-mothers a-node))                  (mark-mothers a-node)                  (setq roots (group-daughters roots t t))                  (unmark-mothers a-node))               (mapc #'traverse (node-daughters a-node)))            (mark-mothers (a-node)               (setf (node-mark a-node) t)               (mapc #'mark-mothers (node-mothers a-node)))            (unmark-mothers (a-node)               (setf (node-mark a-node) nil)               (mapc #'unmark-mothers (node-mothers a-node))))           (mapc #'traverse roots)           roots))(defun singlep (x) (and (consp x) (null (cdr x))))(defun group-daughters (daughters leftmostp rightmostp)   (labels ((group-daughters-right (daughters marked)               (if (null daughters)                   (progn (when marked                             (sort-daughters (reverse marked)                                             leftmostp                                             rightmostp))                          (reverse marked))                   (let ((first-d (first daughters))                         (rest-d (rest daughters)))                        (if (node-mark first-d)                            (group-daughters-right rest-d                                                   (cons first-d marked))                            (cons first-d                                  (group-daughters-right rest-d marked))))))            (group-daughters-left (daughters marked unmarked)               (if (null daughters)                   (progn (when marked                             (sort-daughters (reverse marked)                                             leftmostp                                             rightmostp))                          (revappend marked (reverse unmarked)))                   (let ((first-d (first daughters))                         (rest-d (rest daughters)))                        (if (node-mark first-d)                            (group-daughters-left rest-d                                                  (cons first-d marked)                                                  unmarked)                            (group-daughters-left rest-d                                                  marked                                                  (cons first-d unmarked))))))            (group-daughters-middle (daughters)               (cond ((null daughters) nil)                     ((node-mark (first daughters))                      (group-daughters-left (rest daughters)                                            (list (first daughters))                                             nil))                     (t (cons (first daughters)                              (group-daughters-middle (rest daughters))))))            (sort-node (a-node leftmostp rightmostp)               (setf (node-daughters a-node)                     (group-daughters (node-daughters a-node)                                      leftmostp                                      rightmostp)))            (sort-daughters (daughters leftmostp rightmostp)               (sort-node (first daughters)                          leftmostp                          (and rightmostp (singlep daughters)))               (mapl #'(lambda (daughters)                        (sort-node (first daughters)                                   nil                                   (if (singlep daughters) rightmostp)))                     (rest daughters))))           (cond ((and leftmostp rightmostp)                  (group-daughters-middle daughters))                 (leftmostp (group-daughters-right daughters nil))                 (rightmostp (group-daughters-left daughters nil nil))                 (t (group-daughters-middle daughters)))));*--------------------------------------------------------------------------*;*                                                                          *;*                       BERECHNUNG DER Y-KOORDINATEN                       *;*                       Computation of the y-coordinates                   *;*                                                                          *;*--------------------------------------------------------------------------*(defun traverse-dags (roots y layout-scheme)   (when roots      (traverse-dags (rest roots)                      (traverse-dag (first roots) y layout-scheme)                     layout-scheme)))(defun traverse-dag (root y layout-scheme)   (labels ((traverse (a-node y &aux (height (node-height a-node)))               (cond ((next-daughters (node-daughters a-node))                      (setf (node-global-top a-node) y)                      (do ((daughters (next-daughters (node-daughters a-node))                                      (next-daughters (rest daughters)))                           (y y                              (+ (node-global-bottom (first daughters))                                 *node-distance*)))                          ((null daughters)                           (setf (node-global-bottom a-node)                                 (- y *node-distance*)))                          (traverse (first daughters) y))                      (setf (node-top a-node)                            (- (truncate (+ y (node-global-bottom a-node)) 2)                               (truncate height 2))))                     (t (setf (node-top a-node) y)                        (setf (node-global-top a-node) y)                        (setf (node-global-bottom a-node)                              (+ y height))))               (calc-left-and-right-points a-node height)               (let ((node-box-item (node-box-item a-node))                     (left (node-left a-node))                     (top (node-top a-node)))                 (cond ((box-item-p node-box-item)                        (setf (box-item-position node-box-item)                              (ecase layout-scheme                                (:horizontal (make-point left top))                                (:vertical (make-point top left))))                        (setf (node-layouted-items a-node)                              (list node-box-item)))                       ((layout-spec-p node-box-item)                        (let ((box-items (items-positioned-in-box                                          node-box-item                                          left                                           top                                          (+ left (node-width a-node))                                          (+ top (node-height a-node)))))                          (setf (node-layouted-items a-node)                                box-items))))))            (calc-left-and-right-points (a-node height)               (let ((left (node-left a-node))                     (top (node-top a-node))                     (width (node-width a-node)))                    (let ((mid (+ top (truncate height 2))))                         (setf (node-left-point a-node)                               (make-point left mid))                         (setf (node-right-point a-node)                               (make-point (+ left width) mid)))))            (next-daughters (daughters)               (do ((daughters daughters (rest daughters)))                   ((null daughters) nil)                   (unless (node-global-top (first daughters))                      (return daughters)))))           (traverse root y)           (+ (node-global-bottom root) *node-distance*)));*--------------------------------------------------------------------------*;*                                                                          *;*                       BERECHNUNG DER ITEMS                               *;*                       Computation of the dag items                       *;*                                                                          *;*--------------------------------------------------------------------------*(defun dags-items (roots connector-fcn reference-1-fcn reference-2-fcn)  (let ((view-items nil))    (labels ((traverse (a-node)                       (if a-node                         (let ((daughters (node-daughters a-node)))                           (mapc #'traverse daughters)                           (mapc #'(lambda (item)                                     (pushnew item view-items))                                 (node-layouted-items a-node))                           (mapc #'(lambda (daughter)                                     (let ((connector (funcall connector-fcn)))                                       (parse-layout-spec                                         (funcall reference-2-fcn                                                 connector                                                 (first (node-layouted-items                                                         a-node))))                                       (parse-layout-spec                                         (funcall reference-1-fcn                                                  connector                                                 (first (node-layouted-items                                                          daughter))))                                       (push connector view-items)))                                 daughters))                         nil)))      (if roots        (progn (setf view-items (append view-items                                        (dags-items (rest roots)                                                     connector-fcn                                                    reference-1-fcn                                                     reference-2-fcn)))               (traverse (first roots)))        nil))    view-items))(defun parse-dag-layout-spec (layout-spec left top)  (let* ((roots (second layout-spec))         (successor-fcn (third layout-spec))         (n-expansions (fourth layout-spec))         (expansion-predicate (fifth layout-spec))         (map-fcn (nth 5 layout-spec))         (connector-fcn (nth 6 layout-spec))         (reference-1-fcn (nth 7 layout-spec))         (reference-2-fcn (nth 8 layout-spec))         (node-equal-predicate (or (nth 9 layout-spec) #'eql))         (layout-scheme (or (nth 10 layout-spec) ':horizontal))         (layouted-nodes (build-dag-structures roots                                               left top                                               successor-fcn                                               map-fcn                                               n-expansions                                               expansion-predicate                                               node-equal-predicate                                               layout-scheme)))      (dags-items layouted-nodes                   connector-fcn                  reference-1-fcn                  reference-2-fcn)))) ; end locally;--------------------------------------------------------------------------------------;--------------------------------------------------------------------------------------(in-package :tools);;; This is indeed a patch that will be available in the next release. (defmethod set-view-size :around ((view edge-view) h &optional v)   (call-next-method view                    (if v                      (+ 1 h)                      (+ 1 (point-h h)))                    (if v                      (+ 1 v)                      (+ 1 (point-v h)))));;; Now the changes to the class browser. (defun northern-reference (item-1 item-2)   (:rbox item-1         item-2         (:horizontal :filler :reference :filler) (:vertical :reference :filler)))(defun southern-reference (item-1 item-2)   (:rbox item-1         item-2         (:horizontal :filler :reference :filler) (:vertical :filler :reference)))(defun show-graph (browser                   roots                   successor-generator                   view-mapping-function)  (let ((graph-view (view-named 'graph-view browser)))     (with-cursor *watch-cursor*      (setf (layout:layout graph-view)            (:vbox             ()             10             (:hbox              ()              10              (:dag roots                    successor-generator                    (browser-expansion-depth browser)                    #'(lambda (obj) (declare (ignore obj)) t) view-mapping-function                    #'make-edge-view-item                    #'northern-reference                    #'southern-reference                    #'eql                    ':vertical)))))    (setf (graph-roots graph-view) roots)));---------------------------------------------------------------------------------------;---------------------------------------------------------------------------------------; Patch1.lisp:(in-package :tools);;; This is indeed a patch that will be available in the next release.(defmethod set-view-size :around ((view edge-view) h &optional v)  (call-next-method view                    (if v                       (+ 1 h)                      (+ 1 (point-h h)))                    (if v                      (+ 1 v)                      (+ 1 (point-v h)))));---------------------------------------------------------------------------------------;---------------------------------------------------------------------------------------;Patch2.lisp:(in-package :ccl);;; from view-extensions.lisp(defmacro with-pen-state ((&rest states) &body body)  (let ((ps (gensym)))    `(rlet ((,ps :PenState))       (#_GetPenState :ptr ,ps)       (unwind-protect         (progn           (port-set-pen-state ,@states)           ,@body)         (#_SetPenState :ptr ,ps)))))(defun draw-selection-marks-really (v)  (let ((pos (view-position v))        (siz (view-size v)))    (labels ((draw-little-square               (p)              (rlet ((little-r :rect                               :topleft (subtract-points p #@(2 2))                               :bottomright (add-points p #@(2 2))))                (#_PaintRect little-r)                (#_ValidRect little-r))))      (#_PenNormal)                          ; added by rm 4/30/93      (with-pen-state (:mode :patXor)        (draw-little-square pos)        (draw-little-square (add-points pos siz))        (draw-little-square (add-points pos (make-point (point-h siz) 0)))        (draw-little-square (add-points pos (make-point 0 (point-v siz))))))));---------------------------------------------------------------------------------------;---------------------------------------------------------------------------------------;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: CCL -*- ;;; ********************************************************************;;; Gcontexts **********************************************************;;; ********************************************************************;;; Written by Ralf Moeller;;; University of Hamburg, Computer-Science Department, December 1991.;;; Copyright (c) 1991 by Ralf Moeller. All rights reserved.;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted, so long as the following;;; conditions are met:;;;      o no fees or compensation are charged for use, copies, or;;;        access to this software;;;      o this copyright notice is included intact.;;; This software is made available AS IS, and no warranty is made about ;;; the software or its performance. ;;; Please send bug reports, comments and suggestions to;;; moeller@informatik.uni-hamburg.de(in-package :ccl)(defstruct (gcontext (:constructor make-gcontext-instance))  (pen-mode nil)  (pen-size nil)  (pen-pattern nil)  (fill-pattern nil)  (font nil))(defun make-gcontext (&key (pen-mode ':patCopy)                           (pen-pattern *black-pattern*)                           (pen-size #@(1 1))                           (font nil)                           (fill-pattern *black-pattern*))  (make-gcontext-instance :pen-mode (or (position pen-mode *pen-modes*)                                        (error "Undefined pen-mode ~S"                                               pen-mode))                          :pen-pattern pen-pattern                          :pen-size pen-size                          :font font                          :fill-pattern fill-pattern))(defparameter standard-gcontext  (make-gcontext)  "Standard gcontext. Attention: has to be restored while starting an application.")(defun make-cache (n)  (if (= n 0)    nil    (cons (make-gcontext-instance)          (make-cache (- n 1)))))(defvar *gcontext-cache*)(setf *gcontext-cache* (make-cache 10))(defun restore-gcontexts ()  (setf standard-gcontext (make-gcontext))  (setf *gcontext-cache* (make-cache 10)))(push 'restore-gcontexts *restore-lisp-functions*)(defun get-gcontext (&key (pen-mode ':patCopy)                          (pen-pattern *black-pattern*)                          (pen-size #@(1 1))                          (fill-pattern *black-pattern*)                          (font nil))  (labels ((re-order (cache previous)              (setf (rest previous) (rest cache))              (setf (rest cache) *gcontext-cache*)              (setf *gcontext-cache* cache))           (get-gcontext-internal (cache previous)              (if (endp cache)                (error "End of cache found.")                (let ((current-gcontext (first cache)))                  (cond ((and (eq (gcontext-pen-pattern current-gcontext)                                   pen-pattern)                              (eq (gcontext-pen-mode current-gcontext)                                  pen-mode)                              (eql (gcontext-pen-size current-gcontext)                                   pen-size)                              (eql (gcontext-fill-pattern current-gcontext)                                   fill-pattern)                              (equal (gcontext-font current-gcontext)                                     font))                         (if (not (null previous))                           (re-order cache previous))                         current-gcontext)                        ((endp (rest cache))                           (let ((new-gcontext (make-gcontext                                                :pen-mode pen-mode                                                :pen-pattern pen-pattern                                                :pen-size pen-size                                                :font font                                                :fill-pattern fill-pattern)))                             (setf (car cache)                                   new-gcontext)                             (if (not (null previous))                               (re-order cache previous))                             new-gcontext))                        (t (get-gcontext-internal (rest cache) cache)))))))    (get-gcontext-internal *gcontext-cache* nil)))(defmacro using-gcontext (context-descriptions &body forms)  (labels ((gcontext-bindings (context-descriptions)                              (mapcar #'(lambda (context-descr)                                          `(,(first context-descr)                                            (get-gcontext . ,(rest context-descr))))                                      context-descriptions)))    `(let ,(gcontext-bindings context-descriptions)       . ,forms)))(defclass gcontext-mixin  ()  ((view-gcontext :accessor view-gcontext :initform standard-gcontext)))(let ((method (find-method #'view-draw-contents '(:around)                           (list (find-class 'simple-view))                           nil)))  (if method    (remove-method #'view-draw-contents method)    (warn "Remove removal of method!")))(let ((method (find-method #'window-draw-grow-icon                           '(:around)                           (list (find-class 'gcontext-mixin))                           nil)))  (if method    (remove-method #'window-draw-grow-icon method)    (warn "Remove removal of method!")))(defmacro with-gcontext-installed ((view gcontext) &body forms)  (let ((view-var (gensym))        (gcontext-var (gensym))        (view-gcontext-var (gensym)))    `(let* ((,view-var ,view)            (,gcontext-var ,gcontext)            (,view-gcontext-var (view-gcontext ,view-var)))       (without-interrupts        (with-focused-view ,view-var          (if (eq ,view-gcontext-var ,gcontext-var)            (progn               (#_PenPat (gcontext-pen-pattern ,view-gcontext-var))              (#_PenMode (gcontext-pen-mode ,view-gcontext-var))              (#_PenSize :long (gcontext-pen-size ,view-gcontext-var)))            (progn              (#_PenPat (gcontext-pen-pattern ,gcontext-var))              (#_PenMode (gcontext-pen-mode ,gcontext-var))              (#_PenSize :long (gcontext-pen-size ,gcontext-var))              (let ((font (gcontext-font ,gcontext-var)))                (if (null font)                  (set-view-font ,view-var (view-default-font view))                  (set-view-font ,view-var font)))              (setf (view-gcontext ,view) ,gcontext)))           . ,forms)))))(defmethod draw-line-to ((view simple-view) gcontext h &optional v)  (with-gcontext-installed (view gcontext)    (#_LineTo :long (setq h (make-point h v))))  h)(defmethod draw-line ((view simple-view) gcontext h &optional v)  (with-gcontext-installed (view gcontext)    (#_Line :long (setq h (make-point h v))))  h)(defmethod draw-framed-rect ((view simple-view) gcontext left &optional top right bot) (with-gcontext-installed (view gcontext)   (with-rectangle-arg (r left top right bot) (#_FrameRect r))))(defmethod draw-painted-rect ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot) (#_PaintRect r))))(defmethod draw-erased-rect ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot) (#_EraseRect r))))(defmethod draw-inverted-rect ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot) (#_InvertRect r))))(defmethod draw-filled-rect ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)       (#_FillRect r (gcontext-fill-pattern gcontext)))))(defmethod draw-framed-oval ((view simple-view) gcontext left &optional top right bot) (with-gcontext-installed (view gcontext)   (with-rectangle-arg (r left top right bot) (#_FrameOval r))))(defmethod draw-painted-oval ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot) (#_PaintOval r))))(defmethod draw-erased-oval ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot) (#_EraseOval r))))(defmethod draw-inverted-oval ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot) (#_InvertOval r))))(defmethod draw-filled-oval ((view simple-view) gcontext left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)      (#_FillOval r (gcontext-fill-pattern gcontext)))))(defmethod draw-framed-round-rect ((view simple-view) gcontext oval-width oval-height                              left &optional top right bot) (with-gcontext-installed (view gcontext)   (with-rectangle-arg (r left top right bot)      (#_FrameRoundRect r oval-width oval-height))))(defmethod draw-painted-round-rect ((view simple-view) gcontext oval-width oval-height                              left &optional top right bot) (with-gcontext-installed (view gcontext)   (with-rectangle-arg (r left top right bot)      (#_PaintRoundRect r oval-width oval-height))))(defmethod draw-erased-round-rect ((view simple-view) gcontext oval-width oval-height                              left &optional top right bot) (with-gcontext-installed (view gcontext)   (with-rectangle-arg (r left top right bot)      (#_EraseRoundRect r oval-width oval-height))))(defmethod draw-inverted-round-rect ((view simple-view) gcontext oval-width oval-height                               left &optional top right bot) (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)      (#_InvertRoundRect r oval-width oval-height))))(defmethod draw-filled-round-rect ((view simple-view) gcontext oval-width oval-height                             left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)       (#_FillRoundRect r oval-width oval-height (gcontext-fill-pattern gcontext)))))(defmethod draw-framed-arc ((view simple-view) gcontext start-angle arc-angle                       left &optional top right bot) (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)      (#_FrameArc r start-angle arc-angle))))(defmethod draw-painted-arc ((view simple-view) gcontext start-angle arc-angle                       left &optional top right bot) (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)      (#_PaintArc r start-angle arc-angle))))(defmethod draw-erased-arc ((view simple-view) gcontext start-angle arc-angle                       left &optional top right bot) (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)      (#_EraseArc r start-angle arc-angle))))(defmethod draw-inverted-arc ((view simple-view) gcontext start-angle arc-angle                        left &optional top right bot) (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)      (#_InvertArc r start-angle arc-angle))))(defmethod draw-filled-arc ((view simple-view) gcontext start-angle arc-angle                     left &optional top right bot)  (with-gcontext-installed (view gcontext)    (with-rectangle-arg (r left top right bot)       (#_FillArc r start-angle arc-angle (gcontext-fill-pattern gcontext)))))(defmethod draw-framed-region ((view simple-view) gcontext region)  (with-gcontext-installed (view gcontext)    (#_FrameRgn region)))(defmethod draw-painted-region ((view simple-view) gcontext region)  (with-gcontext-installed (view gcontext)    (#_PaintRgn region)))(defmethod draw-erased-region ((view simple-view) gcontext region)  (with-gcontext-installed (view gcontext)    (#_EraseRgn region)))(defmethod draw-inverted-region ((view simple-view) gcontext region)  (with-gcontext-installed (view gcontext)    (#_InvertRgn region)))(defmethod draw-filled-region ((view simple-view) gcontext region)  (with-gcontext-installed (view gcontext)    (#_FillRgn region (gcontext-fill-pattern gcontext))))(defmethod draw-framed-polygon ((view simple-view) gcontext polygon)  (with-gcontext-installed (view gcontext)    (#_FramePoly polygon)))(defmethod draw-painted-polygon ((view simple-view) gcontext polygon)  (with-gcontext-installed (view gcontext)    (#_PaintPoly polygon)))(defmethod draw-erased-polygon ((view simple-view) gcontext polygon)  (with-gcontext-installed (view gcontext)    (#_ErasePoly polygon)))(defmethod draw-inverted-polygon ((view simple-view) gcontext polygon)  (with-gcontext-installed (view gcontext)    (#_InvertPoly polygon)))(defmethod draw-filled-polygon ((view simple-view) gcontext polygon) (with-gcontext-installed (view gcontext)    (#_FillPoly polygon (gcontext-fill-pattern gcontext))))(export '(draw-line-to draw-line          draw-framed-rect          draw-painted-rect draw-erased-rect draw-inverted-rect          draw-filled-rect draw-framed-oval draw-painted-oval          draw-erased-oval draw-inverted-oval draw-filled-oval           draw-framed-round-rect draw-painted-round-rect          draw-erased-round-rect draw-inverted-round-rectdraw-filled-round-rect           draw-framed-arc          draw-painted-arc draw-erased-arc draw-inverted-arc draw-filled-arc          draw-framed-region draw-painted-region draw-erased-region          draw-inverted-region draw-filled-region          draw-framed-polygon draw-painted-polygon draw-erased-polygon           draw-inverted-polygon draw-filled-polygon                    gcontext-mixin           using-gcontext                    standard-gcontext          make-gcontext))