(in-package :oou)(oou-provide :GoMan-formatter);*****************************************************************                                    ;; Copyright © 1991-96 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; the formatting system of GoMan ; ;; Changes (worth to be mentioned):; ------------------------------;; April 96 Dieter: MCL 3.0 ;;*****************************************************************;*****************************************************************(export '(create-application-item))(oou-dependencies :QuickDraw-u                  :unibas-macros                  :unibas-cursors                  :GoMan-macros                  :resources-u                  :floating-message-dialog                  :with-running-watch                  );--------------------------------------------------------------------------(defun skip-wsp (buffer start-position)  (do* ((position start-position (1+ position))        (char (buffer-char buffer position)              (buffer-char buffer position))        (size (1- (buffer-size buffer))))       ((or (not (memq char '(#\space #\newline #\tab #\linefeed)))            (>= position size))        position)))(defun search-wsp (buffer start-position)  (let ((size (buffer-size buffer)))    (if (< start-position size)      (do ((position start-position (1+ position))           (char (buffer-char buffer start-position)))          ((or (memq char '(#\space #\newline #\tab #\linefeed #\@  #\{ #\} #\" #\|))               (>= position size))           position)        (setf char (buffer-char buffer (1+ position))))      size)))(defun paragraph-end-p (buffer from to)  (let ((first-newline-pos (buffer-char-pos buffer #\newline :start from :end to)))    (and first-newline-pos         (buffer-char-pos buffer #\newline :start (1+ first-newline-pos) :end to))))(defun next-word (buffer start-position)  "returns 2 values. the next word following <start-position> as a string and the new position"  (if (> start-position         (1- (buffer-size buffer)))    (values ""            -1)    (let* ((start (skip-wsp buffer start-position))           (end (search-wsp buffer (1+ start))))      (if (paragraph-end-p buffer start-position start)        (values :paragraph-end                 start)        (values (buffer-substring buffer start end)                end)))))           ;----------------------------------------------------------------------------------(defclass format-mixin ()  ((leftmargin :initform 20               :allocation :class               :accessor leftmargin)   (rightmargin :initform 20                :allocation :class                :accessor rightmargin)   (topmargin :initform 20              :allocation :class              :accessor topmargin )   (default-rightmargin :initform 20     :allocation :class     :accessor default-rightmargin)   (default-leftmargin :initform 20     :allocation :class     :accessor default-leftmargin )   (bottommargin :initform 20                 :allocation :class                 :accessor bottommargin)   (window-width :initform 449                  :allocation :class                 :accessor window-width)   (window-height :initform 537                  :allocation :class                  :accessor window-height)   (cursor-h-position :initform 12                      :allocation :class                      :accessor cursor-h-position)   (cursor-v-position :initform 0                      :allocation :class                      :accessor cursor-v-position)   (line-height :initform 22                :allocation :class                :accessor line-height)   (default-font :initform '("GoMan Helvetica" 12 :plain)     :allocation :class     :accessor default-font)   (verbatim-font :initform '("Monaco" 12 :plain)                  :allocation :class                  :accessor verbatim-font)   (chapter-font :initform '("GoMan Helvetica" 18 :bold)                 :allocation :class                 :accessor chapter-font)   (section-font :initform '("GoMan Helvetica" 14 :bold)                 :allocation :class                 :accessor section-font)   (bold-font :initform '("GoMan Helvetica" 12 :bold)              :allocation :class              :accessor bold-font)   (italic-font :initform '("GoMan Helvetica" 12 :italic)                :allocation :class                :accessor italic-font)   (actual-font :initform '("GoMan Helvetica" 12 :plain)                :allocation :class                :accessor actual-font)   (actual-document :initform nil                    :allocation :class                    :accessor actual-document)   (actual-chapter :initform nil                   :allocation :class                   :accessor actual-chapter)   (actual-section :initform nil                   :allocation :class                   :accessor actual-section)   (actual-subsection :initform nil                      :allocation :class                      :accessor actual-subsection)   (actual-subsubsection :initform nil                         :allocation :class                         :accessor actual-subsubsection)   (actual-example :initform nil                   :allocation :class                   :accessor actual-example)   (log-stream :initform *standard-output*               :accessor log-stream               :allocation :class)   ))(defmethod  fill-to-leftmargin ((self format-mixin) buffer buffer-position)  "fills the buffer with blanks up to the leftmargin. Returns the new buffer-position"  (with-slots (cursor-h-position leftmargin actual-font) self    (buffer-set-font-spec buffer (actual-font self))    (let ((spacewidth (string-width " " actual-font)))      (do ((h-pos cursor-h-position (+ spacewidth h-pos)))          ((>= h-pos leftmargin)            (progn (setf cursor-h-position h-pos)                  buffer-position))        (buffer-insert buffer #\space buffer-position)        (setf buffer-position (1+ buffer-position))))))(defmethod insert-newline ((self format-mixin) buffer position)  (with-slots (cursor-h-position cursor-v-position line-height) self    (buffer-set-font-spec buffer (actual-font self))    (buffer-insert buffer #\newline position)    (setf cursor-h-position 0)    (setf cursor-v-position (+ cursor-v-position (actual-line-height self)))    (1+ position)))(defmethod simple-buffer-insert ((self format-mixin) buffer string position)  (with-slots (cursor-h-position actual-font) self    (buffer-insert buffer string position)    (setf cursor-h-position (+ cursor-h-position (string-width string actual-font)))    (+ position (length string))))(defmethod format-standard-text ((self format-mixin)                                     source-buffer from-position to-pos                                     destination-buffer destination-position)  "formats a text without any @-command. Returns the new buffer-position of the destination buffer"  (with-slots (window-width cursor-h-position actual-font rightmargin) self    (buffer-set-font-spec destination-buffer (actual-font self))    (do ((from-pos from-position)         (textmargin (- window-width rightmargin))         (space-width (string-width " " actual-font)))        ((>= from-pos to-pos)          destination-position)      (multiple-value-bind (next-word new-position)                            (next-word source-buffer from-pos)        (cond ((eq next-word :paragraph-end)               (when (< new-position to-pos)                 (insert-blanklines self destination-buffer destination-position 2)                 (setf  destination-position                         (fill-to-leftmargin self destination-buffer                                             (+ 2 destination-position)))))              (t               (when (> new-position to-pos)                 (setf next-word (subseq next-word 0 (max 0                                                          (- (length next-word)                                                             (- (1- new-position)                                                                to-pos)))))                 (setf new-position to-pos))               (let ((word-width (string-width next-word actual-font)))                 (when (> (+ cursor-h-position                             word-width)                          textmargin)                   (insert-blanklines self destination-buffer destination-position)                   (setf  destination-position                           (fill-to-leftmargin self destination-buffer                                               (1+ destination-position))))                 (when (string/= next-word "")                   (buffer-insert destination-buffer next-word destination-position)                   (setf  destination-position (+ destination-position                                                  (length next-word)))                   (buffer-insert destination-buffer #\space destination-position)                   (setf  destination-position (1+ destination-position)))                 (setf cursor-h-position (+ cursor-h-position                                            word-width                                            space-width)))))        (setf from-pos new-position)))))              (defmethod actual-container ((self format-mixin))  (or (actual-subsubsection self)      (actual-subsection self)      (actual-section self)      (actual-chapter self)))                  ;----------------------------------------------------------------------------------                                                                               (defclass document (save-mixin format-mixin)  ((chapters :initform nil             :accessor chapters)   (figures :initform nil            :accessor figures)   (examples :initform nil             :accessor examples)   (index-entries :initform nil                  :accessor index-entries)   (all-links :initform nil              :accessor all-links)   (all-labels :initform nil               :accessor all-labels)   (all-document-parts :initform nil                       :accessor all-document-parts)   (source-file :initform nil                :initarg :source-file                :accessor source-file)   (source-buffer :initform nil                  :initarg :source-buffer                  :accessor source-buffer)   (destination-file :initform nil                     :initarg :destination-file                     :accessor destination-file)   (destination-buffer :initform nil                       :initarg :destination-buffer                       :accessor destination-buffer)   (source-window :initform nil                  :initarg :source-window                  :accessor source-window)   (destination-window :initform nil                       :initarg :destination-window                       :accessor destination-window))  (:default-initargs     :source-buffer (make-buffer)    :destination-buffer (make-buffer)))(defmethod initialize-instance ((self document) &rest initargs)   (declare (ignore initargs))   (let ((new-document (call-next-method)))      (unless (load-trigger new-document)         (setf (actual-document new-document) new-document)         (setf *actual-document* new-document)         (setf (actual-chapter new-document) nil)         (setf (actual-section new-document) nil))      (push new-document (opened-documents *the-librarian*))))            (defmethod read-source-file ((document document))  (with-slots (source-file source-buffer source-window) document    (when (probe-file source-file)      (when (= (buffer-size source-buffer) 0)        (buffer-delete source-buffer 0 t)        (buffer-insert-file source-buffer source-file 0))      (when source-window        (window-set-not-modified (main-fred-item source-window))        (setf (slot-value (main-fred-item source-window)  'ccl::my-file-name)              source-file)))))(defmethod  show-source-window ((doc document) &key position)  (with-slots (source-window) doc    (unless source-window      (make-source-window doc :position position))    (window-select source-window)    source-window))(defmethod  show-destination-window ((doc document))  (with-slots (destination-window) doc    (make-destination-window-if-necessary doc)    (window-select destination-window)    (fred-update (main-fred-item destination-window))    destination-window))(defmethod  make-destination-window-if-necessary ((doc document))  (with-slots (destination-window) doc    (unless destination-window      (make-destination-window doc))    (setf (scroll-direction (main-fred-item destination-window)) :in-thumb)    destination-window))(defmethod save-pictures-in-resource-fork ((doc document) &key (filename (destination-file doc)))  (with-slots (source-file destination-buffer destination-window) doc    (with-open-resource-file (refnum filename)      (using-resource-file refnum        (delete-all-picts-from-file filename)        (dolist (figure (figures doc))          (when (picture figure)            (release-handle (picture figure))            (setf (picture figure) nil))          (let ((pict (get-pict-picture figure source-file)))            (when pict              (add-pict-to-file pict filename (rsrc-id figure) "")              (release-handle pict))            (setf (picture figure) nil)))))))                                          (defmethod save-document-object-in-resource-fork ((doc document) &key (filename (destination-file doc)))  (save-string-in-resource-fork filename (external-form doc) 201)  (reinitialize (librarian-window *the-librarian*)))(unless (boundp 'ccl::$ioPBSize)  (defconstant ccl::$ioPBSize 122))(unless (boundp 'ccl::$ioFileName)  (defconstant ccl::$ioFileName #x12))   (defmethod save-pict-archive ((self document) &key (filename (source-file self)))  (with-running-watch    (with-slots (source-window) self       (when (and source-window                 (pict-archive source-window))        (setf (resource-file (pict-archive source-window)) filename)        (set-window-title (pict-archive source-window)                          (format nil "Pictures of '~A {...:~A:}'"                                   (file-namestring filename) (car (last (pathname-directory filename)))))        (window-save (pict-archive source-window))        (close-res-file filename)))))(defmethod update-windows ((self document))  (with-slots (source-window destination-window) self    (when source-window      (update source-window))    (when destination-window      (update destination-window)))  (when (and *the-librarian*             (librarian-window *the-librarian*))    (reinitialize (librarian-window *the-librarian*))))(defmethod item-at-source-position ((self document) position)   (with-slots (figures examples index-entries all-links all-labels all-document-parts) self       (dolist (items (list figures examples index-entries all-links all-labels all-document-parts))          (let ((item-found (find position items                                               :key #'source-start-position                                                :test #'(lambda (pos source-pos)                                                             (when (numberp source-pos)                                                                 (< (abs (- pos source-pos)) 3))))))             (when item-found                 (return item-found))))))(defmethod format-selection ((document document))   (with-slots (source-window source-buffer destination-buffer actual-chapter actual-section ) document       (initialize-for-new-formatting document)       (multiple-value-bind (begin-selection end-selection) (selection-range source-window)           (if (= begin-selection end-selection)              (format-text document source-buffer 0 (1- (buffer-size source-buffer))                                    destination-buffer (fill-to-leftmargin document destination-buffer 0))              (format-text document source-buffer begin-selection (min end-selection (1- (buffer-size source-buffer)))                                    destination-buffer (fill-to-leftmargin document destination-buffer 0))))       (when actual-chapter           (setf (format-end-position actual-chapter) (buffer-size destination-buffer))           (setf (source-end-position actual-chapter) (buffer-size source-buffer)))       (when actual-section           (setf (format-end-position actual-section) (buffer-size destination-buffer))           (setf (source-end-position actual-section) (buffer-size source-buffer)))       (sort-contents-entries document)       (update-windows document))) (defmethod format-buffer ((document document))   (with-slots (source-buffer destination-buffer actual-chapter actual-section) document       (initialize-for-new-formatting document)       (format-text document source-buffer 0 (1- (buffer-size source-buffer))                             destination-buffer (fill-to-leftmargin document destination-buffer 0))       (when actual-chapter           (setf (format-end-position actual-chapter) (buffer-size destination-buffer))           (setf (source-end-position actual-chapter) (buffer-size source-buffer)))       (when actual-section           (setf (format-end-position actual-section) (buffer-size destination-buffer))           (setf (source-end-position actual-section) (buffer-size source-buffer)))       (sort-contents-entries document)       (update-windows document)))(defmethod reset-environment ((document document))  (with-slots (all-labels) document    (dolist (label all-labels)      (setf (all-existing-labels *the-librarian*)            (delq label (all-existing-labels *the-librarian*))))    (dolist (label (all-existing-application-labels *the-librarian*))      (dolist (link (links label))        (when (eq (document link) document)          (setf (links label) (delq link (links label)))))      (when (and (null (links label))                 (null (application-items label)))        (setf (all-existing-application-labels *the-librarian*)              (delq label (all-existing-application-labels *the-librarian*)))))))(defmethod initialize-for-new-formatting ((document document))  (with-slots (source-buffer source-file destination-buffer chapters figures examples all-labels index-entries                              all-links leftmargin default-leftmargin rightmargin default-rightmargin                             actual-document actual-chapter actual-section actual-example actual-subsection actual-subsubsection                              cursor-v-position cursor-h-position all-document-parts                             destination-file) document    (reset-environment document)    (setf (actual-font document) (default-font document))    (buffer-delete destination-buffer 0 t)    (buffer-insert destination-buffer #\space 0)    (buffer-set-font-spec destination-buffer '(12) 0 1)    (setf chapters nil)    (dolist (fig figures)      (release-handle (picture fig)))    (setf figures nil)    (setf index-entries nil)    (setf examples nil)    (setf actual-chapter nil)    (setf actual-section nil)    (setf actual-subsection nil)    (setf actual-subsubsection nil)    (setf actual-example nil)    (setf cursor-v-position 18)    (setf cursor-h-position 0)    (setf leftmargin default-leftmargin)    (setf rightmargin default-rightmargin)    (setf actual-document document)    (setf *actual-document* document)    (setf all-labels nil)    (setf all-links nil)    (setf all-document-parts nil)    (unless source-buffer      (setf source-buffer (make-buffer)))    (setf destination-file nil)    (when (and source-file               (= (buffer-size (source-buffer document)) 0))      (read-source-file document))    (when (or (= (buffer-size source-buffer) 0)              (and (char/= (buffer-char source-buffer (1- (buffer-size source-buffer)))                           #\newline)                   (char/= (buffer-char source-buffer (1- (buffer-size source-buffer)))                           #\space)))      (buffer-insert source-buffer #\space (buffer-size source-buffer)))))       (defmethod contents-objects ((self document))  (all-document-parts self))                                                                                                          (defmethod sort-contents-entries ((self document))  (do ((chapters (chapters self) (cdr chapters)))      ((null chapters))    (setf (sections (car chapters)) (sort (sections (car chapters)) #'document-part-lessp  :key #'number)))  (setf (chapters self)         (sort (chapters self) #'document-part-lessp  :key #'number))  (setf (all-document-parts self)        (sort (all-document-parts self) #'document-part-lessp  :key #'number)));---------------------------------------------------------------------------------- (defclass buffer-information-mixin ()  ((source-start-position :initform nil                          :accessor source-start-position                          :initarg :source-start-position)   (source-end-position :initform nil                        :accessor source-end-position                        :initarg :source-end-position)   (format-start-position :initform nil                          :accessor format-start-position                          :initarg :format-start-position)   (format-end-position :initform nil                        :accessor format-end-position                        :initarg :format-end-position)   ))(defclass logical-structure-mixin ()  ((title :accessor title          :initarg :title)   (number :accessor number           :initarg :number)   ))(defclass contains-mixin ()  ((contained-labels :initform nil                     :accessor contained-labels)   (contained-links :initform nil                    :accessor contained-links)   (contained-figures :initform nil                      :accessor contained-figures)   (contained-examples :initform nil                       :accessor contained-examples)   ))(defclass document-mixin ()  ((document :initform nil             :initarg :document             :accessor document)))(defmethod initialize-instance :after ((self document-mixin) &rest initargs)  (declare (ignore initargs))  (setf (document self) (actual-document self)));---------------------------------------------------------------------------------- (defclass chapter (save-mixin format-mixin buffer-information-mixin logical-structure-mixin contains-mixin)  ((document :initform nil             :accessor document)   (sections :initform nil             :accessor sections)   ))(defmethod initialize-instance ((self chapter) &rest initargs)  (declare (ignore initargs))  (let ((new-chapter (call-next-method)))    (unless (load-trigger new-chapter)      (with-slots (number document actual-chapter actual-document) new-chapter        (setf number (if actual-chapter                        (list (1+ (car (number actual-chapter))))                       (list 1)))        (setf document actual-document)        (push new-chapter (all-document-parts document))        (push new-chapter (chapters document))))))              ;---------------------------------------------------------------------------------- (defclass section (save-mixin format-mixin buffer-information-mixin logical-structure-mixin contains-mixin document-mixin)  ((chapter :initform nil            :accessor chapter)   (subsections :initform nil                :accessor subsections)   ))(defmethod initialize-instance ((self section) &rest initargs)  (declare (ignore initargs))  (let ((new-section (call-next-method)))    (unless (load-trigger new-section)      (with-slots (number chapter actual-chapter actual-section actual-document) new-section        (setf number (cond (actual-section                            (list (car (number actual-section))                                  (1+ (cadr (number actual-section)))))                           (actual-chapter                            (list (car (number actual-chapter)) 1))                           (t                            (list 1 1))))        (setf chapter actual-chapter)        (push new-section (all-document-parts actual-document))        (when chapter          (push new-section (sections chapter)))))))              ;---------------------------------------------------------------------------------- (defclass subsection (save-mixin format-mixin buffer-information-mixin logical-structure-mixin contains-mixin document-mixin)  ((section :initform nil            :accessor section)   (subsubsections :initform nil                   :accessor subsubsections)   ))(defmethod initialize-instance ((self subsection) &rest initargs)  (declare (ignore initargs))  (let ((new-subsection (call-next-method)))    (unless (load-trigger new-subsection)      (with-slots (number section actual-chapter actual-section actual-subsection actual-document) new-subsection        (setf number (cond (actual-subsection                            (list (car (number actual-subsection))                                  (cadr (number actual-subsection))                                  (1+ (caddr (number actual-subsection)))))                           (actual-section                            (list (car (number actual-section))                                  (cadr (number actual-section))                                  1))                           (actual-chapter                            (list (car (number actual-chapter)) 1 1))                           (t                            (list 1 1 1))))        (setf section actual-section)        (push new-subsection (all-document-parts actual-document))        (when section          (push new-subsection (subsections section)))))))              ;----------------------------------------------------------------------------------(defclass subsubsection (save-mixin format-mixin buffer-information-mixin logical-structure-mixin contains-mixin document-mixin)  ((subsection :initform nil               :accessor subsection)   ))(defmethod initialize-instance ((self subsubsection) &rest initargs)  (declare (ignore initargs))  (let ((new-subsubsection (call-next-method)))    (unless (load-trigger new-subsubsection)      (with-slots (number subsection actual-chapter actual-section actual-subsection actual-subsubsection                           actual-document) new-subsubsection        (setf number (cond ((and actual-subsubsection                                 ;(/= (car (number actual-subsubsection)) 0)                                 )                            (list (car (number actual-subsubsection))                                  (cadr (number actual-subsubsection))                                  (caddr (number actual-subsubsection))                                  (1+ (cadddr (number actual-subsubsection)))))                           (actual-subsection                            (list (car (number actual-subsection))                                  (cadr (number actual-subsection))                                  (caddr (number actual-subsection))                                  1))                           (actual-section                            (list (car (number actual-section))                                  (cadr (number actual-section))                                  1 1))                           (actual-chapter                            (list (car (number actual-chapter)) 1 1 1))                           (t                            (list 0 0 0 0)                            )))        (setf subsection actual-subsection)        (push new-subsubsection (all-document-parts actual-document))        (when subsection          (push new-subsubsection (subsubsections subsection)))))))              ;----------------------------------------------------------------------------------(defclass index (document-mixin save-mixin format-mixin buffer-information-mixin)  ((container :initform nil              :accessor container              :initarg :container)   (index-entry :initform nil                :accessor index-entry                :initarg :index-entry)));----------------------------------------------------------------------------------(defclass link (document-mixin save-mixin format-mixin buffer-information-mixin)  ((container :initform nil              :accessor container)   (label :initform nil          :accessor label)   (identifier-string :accessor identifier-string                      :initarg :identifier-string)   ))(defmethod initialize-instance ((self link) &rest initargs)  (declare (ignore initargs))  (let ((new-link (call-next-method)))    (unless (load-trigger new-link)      (with-slots (container actual-document document) new-link        (setf document actual-document)        (setf container (actual-container self))        (when container          (push new-link (contained-links container)))        (push new-link (all-links actual-document))))))(defmethod jump ((self link))  (show (label self)));----------------------------------------------------------------------------------(defclass application-link (link)  ())(defmethod jump :after ((self application-link))  (when (destination-window (document self))    (window-select (destination-window (document self)))));----------------------------------------------------------------------------------(defclass document-link (link)  ((document-string :initform nil                    :accessor document-string                    :initarg :document-string)   (label-string :initform nil                 :accessor label-string                 :initarg :label-string)))(defmethod jump ((self document-link))  (show-document *the-librarian* (document-string self) (label-string self)));----------------------------------------------------------------------------------(defclass label (document-mixin save-mixin format-mixin buffer-information-mixin)  ((container :initform nil              :accessor container              :initarg :container)   (links :initform nil          :accessor links)   (identifier-string :accessor identifier-string                      :initarg :identifier-string)   ))(defmethod initialize-instance ((self label) &rest initargs)  (let* ((new-label (call-next-method))         (old-label (label-exists-p (cadr (memq :identifier-string initargs))                                    (actual-document new-label))))    (unless (load-trigger new-label)      (when old-label        (setf (links new-label) (links old-label))        (dolist (link (links old-label))          (setf (label link) new-label))        (setf (contained-labels (container old-label))              (delq old-label (contained-labels (container old-label))))        (setf (all-labels (actual-document new-label))              (delq old-label (all-labels (actual-document new-label))))        (setf (all-existing-labels *the-librarian*)              (delq old-label (all-existing-labels *the-librarian*))))      (setf (container new-label) (actual-container new-label))      (when (container new-label)        (push new-label                (contained-labels (container new-label))))      (push new-label            (all-labels (actual-document new-label))))    (push new-label (all-existing-labels *the-librarian*))))(defmethod default-label-message ((self label))  (floating-message-dialog (format nil                                   "Sorry!~%~%This link is not established yet. The corresponding label ('~A') isn't defined."                                   (identifier-string self))                           :size #@(420 130)));---------------------------------------------------------------------------------(defclass figure (save-mixin format-mixin buffer-information-mixin simple-view)  ((picture :initform nil            :accessor picture)   (caption :initform nil            :accessor caption)   (number :initform nil           :accessor number)   (container :initform nil              :accessor container)   (document :initform nil             :accessor document)   (rsrc-id :initform nil            :accessor rsrc-id            :initarg :rsrc-id)   (picture-width :initform 300                  :accessor picture-width                  :initarg :picture-width)   (picture-height :initform 100                   :accessor picture-height                   :initarg :picture-height)   (topleft :initform nil            :accessor topleft)   (bottomright :initform nil                :accessor bottomright)   (h-pos :initform nil          :accessor h-pos)   ))(defmethod copy ((self figure))  (with-slots (picture) self    (if (handlep picture)      (progn        (put-scrap :pict (copy-PICT picture)))      (ed-beep))))(defmethod get-PICT-picture ((self figure) picture-filename)  (without-interrupts    (with-slots (picture) self     (if (and picture              (handlep picture))       picture       (setf picture              (or (and picture-filename                      (eq picture-filename (source-file (document self)))                      (get-resource-from-file picture-filename                                               "PICT"                                               (rsrc-id self)                                               :detached-p t))                 (and picture-filename                      (eq picture-filename (destination-file (document self)))                      (get-resource-from-file picture-filename                                               "PICT"                                               (rsrc-id self)                                               :detached-p nil))                 (and (source-window (document self))                      (pict-archive (source-window (document self)))                      (let ((pict-in-archive-view                              (find-if #'(lambda (pict)                                          (typecase pict                                            (shrinked-pict                                              (eq (slot-value pict 'rsrc-id) (rsrc-id self)))                                            (expanded-pict                                              (eq (slot-value (shrinked-pict pict) 'rsrc-id) (rsrc-id self)))))                                      (all-picts (pict-archive (source-window (document self)))))))                        (when pict-in-archive-view                          (copy-pict (slot-value pict-in-archive-view 'rsrc-handle)))))                 (and (eq picture-filename (destination-file (document self)))                      (get-resource-from-file (source-file (document self))                                              "PICT"                                               (rsrc-id self)                                               :detached-p t))))))))                                            ;---------------------------------------------------------------------------------(defclass example (document-mixin save-mixin format-mixin buffer-information-mixin)  ((caption :initform nil            :accessor caption)   (number :initform nil           :accessor number)   (container :initform nil              :accessor container)   ));---------------------------------------------------------------------------------;---------------------------------------------------------------------------------(defun insert-blanklines (self buffer position &optional (number 1))  "inserts <number> of newline-characters in <buffer>. Returns the new buffer-position"  (dotimes (i number)    (insert-newline self buffer position))  (+ position number))(defun insert-blanklines-and-indent (self buffer position &optional (number 1))  "inserts <number> of newline-characters in <buffer> and indents to leftmargin.     Returns the new buffer-position"  (fill-to-leftmargin self buffer                       (insert-blanklines self buffer position                                          (max (- number                                                 (do ((count 0 (1- count))                                                      (empty-p (empty-line-p buffer position 0)                                                               (empty-line-p buffer position count)))                                                     ((null empty-p) (- count))))                                              1))))(defun actual-line-height (self)  (multiple-value-bind (a d w l) (font-info (actual-font self))    (declare (ignore w l))    (+ a d)))(defun default-line-height (self)  (multiple-value-bind (a d w l) (font-info (default-font self))    (declare (ignore w l))    (+ a d)))(defun insert-blankspace (self buffer position space)  (with-slots (cursor-v-position) self    (do ((end-v-position (+ cursor-v-position space ))         (pos position (1+ pos)))        ((> cursor-v-position end-v-position) pos)      (insert-blanklines self buffer pos))))(defun insert-paragraph-if-necessary (document source-buffer begin-of-command                                                     destination-buffer destination-position)  (multiple-value-bind (begin-selection end-selection) (selection-range (source-window document))    (if (and (begin-of-line-p source-buffer begin-of-command)             (empty-line-p source-buffer begin-of-command -1)             (or (= begin-selection end-selection)                 (< begin-selection                    (buffer-line-start source-buffer begin-of-command))))      (insert-blanklines-and-indent document destination-buffer destination-position 2)      destination-position)))                        (defun delimiter-position (buffer start end &optional (delimiter-char #\|))  (or (buffer-char-pos buffer delimiter-char                       :start start                       :end end)      end))(defun empty-line-p (buffer position &optional (count 0))  (multiple-value-bind (start out-of-range-p) (buffer-line-start buffer position count)    (unless out-of-range-p      (not (buffer-not-char-pos buffer #\space                                 :start start                                :end (buffer-line-end buffer position count))))))(defun begin-of-line-p (buffer position &optional (count 0))  (let ((begin-of-line (buffer-line-start buffer position count)))    (or (= begin-of-line position)        (not (buffer-not-char-pos buffer #\space                                   :start (buffer-line-start buffer position count)                                   :end position)))))(defun str-to-lis (str)  (with-input-from-string (stream str)    (do ((el (read stream nil 'eof)             (read stream nil 'eof))         (lis))        ((eq el 'eof) (nreverse lis))      (push el lis))))(defun get-identifier-string (buffer start end)  (let* ((identifier-start (or (buffer-char-pos buffer #\"                                                 :start start                                                :end end)                               (let ((first-non-char-pos (buffer-not-char-pos buffer #\space                                                                               :start start                                                                              :end end)))                                 (if first-non-char-pos                                   (1- first-non-char-pos)                                   (1- start)))))         (identifier-end (or (buffer-char-pos buffer #\"                                               :start (1+ identifier-start)                                              :end end)                             (let ((last-non-char-pos (buffer-not-char-pos buffer #\space                                                                            :start start                                                                           :end end                                                                           :from-end t)))                               (if last-non-char-pos                                 (1+ last-non-char-pos)                                 start)))))    (values (buffer-substring buffer (1+ identifier-start) identifier-end)            (1+ identifier-start)            identifier-end)))        (defun set-actual-font (self buffer from to)  (multiple-value-bind (font-face mode-size) (font-codes (actual-font self))    (buffer-set-font-codes buffer                            font-face                           mode-size                           from                           to)))(defun is-defined-command (command-string)  (find command-string '("chapter" "section" "subsection" "subsubsection"                         "label" "link" "document-link" "application-link"                         "figure" "example" "end-example" "index"                          "item" "end-item" "verbatim"                          "@" "leftindent" "rightindent")        :test #'string-equal))   (defun label-exists-p (identifier-string document)  (do ((labels (all-existing-labels *the-librarian*) (cdr labels)))      ((null labels) nil)    (when (and (string-equal (identifier-string (car labels))                             identifier-string)               (eq (document (car labels))                   document))      (return (car labels)))))(defun index-exists-p (index-entry-string document)  (find index-entry-string (index-entries document) :test #'string-equal :key #'index-entry))(defun get-document (thing)  (cond ((typep thing 'chapter)         (document thing))        ((typep thing 'section)         (document (chapter thing)))        ((typep thing 'subsection)         (document (chapter (section thing))))        ((typep thing 'subsubsection)         (document (chapter (section (subsection thing)))))))(defun command-positions (buffer command start-position end-position)  (let* ((end-of-search (min (+ start-position (maximum-length (get-command command)))                              (1+ end-position)))         (begin-of-command (buffer-char-pos buffer #\@                                             :start (max (- start-position 20) 0)                                            :end start-position                                            :from-end t))         (begin-of-argument-list (or (buffer-char-pos buffer #\{                                                       :start start-position                                                      :end end-of-search)                                     -1))         (end-of-argument-list (or (buffer-char-pos buffer #\}                                                     :start (1+ begin-of-argument-list)                                                    :end end-of-search)                                   -1)))    (if (or (= begin-of-argument-list -1)            (= end-of-argument-list -1)            (> begin-of-argument-list end-of-argument-list))      (progn (with-cursor *arrow-cursor*               (message-dialog (format nil                                       (if (= begin-of-argument-list -1)                                         "Sorry!~%~%The {-sign of the ~A command can't be found."                                         "Sorry!~%~%The }-sign of the ~A command can't be found.")                                       command)                               :size #@(350 100)))             (when (source-window *actual-document*)               (let ((fred (real-fred (fred-window (source-window *actual-document*)))))                 (window-select (source-window *actual-document*))                 (collapse-selection fred nil)                 (fred-update fred)                 (scroll-to-position fred begin-of-command)                 (set-selection-range fred begin-of-command start-position)                 (fred-update fred)))             'aborted)      (values begin-of-command               begin-of-argument-list               end-of-argument-list))))(defun get-and-proof-command (buffer command start-position end-position)  (multiple-value-bind (begin-of-command begin-of-args end-of-args)                        (command-positions buffer command start-position end-position)    (let ((arg-list (and (neq begin-of-command 'aborted)                         (get-and-proof-arguments (get-command command)                                                   buffer (1+ begin-of-args) end-of-args))))      (if (or (eq begin-of-command 'aborted)              (eq arg-list 'aborted))        'aborted        (values begin-of-command end-of-args arg-list)))))(defun document-part-lessp (part-1 part-2)  (cond ((< (car part-1) (car part-2)) t)        ((> (car part-1) (car part-2)) nil)        ((and (null (cadr part-1))              (cadr part-2)) t)        ((and (null (cadr part-2))              (cadr part-1)) nil)        ((and (null (cadr part-1))              (null (cadr part-2)) nil))        ((< (cadr part-1) (cadr part-2)) t)        ((> (cadr part-1) (cadr part-2)) nil)        ((and (null (caddr part-1))              (caddr part-2)) t)        ((and (null (caddr part-2))              (caddr part-1)) nil)        ((and (null (caddr part-1))              (null (caddr part-2))) nil)        ((< (caddr part-1) (caddr part-2)) t)        ((> (caddr part-1) (caddr part-2)) nil)        ((and (null (cadddr part-1))              (caddr part-2)) t)        ((and (null (cadddr part-2))              (caddr part-1)) nil)        ((and (null (cadddr part-1))              (null (cadddr part-2)) nil))        ((< (cadddr part-1) (cadddr part-2)) t)        ((> (cadddr part-1) (cadddr part-2)) nil)))(defmethod show-progress-report (view  status goal )  (when (window-shown-p (view-window view))    (with-pen (:PatCopy               *light-gray-pattern*                (round (* (point-h (view-size view))                         (/ status goal)))               (point-v (view-size view))               view)      (move-to view 0 0)      (line-to view 0 0))))                    ;------------------------------------------------------------------------------------;------------------------------------------------------------------------------------(defgeneric update-actuals (self source-begin format-begin)    (:method ((self chapter) source-begin format-begin)           (with-slots (actual-chapter actual-section actual-subsection actual-subsubsection) self             (when actual-chapter               (with-slots (source-end-position format-end-position) actual-chapter                  (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-chapter self)             (when actual-section               (with-slots (source-end-position format-end-position) actual-section                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-section nil)             (when actual-subsection               (with-slots (source-end-position format-end-position) actual-subsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsection nil)             (when actual-subsubsection               (with-slots (source-end-position format-end-position) actual-subsubsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsubsection nil)))    (:method ((self section) source-begin format-begin)           (with-slots (actual-section actual-subsection actual-subsubsection) self             (when actual-section               (with-slots (source-end-position format-end-position) actual-section                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-section self)             (when actual-subsection               (with-slots (source-end-position format-end-position) actual-subsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsection nil)             (when actual-subsubsection               (with-slots (source-end-position format-end-position) actual-subsubsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsubsection nil)))    (:method ((self subsection) source-begin format-begin)           (with-slots (actual-subsection actual-subsubsection) self             (when actual-subsection               (with-slots (source-end-position format-end-position) actual-subsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsection self)             (when actual-subsubsection               (with-slots (source-end-position format-end-position) actual-subsubsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsubsection nil)))    (:method ((self subsubsection) source-begin format-begin)           (with-slots (actual-subsubsection) self             (when actual-subsubsection               (with-slots (source-end-position format-end-position) actual-subsubsection                 (setf source-end-position source-begin)                 (setf format-end-position format-begin)))             (setf actual-subsubsection self)))    )              (defgeneric format-title (self source-buffer arglist destination-buffer destination-position)    (:method ((self chapter) source-buffer arglist destination-buffer destination-position)           (let ((formatted-title-start                   (insert-blanklines-and-indent self destination-buffer destination-position 3))                 (title-number-string (format nil "~A. " (car (number self)))))             (with-font ((chapter-font self) self)               (setf (format-start-position self) formatted-title-start)               (buffer-insert destination-buffer title-number-string formatted-title-start)               (setf destination-position                     (format-standard-text self                                           source-buffer (cadar arglist) (cddar arglist)                                           destination-buffer                                           (+ formatted-title-start                                               (length title-number-string))))               (set-actual-font self destination-buffer                                 formatted-title-start destination-position))             (insert-blanklines-and-indent self destination-buffer destination-position 2)))    (:method ((self section) source-buffer arglist destination-buffer destination-position)           (let ((formatted-title-start                   (insert-blanklines-and-indent self destination-buffer destination-position 3))                 (title-number-string (format nil "~{~A.~} " (number self))))             (with-font ((section-font self) self)               (setf (format-start-position self) formatted-title-start)               (buffer-insert destination-buffer title-number-string formatted-title-start)               (setf destination-position                     (format-standard-text self                                           source-buffer (cadar arglist) (cddar arglist)                                           destination-buffer                                           (+ formatted-title-start                                               (length title-number-string))))               (set-actual-font self destination-buffer                                 formatted-title-start destination-position))             (insert-blanklines-and-indent self destination-buffer destination-position 2)))    (:method ((self subsection) source-buffer arglist destination-buffer destination-position)           (let ((formatted-title-start                   (insert-blanklines-and-indent self destination-buffer destination-position 3))                 (title-number-string (format nil "~{~A.~} " (number self))))             (with-font ((section-font self) self)               (setf (format-start-position self) formatted-title-start)               (buffer-insert destination-buffer title-number-string formatted-title-start)               (setf destination-position                     (format-standard-text self                                           source-buffer (cadar arglist) (cddar arglist)                                           destination-buffer                                           (+ formatted-title-start                                               (length title-number-string))))               (set-actual-font self destination-buffer                                 formatted-title-start destination-position))             (insert-blanklines-and-indent self destination-buffer destination-position 2)))    (:method ((self subsubsection) source-buffer arglist destination-buffer destination-position)           (let ((formatted-title-start                   (insert-blanklines-and-indent self destination-buffer destination-position 2))                 (title-number-string                   (if (= (car (number self)) 0)                    ""                    (format nil "~{~A.~} " (number self)))))             (with-font ((section-font self) self)               (setf (format-start-position self) formatted-title-start)               (buffer-insert destination-buffer title-number-string formatted-title-start)               (setf destination-position                     (format-standard-text self                                           source-buffer (cadar arglist) (cddar arglist)                                           destination-buffer                                           (+ formatted-title-start                                               (length title-number-string))))               (set-actual-font self destination-buffer                                 formatted-title-start destination-position))             (insert-blanklines-and-indent self destination-buffer destination-position 1)))    (:method ((self link) source-buffer arglist destination-buffer destination-position)           (with-font ((italic-font self) self)             (let* ((formatted-title-start destination-position)                    (identifier-string (caadr arglist))                    (label (or (label-exists-p identifier-string (actual-document self))                               (make-instance 'label                                 :identifier-string identifier-string                                 :document (actual-document self)))))               (setf (label self) label)               (push self (links label))               (setf destination-position                     (format-standard-text self source-buffer                                            (cadar arglist) (cddar arglist)                                           destination-buffer formatted-title-start))               (setf destination-position                     (simple-buffer-insert self destination-buffer "  " destination-position))               (setf (format-start-position self) (skip-wsp destination-buffer formatted-title-start))               (setf (format-end-position self) (1- destination-position))               (set-actual-font self destination-buffer                                formatted-title-start destination-position)))           destination-position)    (:method ((self document-link) source-buffer arglist destination-buffer destination-position)           (with-font ((italic-font self) self)             (with-slots (format-start-position format-end-position) self               (let ((formatted-title-start destination-position))                 (setf destination-position                       (format-standard-text self source-buffer                                              (cadar arglist) (cddar arglist)                                             destination-buffer formatted-title-start))                 (setf destination-position                       (simple-buffer-insert self destination-buffer "  " destination-position))                 (setf format-start-position (skip-wsp destination-buffer formatted-title-start))                 (setf format-end-position  (1- destination-position))                 (set-actual-font self destination-buffer                                  formatted-title-start destination-position))))           destination-position)    (:method ((self application-link) source-buffer arglist destination-buffer destination-position)           (with-font ((italic-font self) self)             (let* ((formatted-title-start destination-position)                    (identifier-string (caadr arglist))                    (label (or (application-label-exists-p identifier-string)                               (make-instance 'application-label                                 :identifier-string identifier-string))))               (setf (label self) label)               (push self (links label))               (setf destination-position                     (format-standard-text self source-buffer                                            (cadar arglist) (cddar arglist)                                           destination-buffer formatted-title-start))               (setf destination-position                     (simple-buffer-insert self destination-buffer "  " destination-position))               (setf (format-start-position self) (skip-wsp destination-buffer formatted-title-start))               (setf (format-end-position self) (1- destination-position))               (set-actual-font self destination-buffer                                formatted-title-start destination-position)))           destination-position)    (:method ((self example) source-buffer arglist destination-buffer destination-position)           (let* ((caption-string  (car (first arglist)))                  (actual-container (actual-container self)))             (with-slots (format-start-position  caption container number cursor-h-position                                                 actual-chapter actual-document actual-example document leftmargin rightmargin) self               (push self (examples actual-document))               (when actual-container                 (push self (contained-examples actual-container)))               (when actual-chapter                 (pushnew self (contained-examples actual-chapter)))               (setf caption caption-string)               (setf container actual-container)               (setf number (if actual-chapter                              (list (car (number actual-chapter))                                     (length (contained-examples actual-chapter)))                              (list 0 (length (examples actual-document)))))               (setf document actual-document)               (setf actual-example self)               (setf destination-position                      (if (and (empty-line-p destination-buffer destination-position)                              (empty-line-p destination-buffer destination-position -1))                       (fill-to-leftmargin self destination-buffer  destination-position)                       (insert-blanklines-and-indent self destination-buffer destination-position                                                     (if (empty-line-p destination-buffer destination-position)                                                       1                                                       2))))               (setf format-start-position destination-position)               (let* ((example-text (format nil                                             "Example ~S.~S "                                            (car number)                                            (cadr number)))                      (example-text-length (length example-text)))                 (with-font ((bold-font self) self)                   (buffer-insert destination-buffer example-text destination-position)                   (setf cursor-h-position (+ cursor-h-position (string-width example-text (bold-font self))))                   (set-actual-font self destination-buffer destination-position                                     (+ destination-position example-text-length)))                 (setf destination-position (+ destination-position example-text-length))                 ; (insert-blanklines-and-indent self destination-buffer (+ destination-position example-text-length)))                 (let ((new-destination-pos (format-standard-text self source-buffer                                                                   (cadar arglist) (cddar arglist)                                                                  destination-buffer destination-position)))                   (with-font ((italic-font self) self)                     (set-actual-font self destination-buffer destination-position new-destination-pos))                   (setf leftmargin (+ leftmargin 28))                   (setf rightmargin (+ rightmargin 28))                   (insert-blanklines-and-indent self destination-buffer new-destination-pos))))))    (:method ((self figure) source-buffer arglist destination-buffer destination-position)           (declare (ignore source-buffer))           (let* ((caption-string  (car (first arglist)))                  (pict-id (car (second arglist)))                  (width (car (third arglist)))                  (height (car (fourth arglist)))                  (actual-container (actual-container self)))             (with-slots (format-start-position format-end-position caption container number                                                rsrc-id picture-width picture-height actual-document                                                 actual-chapter document) self               (push self (figures actual-document))               (when actual-container                 (push self (contained-figures actual-container)))               (when actual-chapter                 (pushnew self (contained-figures actual-chapter)))               (setf rsrc-id pict-id)               (setf caption caption-string)               (setf container actual-container)               (setf number (if actual-chapter                              (list (car (number actual-chapter))                                     (length (contained-figures actual-chapter)))                              (list 0 (length (figures actual-document)))))               (setf document actual-document)               (setf picture-width width)               (setf picture-height height)               (setf destination-position                     (insert-blanklines self destination-buffer destination-position 1))               (setf format-start-position destination-position)               (setf destination-position                     (insert-blankspace self destination-buffer destination-position picture-height))               (setf format-end-position destination-position)               (setf destination-position                     (insert-blanklines-and-indent self destination-buffer destination-position 1))               (let* ((figure-text (format nil                                            "Figure ~S.~S "                                           (car number) (cadr number)))                      (figure-text-length (length figure-text))                      (caption-length (length caption-string)))                 (with-font ((bold-font self) self)                   (buffer-insert destination-buffer figure-text destination-position)                   (set-actual-font self destination-buffer destination-position                                     (+ destination-position figure-text-length)))                 (with-font ((italic-font self) self)                   (buffer-insert destination-buffer caption-string                                   (+ destination-position figure-text-length))                   (set-actual-font self destination-buffer                                      (+ destination-position figure-text-length)                                    (+ destination-position figure-text-length caption-length)))                 (setf destination-position                        (+ destination-position figure-text-length caption-length)))               (insert-blanklines-and-indent self destination-buffer destination-position 2))))    )(defgeneric  format-text (self source-buffer source-position end-position                                 destination-buffer destination-position)    (:method ((self document) source-buffer source-position end-position            destination-buffer destination-position)           (setf destination-position                 (fill-to-leftmargin self destination-buffer destination-position))           (when (source-window self)             (set-dialog-item-text (mouse-documentation-line (source-window self)) " ")             (view-draw-contents (mouse-documentation-line (source-window self))))           (do ((from-pos source-position)                 (mdl (when (source-window self)                       (mouse-documentation-line (source-window self))))                (typesetter (when (librarian-window *the-librarian*)                              (view-named :typesetter (librarian-window *the-librarian*))))                (characters-to-format (- end-position source-position))                (to-pos (min (or (buffer-char-pos source-buffer #\@ :start source-position)                                 end-position)                             end-position)                        (min (or (buffer-char-pos source-buffer #\@ :start from-pos)                                 end-position)                             end-position))                (*old-percentage* 0))               ((>= to-pos end-position)                (setf destination-position                      (format-standard-text self source-buffer from-pos to-pos                                            destination-buffer destination-position))                (when mdl                  (show-progress-report mdl (- to-pos source-position)                                        characters-to-format))                (when typesetter                  (show-progress-report typesetter characters-to-format                                        characters-to-format)                  (setf (hilited typesetter) nil))                (values end-position                        destination-position))             (declare (special *old-percentage*))             (setf destination-position                   (format-standard-text self source-buffer from-pos (1- to-pos)                                         destination-buffer destination-position))             (multiple-value-bind (class new-pos) (next-word source-buffer (1+ to-pos))               (cond ((is-defined-command class)                      (multiple-value-bind (new-source-pos new-dest-pos)                                           (format-text (without-interrupts                                                          (let ((current-package (package-name *package*)))                                                           (in-package :oou)                                                           (prog1 (read-from-string class)                                                             (eval `(in-package ,current-package)))))                                                        source-buffer new-pos  end-position                                                         destination-buffer destination-position)                        (setf from-pos new-source-pos)                        (setf destination-position new-dest-pos)))                     (t                      (format (log-stream self)                              "~%The command @~A is not defined."                              class)                      (setf from-pos (1+ to-pos)))))             (when mdl               (show-progress-report mdl (- to-pos source-position) characters-to-format))             (when typesetter               (show-progress-report typesetter (- to-pos source-position) characters-to-format))))    (:method ((self (eql 'chapter)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'chapter source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-chapter (make-instance 'chapter                                    :title (caar arg-list)                                    :source-start-position begin-of-command)))                 (update-actuals new-chapter begin-of-command destination-position)                 (values (skip-wsp source-buffer (1+ end-of-args))                         (format-title new-chapter source-buffer arg-list                                        destination-buffer destination-position))))))    (:method ((self (eql 'section)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'section source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-section (make-instance 'section                                    :title (caar arg-list)                                    :source-start-position begin-of-command)))                 (update-actuals new-section begin-of-command destination-position)                 (values (skip-wsp source-buffer (1+ end-of-args))                         (format-title new-section source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'subsection)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'subsection source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-subsection (make-instance 'subsection                                       :title (caar arg-list)                                       :source-start-position begin-of-command)))                 (update-actuals new-subsection begin-of-command destination-position)                 (values (skip-wsp source-buffer (1+ end-of-args))                         (format-title new-subsection source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'subsubsection)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'subsubsection source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-subsubsection (make-instance 'subsubsection                                          :title (caar arg-list)                                          :source-start-position begin-of-command)))                 (update-actuals new-subsubsection begin-of-command destination-position)                 (values (skip-wsp source-buffer (1+ end-of-args))                         (format-title new-subsubsection source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'link)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'link source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-link (make-instance 'link                                 :identifier-string (caar arg-list)                                 :source-start-position begin-of-command                                 :source-end-position (1+ end-of-args))))                 (setf destination-position                       (insert-paragraph-if-necessary *actual-document*                                                       source-buffer begin-of-command                                                       destination-buffer destination-position))                 (values (1+ end-of-args)                         (format-title new-link source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'document-link)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'document-link source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-link (make-instance 'document-link                                 :identifier-string (caar arg-list)                                 :document-string (caadr arg-list)                                 :label-string (caaddr arg-list)                                 :source-start-position begin-of-command                                 :source-end-position (1+ end-of-args))))                 (setf destination-position                       (insert-paragraph-if-necessary *actual-document*                                                       source-buffer begin-of-command                                                       destination-buffer destination-position))                 (values (1+ end-of-args)                         (format-title new-link source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'application-link)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'application-link source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-link (make-instance 'application-link                                 :identifier-string (caar arg-list)                                 :source-start-position begin-of-command                                 :source-end-position (1+ end-of-args))))                 (setf destination-position                       (insert-paragraph-if-necessary *actual-document*                                                       source-buffer begin-of-command                                                       destination-buffer destination-position))                 (values (1+ end-of-args)                         (format-title new-link source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'figure)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'figure source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-figure (make-instance 'figure                                   :source-start-position begin-of-command                                   :source-end-position (1+ end-of-args))))                 (values (skip-wsp source-buffer (1+ end-of-args))                         (format-title new-figure source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'example)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'example source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (let ((new-example (make-instance 'example                                    :source-start-position begin-of-command)))                 (values (skip-wsp source-buffer (1+ end-of-args))                         (format-title new-example source-buffer arg-list destination-buffer destination-position))))))    (:method ((self (eql 'label)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'label source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (progn                  (setf destination-position                       (insert-paragraph-if-necessary *actual-document*                                                       source-buffer begin-of-command                                                       destination-buffer destination-position))                 (make-instance 'label                   :identifier-string (caar arg-list)                   :source-start-position begin-of-command                   :source-end-position (1+ end-of-args)                   :format-start-position destination-position                   :format-end-position destination-position)                 (values (1+ end-of-args)                         destination-position)))))    (:method ((self (eql 'index)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'index source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (progn (setf destination-position                            (insert-paragraph-if-necessary *actual-document*                                                            source-buffer begin-of-command                                                            destination-buffer destination-position))                       (let ((new-index (make-instance 'index                                         :index-entry (caar arg-list)                                         :container (actual-container *actual-document*)                                         :format-start-position destination-position                                         :format-end-position destination-position                                         :source-start-position begin-of-command                                         :source-end-position end-of-args)))                        (pushnew new-index (index-entries *actual-document*))                        (values (1+ end-of-args)                                destination-position))))))    (:method ((self (eql 'leftindent)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'leftindent source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (with-slots (leftmargin) *actual-document*                 (setf destination-position                       (insert-paragraph-if-necessary *actual-document*                                                       source-buffer begin-of-command                                                       destination-buffer destination-position))                 (setf leftmargin (+ leftmargin (caar arg-list)))                 (setf destination-position                       (fill-to-leftmargin *actual-document* destination-buffer                                            destination-position))                 (values (1+ end-of-args)                         destination-position)))))    (:method ((self (eql 'rightindent)) source-buffer source-position end-position            destination-buffer destination-position)           (multiple-value-bind (begin-of-command end-of-args arg-list)                                 (get-and-proof-command source-buffer 'rightindent source-position end-position)             (if (eq begin-of-command 'aborted)               (values end-position destination-position)               (with-slots (rightmargin) *actual-document*                 (setf destination-position                       (insert-paragraph-if-necessary *actual-document*                                                       source-buffer begin-of-command                                                       destination-buffer destination-position))                 (setf rightmargin (+ rightmargin (caar arg-list)))                 (values (1+ end-of-args)                         destination-position)))))    (:method ((self (eql 'verbatim)) source-buffer source-position end-position            destination-buffer destination-position)            (setf destination-position                 (insert-paragraph-if-necessary *actual-document*                                                 source-buffer                                                (buffer-char-pos source-buffer #\@                                                                  :end source-position                                                                  :from-end t)                                                 destination-buffer destination-position))           (let* ((end-verbatim-pos (or (buffer-string-pos source-buffer "@End-Verbatim"                                                            :start source-position :end end-position)                                        end-position))                  (verbatim-text (buffer-substring source-buffer (1+ source-position) end-verbatim-pos))                  (new-destination-pos (+ destination-position (length verbatim-text)))                  (verbatim-destination-pos new-destination-pos))             (buffer-insert-substring destination-buffer verbatim-text 0 (length verbatim-text) destination-position)             (with-slots (cursor-h-position verbatim-font) *actual-document*               (with-input-from-string (stream verbatim-text)                 (do ((next-char (read-char stream nil nil)                                 (read-char stream nil nil)))                     ((null next-char))                   (if (eq next-char #\Newline)                     (progn (setf cursor-h-position 0)                            (unless (peek-char nil stream nil nil)                              (setf new-destination-pos                                    (fill-to-leftmargin *actual-document* destination-buffer new-destination-pos))))                      (setf cursor-h-position                            (+ cursor-h-position (string-width (format nil "~A" next-char) verbatim-font)))))))             (with-font ((verbatim-font *actual-document*) *actual-document*)               (set-actual-font *actual-document* destination-buffer destination-position verbatim-destination-pos))             (values (min (+ end-verbatim-pos 13) end-position)                     new-destination-pos)))    (:method ((self (eql 'item)) source-buffer source-position end-position            destination-buffer destination-position)           (declare (ignore end-position))           (with-slots (leftmargin rightmargin cursor-h-position actual-font) *actual-document*             (setf leftmargin (+ leftmargin 10))             (setf destination-position                    (if (and (empty-line-p destination-buffer destination-position)                            (empty-line-p destination-buffer destination-position -1))                     (fill-to-leftmargin *actual-document* destination-buffer  destination-position)                     (insert-blanklines-and-indent *actual-document* destination-buffer destination-position                                                   (if (empty-line-p destination-buffer destination-position)                                                     1                                                     2))))             (buffer-insert destination-buffer #\245 destination-position)             (setf cursor-h-position (+ cursor-h-position (string-width (make-string 1 :initial-element #\245) actual-font)))             (setf leftmargin (+ leftmargin 18))             (setf destination-position                    (fill-to-leftmargin *actual-document* destination-buffer  (1+ destination-position)))             (setf rightmargin (+ rightmargin 28))             (values (skip-wsp source-buffer source-position)                     destination-position)))    (:method ((self (eql 'end-item)) source-buffer source-position end-position            destination-buffer destination-position)           (declare (ignore end-position))           (with-slots (leftmargin rightmargin) *actual-document*             (setf leftmargin (- leftmargin 28))             (setf rightmargin (- rightmargin 28))             (setf destination-position                   (insert-blanklines-and-indent *actual-document* destination-buffer destination-position 2))             (values (skip-wsp source-buffer source-position)                     destination-position)))    (:method ((self (eql 'end-example)) source-buffer source-position end-position            destination-buffer destination-position)           (declare (ignore end-position))           (with-slots (leftmargin rightmargin window-width actual-font) *actual-document*             (let ((correct-leftmargin (- leftmargin 28)))               (setf leftmargin (- window-width rightmargin (string-width (make-string 1 :initial-element #\327) actual-font)))               (setf destination-position                     (fill-to-leftmargin *actual-document* destination-buffer destination-position))               (buffer-insert destination-buffer #\327 destination-position)               (setf leftmargin correct-leftmargin)               (setf rightmargin (- rightmargin 28))               (setf destination-position                     (insert-blanklines-and-indent *actual-document* destination-buffer (1+ destination-position) 2))               (setf (source-end-position (actual-example *actual-document*)) source-position)               (setf (format-end-position (actual-example *actual-document*)) destination-position)               (values (skip-wsp source-buffer source-position)                       destination-position))))    (:method ((self (eql '@)) source-buffer source-position end-position            destination-buffer destination-position)           (declare (ignore source-buffer end-position))            (buffer-insert destination-buffer "@ " destination-position)           (values source-position                   (+ destination-position 2)))      )(defmethod create-application-item ((label application-label))  (create-application-item (intern (identifier-string label) :oou)))(defmethod create-application-item (arg)  (declare (ignore arg))   nil)(defmethod find-application-item ((self application-label))  (with-slots (application-items) self    (setf application-items          (remove-if #'(lambda (item)                         (when item                           (null (wptr item))))                     application-items))    (dolist (item application-items)      (when (correct-application-item-p item self)        (return item)))))(defmethod correct-application-item-p (application-item label)  (declare (ignore application-item label))  t)          (defgeneric show (self)    (:method :before ((something standard-object))           (when (slot-exists-p something 'document)             (with-slots (document) something               (with-slots (destination-window) document                 (when destination-window                   (setf (last-position  destination-window) nil)                   (setf (dialog-item-enabled-p (back-arrow destination-window)) nil))))))    (:method ((self label))           (with-slots (container source-start-position document) self             (if source-start-position               (progn                  (when (source-window document)                   (scroll-to-position (real-fred (fred-window (source-window document)))                                       source-start-position))                 (with-slots (destination-window) document                   (when destination-window                     (setf (last-position destination-window)                           (buffer-position (fred-display-start-mark (real-fred (fred-window destination-window)))))                     (setf (dialog-item-enabled-p (back-arrow destination-window)) t)                     (scroll-to-position (real-fred (fred-window destination-window))                                         (format-start-position (or container                                                                    self))))))               (default-label-message self))))    (:method ((self index))           (with-slots (container source-start-position document) self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   (format-start-position (or container                                                              self))))))    (:method ((self link))           (with-slots (source-start-position format-start-position document) self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))    (:method ((self application-label))           (let ((application-item (find-application-item self)))             (unless application-item               (setf application-item (create-application-item self)))             (cond ((or (and (typep application-item 'simple-view)                             (view-window application-item))                        (and (typep application-item 'menu)                             (menu-installed-p application-item))                        (and (typep application-item 'menu-item)                             (or (typep (menu-item-owner application-item) 'pop-up-menu)                                 (menu-installed-p (menu-item-owner application-item)))))                    (if *top-listener*                      (eval-enqueue `(highlight ,application-item))                      (highlight application-item)))                   ((null application-item)                    (default-application-label-message self)))))    (:method ((self subsubsection))           (with-slots (document source-start-position format-start-position)  self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))    (:method ((self subsection))           (with-slots (document source-start-position format-start-position)  self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))    (:method ((self section))           (with-slots (document source-start-position format-start-position)  self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))    (:method ((self chapter))           (with-slots (document source-start-position format-start-position)  self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))    (:method ((self figure))           (with-slots (document source-start-position format-start-position)  self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))  (:method ((self example))           (with-slots (document source-start-position format-start-position)  self             (when (source-window document)               (scroll-to-position (real-fred (fred-window (source-window document)))                                   source-start-position))             (when (destination-window document)               (scroll-to-position (real-fred (fred-window (destination-window document)))                                   format-start-position))))    )                                                                                                                                                                                                                                                                                                                     