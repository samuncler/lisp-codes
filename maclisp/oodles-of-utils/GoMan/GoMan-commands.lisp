(in-package :oou)(oou-provide :GoMan-commands);*****************************************************************                                    ;; Copyright © 1991-96 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; the available formmatting commands of GoMan; ;; Changes (worth to be mentioned):; ------------------------------; none ;;*****************************************************************;*****************************************************************(export '())(oou-dependencies :QuickDraw-u                              :unibas-macros                              :unibas-cursors                              :GoMan-macros                              );--------------------------------------------------------------------------(defclass command ()   ((name :initform nil               :accessor name               :initarg :name)     (command-key :initform nil                             :accessor command-key                             :initarg :command-key)     (number-of-arguments :initform 1                                          :accessor number-of-aguments                                          :initarg :number-of-arguments)     (argument-types :initform nil                                :accessor argument-types                                :initarg :argument-types)     (maximum-length :initform 100                                  :accessor maximum-length                                  :initarg :maximum-length)     (first-part-of-template :initform ""                                            :accessor first-part-of-template                                            :initarg :first-part-of-template)     (second-part-of-template :initform ""                                               :accessor second-part-of-template                                               :initarg :second-part-of-template)     (insertion-point :initform 0                                 :accessor insertion-point                                 :initarg :insertion-point)     ))(defmethod initialize-instance :after ((self command) &rest initargs)   (declare (ignore initargs))   (push self *all-commands*))(defmethod get-and-proof-arguments ((self command) buffer start-position end-position)   (with-slots (number-of-arguments argument-types) self       (let ((argument-list nil)               (start-pos (min start-position end-position)))          (setf argument-list                   (dotimes (arg-number number-of-arguments (nreverse argument-list))                      (let ((delimiter-pos (delimiter-position buffer start-pos end-position)))                         (push                            (multiple-value-bind (arg-string begin-of-arg end-of-arg)                                                              (get-identifier-string buffer start-pos (max delimiter-pos start-pos))                               (if (and (eq (nth arg-number argument-types)                                                  'number)                                            (not (string= arg-string "|")))                                  (let ((num (read-from-string arg-string nil)))                                     (when (and (numberp num)                                                       (/= start-pos (1- delimiter-pos)))                                         (list* num begin-of-arg end-of-arg)))                                  (list* arg-string begin-of-arg end-of-arg)))                           argument-list)                         (setf start-pos (min (1+ delimiter-pos) (1- end-position))))))          (if (or (member nil argument-list :key #'car)                     (member "" argument-list :key #'car :test #'(lambda (arg1 arg2)                                                                                            (and (stringp arg2)                                                                                                    (string= arg1 arg2))))                     (member " " argument-list :key #'car :test #'(lambda (arg1 arg2)                                                                                             (and (stringp arg2)                                                                                                     (string= arg1 arg2))))                     (member "}" argument-list :key #'car :test #'(lambda (arg1 arg2)                                                                                             (and (stringp arg2)                                                                                                     (string= arg1 arg2))))                     (member "|" argument-list :key #'car :test #'(lambda (arg1 arg2)                                                                                             (and (stringp arg2)                                                                                                     (string= arg1 arg2)))))             (progn                 (with-cursor *arrow-cursor*                    (message-dialog (format nil "Sorry!~%~%There ~[is~:;are~] ~1D argument~P needed to perform the ~A command. ~[It~:;Some of them~] can't be found or can't be interpreted as a number."                                                            (1- number-of-arguments)                                                            number-of-arguments                                                            number-of-arguments                                                            (name self)                                                            (1- number-of-arguments))                                               :size #@(400 150)))                (when (source-window *actual-document*)                    (let ((real-fred (real-fred (fred-window (source-window *actual-document*)))))                       (window-select (source-window *actual-document*))                       (collapse-selection real-fred nil)                       (fred-update real-fred)                       (scroll-to-position real-fred start-position)                       (set-selection-range real-fred start-position end-position)                       (fred-update real-fred)))                'aborted)             argument-list))))(defmethod insert ((self command) window &optional (pos (buffer-position (fred-buffer window))))   (multiple-value-bind (start-selection end-selection) (selection-range window)       (if (/= start-selection end-selection)          (insert-around-selection self window start-selection end-selection)          (insert-without-selection self window pos))       (fred-update window)))(defmethod insert-around-selection ((comm command) window start-selection end-selection)   (let ((buffer (fred-buffer window)))      (buffer-insert buffer (second-part-of-template comm) end-selection)      (buffer-insert buffer (first-part-of-template comm) start-selection)      (set-mark buffer (+ start-selection (insertion-point comm)))))(defmethod insert-without-selection ((comm command) window pos)   (let ((buffer (fred-buffer window)))      (buffer-insert buffer (second-part-of-template comm) pos)      (buffer-insert buffer (first-part-of-template comm) pos)      (set-mark buffer (+ pos (insertion-point comm)))))                         (defun get-command (name-string)   (find name-string *all-commands* :test #'(lambda (str cmd-ob)                                                                         (eq str (name cmd-ob)))))(defun make-commands ()   (setf *all-commands* nil)   (make-instance 'command                              :name 'chapter                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@Chapter{"                             :second-part-of-template "}"                             :insertion-point 10)   (make-instance 'command                              :name 'section                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@Section{"                             :second-part-of-template "}"                             :insertion-point 10)   (make-instance 'command                              :name 'subsection                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@SubSection{"                             :second-part-of-template "}"                             :insertion-point 13)   (make-instance 'command                              :name 'subsubsection                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@SubSubSection{"                             :second-part-of-template "}"                             :insertion-point 16)   (make-instance 'command                              :name 'figure                             :number-of-arguments 4                             :argument-types '(string number number number)                             :maximum-length 300                             :first-part-of-template "@Figure{ \""                             :second-part-of-template "\" | \"\" |  |  }"                             :insertion-point 11)   (make-instance 'command                              :name 'example                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@Example{"                             :second-part-of-template "}@End-Example "                             :insertion-point 10)   (make-instance 'command                              :name 'index                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@Index{"                             :second-part-of-template "}"                             :insertion-point 7)   (make-instance 'command                              :name 'label                             :number-of-arguments 1                             :argument-types '(string)                             :maximum-length 100                             :first-part-of-template "@Label{ \""                              :second-part-of-template "\" }"                             :insertion-point 9)   (make-instance 'command                              :name 'link                             :number-of-arguments 2                             :argument-types '(string string)                             :maximum-length 200                             :first-part-of-template "@Link{ \""                             :second-part-of-template "\" | \"\" }"                             :insertion-point 8)   (make-instance 'command                              :name 'document-link                             :number-of-arguments 3                             :maximum-length 300                             :argument-types '(string string string)                             :first-part-of-template "@Document-Link{ \""                             :second-part-of-template "\" | \"\" | \"\" }"                             :insertion-point 17)   (make-instance 'command                              :name 'application-link                             :number-of-arguments 2                             :maximum-length 200                             :argument-types '(string string)                             :first-part-of-template "@Application-Link{ \""                             :second-part-of-template "\" | \"\" }"                             :insertion-point 20)   (make-instance 'command                              :name 'item                             :number-of-arguments 1                             :maximum-length 500                             :argument-types '(string)                             :first-part-of-template "@Item	"                             :second-part-of-template "@End-Item "                             :insertion-point 8)   (make-instance 'command                              :name 'verbatim                             :number-of-arguments 1                             :maximum-length 500                             :argument-types '(string)                             :first-part-of-template "@Verbatim "                             :second-part-of-template "@End-Verbatim "                             :insertion-point 10)      (make-instance 'command                              :name 'leftindent                             :command-key #\L                             :number-of-arguments 1                             :maximum-length 20                             :argument-types '(number)                             :first-part-of-template "@Leftindent{"                             :second-part-of-template "}"                             :insertion-point 13)   (make-instance 'command                              :name 'rightindent                             :number-of-arguments 1                             :maximum-length 20                             :argument-types '(number)                             :first-part-of-template "@Rightindent{"                              :second-part-of-template "}"                             :insertion-point 14)   )#|(defmethod insert-around-selection ((command (eql (get-command 'item))) fred-item start end)  (let* ((buffer (fred-buffer fred-item)))    (do* ((item-start (wrap-start-position fred-item start)                      (wrap-start-position fred-item item-end))          (item-end (min (wrap-end-position fred-item start)                         end)                    (min (wrap-end-position fred-item item-start)                         end)))         ((>= item-end end)          (apply #'call-next-method command fred-item item-start item-end))      (apply #'call-next-method command fred-item item-start item-end))))|#                  