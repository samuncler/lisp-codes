(in-package :ccl)(oou::oou-provide :receive-drag)(require :quickdraw)(export '(drag-&-drop-window-mixin          tracking-handler          receive-handler          drag-reference                    drag-window-p                    drag-tracking-enter-handler		drag-tracking-leave-handler          drag-tracking-enter-view		drag-tracking-leave-view          drag-tracking-in-view                    drag-manager-present-p                    drag-attributes          drag-within-sender-application-p          drag-left-sender-window-p		drag-left-sender-view-p          drag-within-sender-window-p		drag-within-sender-view-p                    drag-item-count          drag-item-reference-number          drag-item-flavor-count          drag-item-flavor-type			drag-item-flavor-type-list          drag-item-flavor-flags          drag-item-flavor-size          drag-item-flavor-data			with-drag-item-flavor-data          drag-item-flavor-exists-p          with-drag-items                    with-new-drag          drag-add-item-flavor          drag-set-item-flavor-data          drag-selection-p          $PromisedHFSObject                    drag-receive-drag                    drag-get-drop-location          drag-get-drop-location-as-path                    view-drag-hilite          find-view-containing-global-point          drag-mouse-location          drag-mouse-view                    drag-get-modifiers                    drag-command-key-p          drag-shift-key-p          drag-control-key-p          drag-option-key-p          drag-caps-lock-key-p                    text-edit-highlight-region          create-drag-item-bounds          zoom-rectangle			zoom-rectangle-points          zoom-region                    wptr-to-drag-window          drag-window-to-wptr          drag-reference-to-window)        );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Low-level stuff....;;;(defvar *drag-&-drop-window-list* nil)(defconstant $PromisedHFSObject :|HFSp|)(defmacro oserr-check (&body body)  (let ((result (gensym)))    `(let ((,result (progn ,@body)))       (cond ((eql ,result #$userCanceledErr)              (throw-cancel ,result))             ((neq ,result #$noErr)              (error "~S" ,result)))       ,result)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; еее Low-level entries to/from Drag Manager;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; The system calls this function whenever a dragged item causes an event in a;; drag & drop window.  Following is the default version; a different routine can;; be specified with :tracking-handler argument during the window's make-instance.;;;; This default version acts as a dispatcher to predefined MCL methods, which you;; should specialize as necessary.  The methods to specialize are:;;;;    drag-tracking-enter-handler;;    drag-tracking-leave-handler;;    drag-tracking-enter-view;;    drag-tracking-leave-view;;    drag-tracking-in-view;;;; This spoofs the normal Drag Manager behavior quite a bit.  Basically, we're;; allowing window-like drag behavior from subviews in the window.;;; modified 6/2/95 Dieter - LeaveWindow called the wrong view(defpascal DragTrackingHandlerDispatch.p (:word $theMessage :ptr $theWindow :ptr $handlerRefCon                                                :long $dragReference                                                :word)  (declare (ignore $handlerRefcon))  (let ((w (wptr-to-drag-window $theWindow))        (old-ref 0))    (when w      (unwind-protect        (progn          (setf old-ref (drag-reference w)      ; save old reference and restore when completed                (slot-value w 'drag-reference) $dragReference)          (case $theMessage            (#.#$dragTrackingEnterHandler             (drag-tracking-enter-handler w))            (#.#$dragTrackingEnterWindow             (let ((v (drag-mouse-view w)))               (drag-tracking-enter-view v)               (setf (%last-view w) v)               ))            (#.#$dragTrackingInWindow             (let ((v (drag-mouse-view w)))               (unless (eq (%last-view w) v)   ; see if we're switching views and adjust if necessary                 (when (and (%last-view w)                            (wptr (%last-view w)))                   (drag-tracking-leave-view (%last-view w)))                 (when v                   (drag-tracking-enter-view v)))               (drag-tracking-in-view v)               (setf (%last-view w) v)))            (#.#$dragTrackingLeaveWindow             (let ((v (or (%last-view w)                          w)))               (when (wptr v)                 (drag-tracking-leave-view v))               (setf (%last-view w) nil)               ))            (#.#$dragTrackingLeaveHandler             (drag-tracking-leave-handler w))))        (setf (slot-value w 'drag-reference) old-ref))))  #$noErr);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; The system calls this function when an item or items are being dropped into a;; drag & drop window.  Following is the default version; a different routine can;; be specified with :receive-handler argument during the window's make-instance.;;;; Specialize the 'drag-receive-drag function for your view in order to receive;; drops from the Drag Manager.;;(defpascal DragReceiveHandlerDispatch.p (:ptr $theWindow :ptr $handlerRefCon :long $dragReference                                              :word)  (declare (ignore $handlerRefcon))  (let ((w (wptr-to-drag-window $theWindow))        (old-ref 0)        (result #$dragNotAcceptedErr))    (when w      (unwind-protect        (progn          (setf old-ref (drag-reference w)      ; save old reference and restore when completed                (slot-value w 'drag-reference) $dragReference                result (drag-receive-drag (drag-mouse-view w))))        (setf (slot-value w 'drag-reference) old-ref)))    (cond ((eql result t) (setf result #$noErr))          ((not (integerp result)) (setf result #$dragNotAcceptedErr)))    result));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass drag-&-drop-window-mixin ()  ((drag-reference :initform 0 :reader drag-reference)   (tracking-handler :initform DragTrackingHandlerDispatch.p :initarg :tracking-handler :reader tracking-handler)   (receive-handler :initform DragReceiveHandlerDispatch.p :initarg :receive-handler :reader receive-handler)   (%last-view :initform nil :accessor %last-view)   (%source-view :initform nil :accessor %source-view)   ))(defmethod initialize-instance :after ((w drag-&-drop-window-mixin) &rest initargs)  (declare (ignore initargs))  (push (cons (wptr w) w) *drag-&-drop-window-list*)  (oserr-check (#_InstallTrackingHandler (tracking-handler w) (wptr w) (%null-ptr)))  (oserr-check (#_InstallReceiveHandler (receive-handler w) (wptr w) (%null-ptr)))  )(defmethod window-close :around ((w drag-&-drop-window-mixin))  (let ((current-wptr (wptr w)))    (call-next-method)    (unless (wptr w)      ; Cleanup the window's internal data      (setf *drag-&-drop-window-list* (delete current-wptr *drag-&-drop-window-list* :key #'car))      (ignore-errors (#_DisposeDrag (drag-reference w)))      (when (tracking-handler w)        (oserr-check (#_RemoveTrackingHandler (tracking-handler w) current-wptr))        (setf (slot-value w 'tracking-handler) nil))      (when (receive-handler w)        (oserr-check (#_RemoveReceiveHandler (receive-handler w) current-wptr))        (setf (slot-value w 'receive-handler) nil)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; еее The following methods should be shadowed by the user to get actual;; еее behavior.  Note that some functions should be specialized on the window;; еее while others can go down to a view.  The argument name is an indication;; еее of which is which.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Called whenever a particular drag handler is called for the first time.;;(defmethod drag-tracking-enter-handler ((window t))  (declare (ignore window))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Called whenever a drag enters a drag & drop window or a view within the;; window.;;(defmethod drag-tracking-enter-view ((view t))  (declare (ignore view))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Called while a drag is occuring within a view within a drag & drop window.;;(defmethod drag-tracking-in-view ((view t))  (declare (ignore view))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Called whenever a drag leaves a drag & drop window or a subview.;;(defmethod drag-tracking-leave-view ((view t))  (declare (ignore view))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Called whenever a drag is exiting a particular drag handler.;;(defmethod drag-tracking-leave-handler ((window t))  (declare (ignore window))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Called when the Drag Manager is dropping something into a drag & drop window;; or subview.;;(defmethod drag-receive-drag ((view t))  (declare (ignore view))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Boolean indicating whether it's appropriate to begin a drag or not.;; Should take into account such things as hilited items, where the mouse;; is, etc..  Note that the mouse position is in global coordinates.;;(defmethod drag-selection-p ((view t) global-mouse-position)  (declare (ignore view global-mouse-position))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; еее Drag Toolkit;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Boolean indicating the presence of the Drag Manager in the current system.;;(defun drag-manager-present-p ()  (and (gestalt #$gestaltDragMgrAttr)       (logbitp #$gestaltDragMgrPresent (gestalt #$gestaltDragMgrAttr))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Provides the Drag Manager default hiliting of destination windows (drawing;; the gray border around the inside of the window's edge).  Spoofed to;; automatically perform this behavior on the view.;;; modified 5/2/95 Dieter - the view is not always a direct subview of the window(defmethod view-drag-hilite ((view simple-view) hilite-p &optional (topleft nil) (bottomright nil))  (let ((window (view-window view))        (result nil))    (if hilite-p      (let ((region (new-region)))        (unless (integerp topleft)          (setf topleft (convert-coordinates #@(0 0) view window)))        (unless (integerp bottomright)          (setf bottomright (convert-coordinates (view-size view) view window)))        (with-focused-view window          (oserr-check (#_ShowDragHilite (drag-reference window) (set-rect-region region topleft bottomright) t)))        (dispose-region region)        (setf result t))      (progn        (with-focused-view window          (oserr-check (#_HideDragHilite (drag-reference window))))))    result));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Testing to see if an MCL object or WindowRecord pointer can accept drags;;(defmethod drag-window-p ((window-or-ptr macptr))  (if (wptr-to-drag-window window-or-ptr)    t))(defmethod drag-window-p ((window-or-ptr drag-&-drop-window-mixin))  t)(defmethod drag-window-p ((window-or-ptr t))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Conversion routines;;(defmethod wptr-to-drag-window ((window-ptr macptr))  (cdr (find window-ptr *drag-&-drop-window-list* :key #'car)))(defmethod drag-window-to-wptr ((window drag-&-drop-window-mixin))  (wptr window))#|(defmethod drag-reference-to-window ((reference integer))  (cdr (find reference *drag-&-drop-window-list* :key #'(lambda (x) (drag-reference (cdr x))))))|#; Modified 12/18/94 dieter: There can be two windows with the same reference in the list(defmethod drag-reference-to-window ((reference integer))  (cdr (find reference *drag-&-drop-window-list*              :test #'(lambda (ref x)                        (and (eq (drag-reference (cdr x))                                ref)                            (%source-view (cdr x)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Obtaining the attributes of a particular drag.  General first, then;; specific predicates.;;(defmethod drag-attributes ((window drag-&-drop-window-mixin))  (rlet ((flags :DragAttributes))    (oserr-check (#_GetDragAttributes (drag-reference window) flags))    (%get-long flags)))(defmethod drag-left-sender-window-p ((window drag-&-drop-window-mixin))  (and (drag-window-p window)       (logtest #$dragHasLeftSenderWindow (drag-attributes window))))(defmethod drag-left-sender-view-p ((view simple-view))  (let ((window (view-window view)))    (and (drag-window-p window)         (or (drag-left-sender-window-p window)             (not (equal (%source-view window) (drag-mouse-view window)))))))(defmethod drag-within-sender-application-p ((window drag-&-drop-window-mixin))  (and (drag-window-p window)       (logtest #$dragInsideSenderApplication (drag-attributes window))))(defmethod drag-within-sender-window-p ((window drag-&-drop-window-mixin))  (and (drag-window-p window)       (logtest #$dragInsideSenderWindow (drag-attributes window))))(defmethod drag-within-sender-view-p ((view simple-view))  (let ((window (view-window view)))    (and (drag-within-sender-window-p window)         (equal (%source-view window) (drag-mouse-view window)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Returns the number of items in a drag;;(defmethod drag-item-count ((window drag-&-drop-window-mixin))  (rlet ((count :signed-integer))    (oserr-check (#_CountDragItems (drag-reference window) count))    (%get-word count)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Returns the drag item reference number of the nth item.;;(defmethod drag-item-reference-number ((window drag-&-drop-window-mixin) &optional (index 1))  (rlet ((item :ItemReference))    (oserr-check (#_GetDragItemReferenceNumber (drag-reference window) index item))    (%get-long item)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Returns the number of flavors in a given drag item.;;(defmethod drag-item-flavor-count ((window drag-&-drop-window-mixin) (item-reference integer))  (rlet ((count :signed-integer))    (let ((err (#_CountDragItemFlavors (drag-reference window) item-reference count)))      (if (eql err #$noErr)        (%get-word count)        0))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Obtains the flavor for a given item.;;(defmethod drag-item-flavor-type ((window drag-&-drop-window-mixin) (item-reference integer)                                  &optional (flavor-index 1))  (rlet ((flavor :ostype))    (let ((err (#_GetFlavorType (drag-reference window) item-reference flavor-index flavor)))      (if (eql err #$noErr)        (%get-ostype flavor)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Build a list of flavor types for the given drag item.  The position of types in;; the returned list is the same as the relative ordering in the actual drag item.;;(defmethod drag-item-flavor-type-list ((w drag-&-drop-window-mixin) (item-reference integer))  (let ((flavor-list nil)        (count (drag-item-flavor-count w item-reference)))    (dotimes (index count)      (push (drag-item-flavor-type w item-reference (1+ index)) flavor-list))    (reverse flavor-list)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Obtains the flavor flags for a given item.  Note that the 'flavor' argument is;; an OSType.;;(defmethod drag-item-flavor-flags ((window drag-&-drop-window-mixin) (flavor keyword)                                   (item-reference integer))  (rlet ((flags :FlavorFlags))    (let ((err (#_GetFlavorFlags (drag-reference window) item-reference flavor flags)))      (if (eql err #$noErr)        (%get-long flags)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Boolean indicating whether a particular flavor in an item is available.  Note;; that the 'flavor' argument is an OSType.;;(defmethod drag-item-flavor-exists-p ((window drag-&-drop-window-mixin) (flavor keyword)                                      (item-reference integer))  (if (drag-item-flavor-flags window flavor item-reference)    t));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Obtains the size of a particular item's flavor.  Note that the 'flavor' argument;; is an OSType.;;(defmethod drag-item-flavor-size ((window drag-&-drop-window-mixin) (flavor keyword)                                  (item-reference integer))  (rlet ((size :size))    (oserr-check (#_GetFlavorDataSize (drag-reference window) item-reference flavor size))    (%get-long size)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Obtains the data for a particular item's flavor.  Note that the 'flavor' argument;; is an OSType.  Also note that if the function succeeds (ie, it returns a pointer);; then you MUST eventually dispose of the pointer with #_DisposePtr !;;(defmethod drag-item-flavor-data ((window drag-&-drop-window-mixin) (flavor keyword)                                  (item-reference integer))  (let ((size (drag-item-flavor-size window flavor item-reference)))    (rlet ((size-ptr :integer))      (when (and (numberp size) (plusp size))        (%put-word size-ptr size)        (let ((data-ptr (#_NewPtr size)))          (oserr-check (#_GetFlavorData (drag-reference window) item-reference flavor data-ptr size-ptr 0))          data-ptr)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Easy way to work with a particular flavor of data.  Note that the 'flavor';; argument is an OSType.;;(defmacro with-drag-item-flavor-data ((data-symbol window flavor item-reference) &body body)  (let ((result (gensym)))    `(let ((,result nil)           (,data-symbol (drag-item-flavor-data ,window ,flavor ,item-reference)))       (when ,data-symbol         (unwind-protect           (setf ,result (progn ,@body))           (#_DisposePtr ,data-symbol)))       ,result)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Macro for iterating through all the items in a drag;;(defmacro with-drag-items ((ref-symbol window) &body body)  (let ((item-count (gensym)))    `(let ((,item-count (drag-item-count ,window)))       (when (plusp ,item-count)         (dotimes (counter ,item-count)           (let ((,ref-symbol (drag-item-reference-number ,window (1+ counter))))             (progn ,@body)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Setting a flavor's data (usually called from the send procedure);;(defmethod drag-set-item-flavor-data ((window drag-&-drop-window-mixin) (item-reference integer)                                      (flavor keyword) (item-ptr macptr) (item-size integer)                                      &optional (offset 0))  (oserr-check (#_SetDragItemFlavorData (drag-reference window) item-reference flavor item-ptr item-size offset))  t);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Here's where you add a flavor to a drag MCL initiates.;;(defmethod drag-add-item-flavor ((window drag-&-drop-window-mixin) (item-reference integer)                                 (flavor keyword) (item-ptr macptr) (item-size integer)                                 &optional (flags 0))  (oserr-check (#_AddDragItemFlavor (drag-reference window) item-reference flavor item-ptr item-size flags))  t);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Same as MCL's #'find-view-containing-point but assumes a global mouse location;;(defmethod find-view-containing-global-point ((view simple-view) (mouse integer))  (with-focused-view view    (find-view-containing-point view (global-to-local view mouse))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Returns the current mouse location.  This works only during a drag.;;(defmethod drag-mouse-location ((window drag-&-drop-window-mixin) &optional (local-p t))  (rlet ((mouse :point))    (oserr-check (#_GetDragMouse (drag-reference window) mouse (%null-ptr)))    (when local-p      (with-focused-view window        (#_GlobalToLocal mouse)))    (%get-long mouse)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Returns the view the mouse is currently over.  This works only during a drag.;;#|(defmethod drag-mouse-view ((window drag-&-drop-window-mixin))  (or (find-view-containing-point window (drag-mouse-location window) nil t) window))|#;modified 12/18/94 Dieter - all subviews are allowed(defmethod drag-mouse-view ((window drag-&-drop-window-mixin))  (or (find-view-containing-point window (drag-mouse-location window) nil nil) window));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Following methods return the state of various keys during a drag.  The optional;; argument 'when should be one of '(:before :now :after), which corresponds to;; key states at the beginning of a drag, during a drag and after a drop respectively.;; The default for 'when is :now.;;;; Note that this call is valid ONLY while items are being dragged around.  If;; the drag originated from within MCL this means after #_TrackDrag is called.;;(defmethod drag-get-modifiers ((view simple-view) &optional (when :now))  (rlet ((currentMods :signed-integer)         (downMods :signed-integer)         (upMods :signed-integer))    (oserr-check (#_GetDragModifiers (drag-reference (view-window view)) currentMods downMods upMods))    (case when      (:before (%get-signed-word downMods))      (:after (%get-signed-word upMods))      (t (%get-signed-word currentMods)))))(defmethod drag-command-key-p ((view simple-view) &optional (when :now))  (logtest #$CmdKey (drag-get-modifiers view when)))(defmethod drag-shift-key-p ((view simple-view) &optional (when :now))  (logtest #$shiftKey (drag-get-modifiers view when)))(defmethod drag-control-key-p ((view simple-view) &optional (when :now))  (logtest #$controlKey (drag-get-modifiers view when)))(defmethod drag-option-key-p ((view simple-view) &optional (when :now))  (logtest #$optionKey (drag-get-modifiers view when)))(defmethod drag-caps-lock-key-p ((view simple-view) &optional (when :now))  (logtest #$alphaLock (drag-get-modifiers view when)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Get the highlighted region of a TextEdit record.  If you don't supply a region;; to modify then remember to dispose of the result with #'dispose-region!;;(defmethod text-edit-highlight-region ((view simple-view) &optional (region (new-region)))  (with-focused-view view    (oserr-check (#_TEGetHiliteRgn region (dialog-item-handle view))))  region);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; zoom-rectangle;;;; This method animates a movement between two rectangles on the screen.  The;; 'zoom-steps argument specifies the number of incremental drawings between the;; source and destination rectangles, and it must be between 4 and 25 (inclusive).;; 'zoom-speed affects the distance between the incremental drawings, giving the;; effect of speeding up or slowing down during transit; use :accelerate or;; :decelerate as possible values (the default is a constant speed).;;;; Both 'source-rect and 'dest-rect must be :Rect data structure.;;(defmethod zoom-rectangle ((source-rect macptr) (dest-rect macptr) &key                           (zoom-steps 12) zoom-speed)  (let ((speed-value (case zoom-speed                       (:accelerate #$zoomAccelerate)                       (:decelerate #$zoomDecelerate)                       (t #$zoomNoAcceleration))))    (oserr-check (#_ZoomRects source-rect dest-rect zoom-steps speed-value)))  t);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; zoom-rectangle-points;;;; This is simply another way to call #'zoom-rectangle.  It uses points of the;; rectangles rather than :Rect data structures. See the comments for #'zoom-rectangle.;;(defmethod zoom-rectangle-points ((source-topleft integer) (source-bottomright integer)                                  (dest-topleft integer) (dest-bottomright integer)                                  &key (zoom-steps 12) zoom-speed)  (rlet ((source-rect :rect                      :topleft source-topleft                      :bottomright source-bottomright)         (dest-rect :rect                    :topleft dest-topleft                    :bottomright dest-bottomright))    (zoom-rectangle source-rect dest-rect :zoom-steps zoom-steps :zoom-speed zoom-speed)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; zoom-region;;;; Method provides similar animation as when Finder icons are moved during a;; "Clean Up" operation.  The 'region argument should be a valid Macintosh region;; handle.  'distance is a point specifying the distance to move the region.;; 'zoom-steps and 'zoom-speed are the same as for #'zoom-rectangle.;;(defmethod zoom-region ((region macptr) (distance integer) &key                        (zoom-steps 12) zoom-speed)  (let ((speed-value (case zoom-speed                       (:accelerate #$zoomAccelerate)                       (:decelerate #$zoomDecelerate)                       (t #$zoomNoAcceleration))))    (oserr-check (#_ZoomRegion region distance zoom-steps speed-value)))  t);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Drop location stuff;;(defmethod %resolve-alias-handle ((alias macptr))  (rlet ((fsspec :FSSpec)         (wasChanged :boolean))    (#_ResolveAlias (%null-ptr) alias fsspec wasChanged)    (let ((path (%path-from-fsspec fsspec)))      (unless (directory-pathname-p path)        (if (probe-file (format nil "~A:" path))          (setf path (make-pathname :directory (append (pathname-directory path)                                                       (list (mac-file-namestring path)))))))      path)));; A non-nil result from this function MUST be disposed via a call to #_AEDisposeDesc;(defmethod drag-get-drop-location ((window drag-&-drop-window-mixin))  (let ((drop-location (make-record :AEDesc)))    (oserr-check (#_GetDropLocation (drag-reference window) drop-location))    (if (%null-ptr-p drop-location)      (progn        (#_AEDisposeDesc drop-location)        nil)      drop-location)))(defmethod drag-get-drop-location-as-path ((window drag-&-drop-window-mixin))  (let ((result nil))    (with-aedescs (drop-location)      (oserr-check (#_GetDropLocation (drag-reference window) drop-location))      (when (and (not (%null-ptr-p drop-location))                 (not (%null-ptr-p (rref drop-location :AEDesc.dataHandle)))                 (eql (rref drop-location :AEDesc.descriptorType) #$rAliasType))        (setf result (%resolve-alias-handle (rref drop-location :AEDesc.dataHandle)))))    result));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Here's a nice little function that returns a pathname to those "special";; folders System 7 maintains.;;(defun special-folder-path (folderkey &optional (create? t))  (let ((errnum 0)        (folder-value (case folderkey                        (:systemfolder #$kSystemFolderType)                        (:extensions #$kExtensionFolderType)                        (:startupitems #$kStartupFolderType)                        (:applemenuitems #$kAppleMenuFolderType)                        (:controlpanels #$kControlPanelFolderType)                        (:preferences #$kPreferencesFolderType)                        (:temporaryitems #$kTemporaryFolderType)                        (t nil)))        (create-value (if create? #$kCreateFolder #$kDontCreateFolder)))    (when folder-value      (rlet ((foundvrefnum :signed-integer)             (founddirid :signed-long)             (filename (:string 255))             (fsspec :fsspec))        (setf errnum (#_FindFolder #$kOnSystemDisk folder-value create-value                      foundvrefnum founddirid))        (when (zerop errnum)          (%put-string filename "")          (setf errnum (#_FSMakeFSSpec (%get-word foundvrefnum)                        (%get-signed-long founddirid) filename fsspec))          (when (zerop errnum)            (make-pathname :directory (namestring (%path-from-fsspec fsspec)))))))))