(in-package :oou)(oou-provide :with-running-watch);*****************************************************************                                    ;; Copyright © 1991-95 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; macro which changes the cursor periodically during the evaluation; of a form;;  ccl::%install-periodic-task name function interval &optional flags private-data;  Install or overwrite a periodic task with the given NAME (compared;  with EQ). Will cause FUNCTION to be funcalled with no arguments once;  every INTERVAL ticks (1/60 second). Flags defaults to 0 meaning call;  your function no matter what the context. If your function does drawing;  or should not be called while event processing is being done, you;  should use one or both (logior'd together) of the following values;  for FLAGS (both are defined in "ccl:library;lispequ.lisp" so you'll;  need to (require "LISPEQU") to use them):;;  $ptask_draw-flag            Your periodic task does drawing;  $ptask_event-dispatch-flag  Your periodic task should not be called;                              during EVENT-DISPATCH.;;  private-data is stored in the mac heap part of theperiodic task record,;  but this will not be useful unless you are writing an interrupt routine;  (in LAP or with the foreign function interface) that needs to interact;  with a periodic task (I'll give details to anyone who thinks they;  need to do this).;;  ccl::%remove-periodic-task name;  Remove the periodic task with the given name.; ;; Changes (worth to be mentioned):; ------------------------------; May 95  Dieter: Code changed completly for MCL 3.0 ;;*****************************************************************;*****************************************************************;-----------------------------------------------------------------#|old version(oou-dependencies :resources-u)(export '(with-running-watch stop-watch))(defvar *all-watch-cursors*   (cons *watch-cursor*        (mapcar #'(lambda (index)                     (let ((curs (#_GetCursor index)))                       (when (%null-ptr-p curs)                          (with-res-file ("oou:Resources Stuff")                             (setf curs (#_GetCursor index))                             (#_DetachResource curs)))                       curs))                 '(6500 6501 6502 6503 6504 6505 6506))))(defvar *last-running-watch* nil)(defmacro with-running-watch (&body body)  `(let ((old-cursor *cursorhook*))     (setf *cursorhook* (or *last-running-watch*                            (car *all-watch-cursors*)))     (setf *last-running-watch* *cursorhook*)     (update-cursor)     (ccl::%install-periodic-task :run-the-watch #'increase-watch 15)     (prog1         (progn ,@body)       (ccl::%remove-periodic-task :run-the-watch)       (setf *cursorhook* old-cursor))))(defun increase-watch ()  (let* ((actual-pos (position *last-running-watch* *all-watch-cursors*))         (next-watch (elt *all-watch-cursors* (if (or (null actual-pos)                                                      (= actual-pos 7))                                                0                                                (1+ actual-pos)))))    (setf *cursorhook*  next-watch)    (setf *last-running-watch* next-watch)))(defun stop-watch ()  (ccl::%remove-periodic-task :run-the-watch))|#(require 'animated-cursor)(export '(with-running-watch))(defmacro with-running-watch (&body body)  `(with-animated-cursor -6078     (progn ,@body)))#|(with-running-watch  (sleep 5)  "hello")|#