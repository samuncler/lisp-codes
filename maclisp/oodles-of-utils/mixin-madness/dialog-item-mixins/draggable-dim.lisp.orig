(in-package :ccl)(provide :draggable-dim);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; draggable-dim.Lisp;;;; Copyright © 1991 Northwestern University Institute for the Learning Sciences;; All Rights Reserved;;;; author: Michael S. Engber; some modifications by Dieter Holz, University of Basel, Switzerland;;;; Dialog item mixin for dragging dialog items.;;;; Changes (worth to be mentioned);;-----------------------;;;; 9/17/1991 Dieter: 'view-click-event-handler' extended. Now the '*full-hand-cursor*' appears while dragging. ;;                                   The dragged view is the frontmost view now.;;  2/21/1992 Dieter: the default drag-end-action-fn is now 'set-view-at-grid-position'.  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (:compile-toplevel :load-toplevel :execute)    (require :simple-view-ce)    (require :view-ce)    (require :QuickDraw-u)    (require :unibas-cursors)    )(export '(draggable-dim));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|This mixin allows a dialog item to be dragged around. The dragging effectis implemented using the ToolBox call, DragGrayRgn. Reading the discussionof DragGrayRgn in IM I p. 294 may be helpful.See Also droppable-dim  - dropping the selection onto a target selectable-dim - for dragging multiple itemsInitargs :drag-bounds   Determines the legal drag area (a rectangle). Allowed values are   :window (item's window), :container (item's containing view), and   :none (entire desktop). :h-drag-slop [20] :v-drag-slop [20]   These control how far the user can move the mouse outside the drag limits   before the drag becomes void (and the outline disappears). :drag-axis [:both]   Constrains the drag direction. Allowed values are :vertical, :horizontal,   or :both :drag-start-tol [#@(2 2)]   This point specififies the delta-h and delta-v the mouse must travel before   a click turns into a drag. This prevents accidentally dragging something   you only intended to click on. :drag-action-fn [no default]   The default drag-action method calls the function stored in this slot.   The function should accept one argument, the dialog item being dragged.   Use this function to perform some action continuously during the drag.  :drag-end-action-fn [snap to grid]   The default drag-end-action method calls the function stored in this slot.   The function should accept 3 arguments, the item dragged, the change in   mouse position as a point (delat-h,delta-v), and the final mouse position   as a point (in the dialog item container's coordinates). Use this function   to perform an action after a legal drag.Methods of Interest pre-drag-hilite (di draggable-dim) hilite-flag   Specialize this to customize the hiliting effect on the original position   of the item being dragged. hilite-flag indicates whether to hilite or un-hilite   the item (t/nil). The default method uses inversion. draggable-p (di draggable-dim)   Specialize this to control when an item can be dragged. Default is always.|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass draggable-dim ()    ((drag-bounds        :initarg :drag-bounds                                     :accessor drag-bounds)      (h-drag-slop        :initarg :h-drag-slop                                     :accessor h-drag-slop)      (v-drag-slop        :initarg :v-drag-slop                                     :accessor v-drag-slop)      (drag-axis)      (drag-start-tol     :initarg :drag-start-tol                                     :accessor drag-start-tol)      (drag-action-fn     :initarg :drag-action-fn                                      :accessor drag-action-fn)      (drag-end-action-fn :initarg :drag-end-action-fn                                          :accessor drag-end-action-fn))    (:default-initargs       :drag-bounds :none       :h-drag-slop 20       :v-drag-slop 20       :drag-axis :both       :drag-start-tol #@(2 2)       :drag-end-action-fn #'(lambda (di delta pt)                                                 (declare (ignore pt))                                                 (set-view-at-grid-position (view-container di) di delta))       ))(defmethod initialize-instance :after ((di draggable-dim) &rest initargs &key drag-axis)    (declare (ignore initargs))    (setf (drag-axis di) drag-axis))(defmethod drag-axis ((di draggable-dim))    ;;internally the drag axis is stored as the corresponding ToolBox constant    (ecase (slot-value di 'drag-axis)        (#.#$noConstraint :both)        (#.#$hAxisOnly :horizontal)        (#.#$vAxisOnly :vertical)))(defmethod (setf drag-axis) (axis-key (di draggable-dim))    ;;internally the drag axis is stored as the corresponding ToolBox constant    (setf (slot-value di 'drag-axis) (ecase axis-key                                                             (:both #.#$noConstraint)                                                             (:horizontal #.#$hAxisOnly)                                                             (:vertical #.#$vAxisOnly)))    axis-key)(defmethod view-click-event-handler ((di draggable-dim) where)    (when (draggable-p di)         (with-cursor *full-hand-cursor*               (when (view-overlapped-p di)                   (view-bring-to-front di)                   (validate-view (view-window di))                   (invalidate-view di))              (pre-drag-hilite di t)              (if (drag-start-p di where)                  (let* ((old-scroll-position (view-scroll-position (view-container di)))                              (drag-offset (drag-item di where))                              (scroll-offset (if (view-container di)                                                          (subtract-points (view-scroll-position (view-container di))  old-scroll-position)                                                          #@(0 0)))                              (total-offset (when drag-offset                                                         (add-points drag-offset scroll-offset))))                      (pre-drag-hilite di nil)                      (when total-offset                           (call-drag-end-action di total-offset (add-points total-offset where))                           (when (view-overlapped-p di)                                (view-bring-to-front di)                                 (invalidate-view di))))                  (progn                      (pre-drag-hilite di nil)                      (call-next-method))))))(defmethod draggable-p ((di draggable-dim)) (declare (ignore di)) ;;specialize to control when an item can be dragged"     t)(defmethod call-drag-action ((di draggable-dim))    ;;exists primarily to be specialized by selectable-dim    (drag-action di))(defmethod drag-action ((di draggable-dim))    (when (slot-boundp di 'drag-action-fn)         (funcall (drag-action-fn di) di)))(defmethod call-drag-end-action ((di draggable-dim) drag-offset dest-point)    ;;exists primarily to be specialized by selectable-dim    (drag-end-action di drag-offset dest-point))(defmethod drag-end-action ((di draggable-dim) drag-offset dest-point)    (when (slot-boundp di 'drag-end-action-fn)         (funcall (drag-end-action-fn di) di drag-offset dest-point)))(defmethod pre-drag-hilite ((di draggable-dim) hilite-flag)    (with-focused-view (view-container di)         (hilite-view di hilite-flag)))(defmethod drag-start-p ((di draggable-dim) where)    ;;tracks the mouse to see if the user breaks the item loose    (rlet ((r :Rect                     :topLeft (subtract-points where (drag-start-tol di))                     :botRight (add-points where (drag-start-tol di))))        (loop (unless (#_WaitMouseUp) (return nil))                  (unless (#_PtInRect (view-mouse-position (view-container di)) r)                      (return t)))))(defpascal drag-action-proc ()    ;;pascal style fn passed to DragGrayRgn, the call-drag-action method does the    ;;real work. *current-draggable-di* is bound for the duration of the drag, to    ;;communicate the item being dragged to drag-action-proc.    (declare (special *current-draggable-di*))    (call-drag-action *current-draggable-di*))(defmethod drag-item ((di draggable-dim) where)    ;;Returns the drag-offset or nil (illegal drag - no call to drag-end-action)    (setf where (view-to-global (view-container di) where))    (rlet ((limitRect :Rect)                (slopRect :Rect))        (with-macptrs ((dragRgn (#_NewRgn)))             (unwind-protect                 (let ((*current-draggable-di* di))                     (declare (special *current-draggable-di*))                     (set-DragGrayRgn-areas di where dragRgn limitRect slopRect)                     (shrink-wrap-limitRect where dragRgn limitRect)                     (with-focused-view *WMgr-view*                          (setf where (#_DragGrayRgn dragRgn where limitRect slopRect (slot-value di 'drag-axis) drag-action-proc)))                     (unless (eql #@(-32768 -32768) where) where))                 (#_DisposeRgn dragRgn)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; these routines use GLOBAL coordinates(defmethod set-DragGrayRgn-areas ((di draggable-dim) where drag-rgn limitRect slopRect)    (declare (ignore where))    (set-drag-limit-rect di limitRect)    (set-drag-slop-rect di slopRect)    (set-drag-outline-rgn di drag-rgn))(defmethod set-drag-outline-rgn ((di draggable-dim) drag-rgn)    (multiple-value-bind (topLeft botRight) (view-global-corners di)         (rlet ((r :Rect :topLeft topLeft :botRight botRight))             (#_RectRgn drag-rgn r))))(defmethod set-drag-limit-rect ((di draggable-dim) r)    (ecase (drag-bounds di)        (:container (multiple-value-bind (c-topLeft c-botRight) (view-global-corners (view-container di))                                 (rset r :Rect.topLeft c-topLeft :storage :pointer)                                 (rset r :Rect.botRight c-botRight :storage :pointer))                            (multiple-value-bind (w-topLeft w-botRight) (view-global-corners (view-window di))                                 (rlet ((wRect :Rect :topLeft w-topLeft :botRight w-botRight))                                     (#_SectRect r wRect r))))        (:window  (multiple-value-bind (w-topLeft w-botRight) (view-global-corners (view-window di))                              (rset r :Rect.topLeft w-topLeft :storage :pointer)                              (rset r :Rect.botRight w-botRight :storage :pointer)))        (:none (rset r :Rect.topLeft #@(-32768 -32768) :storage :pointer)                    (rset r :Rect.botRight #@(32767 32767) :storage :pointer))))(defmethod set-drag-slop-rect ((di draggable-dim) r)    (set-drag-limit-rect di r)    (#_InsetRect r  (- (h-drag-slop di)) (- (v-drag-slop di))))(defun shrink-wrap-limitRect (where dragRgn limitRect)    (let ((h (point-h where))              (v (point-v where)))        (rset limitRect :Rect.top (- v (max 0 (- (rref dragRgn :Region.rgnBBox.top :storage :handle)                                                                            (rref limitRect :Rect.top)))))        (rset limitRect :Rect.left (- h (max 0 (- (rref dragRgn :Region.rgnBBox.left :storage :handle)                                                                             (rref limitRect :Rect.left)))))        (rset limitRect :Rect.bottom (+ v (max 0 (- (rref limitRect :Rect.bottom)                                                                                  (rref dragRgn :Region.rgnBBox.bottom :storage :handle)))))        (rset limitRect :Rect.right (+ h (max 0 (- (rref limitRect :Rect.right)                                                                                (rref dragRgn :Region.rgnBBox.right :storage :handle)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|;;; a modest example - adding drag behavior to static text dialog items(defclass stdrg (draggable-dim static-text-dialog-item) ())(setf *test-w*      (make-instance 'dialog                     :window-type :document                     :view-position :centered                     :view-size #@(200 100)                     :window-title "draggable-dim demo"                     :close-box-p t                     :color-p t                     :view-subviews                     (list (make-instance 'stdrg                                          :view-position #@(10 20)                                          :dialog-item-text "change my position"                                          :view-nick-name :i1                                          :drag-end-action-fn #'(lambda (di delta pt)                                                           (declare (ignore pt))                                                           (offset-view-position di delta))                                          :drag-bounds :window                                          )                           (make-instance 'stdrg                                          :view-position #@(10 50)                                          :dialog-item-text "drag me anywhere"                                          :view-nick-name :i2                                          :dialog-item-action #'(lambda (di) (declare (ignore di)) (ed-beep))                                          :drag-action-fn #'(lambda (di) (declare (ignore di)) (ed-beep))                                          :drag-bounds :none                                          ))))|#