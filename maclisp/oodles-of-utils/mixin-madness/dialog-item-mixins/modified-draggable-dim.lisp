(in-package :oou)(oou-provide :draggable-dim);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; draggable-dim.Lisp;;;;  Copyright © 1991 Northwestern University Institute for the Learning Sciences;;  Copyright © 1992 Instiut fuer Informatik, University of Basel, Switzerland;; All Rights Reserved;;;; authors: Michael S. Engber; Northwestern University;;               Dieter Holz, University of Basel, Switzerland;;;; Dialog item mixin for dragging dialog items.;;;; Changes (worth to be mentioned);;-----------------------;;;; 9/17/1991 Dieter: 'view-click-event-handler' extended. Now the '*full-hand-cursor*' appears while dragging. ;;                                   The dragged view is the frontmost view now.;;  2/21/1992 Dieter: the default drag-end-action-fn is now 'set-view-at-grid-position'.  ;;  May 1992 Dieter: Now you have better control during the drag. '#_DragGrayRgn' isn't used any more. New methods ;;                                of interest defined. (see below);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(oou-dependencies :simple-view-ce                                :view-ce                                :QuickDraw-u                                :unibas-cursors                                )(export '(draggable-dim));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|This mixin allows a dialog item to be dragged around. The dragging effectis implemented using the ToolBox call, DragGrayRgn. Reading the discussionof DragGrayRgn in IM I p. 294 may be helpful.See Also droppable-dim  - dropping the selection onto a target selectable-dim - for dragging multiple itemsInitargs :drag-bounds   Determines the legal drag area (a rectangle). Allowed values are   :window (item's window), :container (item's containing view), and   :none (entire desktop). :h-drag-slop [20] :v-drag-slop [20]   These control how far the user can move the mouse outside the drag limits   before the drag becomes void (and the outline disappears). :drag-axis [:both]   Constrains the drag direction. Allowed values are :vertical, :horizontal,   or :both :drag-start-tol [#@(2 2)]   This point specififies the delta-h and delta-v the mouse must travel before   a click turns into a drag. This prevents accidentally dragging something   you only intended to click on. :drag-action-fn [no default]   The default drag-action method calls the function stored in this slot.   The function should accept one argument, the dialog item being dragged.   Use this function to perform some action continuously during the drag.  :drag-end-action-fn [snap to grid]   The default drag-end-action method calls the function stored in this slot.   The function should accept 3 arguments, the item dragged, the change in   mouse position as a point (delat-h,delta-v), and the final mouse position   as a point (in the dialog item container's coordinates). Use this function   to perform an action after a legal drag.Slots of InterestMethods of Interest pre-drag-hilite (di draggable-dim) hilite-flag   Specialize this to customize the hiliting effect on the original position   of the item being dragged. hilite-flag indicates whether to hilite or un-hilite   the item (t/nil). The default method uses inversion. draggable-p (di draggable-dim)   Specialize this to control when an item can be dragged. Default is always. draggable-view-enters ((self simple-view) draggable-view global-mouse-pos)   Is called during the drag whenever the mouse enters a view. The default-method does nothing.     draggable-view-leaves ((self simple-view) draggable-view global-mouse-pos)   Is called during the drag  whenever the mouse enters a view. The default-method does nothing.     draggable-dim-is-above ((self simple-view) (draggable-view draggable-dim) global-position)   Is called periodically during the drag.  hide-drag-rect-p ((self simple-view) (draggable-view draggable-dim) global-position)   Is called during the drag. Specialize this to customize the hiding of the drag-rect. E.g. during an    autoscroll the drag-rect should be hidden to avoid nasty drag-rect corpse on the screen.|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass draggable-dim ()    ((drag-bounds  :initarg :drag-bounds                               :accessor drag-bounds)      (h-drag-slop   :initarg :h-drag-slop                                :accessor h-drag-slop)      (v-drag-slop    :initarg :v-drag-slop                                 :accessor v-drag-slop)      (drag-axis)      (drag-start-tol :initarg :drag-start-tol                                 :accessor drag-start-tol)      (drag-action-fn :initarg :drag-action-fn                                  :accessor drag-action-fn)      (drag-end-action-fn :initarg :drag-end-action-fn                                          :accessor drag-end-action-fn)      (current-target :initform nil                                  :initarg :current-target                                  :accessor current-target)      (last-target :initform nil                           :initarg :last-target                           :accessor last-target)      (last-real-target :initform nil                                    :initarg :last-real-target                                    :accessor last-real-target))    (:default-initargs       :drag-bounds :none       :h-drag-slop 20       :v-drag-slop 20       :drag-axis :both       :drag-start-tol #@(2 2)       :drag-end-action-fn #'(lambda (di delta pt)                                                 (declare (ignore pt))                                                 (set-view-at-grid-position (or (view-container di) di) di delta))       ))(defmethod view-cursor ((self draggable-dim) where)   (declare (ignore where))   *full-hand-cursor*)(defmethod initialize-instance :after ((di draggable-dim) &rest initargs &key drag-axis)    (declare (ignore initargs))    (setf (drag-axis di) drag-axis))(defmethod drag-axis ((di draggable-dim))    ;;internally the drag axis is stored as the corresponding ToolBox constant    (ecase (slot-value di 'drag-axis)        (#.#$noConstraint :both)        (#.#$hAxisOnly :horizontal)        (#.#$vAxisOnly :vertical)))(defmethod (setf drag-axis) (axis-key (di draggable-dim))    ;;internally the drag axis is stored as the corresponding ToolBox constant    (setf (slot-value di 'drag-axis) (ecase axis-key                                                             (:both #.#$noConstraint)                                                             (:horizontal #.#$hAxisOnly)                                                             (:vertical #.#$vAxisOnly)))    axis-key)(defmethod window-drag-event-handler ((self draggable-dim) global-position)    (do-whole-drag self (global-to-view self global-position)))(defmethod initial-last-real-target ((self draggable-dim))    (or (view-container self) self))(defmethod do-whole-drag ((di draggable-dim) where)     (without-interrupts       (when (draggable-p di where)           (with-cursor *full-hand-cursor*                 (when (view-overlapped-p di)                     (view-bring-to-front di)                     (validate-view (view-window di))                     (invalidate-view di))                (setf (last-real-target di) (initial-last-real-target di))                (pre-drag-hilite di t)                (draggable-dim-is-above (last-real-target di) di                                                             (view-to-global (or (view-container di) di) where))                (if (drag-start-p di where)                    (let* ((*current-draggable-di* di)                                (drag-offset (drag-item di where)))                        (declare (special *current-draggable-di*))                        (pre-drag-hilite di nil)                        (when  drag-offset                             (call-drag-end-action di drag-offset (add-points drag-offset where))                             (when (view-overlapped-p di)                                  (view-bring-to-front di)                                   (invalidate-view di))))                    (pre-drag-hilite di nil))))))(defmethod view-click-event-handler :around ((di draggable-dim) where)    (if (draggable-p di where)        (do-whole-drag di where)        (call-next-method)))(defmethod draggable-p ((di draggable-dim) &optional view-position)     (declare (ignore di view-position)) ;;specialize to control when an item can be dragged     t)(defmethod call-drag-action ((di draggable-dim))    ;;exists primarily to be specialized by selectable-dim    (drag-action di))(defun frame-current-rect (&optional rect)    (declare (special *current-rect*))    (unless rect         (setf rect *current-rect*))    (with-focused-view *WMgr-view*         (with-pen (:NotPatXor *gray-pattern* 1 1 *WMgr-view*)              (#_FrameRect rect))))(defun frame-current-rects (rects)    (with-focused-view *WMgr-view*         (with-pen (:NotPatXor *gray-pattern* 1 1 *WMgr-view*)              (dolist (rect rects)                  (#_FrameRect rect)))))(defmethod drag-action ((di draggable-dim))    (declare (special *current-rect*))    (when (slot-boundp di 'drag-action-fn)         (funcall (drag-action-fn di) di))    (with-slots (last-target current-target last-real-target) di         (let* ((global-mouse-pos (view-mouse-position nil))                     (target-view  (find-target-view-containing-point di global-mouse-pos)))             (setf current-target target-view)             (unless (eq last-target  target-view)                 (when last-target                      (draggable-view-leaves last-target di global-mouse-pos))                 (when target-view                      (draggable-view-enters target-view di global-mouse-pos)))             (when (and (null target-view)                                 (neq (front-window) (view-window di))                                 (view-container di)                                 (view-contains-point-p  (view-container di)                                                                             (global-to-view (or (view-container (view-container di))                                                                                                               (view-container di))                                                                                                         global-mouse-pos))                                 (not (view-contains-point-p (front-window) global-mouse-pos)))                  (draggable-view-enters (view-container di) di global-mouse-pos)                  (setf target-view (view-container di)))             (setf target-view (or target-view                                                  last-real-target                                                  (view-container di)                                                  di))             (when (eq (front-window) (view-window target-view))                  (when (hide-drag-rect-p target-view di global-mouse-pos)                       (frame-current-rect))                  (draggable-dim-is-above target-view di global-mouse-pos)                  (when (hide-drag-rect-p target-view di global-mouse-pos)                        (frame-current-rect)))             (setf last-real-target target-view)             (setf last-target current-target))))(defmethod draggable-view-leaves ((self simple-view) draggable-view global-mouse-pos)    (declare (ignore draggable-view global-mouse-pos))    nil)(defmethod draggable-view-enters ((self simple-view) draggable-view global-mouse-pos)    (declare (ignore draggable-view global-mouse-pos))    nil)(defmethod draggable-view-enters :around ((sv simple-view) draggable-view global-mouse-pos)    (declare (special *current-rect* ))    (when (hide-drag-rect-p sv draggable-view global-mouse-pos)         (frame-current-rect))    (call-next-method)    (when (hide-drag-rect-p sv draggable-view global-mouse-pos)         (frame-current-rect)))(defmethod draggable-dim-is-above ((self simple-view) (draggable-view draggable-dim) global-position)    (declare (ignore draggable-view global-position))    nil)(defmethod hide-drag-rect-p ((self simple-view) (draggable-view draggable-dim) global-position)   (declare (ignore global-position))    (and (neq (last-real-target draggable-view) self)            (last-real-target draggable-view)           (neq (view-container (last-real-target draggable-view)) self)))             (defmethod find-target-view-containing-point ((self  draggable-dim) global-point)    (let ((root (root-target-view self global-point)))        (when  root             (let ((view (find-view-containing-point root (global-to-view root global-point))))                 (if (eq view self)                     (or (initial-last-real-target self) self)                     view)))))       (defmethod root-target-view ((self  draggable-dim) global-point)    (ecase (drag-bounds self)        (:container (view-container self))        (:window (view-window self))        (:none (find-view-containing-point nil global-point nil t))))(defmethod call-drag-end-action ((di draggable-dim) drag-offset dest-point)    ;;exists primarily to be specialized by selectable-dim    (drag-end-action di drag-offset dest-point))(defmethod drag-end-action ((di draggable-dim) drag-offset dest-point)    (when (slot-boundp di 'drag-end-action-fn)         (funcall (drag-end-action-fn di) di drag-offset dest-point))    (setf (last-target di) nil)    (setf (current-target di) nil)    (setf (last-real-target di) nil))(defmethod pre-drag-hilite ((di draggable-dim) hilite-flag)    (with-focused-view (or (view-container di) di)        (hilite-view di hilite-flag)))(defmethod drag-start-p ((di draggable-dim) where)    ;;tracks the mouse to see if the user breaks the item loose    (rlet ((r :Rect                     :topLeft (subtract-points where (drag-start-tol di))                     :botRight (add-points where (drag-start-tol di)))                (view-rect :Rect))        (multiple-value-bind (topleft bottomright) (view-outline-rect di)             (rset view-rect :rect.topLeft topleft)             (rset view-rect :rect.botRight bottomright))        (frame-current-rect view-rect)        (prog1             (loop (unless (#_WaitMouseUp)                          (return nil))                      (unless (#_PtInRect                                       (view-mouse-position (if (typep di 'view)                                                                                di                                                                                (view-container di)))                                      r)                          (return t)))            (frame-current-rect view-rect))))#|; this version drags only one (self) draggable-dim. There can be more item selected, all of them wanting to be dragged.(defmethod drag-item ((self draggable-dim) where)    ;;Returns the drag-offset or nil (illegal drag - no call to drag-end-action)    (with-focused-view *WMgr-view*         (let* ((wait-ticks (max 1 (floor internal-time-units-per-second 30)))                     (time (get-internal-run-time))                     (rect (make-record :rect))                     (view-topleft nil)                     (view-bottomright nil)                     (container (or (view-container self) self))                     (old-offset #@(0 0))                     (old-scroll-position (view-scroll-position container))                     (scroll-offset nil)                     offset                     (pos-in-window (view-to-window                                                     container                                                    (subtract-points (view-top-left self)                                                                                 (if (eq container (view-window self))                                                                                     (view-scroll-position container)                                                                                     #@(0 0))                                                                                 )))                     (pos-in-container (subtract-points (view-top-left self)                                                                                  (view-scroll-position container)))                     (min-offset-h (ecase (drag-bounds self)                                                  (:window (- (- (point-h pos-in-window))                                                                        (h-drag-slop self)))                                                  (:container (- (- (point-h pos-in-container))                                                                           (h-drag-slop self)))                                                  (:none (- *screen-width*))))                     (max-offset-h (ecase (drag-bounds self)                                                  (:window (+ (- (view-width (view-window self))                                                                             (point-h pos-in-window)                                                                             (view-width self))                                                                        (h-drag-slop self)))                                                  (:container (+ (- (view-width container)                                                                                 (point-h pos-in-container)                                                                                 (view-width self))                                                                           (h-drag-slop self)))                                                  (:none *screen-width*)))                     (min-offset-v (ecase (drag-bounds self)                                                  (:window (- (- (point-v pos-in-window))                                                                        (v-drag-slop self)))                                                  (:container (- (- (point-v pos-in-container))                                                                           (v-drag-slop self)))                                                  (:none (- *screen-height*))))                     (max-offset-v (ecase (drag-bounds self)                                                  (:window (+ (- (view-height (view-window self))                                                                             (point-v pos-in-window)                                                                             (view-height self))                                                                        (v-drag-slop self)))                                                  (:container (+ (- (view-height container)                                                                                 (point-v pos-in-container)                                                                                 (view-height self))                                                                           (v-drag-slop self)))                                                  (:none *screen-height*)))                     (old-grafport-font (rref (wptr *WMgr-View*) :grafport.txfont)))             (multiple-value-setq (view-topleft view-bottomright) (view-outline-rect self))             (setf where (view-to-global (if (or (typep self 'view)                                                                          (typep self 'editable-text-dialog-item))                                                                 self                                                                  container)                                                             where))             (with-pen (:NotPatXor *gray-pattern* 1 1 *WMgr-view*)                  (points-to-rect view-topleft                                              view-bottomright                                                rect)                  (frame-current-rect rect)                  (unwind-protect                      (loop                          (rset (wptr *WMgr-View*) :grafport.txfont old-grafport-font)                          (let ((*current-rect* rect))                              (declare (special  *current-rect*))                              (call-drag-action self))                          (setf offset (subtract-points (view-mouse-position *WMgr-view*) where))                          (setf offset (make-point (if (minusp (point-h offset))                                                                       (max min-offset-h (point-h offset))                                                                       (min max-offset-h (point-h offset)))                                                                   (if (minusp (point-v offset))                                                                       (max min-offset-v (point-v offset))                                                                       (min max-offset-v (point-v offset)))))                          (cond ((mouse-down-p)                                      (unless (or (= offset old-offset)                                                          (<= (get-internal-run-time) (+ time wait-ticks)))                                          ;(unless (eq old-offset #@(0 0))                                              (frame-current-rect rect)                                              ;)                                          (points-to-rect (add-points view-topleft offset)                                                                      (add-points view-bottomright offset)                                                                      rect)                                          (frame-current-rect rect)                                          (setf old-offset offset)                                          (setf time (get-internal-run-time))))                                    (t (frame-current-rect rect)                                         (return t))))))             (dispose-record rect)             (rset (wptr *WMgr-View*) :grafport.txfont old-grafport-font)             (when offset                   (setf scroll-offset                           (if (view-container self)                               (subtract-points (view-scroll-position (view-container self))  old-scroll-position)                               #@(0 0)))                  (add-points offset scroll-offset)))))|#; this version drags all selected items of a selection-cluster(defmethod drag-item ((self draggable-dim) where)    ;;Returns the drag-offset or nil (illegal drag - no call to drag-end-action)    (with-focused-view *WMgr-view*         (let* ((wait-ticks (max 1 (floor internal-time-units-per-second 30)))                     (time (get-internal-run-time))                     (rects nil)                     (view-topleft nil)                     (view-bottomright nil)                     (container (or (view-container self) self))                     (old-offset #@(0 0))                     (old-scroll-position (view-scroll-position container))                     (scroll-offset nil)                     offset                     (pos-in-window (view-to-window                                                     container                                                    (subtract-points (view-top-left self)                                                                                 (if (eq container (view-window self))                                                                                     (view-scroll-position container)                                                                                     #@(0 0))                                                                                 )))                     (pos-in-container (subtract-points (view-top-left self)                                                                                  (view-scroll-position container)))                     (min-offset-h (ecase (drag-bounds self)                                                  (:window (- (- (point-h pos-in-window))                                                                        (h-drag-slop self)))                                                  (:container (- (- (point-h pos-in-container))                                                                           (h-drag-slop self)))                                                  (:none (- *screen-width*))))                     (max-offset-h (ecase (drag-bounds self)                                                  (:window (+ (- (view-width (view-window self))                                                                             (point-h pos-in-window)                                                                             (view-width self))                                                                        (h-drag-slop self)))                                                  (:container (+ (- (view-width container)                                                                                 (point-h pos-in-container)                                                                                 (view-width self))                                                                           (h-drag-slop self)))                                                  (:none *screen-width*)))                     (min-offset-v (ecase (drag-bounds self)                                                  (:window (- (- (point-v pos-in-window))                                                                        (v-drag-slop self)))                                                  (:container (- (- (point-v pos-in-container))                                                                           (v-drag-slop self)))                                                  (:none (- *screen-height*))))                     (max-offset-v (ecase (drag-bounds self)                                                  (:window (+ (- (view-height (view-window self))                                                                             (point-v pos-in-window)                                                                             (view-height self))                                                                        (v-drag-slop self)))                                                  (:container (+ (- (view-height container)                                                                                 (point-v pos-in-container)                                                                                 (view-height self))                                                                           (v-drag-slop self)))                                                  (:none *screen-height*)))                     (old-grafport-font (rref (wptr *WMgr-View*) :grafport.txfont)))             (declare (special *current-drag-selection*))             (multiple-value-setq (view-topleft view-bottomright) (view-outline-rect self))             (setf where (view-to-global (if (or (typep self 'view)                                                                          (typep self 'editable-text-dialog-item))                                                                 self                                                                  container)                                                             where))             (with-pen (:NotPatXor *gray-pattern* 1 1 *WMgr-view*)                  (if (boundp '*current-drag-selection*)                      (dolist (selected-view *current-drag-selection*)                          (let ((new-rect (make-record :rect)))                              (multiple-value-setq (view-topleft view-bottomright) (view-outline-rect selected-view))                              (points-to-rect  view-topleft                                                           view-bottomright                                                           new-rect)                              (push new-rect rects)))                      (setf rects                               (list (let ((new-rect (make-record :rect)))                                           (multiple-value-setq (view-topleft view-bottomright) (view-outline-rect self))                                           (points-to-rect  view-topleft view-bottomright new-rect)                                           new-rect))))                  (frame-current-rects rects)                  (unwind-protect                      (loop                          (rset (wptr *WMgr-View*) :grafport.txfont old-grafport-font)                          (let ((*current-rect* (car rects)))                              (declare (special  *current-rect*))                              (call-drag-action self))                          (setf offset (subtract-points (view-mouse-position *WMgr-view*) where))                          (setf offset (make-point (if (minusp (point-h offset))                                                                       (max min-offset-h (point-h offset))                                                                       (min max-offset-h (point-h offset)))                                                                   (if (minusp (point-v offset))                                                                       (max min-offset-v (point-v offset))                                                                       (min max-offset-v (point-v offset)))))                          (cond ((mouse-down-p)                                      (unless (or (= offset old-offset)                                                          (<= (get-internal-run-time) (+ time wait-ticks)))                                          (frame-current-rects rects)                                          (let ((i 0))                                              (dolist (rect rects)                                                  (multiple-value-setq (view-topleft view-bottomright) (view-outline-rect (if (boundp '*current-drag-selection*)                                                                                                                                                                                    (elt *current-drag-selection* i)                                                                                                                                                                                    self)))                                                  (points-to-rect (add-points view-topleft offset)                                                                              (add-points view-bottomright offset)                                                                              rect)                                                  (setf i (1+ i))))                                          (frame-current-rects rects)                                          (setf old-offset offset)                                          (setf time (get-internal-run-time))))                                    (t (frame-current-rects rects)                                         (return t))))))             (dolist (rect rects)                 (dispose-record rect))             (rset (wptr *WMgr-View*) :grafport.txfont old-grafport-font)             (when offset                   (setf scroll-offset                           (if (view-container self)                               (subtract-points (view-scroll-position (view-container self))  old-scroll-position)                               #@(0 0)))                  (add-points offset scroll-offset)))))#|Mike's version.It uses #_DragGrayRgn, but then it's impossible to hide the dragged rect during the drag-action. Thisis necessary e.g. during autoscrolling. (defpascal drag-action-proc ()    ;;pascal style fn passed to DragGrayRgn, the call-drag-action method does the    ;;real work. *current-draggable-di* is bound for the duration of the drag, to    ;;communicate the item being dragged to drag-action-proc.    (declare (special *current-draggable-di*))    (call-drag-action *current-draggable-di*))(defmethod drag-item ((di draggable-dim) where)    ;;Returns the drag-offset or nil (illegal drag - no call to drag-end-action)    (setf where (view-to-global (view-container di) where))    (rlet ((limitRect :Rect)                (slopRect :Rect))        (with-macptrs ((dragRgn (#_NewRgn)))             (unwind-protect                 (let ((*current-draggable-di* di))                     (declare (special *current-draggable-di*))                     (set-DragGrayRgn-areas di where dragRgn limitRect slopRect)                     (shrink-wrap-limitRect where dragRgn limitRect)                     (with-focused-view *WMgr-view*                          (setf where (#_DragGrayRgn dragRgn where limitRect slopRect (slot-value di 'drag-axis) drag-action-proc)))                     (unless (eql #@(-32768 -32768) where) where))                 (#_DisposeRgn dragRgn)))))|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; these routines use GLOBAL coordinates(defmethod set-DragGrayRgn-areas ((di draggable-dim) where drag-rgn limitRect slopRect)    (declare (ignore where))    (set-drag-limit-rect di limitRect)    (set-drag-slop-rect di slopRect)    (set-drag-outline-rgn di drag-rgn))(defmethod set-drag-outline-rgn ((di draggable-dim) drag-rgn)    (multiple-value-bind (topLeft botRight) (view-global-corners di)         (rlet ((r :Rect :topLeft topLeft :botRight botRight))             (#_RectRgn drag-rgn r))))(defmethod set-drag-limit-rect ((di draggable-dim) r)    (ecase (drag-bounds di)        (:container (multiple-value-bind (c-topLeft c-botRight) (view-global-corners (view-container di))                                 (rset r :Rect.topLeft c-topLeft :storage :pointer)                                 (rset r :Rect.botRight c-botRight :storage :pointer))                            (multiple-value-bind (w-topLeft w-botRight) (view-global-corners (view-window di))                                 (rlet ((wRect :Rect :topLeft w-topLeft :botRight w-botRight))                                     (#_SectRect r wRect r))))        (:window  (multiple-value-bind (w-topLeft w-botRight) (view-global-corners (view-window di))                              (rset r :Rect.topLeft w-topLeft :storage :pointer)                              (rset r :Rect.botRight w-botRight :storage :pointer)))        (:none (rset r :Rect.topLeft #@(-32768 -32768) :storage :pointer)                    (rset r :Rect.botRight #@(32767 32767) :storage :pointer))))(defmethod set-drag-slop-rect ((di draggable-dim) r)    (set-drag-limit-rect di r)    (#_InsetRect r  (- (h-drag-slop di)) (- (v-drag-slop di))))(defun shrink-wrap-limitRect (where dragRgn limitRect)    (let ((h (point-h where))              (v (point-v where)))        (rset limitRect :Rect.top (- v (max 0 (- (rref dragRgn :Region.rgnBBox.top :storage :handle)                                                                            (rref limitRect :Rect.top)))))        (rset limitRect :Rect.left (- h (max 0 (- (rref dragRgn :Region.rgnBBox.left :storage :handle)                                                                             (rref limitRect :Rect.left)))))        (rset limitRect :Rect.bottom (+ v (max 0 (- (rref limitRect :Rect.bottom)                                                                                  (rref dragRgn :Region.rgnBBox.bottom :storage :handle)))))        (rset limitRect :Rect.right (+ h (max 0 (- (rref limitRect :Rect.right)                                                                                (rref dragRgn :Region.rgnBBox.right :storage :handle)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|;;; a modest example - adding drag behavior to static text dialog items(defclass stdrg (draggable-dim static-text-dialog-item) ())(setf *test-w*      (make-instance 'dialog                     :window-type :document                     :view-position :centered                     :view-size #@(200 100)                     :window-title "draggable-dim demo"                     :close-box-p t                     :color-p t                     :view-subviews                     (list (make-instance 'stdrg                                          :view-position #@(10 20)                                          :dialog-item-text "change my position"                                          :view-nick-name :i1                                          :drag-end-action-fn #'(lambda (di delta pt)                                                           (declare (ignore pt))                                                           (offset-view-position di delta))                                          :drag-bounds :window                                          )                           (make-instance 'stdrg                                          :view-position #@(10 50)                                          :dialog-item-text "drag me anywhere"                                          :view-nick-name :i2                                          :dialog-item-action #'(lambda (di) (declare (ignore di)) (ed-beep))                                          :drag-action-fn #'(lambda (di) (declare (ignore di)) (ed-beep))                                          :drag-bounds :none                                          ))))|#