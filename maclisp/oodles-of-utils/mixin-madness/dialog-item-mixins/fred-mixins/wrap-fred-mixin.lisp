(in-package :oou)(oou-provide :wrap-fred-mixin);*****************************************************************                                    ;; Copyright © 1991-96 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; a mixin for fred. Implements an auto-wrapping mode and a wrap-paragraph method; ;; Changes (worth to be mentioned):; ------------------------------; none ;;*****************************************************************;*****************************************************************(oou-dependencies :simple-view-ce                                    :update-when-changed-mixin                  :fred-mixin-ce) (export '(wrap-fred-mixin                    ));---------------------------- -------------------------------------(defclass wrap-fred-mixin (update-when-changed-mixin)    ((auto-wrap :initform t                            :initarg :auto-wrap                            :accessor auto-wrap)   (consider-next-indent :initform nil                         :accessor consider-next-indent)))(defmethod initialize-instance :around ((ob wrap-fred-mixin) &rest initargs)     (declare (ignore initargs))    (setf (auto-wrap ob) nil)    (call-next-method)    (setf (auto-wrap ob) t))(defmethod initialize-instance :after ((ob wrap-fred-mixin) &rest initargs)     (declare (ignore initargs))    (comtab-set-key (slot-value ob 'comtab) '(:meta #\q) #'ed-fill-paragraph))(defmethod text-area-width ((self fred-window))  (let ((fred (ccl::window-key-handler self)))    (when fred       (text-area-width fred))))(defmethod text-area-width ((self fred-item))    (view-width self))(defmethod window-show-cursor ((self wrap-fred-mixin) &optional position scrolling)  (declare (ignore  scrolling))  (if (and (auto-wrap self)           (< (fr-cursor-hpos self)              (text-area-width self)))        (call-next-method self (buffer-line-start (fred-buffer self) position) nil)        (call-next-method)))(defmethod view-key-event-handler :before ((self wrap-fred-mixin) key)  (declare (ignore key))  (when (auto-wrap self)    (let* ((buff (fred-buffer self))           (pos (buffer-position buff))           (line-start (buffer-line-start buff pos))           (line-end (buffer-line-end buff pos)))      (setf (consider-next-indent self) nil)      (when (and (or (and (null (ccl::buffer-forward-find-not-char buff *wsp* line-start pos))                          (ccl::buffer-forward-find-not-char buff *wsp* line-start line-end))                     (and (= line-start pos)                          (/= line-start line-end))))        (let* ((first-real-char-pos (ccl::buffer-forward-find-not-char buff *wsp&cr* line-start line-end))               (indent-string (when first-real-char-pos                                (buffer-substring buff line-start (1- first-real-char-pos))))               (indent-string-length (length indent-string))               (same-indent-begin (and indent-string                                       (< (buffer-line-start buff pos 1)                                          (buffer-size buff))                                       (buffer-substring-p buff indent-string (buffer-line-start buff pos 1)))))          (setf (consider-next-indent self) (and same-indent-begin                                                 (not (find (buffer-char buff (+ (buffer-line-start buff pos 1) indent-string-length)) *wsp&cr*)))))))))  (defmethod after-change-update-method :after ((self wrap-fred-mixin) &key (draw-now-p t))  (declare (ignore draw-now-p))   (when (auto-wrap self)    (let* ((buff (fred-buffer self))           (pos (buffer-position buff))           (line-end (buffer-line-end buff pos))           (line-start (buffer-line-start buff pos)))      (when (> (buffer-size buff) 0)        (cond ((or (and (null (ccl::buffer-forward-find-not-char buff *wsp* line-start pos))                        (ccl::buffer-forward-find-not-char buff *wsp* line-start line-end))                   (and (= line-start pos)                        (/= line-start line-end)))               (word-wrap-region self (buffer-line-start buff pos)                                  (wrap-end-position self pos :consider-next-indent (consider-next-indent self))                                 :wrap-to-end-pos t))              ((> (fr-line-width self pos)                  (text-area-width self))               (word-wrap-region self line-start (wrap-end-position self pos)))              ))      (setf (consider-next-indent self) nil))))(defmethod in-text-area-p ((self wrap-fred-mixin) pos)  (< (+ (fred-hpos self pos) (fred-hscroll self))     (text-area-width self)))(defmethod word-wrap-region ((self wrap-fred-mixin) start-pos end-pos &key (wrap-to-end-pos nil))  (declare (optimize (speed 3) (safety 0) (compilation-speed 0) (space 0)))  (when (> end-pos start-pos)    (let* ((buff (fred-buffer self))           (cursor-pos (buffer-position buff))           (cursor-in-line (buffer-line buff cursor-pos))           (last-char (when (and (> cursor-pos 0)                                 (or (= (buffer-line-end buff  start-pos) cursor-pos)                                     (null (ccl::buffer-forward-find-not-char buff *wsp&cr* cursor-pos (buffer-line-end buff start-pos)))))                         (buffer-char buff (1- cursor-pos))))                     (eol-pos (make-mark buff (buffer-line-end buff  start-pos)))                    (bol-pos (make-mark buff (buffer-line-start buff start-pos)))                     actual-pos                    (first-real-char-pos (ccl::buffer-forward-find-not-char buff *wsp&cr* bol-pos eol-pos))                    (insertion-string (when (and first-real-char-pos                                                                              (> first-real-char-pos (buffer-position bol-pos)))                                                            (buffer-substring buff bol-pos (1- first-real-char-pos))))                    (lines-wrapped 0)            (loops-done 0)           break-pos)          (unwind-protect              (setf end-pos (make-mark buff end-pos))              (setf start-pos (make-mark buff start-pos))              (loop           (setf eol-pos (set-mark eol-pos (buffer-line-end buff start-pos lines-wrapped)))                  (setf bol-pos (set-mark bol-pos (buffer-line-start buff start-pos lines-wrapped)))                  (setf actual-pos (buffer-position eol-pos))          (if (or (and (not wrap-to-end-pos)                       (in-text-area-p self actual-pos))                  (and (>= actual-pos (buffer-position end-pos))                       (in-text-area-p self actual-pos))                  (< lines-wrapped loops-done))                      (return)                      (progn              (setf actual-pos (buffer-position eol-pos))                          (loop                 (if (or (null actual-pos)                        (in-text-area-p self actual-pos))                                  (progn (setf break-pos actual-pos)                                                (return))                                  (setf actual-pos (ccl::buffer-backward-find-char buff *wsp&cr2* actual-pos bol-pos))))                          (when break-pos                              (when (<= (buffer-position eol-pos) (buffer-position end-pos))                                  (let ((real-break-pos (buffer-not-char-pos buff *wsp&cr2* :start bol-pos :end  (1+ break-pos) :from-end t)))                                      (if real-break-pos                      (progn (buffer-delete buff  (1+ real-break-pos) (1+ break-pos))                             (setf break-pos real-break-pos))                      (setf break-pos (buffer-char-pos buff *wsp&cr2* :start (1+ break-pos)                                                       :end (1+ (buffer-position eol-pos)))))                     (let ((delete-pos-1 (ccl::buffer-backward-find-not-char buff *wsp&cr2* eol-pos                                                                            bol-pos))                          (delete-pos-2 (if  (>= (buffer-position eol-pos)(buffer-position end-pos))                                          (buffer-position eol-pos)                                          (buffer-not-char-pos buff *wsp&cr2* :start eol-pos :end end-pos))))                      (when delete-pos-1                        (incf delete-pos-1))                      (when (and delete-pos-1 delete-pos-2)                                               (buffer-delete buff delete-pos-1 delete-pos-2))                      (when (and                              delete-pos-1                             (or (and (= lines-wrapped 0)                                      (find last-char *wsp*)                                      (/= (buffer-position eol-pos) (buffer-position end-pos))                                      (/= (buffer-position buff) delete-pos-1))                                                                  (/= (1+ break-pos) (buffer-position eol-pos))                                 (and (= lines-wrapped 0)                                      (find last-char *wsp*)                                      (/= (1+ break-pos) delete-pos-1)))                             (< delete-pos-1 (buffer-size buff)))                        (buffer-insert buff #\Space  delete-pos-1)                        (when (and (not (find last-char *wsp*))                                   (= (buffer-position buff) (1+ delete-pos-1)))                          (set-mark buff (1- (buffer-position buff))))))))                (when (and break-pos                           (< (1+ break-pos) (buffer-size buff))                           (or (and (= lines-wrapped 0)                                    (find last-char *wsp*))                               (/= (1+ break-pos)(buffer-position end-pos))))                  (buffer-insert buff #\NewLine (1+ break-pos))                  (when insertion-string                    (buffer-insert buff insertion-string (+ 2 break-pos))))                (incf lines-wrapped))))          (incf loops-done)))            (when break-pos        (set-fred-hscroll self 0))      (when (and (or (not (ccl::buffer-backward-find-not-char buff *wsp* (buffer-position buff) bol-pos))                     (= (buffer-position buff)                        (buffer-line-start buff (buffer-position buff))                        (1+ cursor-pos)))                 (or (> cursor-pos (buffer-size buff))                     (= cursor-in-line (buffer-line buff cursor-pos)))                 (> lines-wrapped 0))        (when (find last-char *wsp*)          (buffer-insert buff last-char (min (1- cursor-pos) (buffer-size buff))))        (set-mark buff cursor-pos))      )))(defmethod ed-fill-paragraph ((w wrap-fred-mixin) &optional begin end (setup-undo nil))  (declare (optimize (speed 3)                                           (safety 0)                                           (compilation-speed 0)                                           (space 0)))    (multiple-value-bind (b e) (paragraph-bounds w)        (when begin             (setf b begin))        (when end            (setf e end))        (unless (eq b e)            (let* ((buf (fred-buffer w))             (prefix (view-get w 'fill-prefix))             (bmark (make-mark buf b t))             (emark (make-mark buf e))             (string (when setup-undo                                               (buffer-substring buf b e)))                          (style (when setup-undo                                            (buffer-get-style buf b e)))                          p last-word-end wsp-end done?)                (unwind-protect                    (progn                        (setq e (make-mark buf e))                        (if (and (eql b (buffer-line-start buf b))                                          (setq p (ccl::buffer-forward-find-not-char buf *wsp&cr* b e)))                            (progn                                (buffer-delete buf b (decf p))                                (setq p b)                                (when prefix                                    (buffer-insert-with-style buf (car prefix) (cdr prefix) b)                                    (incf p (length (car prefix)))))                            (setq p b))                        (loop                            (setq p (ccl::buffer-forward-find-char buf *wsp&cr* p e))                            (if p                                 (progn                                    (setq wsp-end (ccl::buffer-forward-find-not-char buf *wsp&cr* p e)                                                p (1- p)                                                wsp-end (if wsp-end (1- wsp-end) e))                                    (buffer-delete buf p wsp-end)                                    (buffer-insert buf #\Space p))                                (setq p (buffer-position e) wsp-end p done? t))                            (if (in-text-area-p w p)                                (progn                                    (setq last-word-end p)                                    (incf p))                                (progn                                    (unless last-word-end                                        (if done? (return))                                        (setq last-word-end p))                                    (buffer-delete buf last-word-end (1+ last-word-end))                                    (let ((length (indent w  last-word-end)))                                        (buffer-insert buf #\newline last-word-end)                                        (setq b  (+ 1 last-word-end length)                                                     p b)                                        (if (>= p (buffer-position e)) (return))                                        (when prefix                                            (buffer-insert-with-style buf (car prefix) (cdr prefix) b)                                            (incf p (length (car prefix))))                                        (setq last-word-end nil))))                            (if done? (return))))                    (when setup-undo                        (setup-undo w #'(lambda ()                                                            (buffer-delete bmark (buffer-position bmark) (buffer-position emark))                                                            (buffer-insert-with-style bmark string style)                                                            (fred-update w))))))))    (set-fred-hscroll w 0))(defmethod ed-fill-selection ((self wrap-fred-mixin))    (declare (optimize (speed 3)                                           (safety 0)                                           (compilation-speed 0)                                           (space 0)))    (multiple-value-bind (start end) (selection-range self)        (let* ((buffer (fred-buffer self))                      (end-mark (make-mark buffer end))                      (para-start)                      (para-end start))            (collapse-selection self nil)            (do ()                    ((>= para-end (buffer-position end-mark))                       (set-selection-range self start (buffer-position end-mark)))                (multiple-value-setq (para-start para-end) (paragraph-bounds self))                (let  ((next-para-start                                 (ccl::buffer-forward-find-not-char buffer *wsp&cr* para-end                                                                                                       (buffer-position end-mark))))                    (ed-fill-paragraph self                                                           (max para-start start)                                                            (if next-para-start                                                              (min (buffer-position end-mark)                                                                        (- next-para-start 3))                                                              (buffer-position end-mark)))                    (set-mark buffer next-para-start))))))(defmethod indent ((self wrap-fred-mixin) &optional (pos (buffer-position (fred-buffer self))))    (declare (optimize (speed 3)                                           (safety 0)                                           (compilation-speed 0)                                           (space 0)))    (let* ((buffer (fred-buffer self))                  (line-start-pos (buffer-line-start buffer pos))                  (first-real-char-pos (ccl::buffer-forward-find-not-char buffer *wsp&cr* line-start-pos pos))                  (insertion-string (when (and first-real-char-pos                                                                            (<  first-real-char-pos pos))                                                          (buffer-substring buffer line-start-pos (1- first-real-char-pos)))))        ;(buffer-insert buffer #\newline pos)        (when insertion-string            (buffer-insert buffer insertion-string pos))        (if insertion-string            (length insertion-string)            0)))                #|(defclass my-fred (wrap-fred-mixin fred-window)    ()    (:default-initargs :comtab (make-comtab))) ; be sure to have your own comtab(setf win (make-instance 'my-fred))(defclass my-fred-di (wrap-fred-mixin fred-item)    ()    (:default-initargs :comtab (make-comtab))) ; be sure to have your own comtab(make-instance 'window    :view-size #@(300 200)    :view-subviews (list (make-instance 'scrolling-fred-view                         :fred-item-class 'my-fred-di                                                  :allow-returns t                                                  :view-position #@(50 50)                                                  :view-size #@(200 100))))|#