(in-package :oou)(oou-provide :selectable-dim);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; selectable-dim.Lisp;;;; Copyright © 1991 Northwestern University Institute for the Learning Sciences;; All Rights Reserved;;;; author: Michael S. Engber; some modifications by Dieter Holz, university of Basel, Switzerland;;;; Dialog item mixins for selecting dialog items.;;;; Changes (worth to be mentioned);;-----------------------;;;; 9/17/1991 Dieter:  'hilite-selected-item' doesn't always focus on the correct view;; 2/5/1992   Dieter: 'nice-hilite-dim' inserted for hiliting a selected/deselected item;; 9/8/1992 Dieter: The selection cluster isn't restricted to the view's container any more. You can specify the;;                                'cluster-root'. That is the reference view of the cluster.;; 9/25/1992 Dieter:  'drag-start-p' now binds *current-drag-selection* (like 'drag-item');; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(oou-dependencies :simple-view-ce                                :unibas-cursors                                )(export '(selectable-dim selectable-rb-dim selectable-cb-dim          selected-items           nice-hilite-dim          ));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|These mixins group dialog items into clusters and handle selection ofitems within a cluster. 3 classes are defined, differing in how they handlemultiple selections: selectable-dim    - shift click to extend selections (ˆ la the Finder) selectable-rb-dim - no multiple selections (ˆ la radio buttons) selectable-cb-dim - click to toggle selections (ˆ la check boxes)See Also draggable-dim - dragging current selection droppable-dim - dragging + dropping selection onto targetsInitargs :selection-cluster (nil)    The selection cluster to which the item belongs. (test with eq)    Members of a cluster are required to have the same containing view.    Multiple selection constraints are enforced within each cluster. :selected-p [nil]    Determines if the item initially selected. :all-drag-actions-p [t]    If the item is draggable, this determines if the drag actions of    all items in the selections will be called during the drag. :all-drag-end-actions-p [t]    If the item is draggable, this determines if the drag end actions of    all items in the selections will be called after the drag. :all-drop-actions-p [t]    If the item is droppable, this determines if the drop actions of    all items in the selections will be called after the drop.Methods of Interest selected-items (di selectable-dim)   Returns a list of the items currently selected in di's cluster.   Use with setf to change the current selection. hilite-selected-item (di selectable-dim) hilite-flag   Specialize this to customize the hiliting effect for selected items.   hilite-flag indicates whether to hilite or un-hilite the item (t/nil).   The default method uses inversion.Note on combining selectable and draggable behavior:selectable-dim must appear BEFORE draggable-dim in the class precedencelist (it specializes some of draggable-dim's methods). Keep this in mindwhen using selectable-dim with any items that inherit from draggable-dimlike droppable-dim.|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass selectable-dim ()    ((cluster-root :initform nil                              :accessor cluster-root                              :initarg :cluster-root)      (selection-cluster      :initarg :selection-cluster                                           :accessor selection-cluster)      (selected-p             :initarg :selected-p                                      :accessor selected-p)      (all-drag-actions-p     :initarg :all-drag-actions-p                                             :accessor all-drag-actions-p)      (all-drag-end-actions-p :initarg :all-drag-end-actions-p                                                 :accessor all-drag-end-actions-p)      (all-drop-actions-p     :initarg :all-drop-actions-p                                             :accessor all-drop-actions-p))    (:default-initargs       :selection-cluster nil       :selected-p nil       :all-drag-actions-p t       :all-drag-end-actions-p t       :all-drop-actions-p t       ));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; click handling(defmethod view-click-event-handler :around ((di selectable-dim) where)     (declare (ignore where))    (with-focused-view (view-container di)         (if (selected-p di)             (click-selected-item di (shift-key-p))             (click-unselected-item di (shift-key-p))))    (call-next-method))(defmethod click-unselected-item ((di selectable-dim) shift-p)    (unless shift-p (deselect-all di :draw-now-p t))    (select-item di :draw-now-p t))(defmethod click-selected-item ((di selectable-dim) shift-p)    (when shift-p (deselect-item di :draw-now-p t)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; drawing (hiliting)(defmethod view-draw-contents ((di selectable-dim))    (let ((needs-update (view-needs-update di)))        (call-next-method)        (when needs-update             (when (selected-p di) (hilite-selected-item di t)))))(defmethod hilite-selected-item ((di selectable-dim) hilite-flag)    (with-focused-view (view-container di)         (hilite-view di hilite-flag)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; handling the current selection#|(defmethod mapc-selectable-cluster ((di selectable-dim) fn &optional selected-only-p)    ;;search starts from the item's container    (with-slots (selection-cluster) di         (flet ((map-fn (i) (when (and (eq (selection-cluster i) selection-cluster)                                                             (or (selected-p i) (not selected-only-p)))                                              (funcall fn i))))             (declare (dynamic-extent #'map-fn))             (map-subviews (view-container di) #'map-fn 'selectable-dim))))|#(defmethod mapc-selectable-cluster ((di selectable-dim) fn &optional selected-only-p)    ;;search starts from the item's container    (with-slots (selection-cluster) di         (flet ((map-fn (i) (when (and (eq (selection-cluster i) selection-cluster)                                                             (or (selected-p i) (not selected-only-p)))                                              (funcall fn i))))             (declare (dynamic-extent #'map-fn))             (mapcar #'map-fn (all-selectable-views-in-cluster di)))))(defmethod all-selectable-views-in-cluster ((di selectable-dim))    (let ((root (or (cluster-root di)                              (view-container di))))        (remove-if-not #'(lambda (selectable-view)                                           (eq (selection-cluster di) (selection-cluster selectable-view)))                                    (all-subviews root 'selectable-dim))))                               (defmethod selected-items ((di selectable-dim))    "(di selectable-dim)Returns a list of all the selected items in di's cluster"    (let ((item-list nil))        (flet ((fn (i) (push i item-list)))            (declare (dynamic-extent #'fn))            (mapc-selectable-cluster di #'fn t)            (nreverse item-list))))(defmethod (setf selected-items) (items (di selectable-dim))    (without-interrupts      (deselect-all di)      (dolist (i items) (select-item i))));;;;;;;;;;;;Note: the draw-now-p is provided for using these methods at;;interrupt time (e.g. during click event handling). Normally you;;should let draw-now-p default to nil. If you use a non-nil;;draw-now-p, make sure the current view is focused to the item's;;container.(defmethod select-item ((di selectable-dim) &key draw-now-p)    (unless (selected-p di)        (setf (selected-p di) t)        (if draw-now-p            (hilite-selected-item di t)            (invalidate-view di t))))(defmethod deselect-item ((di selectable-dim) &key draw-now-p)    (when (selected-p di)         (setf (selected-p di) nil)         (if draw-now-p             (hilite-selected-item di nil)             (invalidate-view di t))))(defmethod deselect-all ((di selectable-dim) &key draw-now-p)    (flet ((fn (i) (deselect-item i :draw-now-p draw-now-p)))        (declare (dynamic-extent #'fn))        (mapc-selectable-cluster di #'fn t)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;specializations for handling dragging selections(defmethod set-DragGrayRgn-areas :after ((di selectable-dim) where drag-rgn limitRect slopRect)    ;;specialize the drag-rgn to be the union of all selected items    (declare (ignore where limitRect slopRect))    (with-macptrs ((temp-rgn (#_NewRgn)))         (flet ((add-rgn (i)                        (set-drag-outline-rgn i temp-rgn)                        (#_UnionRgn temp-rgn drag-rgn drag-rgn)))             (declare (dynamic-extent #'add-rgn))             (mapc-selectable-cluster di #'add-rgn t))         (#_DisposeRgn temp-rgn)))(defmethod draggable-p ((di selectable-dim) &optional where)    (declare (ignore where))    ;;Must check if the item is selected before allowing dragging. Normally this    ;;isn't needed cause the click selects the item, but a shift-click can de-select.    (and (selected-p di) (call-next-method)))(defmethod pre-drag-hilite ((di selectable-dim) hilite-flag)    ;;selectable items already hilite when clicked - so do nothing    (declare (ignore di hilite-flag)))(defmethod drag-start-p ((di selectable-dim) where)    ;;*current-drag-selection* is bound for the duration of the drag,     ;;so droppable-p won't have to repeatedly compute the current selection.    (declare (ignore where))    (let ((*current-drag-selection* (selected-items di)))        (declare (special *current-drag-selection*))        (call-next-method)))(defmethod drag-item ((di selectable-dim) where)    ;;*current-drag-selection* is bound for the duration of the drag,     ;;so droppable-p won't have to repeatedly compute the current selection.    (declare (ignore where))    (let ((*current-drag-selection* (selected-items di)))        (declare (special *current-drag-selection*))        (call-next-method)))(defmethod droppable-p ((di selectable-dim) (target simple-view))    ;;disallow dropping on any member of current selection    (declare (special *current-drag-selection*))    (unless (find target *current-drag-selection*)        (call-next-method)));;;;;;;;;;;;3 call action functions specialized to use entire selection(defmethod call-drag-action ((di selectable-dim))    (declare (special *current-drag-selection*))    (if (slot-value di 'all-drag-actions-p)        (dolist (i *current-drag-selection*) (drag-action i))        (drag-action di)))(defmethod call-drag-end-action ((di selectable-dim) drag-offset dest-point)    (if (slot-value di 'all-drag-end-actions-p)        (flet ((fn (i) (drag-end-action i drag-offset dest-point)))            (declare (dynamic-extent #'fn))            (mapc-selectable-cluster di #'fn t))        (drag-end-action di drag-offset dest-point)))(defmethod call-drop-action ((di selectable-dim) (target simple-view) drag-offset dest-point)    (if (slot-value di 'all-drag-end-actions-p)        (flet ((fn (i) (drop-action i target drag-offset dest-point)))            (declare (dynamic-extent #'fn))            (mapc-selectable-cluster di #'fn t))        (drop-action di target drag-offset dest-point)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; selectable dialog items with radio button behavior(defclass selectable-rb-dim (selectable-dim) ())(defmethod click-unselected-item ((di selectable-rb-dim) shift-p)    (declare (ignore shift-p))    (deselect-all di :draw-now-p t)    (select-item di :draw-now-p t))(defmethod click-selected-item ((di selectable-rb-dim) shift-p)    (declare (ignore di shift-p)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; selectable dialog items with check box behavior(defclass selectable-cb-dim (selectable-dim) ())(defmethod click-unselected-item ((di selectable-cb-dim) shift-p)  (declare (ignore shift-p))  (select-item di :draw-now-p t))(defmethod click-selected-item ((di selectable-cb-dim) shift-p)  (declare (ignore shift-p))  (deselect-item di :draw-now-p t));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass nice-hilite-dim ()   ())(defmethod draw-inside-rect ((self nice-hilite-dim))   (with-pen-mode (:PatCopy self)       (with-pen-size (1 1 self)           (frame-rect self  #@(4 4) (subtract-points (view-size self) #@(4 4))))))(defmethod draw-outside-rect ((self nice-hilite-dim))   (with-pen-mode (:PatCopy self)       (with-pen-pattern (*black-pattern* self)           (with-pen-size (3 3 self)               (view-frame self)))       (with-pen-pattern (*white-pattern* self)           (with-pen-size (1 1 self)               (frame-rect self  #@(3 3) (subtract-points (view-size self) #@(3 3)))))       (with-pen-pattern (*black-pattern* self)           (draw-inside-rect self))))(defmethod erase-outside-rect ((self nice-hilite-dim))   (with-pen (:PatCopy *white-pattern* 4 4 self)       (view-frame self)))(defmethod deselect-item :around ((self nice-hilite-dim) &key draw-now-p)     (declare (ignore draw-now-p))    (let ((needs-update (and (selected-p self)                                            (view-needs-update self))))       (call-next-method)       (when needs-update           (with-pen-pattern (*gray-pattern* self)               (draw-inside-rect self))           (erase-outside-rect self))))(defmethod view-draw-contents :around ((self nice-hilite-dim))   (let ((needs-update (view-needs-update self)))      (call-next-method)      (when needs-update          (if (selected-p self)             (with-pen-pattern (*black-pattern* self)                 (draw-outside-rect self)                 (draw-inside-rect self))             (with-pen-pattern (*gray-pattern* self)                 (erase-outside-rect self)                 (draw-inside-rect self))))))(defmethod hilite-view ((self nice-hilite-dim) hilite-flag)   (if hilite-flag       (with-pen-pattern (*black-pattern* self)            (draw-outside-rect self)            (draw-inside-rect self))       (with-pen-pattern (*gray-pattern* self)                 (erase-outside-rect self)                 (draw-inside-rect self))))(defmethod view-cursor ((self nice-hilite-dim) where)   (declare (ignore where))   (if (selected-p self)      *full-hand-cursor*      *pointer-hand-cursor*))#|;;; a modest example - adding select behavior to static text dialog items(defclass stsel (selectable-dim static-text-dialog-item) ());(defclass stsel (selectable-rb-dim static-text-dialog-item) ());(defclass stsel (selectable-cb-dim static-text-dialog-item) ())(setf *test-w*      (make-instance 'dialog                     :window-type :document                     :view-position :centered                     :view-size #@(200 100)                     :window-title "selectable-dim demo"                     :close-box-p t                     :color-p t                     :view-subviews                     (list (make-instance 'stsel                                             :view-position #@(20 20)                                             :dialog-item-text "item 1"                                             :view-nick-name :i1                                             :selection-cluster 1                                             )                           (make-instance 'stsel                                             :view-position #@(20 40)                                             :dialog-item-text "item 2"                                             :view-nick-name :i2                                             :selection-cluster 1                                             )                           (make-instance 'stsel                                             :view-position #@(20 60)                                             :dialog-item-text "Item 3"                                             :view-nick-name :i2                                             :selection-cluster 1                                             )                           )));(selected-items (view-named :i1 *test-w*))|#