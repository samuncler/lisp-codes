(in-package :oou)(oou-provide :save-object-gm);*****************************************************************                                    ;; Copyright © 1991-96 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; saving an object an a file  ; ; ;; Changes (worth to be mentioned):; ------------------------------; none ;;*****************************************************************;*****************************************************************(oou-dependencies :unibas-macros                  :simple-view-ce                  :unibas-cursors                  :with-running-watch                  )(export '(save-mixin load-trigger save-object-in-file read-object-from-file ));---------------------------------------------------------------------------(defvar *read-objects* (make-hash-table :size 500))(defvar *saved-objects* (make-hash-table :size 500));-----------------------------------------------------------------------------(defclass save-mixin ()  ((load-trigger :initform nil                 :accessor load-trigger                 :initarg :load-trigger)));-----------------------------------------------------------------------------; some additional methods(defmethod all-sorted-slot-values ((self save-mixin))  (let ((values nil))    (dolist (slot (all-sorted-slot-names self) (nreverse values))      (push (if (slot-boundp self slot)              (slot-value self slot)              'unbound)            values))))(defmethod all-sorted-slot-names ((self save-mixin))  (sort (nconc (instance-slot-names self)               (class-slot-names self))        #'string<))(defmethod all-slot-values ((self save-mixin))  (let ((values nil))    (dolist (slot (all-slot-names self) (nreverse values))      (push (if (slot-boundp self slot)              (slot-value self slot)              'unbound)            values))))(defmethod all-slot-names ((self save-mixin))  (instance-slot-names self)); in an older version there were all class slots saved. This is not necessary in this application;   (nconc (instance-slot-names self);              (class-slot-names self)))(defmethod instance-slot-names ((self  save-mixin))  (do* ((slot-vector (cdr (slot-value (class-of self) 'ccl::slots)))        (vector-length (length slot-vector))        (i 0 (1+ i))        (slot-names nil))       ((>= i vector-length) slot-names)    (push (car (aref slot-vector i))          slot-names)))(defmethod class-slot-names ((self  save-mixin))  (do ((slot-list (car (slot-value (class-of self) 'ccl::slots)) (cdr slot-list))       (slot-names nil))      ((null slot-list) slot-names)    (push (caar slot-list)          slot-names)));-----------------------------------------------------------------------------(defmethod reinitialize-object ((self save-mixin) valuelist identification)  (dolist (slot (all-slot-names self))    (setf (slot-value self slot) (pop valuelist)))  (setf (load-trigger self) nil)  (setf (gethash identification *read-objects*) self)  self)(defmethod save-object-in-file ((self save-mixin) filename)  (with-running-watch    (clrhash *saved-objects*)    (with-open-stream (stream (open filename                                     :direction :io                                    :if-does-not-exist :create                                     :if-exists :supersede))      (format stream               "(in-package :oou)~%(defvar *object-in-file* nil)~%(setf *object-in-file* '~S)"              (list-of-saved-objects self))      (set-mac-file-type filename :text))    (let ((fasl-file (compile-file filename :save-definitions nil)))      (rename-file fasl-file filename :if-exists :supersede)      )    *saved-objects*))(defmethod external-form ((ob save-mixin))  (clrhash *saved-objects*)  (format nil          "(progn (defvar oou::*object-in-file* nil)~%(setf oou::*object-in-file* '~S))"          (list-of-saved-objects ob)));-----------------------------------------------------------------------------;-----------------------------------------------------------------------------; Function for saving(defun list-of-saved-objects (self)  (cond ((null self) nil)        ((and (listp self)              (cdr self))         (cons (list-of-saved-objects (car self))               (list-of-saved-objects (cdr self) )))        ((listp self)         (list (list-of-saved-objects (car self))))        ((pathnamep self)                                      ; exception saved in a special way         (list* '*save-pathname*                         ; do the inverse exception handling during loading                (namestring self)))        ((and (typep self 'save-mixin)              (null (gethash self *saved-objects*)))         (let ((identification (hash-table-count *saved-objects*)))           (setf (gethash self *saved-objects*) identification)           (list '*save-object*                 (class-name (class-of self))                 (list-of-saved-objects (all-slot-values self))                 identification)))        ((typep self 'save-mixin)         (list* '*save-open-reference*                (gethash self *saved-objects*)))        ((unsaved-type-p self)         nil)        (t self)))(defun unsaved-type-p (item)  "exceptions, which shouldn't be saved. nil is saved instead"  (or (typep item 'ccl::buffer-mark)                  (typep item 'stream)                                 (typep item 'ccl::menu-element)      (typep item 'macptr)));-----------------------------------------------------------------------------; functions for loading(defun read-object-from-file (filename)  (declare (special *object-in-file*))  (with-running-watch    (clrhash *read-objects*)    (let ((warning *warn-if-redefine*))      (setf *warn-if-redefine* nil)      (load filename :verbose nil :print nil)      (setf *warn-if-redefine* warning))    (reinstall-objects *object-in-file*)    (maphash #'(lambda (key value)                 (declare (ignore key))                 (install-open-refs-and-reset value))             *read-objects*)    (gethash 0 *read-objects*)))(defun read-object-from-resource-fork (filename rsrc-id)  (declare (special *object-in-file*))  (clrhash *read-objects*)  (let* ((external-form (get-string-from-resource-fork filename rsrc-id))         (warning *warn-if-redefine*))    (when external-form      (setf *warn-if-redefine* nil)      (eval (read-from-string external-form nil))      (setf *warn-if-redefine* warning)      (reinstall-objects *object-in-file*)      (maphash #'(lambda (key value)                   (declare (ignore key))                   (install-open-refs-and-reset value))               *read-objects*)      (gethash 0 *read-objects*)      )))(defun reinstall-objects (list-of-objects)  (cond ((null list-of-objects) nil)        ((and (listp list-of-objects)              (eq (car list-of-objects) '*save-object*))         (let ((class-name (second list-of-objects))               (arg-list (reinstall-objects (third list-of-objects)))               (identification (fourth list-of-objects)))           (reinitialize-object  (make-instance class-name :load-trigger t)                                  arg-list                                 identification)))        ((and (listp list-of-objects)              (eq (car list-of-objects) '*save-pathname*))         (full-pathname (cdr list-of-objects)))        ((and (listp list-of-objects)              (cdr list-of-objects))         (cons (reinstall-objects (car list-of-objects))               (reinstall-objects (cdr list-of-objects))))        ((listp list-of-objects)         (list  (reinstall-objects (car list-of-objects))))        (t list-of-objects)))(defun install-open-refs-and-reset (list-of-objects)  (cond ((null list-of-objects) nil)        ((and (listp list-of-objects)              (eq (car list-of-objects) '*save-open-reference*))         (identifier-known-p (cdr list-of-objects)))        ((listp list-of-objects)         (cons (install-open-refs-and-reset (car list-of-objects))               (install-open-refs-and-reset (cdr list-of-objects))))        ((and (typep list-of-objects 'save-mixin)              (not (load-trigger list-of-objects)))         (dolist (slot-name (all-slot-names list-of-objects))           (let ((value (slot-value list-of-objects slot-name)))             (cond ((eq value 'unbound)                    (slot-makunbound list-of-objects slot-name))                   ((listp value)                    (setf (slot-value list-of-objects slot-name)                          (install-open-refs-and-reset value))))             (setf (load-trigger list-of-objects) t)))         list-of-objects)        (t list-of-objects)))(defun identifier-known-p (identification)  (gethash identification *read-objects*))