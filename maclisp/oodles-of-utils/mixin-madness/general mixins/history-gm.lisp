(in-package :oou)(oou-provide :history-gm);*****************************************************************                                    ;; Copyright © 1991-96 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; a mixin for saving the state of an application; ;; Changes (worth to be mentioned):; ------------------------------; 1/9/92    Dieter : 'restore-last-state' added. It restores the prededing state of the ;                              current state; 1/10/92  Dieter : 'reset-history' added. Sets the current history state to the root.;                             But the history isn't deleted ;;*****************************************************************;*****************************************************************(oou-dependencies :QuickDraw-u                              :unibas-cursors                              :shrinked-view-di                              :selectable-dim                              :double-click-dim                              )(export '(save-state clear-history                menu-history-mixin history-class history-menu restore-function               visual-history-mixin visualization-view view-to-visualize                default-view-size bookmark-direction               current-restore-information restore-last-state clear reset-history               ));---------------------------------------------------------------------------(defun default-restore-function (restoring-object restore-information)   (declare (ignore restoring-object restore-information))   (message-dialog "You should define a restore-function to be able to reestablish a former state.This has to be a function with two arguments: The responible object for the reestablishment and the stored information.The function's name has to be stored in the slot 'restore-function'."                              :size #@(550 200)))(defun all-states (state)   (cond ((null state) nil)             ((listp state) (append (all-states (cdr state))                                                (all-states (car state))))             (t (cons state                          (append (all-states (cdr (following-states state)))                                       (all-states (car (following-states state))))))))                            ;------------------------------------------------------------------------------------(defclass unibas-history-meta-class (standard-class)   ((state-class :initform nil                         :initarg :state-class                         :accessor state-class)     (root :initform nil             :accessor root)     (restore-function :initform 'default-restore-function                                  :accessor restore-function                                  :initarg :restore-function)     (restoring-object :initform nil                                  :accessor restoring-object                                  :initarg :restoring-object)     (current-history-state :initform nil                                          :accessor current-history-state)))(defclass unibas-menu-history-meta-class (unibas-history-meta-class)   ((history-menu :initform nil                             :accessor history-menu                             :initarg :history-menu)))(defclass unibas-visual-history-meta-class (unibas-history-meta-class)   ((visualization-view :initform nil                                     :accessor visualization-view                                     :initarg :visualization-view)     (view-to-visualize :initform nil                                    :accessor view-to-visualize                                    :initarg :view-to-visualize)     (default-view-size :initform #@(100 100)                                    :accessor default-view-size                                    :initarg :default-view-size)     (bookmark-direction :initform :vertical                                      :accessor bookmark-direction                                      :initarg :bookmark-direction)     (bookmark-class :initform 'bookmark                                :accessor bookmark-class                                :initarg :bookmark-class)));-------------------------------------------------------------------------------------(defclass unibas-history-state ()   ((preceding-state :initform nil                                :initarg :preceding-state                                :accessor preceding-state)     (following-states :initform nil                                  :initarg :following-states                                  :accessor following-states                                  :documentation "all states in REVERSE order of their appearence")     (printed-information :initform nil                                       :accessor printed-information                                       :initarg :printed-information                                       :documentation "a string to be printed in the presentation of the state")     (restore-information :initform nil                                       :initarg :restore-information                                       :accessor restore-information                                       :documentation "contains a list to be send as an argument to the restore function")     )   (:metaclass unibas-history-meta-class))(defmethod depth ((self unibas-history-state))   (do ((depth 0 (1+ depth))          (prec-state (preceding-state self)                             (preceding-state prec-state)))         ((null prec-state) depth)));-------------------------------------------------------------------------------------(defclass unibas-menu-history-state (unibas-history-state)   ((menu-item :initform nil                         :accessor menu-item))   (:metaclass unibas-menu-history-meta-class))(defmethod initialize-instance :after ((self unibas-menu-history-state) &rest initargs)   (declare (ignore initargs))   (with-slots (printed-information restore-information menu-item) self       (setf menu-item                (make-instance 'menu-item-with-help                                          :menu-item-title (format nil                                                                                    (format nil                                                                                                "~~~DT~~A~~%"                                                                                                (* (depth self) 3))                                                                                    (or printed-information                                                                                         (format nil "~A" restore-information)))                                          :update-function                                           (eval `(function (lambda (menu-item)                                                                      (if (eq (current-history-state ,(class-of self)) ,self)                                                                         (set-menu-item-style menu-item :italic)                                                                         (set-menu-item-style menu-item :plain)))))                                          :menu-item-action                                          (eval `(function (lambda ()                                                                      (restore-state ,(class-of self) ,self))))))));-------------------------------------------------------------------------------------(defclass bookmark (nice-hilite-dim double-click-dim selectable-rb-dim shrinked-view-di)   ()   (:default-initargs      :margin 5 ))(defmethod draw-inside-rect :after ((self bookmark))   (with-pen-size (1 1 self)       (paint-rect self (subtract-points                                   (subtract-points (view-size self) #@(4 4))                                  (make-point (handle-size self) (handle-size self)))                          (subtract-points (view-size self) #@(4 4)))));-------------------------------------------------------------------------------------(defclass unibas-visual-history-state (unibas-history-state)   ((shrinked-view :initform nil                             :accessor shrinked-view))   (:metaclass unibas-visual-history-meta-class))(defmethod initialize-instance :after ((self unibas-visual-history-state) &rest initargs)   (declare (ignore initargs))   (with-slots (shrinked-view default-view-size) self       (let ((view-to-visualize (view-to-visualize (class-of self))))          (setf shrinked-view                   (make-instance (bookmark-class (class-of self))                                              :picture (get-picture-from-view view-to-visualize)                                             :drop-target-class (class-name (class-of view-to-visualize))                                             :drop-targets (list view-to-visualize)                                             :drop-action-fn                                              (eval `(function (lambda (shrinked-view target offset where)                                                                         (declare (ignore where))                                                                         (explode (view-to-global (view-container shrinked-view)                                                                                                                  (add-points (view-position shrinked-view)                                                                                                                                    offset))                                                                                       (view-to-global (view-container shrinked-view)                                                                                                                  (add-points (add-points (view-position shrinked-view)                                                                                                                                                       offset)                                                                                                                                    (view-size shrinked-view)))                                                                                       (view-to-global target #@(0 0))                                                                                       (view-to-global target (view-size target)))                                                                         (restore-state ,(class-of self) ,self))))                                             :drag-bounds :window                                             :dialog-item-double-click-action                                             (eval `(function (lambda (shrinked-view)                                                                         (view-explode shrinked-view                                                                                                  (view-to-global ,view-to-visualize #@(0 0))                                                                                                 (view-to-global ,view-to-visualize ,(view-size view-to-visualize)))                                                                         (restore-state ,(class-of self) ,self))))                                             :selection-cluster view-to-visualize                                             :view-size (default-view-size (class-of self))                                             :view-position (get-new-position (class-of self))                                             :view-container (visualization-view (class-of self))))          (make-view-completely-visible shrinked-view)          (deselect-all shrinked-view :draw-now-p t)          (select-item shrinked-view :draw-now-p t))))                                          ;-------------------------------------------------------------------------------------(defmethod save-state ((class unibas-history-meta-class) restore-information                                                                                                &optional (printed-information nil))   (with-slots (state-class root current-history-state) class       (let ((new-state (make-instance state-class                                                           :preceding-state (current-history-state class)                                                           :restore-information restore-information                                                           :printed-information printed-information)))          (when current-history-state              (push new-state (following-states current-history-state))              (setf (preceding-state new-state) current-history-state))          (unless root             (setf root new-state))          (setf current-history-state new-state))))(defmethod restore-state ((class unibas-history-meta-class) state)   (setf (current-history-state class) state)   (funcall (restore-function class) (restoring-object class) (restore-information state)))(defmethod restore-last-state ((class unibas-history-meta-class))   (let ((state-to-restore (preceding-state (current-history-state class))))      (if state-to-restore         (restore-state class state-to-restore)         (ed-beep))))(defmethod states ((class unibas-history-meta-class))   (all-states (root class)))(defmethod clear-history ((class unibas-history-meta-class))   (with-slots (root current-history-state) class       (setf root nil)       (setf current-history-state nil)))(defmethod reset-history ((class unibas-history-meta-class))   (with-slots (root current-history-state) class       (setf current-history-state root)));-------------------------------------------------------------------------------------(defmethod save-state :after ((class unibas-menu-history-meta-class) restore-information                                                 &optional (printed-information nil))   (declare (ignore restore-information printed-information))   (with-slots (history-menu) class       (when history-menu           (apply #'remove-menu-items history-menu (menu-items history-menu))           (apply  #'add-menu-items history-menu (history-menu-items class)))))(defmethod history-menu-items ((class unibas-menu-history-meta-class))   (mapcar #'menu-item (states class)))(defmethod clear-history :after ((class unibas-menu-history-meta-class))    (with-slots (history-menu) class        (when history-menu            (apply #'remove-menu-items history-menu (menu-items history-menu)))));-------------------------------------------------------------------------------------(defmethod get-new-position ((class unibas-visual-history-meta-class))   (let ((states (states class))           (margin 5))      (if states         (if (eq (bookmark-direction class) :vertical)            (make-point              margin              (+ (apply #'max (mapcar #'(lambda (item)                                                          (view-bottom item))                                                     (mapcar #'shrinked-view states)))                  margin))            (make-point              (+ (apply #'max (mapcar #'(lambda (item)                                                          (view-right item))                                                     (mapcar #'shrinked-view states)))                  margin)              (apply #'max (mapcar #'(lambda (item)                                                      (view-top item))                                                 (mapcar #'shrinked-view states)))))         (make-point margin margin))))(defmethod clear-history :after ((class unibas-visual-history-meta-class))    (with-slots (visualization-view) class        (apply #'remove-subviews visualization-view (subviews visualization-view))));-------------------------------------------------------------------------------------;-------------------------------------------------------------------------------------(defclass history-mixin ()   ((history-class :initform nil                            :accessor history-class)     (restore-function :initform nil                                  :initarg :restore-function                                  :accessor restore-function)))(defmethod (setf restore-function) :after (newvalue (self history-mixin))     (setf (restore-function (history-class self)) newvalue))(defmethod save-state ((self history-mixin) restore-information &optional (printed-information nil))   "Saves all the given informations in a adequate way. The information should be a list of all items    needed to reestablish the current state. "    (save-state (history-class self) restore-information printed-information))(defmethod restore-last-state ((self history-mixin))   (restore-last-state (history-class self)))(defmethod current-restore-information ((self history-mixin))   (restore-information (current-history-state (history-class self))))   (defmethod clear-history ((self history-mixin))   (clear-history (history-class self)))(defmethod reset-history ((self history-mixin))   (reset-history (history-class self)));-------------------------------------------------------------------------------------(defclass menu-history-mixin (history-mixin)   ((history-menu :initform nil                             :initarg :history-menu                             :accessor history-menu)))(defmethod initialize-instance :around ((self menu-history-mixin) &rest initargs)    (declare (ignore initargs))    (let ((new-history-class (eval `(defclass ,(gensym "history-class") (unibas-menu-history-state)                                                         ()                                                         (:metaclass unibas-menu-history-meta-class)))))       (setf (history-class self) new-history-class)       (setf (state-class new-history-class) new-history-class)       (setf (restoring-object new-history-class) self)       (call-next-method)       (setf (history-menu new-history-class) (history-menu self))       (when (restore-function self)           (setf (restore-function new-history-class) (restore-function self)))))(defmethod (setf history-menu) :after (newvalue (self menu-history-mixin))     (setf (history-menu (history-class self)) newvalue))(defmethod history-menu-items ((self menu-history-mixin))   "Gives a list of menu items. One item correspond to a saved state. The menu item action calls the    restore function of <self>, which is responsible for reestablishing the former state."   (history-menu-items (history-class self)));-------------------------------------------------------------------------------------(defclass visual-history-mixin (history-mixin)   ((visualization-view :initform nil                                     :initarg :visualization-view                                     :accessor visualization-view)     (view-to-visualize :initform nil                                    :initarg :view-to-visualize                                    :accessor view-to-visualize)     (default-view-size :initform #@(100 100)                                    :initarg :default-view-size                                    :accessor default-view-size)     (bookmark-direction :initform :vertical                                      :accessor bookmark-direction                                      :initarg :bookmark-direction)     (bookmark-class :initform 'bookmark                                :initarg :bookmark-class                                :accessor bookmark-class)))(defmethod initialize-instance :around ((self visual-history-mixin) &rest initargs)    (declare (ignore initargs))    (let ((new-history-class (eval `(defclass ,(gensym "history-class") (unibas-visual-history-state)                                                         ()                                                         (:metaclass unibas-visual-history-meta-class)))))       (setf (history-class self) new-history-class)       (setf (state-class new-history-class) new-history-class)       (setf (restoring-object new-history-class) self)       (call-next-method)       (setf (default-view-size new-history-class) (default-view-size self))       (setf (view-to-visualize new-history-class) (view-to-visualize self))       (setf (visualization-view new-history-class) (visualization-view self))       (setf (bookmark-direction new-history-class) (bookmark-direction self))       (setf (bookmark-class new-history-class) (bookmark-class self))       (when (restore-function self)           (setf (restore-function new-history-class) (restore-function self)))))(defmethod (setf visualization-view) :after (newvalue (self visual-history-mixin))     (setf (visualization-view (history-class self)) newvalue))(defmethod (setf view-to-visualize) :after (newvalue (self visual-history-mixin))     (setf (view-to-visualize (history-class self)) newvalue))(defmethod (setf default-view-size) :after (newvalue (self visual-history-mixin))     (setf (default-view-size (history-class self)) newvalue))(defmethod (setf bookmark-direction) :after (newvalue (self visual-history-mixin))     (setf (bookmark-direction (history-class self)) newvalue));-------------------------------------------------------------------------------------(oou-dependencies :help-svm)  ;-------------------------------------------------------------------------------------#|(defclass window-with-history (menu-history-mixin window)   ()   (:default-initargs :window-type :document                               :view-size #@(220 100)                               :view-position '(:top 40)                               :window-title "History"))(defmethod initialize-instance :after ((self window-with-history) &rest initargs)    (declare (ignore initargs))    (let ((editable-text (make-instance 'editable-text-dialog-item                                                      :view-nick-name :editable-text                                                      :dialog-item-text "initial text"                                                      :view-size #@(200 20)                                                      :view-position #@( 10 10)))            (save-button (make-instance 'button-dialog-item                                                      :dialog-item-action 'save-state-of-window                                                      :dialog-item-text "Save"                                                      :view-position #@(10 60)))            (history-menu (make-instance 'pop-up-menu                                                       :item-display "History"                                                      :view-nick-name :history-menu                                                      :view-position #@(120 60))))       (add-subviews self editable-text save-button history-menu)       (setf (restore-function self) 'get-back-to-former-state)       (setf (history-menu self) history-menu)))(defmethod get-back-to-former-state ((self window-with-history) restore-information)   "use the stored information to get the former state"   (let ((text (car restore-information))           (cursor-position (cdr restore-information))           (fred-buffer (fred-buffer (view-named :editable-text self)))           (dialog-item (view-named :editable-text self)))      (set-dialog-item-text dialog-item text)      (set-mark fred-buffer cursor-position)))(defun save-state-of-window (button)   (let* ((window (view-container button))             (editable-text-dialog-item (view-named :editable-text window))             (history-menu (view-named :history-menu window))             (text-to-save (dialog-item-text editable-text-dialog-item))             (cursor-position-to-save (buffer-position (fred-buffer editable-text-dialog-item))))      ;save all the information needed for getting in the same state       (save-state window                              (list* text-to-save cursor-position-to-save) ;information                             text-to-save) ;printed information      )) (setf hw (make-instance 'window-with-history));-------------------------------------------------------------------------------------(defclass window-with-visual-history (visual-history-mixin window)   ()   (:default-initargs :window-type :document                               :bookmark-direction :horizontal                               :view-size #@(330 220)                               :view-position '(:top 40)                               :window-title "Bookmarks"                               :default-view-size #@(80 15)))(defmethod view-draw-contents :after ((self window-with-visual-history))    (when (view-named :bookmark-view self)        (view-frame-outside (view-named :bookmark-view self))))(defmethod initialize-instance :after ((self window-with-visual-history) &rest initargs)    (declare (ignore initargs))    (let ((editable-text (make-instance 'editable-text-dialog-item                                                      :view-nick-name :editable-text                                                      :dialog-item-text "initial text"                                                      :view-size #@(300 20)                                                      :view-position #@( 10 10)))            (save-button (make-instance 'button-dialog-item                                                      :dialog-item-action 'save-state-of-window                                                      :dialog-item-text "Save"                                                      :view-position #@(10 60)))            (visualization-view (make-instance 'view                                                                      :view-position #@(10 100)                                                                      :view-size #@(300 100)                                                                      :view-nick-name :bookmark-view)))       (add-subviews self editable-text save-button visualization-view)       (setf (restore-function self) 'get-back-to-former-state)       (setf (view-to-visualize self) editable-text)      (setf (visualization-view self) visualization-view)))(defmethod get-back-to-former-state ((self window-with-visual-history) restore-information)   "use the stored information to get the former state"   (let ((text (car restore-information))           (cursor-position (cdr restore-information))           (fred-buffer (fred-buffer (view-named :editable-text self)))           (dialog-item (view-named :editable-text self)))      (set-dialog-item-text dialog-item text)      (set-mark fred-buffer cursor-position)))(defun save-state-of-window (button)   (let* ((window (view-container button))             (editable-text-dialog-item (view-named :editable-text window))             (text-to-save (dialog-item-text editable-text-dialog-item))             (cursor-position-to-save (buffer-position (fred-buffer editable-text-dialog-item))))      ;save all the information needed for getting in the same state       (save-state window                              (list* text-to-save cursor-position-to-save) ;information                             text-to-save) ;printed information      )) (setf hw2 (make-instance 'window-with-visual-history)) |#