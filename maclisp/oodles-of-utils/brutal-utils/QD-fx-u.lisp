(in-package  :oou)(oou-provide :QD-fx-u);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; QD-fx-u.lisp;;;; Copyright © 1992 Northwestern University Institute for the Learning Sciences;; All Rights Reserved;;;; author: Michael S. Engber;;         Rich Lynch (much faster version of wipe effects);;;; utilites for various special effects;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(oou-dependencies :records-u                  :macptr-u                  :QuickDraw-u                  :GWorld-view                  )(export '(dissolve-o-rama wipe-o-rama iris-of-rama          map-pat-masks map-iris-masks          ));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; dissolve effects;;Hex rep of special effect pattern lists (list of eight 8x8 1bit Patterns);; - the 1st two bytes (4 hex digits) are the number of patterns;; - the remaning bytes are raw pattern data;; - this format is the same as PAT# resources;; - you can use ResEdit to create/view them by copying/pasting hex strings;;   between Fred and ResEdit's hex editor (pretty convenient, eh?);;    - normally PAT#'s open into a nice template editor;;    - to edit a PAT# in hex, option double-click;;    - from the hex editor you can use select-all, copy, and paste(defvar *QD-fx-pats*  '(    :transporter  "000804200210800108404001100804208002108008200240040102084001200410800110048008024020200280044010010808400102108020048004204001080210"    :screen-door  "000880100240080120044008012004801002200480100240080110024008012004800801200480100240048010024008012002400801200480100120048010024008"    :waynes-world "000801808001010202011008081010202010080404080810100880404080800101802010102020404020040202040408080440202040408080400201010202040402"    :v-blind      "000880808080808080804040404040404040202020202020202010101010101010100808080808080808040404040404040402020202020202020101010101010101"    :h-blind      "0008FF0000000000000000FF0000000000000000FF0000000000000000FF0000000000000000FF0000000000000000FF0000000000000000FF0000000000000000FF"    ))(defun map-pat-masks (fn mask-rect pat-hex-string)  (let ((pat-count (parse-integer pat-hex-string :end 4 :radix 16)))    (%stack-block ((pat-list_p (ceiling (length pat-hex-string) 2)))      (%put-hex-str pat-list_p pat-hex-string)      (%incf-ptr pat-list_p 2)      (let ((gw-view (make-instance 'GWorld-view                       :GW-depth 1                       :view-position (pref mask-rect :Rect.topLeft)                       :view-size     (subtract-points (pref mask-rect :Rect.botRight)                                                       (pref mask-rect :Rect.topLeft)))))        (GWorld-alloc gw-view)        (unwind-protect          (dotimes (i pat-count)            (with-focused-view gw-view              (#_FillRect mask-rect pat-list_p))            (with-locked-GWorld-view gw-view              (funcall fn (view-portBits gw-view)))            (%incf-ptr pat-list_p (rlength :Pattern)))          (GWorld-free gw-view))))))(defun copy-thru-pats (src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks pat-hex-string)  (rlet ((mask-rect :Rect                    :topLeft #@(0 0)                    :botRight (subtract-points (pref dest-rect :Rect.botRight)                                               (pref dest-rect :Rect.topLeft))))    (with-current-portBits cur-portBits      (flet ((off-copy (mask-portBits)               (#_CopyDeepMask src-portBits mask-portBits cur-portBits src-rect mask-rect dest-rect copy-mode copy-rgn)               (rlet ((finalTicks_p :longint))                 (#_Delay delay-ticks finalTicks_p))))        (declare (dynamic-extent #'off-copy))        (map-pat-masks #'off-copy mask-rect pat-hex-string)))))(defun dissolve-o-rama (src-portBits src-rect dest-rect                                     &key                                     (copy-mode     #$srcCopy)                                     (copy-rgn      (%null-ptr))                                     (delay-ticks   0)                                     (dissolve-type :transporter))  (copy-thru-pats src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks                  (getf *QD-fx-pats* dissolve-type (second *QD-fx-pats*))))                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; wipe effects(defun copy-thru-wipe (src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks wipe-direction wipe-count)  (let* ((src-size   (subtract-points (pref src-rect :rect.botright)  (pref src-rect :rect.topleft)))         (dst-size   (subtract-points (pref dest-rect :rect.botright) (pref dest-rect :rect.topleft)))         (src-width  (point-h src-size))         (src-height (point-v src-size))         (dst-width  (point-h dst-size))         (dst-height (point-v dst-size))         (src-dh 0)         (src-dv 0)         (dst-dh 0)         (dst-dv 0))    (decf wipe-count)    (rlet ((src-wipe :rect :topleft #@(0 0) :botright src-size)           (dst-wipe :rect :topleft #@(0 0) :botright dst-size)           (tick-count :longint))      (ecase wipe-direction        (:left-to-right         (setf src-dh (floor src-width wipe-count))         (pset src-wipe :rect.right src-dh)         (setf dst-dh (floor dst-width wipe-count))         (pset dst-wipe :rect.right dst-dh))        (:right-to-left         (setf src-dh (- (floor src-width wipe-count)))         (pset src-wipe :rect.left (+ src-width src-dh))         (setf dst-dh (- (floor dst-width wipe-count)))         (pset dst-wipe :rect.left (+ dst-width dst-dh)))        (:top-to-bottom         (setf src-dv (floor src-height wipe-count))         (pset src-wipe :rect.bottom src-dv)         (setf dst-dv (floor src-height wipe-count))         (pset dst-wipe :rect.bottom dst-dv))        (:bottom-to-top ;God knows who would want it...Raymie!         (setf src-dv (- (floor src-height wipe-count)))         (pset src-wipe :rect.top (+ src-height src-dv))         (setf dst-dv (- (floor dst-height wipe-count)))         (pset dst-wipe :rect.top (+ dst-height dst-dv))))      (with-current-portbits cur-portBits        (dotimes (i wipe-count)          (#_CopyBits src-portBits cur-portBits src-wipe dst-wipe copy-mode copy-rgn)          (#_Delay delay-ticks tick-count)          (incf (pref src-wipe :rect.left) src-dh)          (incf (pref src-wipe :rect.top) src-dv)          (incf (pref src-wipe :rect.right) src-dh)          (incf (pref src-wipe :rect.bottom) src-dv)          (incf (pref dst-wipe :rect.left) dst-dh)          (incf (pref dst-wipe :rect.top) dst-dv)          (incf (pref dst-wipe :rect.right) dst-dh)          (incf (pref dst-wipe :rect.bottom) dst-dv))        (ecase wipe-direction          (:left-to-right           (pset src-wipe :rect.right src-width)           (pset dst-wipe :rect.right dst-width))          (:right-to-left           (pset src-wipe :rect.left 0)           (pset dst-wipe :rect.left 0))          (:top-to-bottom           (pset src-wipe :rect.bottom src-height)           (pset dst-wipe :rect.bottom dst-height))          (:bottom-to-top           (pset src-wipe :rect.top 0)           (pset dst-wipe :rect.top 0)))        (#_CopyBits src-portBits cur-portBits src-wipe dst-wipe copy-mode copy-rgn)))))(defun wipe-o-rama (src-portBits src-rect dest-rect                                 &key                                 (copy-mode      #$srcCopy)                                 (copy-rgn       (%null-ptr))                                 (delay-ticks    0)                                 (wipe-direction :left-to-right)                                 (wipe-count     10))  (copy-thru-wipe src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks wipe-direction wipe-count));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; iris effects(defun map-round-iris-masks (fn mask-rect iris-direction iris-count)  (let* ((mask-width  (- (pref mask-rect :Rect.right)  (pref mask-rect :Rect.left)))         (mask-height (- (pref mask-rect :Rect.bottom) (pref mask-rect :Rect.top)))         (diameter    (ceiling (max mask-width mask-height) (1- iris-count)))         (radius      (ceiling diameter 2))         (dr          (ecase iris-direction (:outward (- radius)) (:inward radius)))         (radius-arm (make-point radius radius))         (center (make-point (round (+ (pref mask-rect :Rect.right)  (pref mask-rect :Rect.left)) 2)                             (round (+ (pref mask-rect :Rect.bottom) (pref mask-rect :Rect.top))  2))))    (rlet ((iris-rect :Rect)           (last-iris :Rect))      (ecase iris-direction        (:outward (pset iris-rect :Rect.topLeft  (subtract-points center radius-arm))                  (pset iris-rect :Rect.botRight (add-points      center radius-arm))                  (pset last-iris :Rect.topLeft  #@(-1 -1))                  (pset last-iris :Rect.botRight #@(-2 -2)))        (:inward  (let ((nradius-arm (make-point (* iris-count radius) (* iris-count radius))))                    (pset iris-rect :Rect.topLeft (subtract-points center nradius-arm))                    (pset iris-rect :Rect.botRight (add-points center nradius-arm)))                  (pset last-iris :Rect.topLeft  #@(-16000 -16000))                  (pset last-iris :Rect.botRight #@(16000 16000))))      (let ((gw-view (make-instance 'GWorld-view                       :GW-depth 1                       :view-position (pref mask-rect :Rect.topLeft)                       :view-size     (subtract-points (pref mask-rect :Rect.botRight)                                                       (pref mask-rect :Rect.topLeft)))))        (GWorld-alloc gw-view)        (unwind-protect          (progn            (with-focused-view gw-view              (#_EraseRect mask-rect))            (dotimes (i (1- iris-count))              (with-focused-view gw-view                (ecase iris-direction                  (:outward (#_FillOval  iris-rect *black-pattern*)                            (#_EraseOval last-iris))                  (:inward  (#_EraseRect mask-rect)                            (#_FillOval  last-iris *black-pattern*)                            (#_EraseOval iris-rect))))              (with-locked-GWorld-view gw-view                (funcall fn (view-portBits gw-view)))              (pset last-iris :Rect iris-rect)              (#_InsetRect iris-rect dr dr))                        (with-focused-view gw-view              (ecase iris-direction                (:outward  (#_FillOval last-iris *black-pattern*)                           (#_InvertRect mask-rect))                (:inward   (#_FillOval last-iris *black-pattern*))))            (with-locked-GWorld-view gw-view              (funcall fn (view-portBits gw-view))))          (GWorld-free gw-view))))))(defun copy-thru-round-iris (src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks iris-direction iris-count)  (rlet ((mask-rect :Rect                    :topLeft #@(0 0)                    :botRight (subtract-points (pref dest-rect :Rect.botRight)                                               (pref dest-rect :Rect.topLeft))))    (with-current-portBits cur-portBits      (flet ((off-copy (mask-portBits)               (#_CopyDeepMask src-portBits mask-portBits cur-portBits src-rect mask-rect dest-rect copy-mode copy-rgn)               (rlet ((finalTicks_p :longint))                 (#_Delay delay-ticks finalTicks_p))))        (declare (dynamic-extent #'off-copy))        (map-round-iris-masks #'off-copy mask-rect iris-direction iris-count)))))(defun map-square-iris-masks (fn mask-rect iris-direction iris-count)  (let* ((mask-width  (- (pref mask-rect :Rect.right)  (pref mask-rect :Rect.left)))         (mask-height (- (pref mask-rect :Rect.bottom) (pref mask-rect :Rect.top)))         (diameter    (ceiling (max mask-width mask-height) iris-count))         (radius      (ceiling diameter 2))         (dr          (ecase iris-direction (:outward (- radius)) (:inward radius)))         (radius-arm (make-point radius radius))         (center (make-point (round (+ (pref mask-rect :Rect.right)  (pref mask-rect :Rect.left)) 2)                             (round (+ (pref mask-rect :Rect.bottom) (pref mask-rect :Rect.top))  2))))    (rlet ((iris-rect :Rect)           (last-iris :Rect))      (ecase iris-direction        (:outward (pset iris-rect :Rect.topLeft  (subtract-points center radius-arm))                  (pset iris-rect :Rect.botRight (add-points center radius-arm))                  (pset last-iris :Rect.topLeft  #@(-1 -1))                  (pset last-iris :Rect.botRight #@(-2 -2)))        (:inward  (let ((nradius-arm (make-point (* iris-count radius) (* iris-count radius))))                    (pset iris-rect :Rect.topLeft (subtract-points center nradius-arm))                    (pset iris-rect :Rect.botRight (add-points center nradius-arm)))                  (pset last-iris :Rect mask-rect)                  (#_InsetRect iris-rect dr dr)))      (let ((gw-view (make-instance 'GWorld-view                       :GW-depth 1                       :view-position (pref mask-rect :Rect.topLeft)                       :view-size     (subtract-points (pref mask-rect :Rect.botRight)                                                       (pref mask-rect :Rect.topLeft)))))        (GWorld-alloc gw-view)        (unwind-protect          (progn            (with-focused-view gw-view              (#_EraseRect mask-rect))            (dotimes (i iris-count)              (with-focused-view gw-view                (ecase iris-direction                  (:outward (#_FillRect  iris-rect *black-pattern*)                            (#_EraseRect last-iris))                  (:inward  (#_EraseRect mask-rect)                            (#_FillRect  last-iris *black-pattern*)                            (#_EraseRect iris-rect))))              (with-locked-GWorld-view gw-view                (funcall fn (view-portBits gw-view)))              (pset last-iris :Rect iris-rect)              (#_InsetRect iris-rect dr dr)))          (GWorld-free gw-view))))))(defun copy-thru-square-iris (src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks iris-direction iris-count)  (rlet ((mask-rect :Rect                    :topLeft #@(0 0)                    :botRight (subtract-points (pref dest-rect :Rect.botRight)                                               (pref dest-rect :Rect.topLeft))))    (with-current-portBits cur-portBits      (flet ((off-copy (mask-portBits)               (#_CopyDeepMask src-portBits mask-portBits cur-portBits src-rect mask-rect dest-rect copy-mode copy-rgn)               (rlet ((finalTicks_p :longint))                 (#_Delay delay-ticks finalTicks_p))))        (declare (dynamic-extent #'off-copy))        (map-square-iris-masks #'off-copy mask-rect iris-direction iris-count)))))(defun iris-o-rama (src-portBits src-rect dest-rect                            &key                            (copy-mode      #$srcCopy)                            (copy-rgn       (%null-ptr))                            (delay-ticks    0)                            (iris-direction :outward)                            (iris-count     8)                            (iris-shape     :round))  (ecase iris-shape    (:round     (copy-thru-round-iris  src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks iris-direction iris-count))    (:square     (copy-thru-square-iris src-portBits src-rect dest-rect copy-mode copy-rgn delay-ticks iris-direction iris-count))))