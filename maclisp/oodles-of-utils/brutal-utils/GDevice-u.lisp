(in-package  :oou)(oou-provide :GDevice-u);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; GDevice-u.Lisp;;;; Copyright © 1992 Northwestern University Institute for the Learning Sciences;; All Rights Reserved;;;; author: Michael S. Engber;;;; utilities for working with g-devices;;;; Changes (worth to be mentioned):;; ---------------------------------;;  ;; 8/27/92 Dieter : 'main-screen-color-p' added;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(export '(get-max-device mapc-GDevices find-GDevice-containing-point          with-GDevice with-gd-SearchProc          main-screen-color-p));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (:compile-toplevel :load-toplevel :execute)    (defmacro with-GDevice (gdh &body body)    (let ((old-gd (gensym)))      `(with-macptrs ((,old-gd (require-trap #_GetGDevice)))         (unwind-protect           (progn             (require-trap #_SetGDevice ,gdh)             ,@body)           (require-trap #_SetGDevice,old-gd)))))  (defmacro with-gd-SearchProc ((gdh searchProc) &body body)    `(unwind-protect       (progn         (with-GDevice ,gdh           (require-trap #_AddSearch ,searchProc))         ,@body)       (with-GDevice, gdh         (require-trap #_DelSearch ,searchProc))))    );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun get-max-device (&optional globalRect)  (if globalRect    (#_GetMaxDevice globalRect)    (with-dereferenced-handles ((GrayRgn_p (%get-ptr (%int-to-ptr #$GrayRgn))))      (#_GetMaxDevice (pref GrayRgn_p :Region.rgnBBox)))))(defun mapc-GDevices (fn &optional (active-screens-only-p t));;Maps fn over the GDevice list. fn should accept one parameter, a GDHandle  (do ((gd (#_GetDeviceList) (#_GetNextDevice gd)))      ((%null-ptr-p gd))    (when (or (and (#_TestDeviceAttribute gd #$screenDevice)                   (#_TestDeviceAttribute gd #$screenActive))              (not active-screens-only-p))      (funcall fn gd))))(defun find-GDevice-containing-point (&optional (where (%stack-block ((p 4))                                                         (#_GetMouse :ptr p)                                                         (#_LocalToGlobal :ptr p)                                                         (%get-long p))))  (mapc-GDevices #'(lambda (gd)                     (with-dereferenced-handles ((gd_p gd))                       (when (#_PtInRect where (pref gd_p :GDevice.gdRect))                         (return-from find-GDevice-containing-point gd))))))(defun main-screen-color-p ()  "Is the main screen capable of displaying color?"  ;; *color-available* just tells you if color quickdraw is in ROM  ;; it doesn't tell you if the screen can display in color  ;; #_getmaindevice trap gives handle to screen containing menubar  (and *color-available*       (let ((screen (#_getmaindevice))             (gddevtype 0))         (#_testdeviceattribute screen gddevtype)         )))