(in-package :oou)(oou-provide :macptr-u);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; macptr-u.lisp;;;; Copyright © 1991 Northwestern University Institute for the Learning Sciences;; All Rights Reserved;;;; author: Michael S. Engber;;;; utilities for working with macptrs;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(export '(%get-boolean   %put-boolean          %get-character %put-character          %get-text      %put-text          %get-list      %put-list          %get-hex-str   %put-hex-str          ));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#||#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun %get-boolean (ptr &optional (offset 0))  (logbitp 8 (%get-signed-byte ptr offset)))(defun %put-boolean (ptr bool &optional (offset 0))  (%put-byte ptr (if bool -1 0) offset))(defun %get-character (ptr &optional (offset 0))  (code-char (%get-unsigned-byte ptr offset)))(defun %put-character (ptr char &optional (offset 0))  (%put-byte ptr (char-code char) offset));;These 2 need to be rewritten to operate more efficiently;; look into (ccl::%str-from-ptr ptr size)(defun %get-text (ptr length &optional (offset 0))  (let ((text_p (%inc-ptr ptr offset))        (str (make-array length :element-type 'base-character :fill-pointer 0)))    (dotimes (i length str) (vector-push (%get-character text_p i) str))))(defun %put-text (ptr string &optional (offset 0))  (with-cstrs ((cstr_p string))    (#_BlockMove cstr_p (%inc-ptr ptr offset) (length string)))  nil)(defun %get-list (ptr elt-%get-fn elt-size elt-count &optional (offset 0))  (when (plusp elt-count)    (cons (funcall elt-%get-fn ptr offset) (%get-list (%inc-ptr ptr elt-size)                                              elt-%get-fn                                              elt-size                                              (1- elt-count)                                              offset))))(defun %put-list (ptr list elt-%put-fn elt-size &optional (offset 0))  (dolist (elt list nil)    (funcall elt-%put-fn ptr elt offset)    (incf offset elt-size)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun %get-hex-str (ptr byte-count &optional (offset 0))  (let ((str (make-string (+ (* 2 byte-count) (1- (ceiling byte-count 2)))                          :initial-element #\space))        (hex-vector #(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\A #\B #\C #\D #\E #\F)))    (dotimes (i byte-count str)      (let ((byte (%get-unsigned-byte ptr (+ i offset)))            (str-index (+ (* i 2) (truncate i 2))))        (setf (schar str str-index)      (svref hex-vector (ash byte -4)))        (setf (schar str (1+ str-index)) (svref hex-vector (logand #x0F byte)))))))(defun %put-hex-str (ptr hex-str &optional (offset 0))  (let ((i offset)        (byte nil))    (etypecase hex-str      (simple-string       (dotimes (str-index (length hex-str))         (let ((nibble (digit-char-p (schar hex-str str-index) 16)))           (when nibble             (if byte               (progn                 (%put-byte ptr (+ byte nibble) i)                 (incf i)                 (setf byte nil))               (setf byte (ash nibble 4)))))))      (string       (dotimes (str-index (length hex-str))         (let ((nibble (digit-char-p (char hex-str str-index) 16)))           (when nibble             (if byte               (progn                 (%put-byte ptr (+ byte nibble) i)                 (incf i)                 (setf byte nil))               (setf byte (ash nibble 4))))))))    ;take care of the odd half byte    (when byte (%put-byte ptr (+ byte (logand #x0F (%get-byte ptr i))) i)))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;