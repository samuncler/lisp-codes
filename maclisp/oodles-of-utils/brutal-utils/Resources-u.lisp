(in-package :oou)(oou-provide :Resources-u);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Resources-u.Lisp;;;; Copyright © 1991 Northwestern University Institute for the Learning Sciences;; Copyright © 1992-96 Institut fuer Informatik, University of Basel, Switzerland;; Copyright © 1991 Matthew Cornell;;;; All Rights Reserved;;;; authors: Michael S. Engber, Northwestern University;;              Dieter Holz, University of Basel;;              Matthew Cornell;;;; Utilities for working with resources ;;;; changes:;; 1/24/92 Dieter : get-resource and release-resource is now defined in library:resoures;; 1/24/92 Dieter : some new functions added;; 1/24/92 Dieter : some code of Matthew Cornell included;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require :resources) (oou-dependencies :Traps-u                              )(export '(get-resource get-resource-id with-purgeable-resource          opened-res-file-p open-res-file close-res-file           with-res-file without-res-load          ;add-resource           add-resource-to-file           get-resource-from-file          remove-resource-from-file          count-types          count-resources          get-resources-of-file));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; defrecords & macros(eval-when (:compile-toplevel :load-toplevel :execute)    (defrecord (ResourceHeader :handle)    (dataOffset longint)    (mapOffset longint)    (dataLength longint)    (mapLength longint))    (defrecord (ResourceMap :handle)    (header ResourceHeader)    (nextMapH handle)    (refnum integer)    (fileAttributes integer)    (typeListOffset integer)    (nameListOffset integer))    (defvar *open-resource-files* ()    "An alist of the form ((full-pathname1 . ref-num1) ...) managed byopen-resource-file close-resource-file and close-all-resource-files.")    (defmacro check-resource-handle (resource-handle)    "Ensures <resource-handle> is handlep, calling error if not."    ;;    `(unless (resource-handlep ,resource-handle)       (error "~S not a handle" ,resource-handle)))    (defmacro with-res-file-refNum ((refNum                                       &key                                       (close-when-done-p nil)                                       (write-changes-p nil))                                      &body body)    (let ((new-refNum (gensym))          (old-refNum (gensym)))      `(let ((,new-refNum)             (,old-refNum (require-trap #_CurResFile)))         (declare (dynamic-extent ,old-refNum ,new-refNum)                   (fixnum ,old-refNum ,new-refNum))         (unwind-protect           (progn             ;must protect evaluation of refNum in case it alters             ;the current res file (like a call to open-res-file)             (setf ,new-refNum ,refNum)              (require-trap #_UseResFile ,new-refNum)             ,@body)           (when ,new-refNum             (when ,write-changes-p (require-trap #_UpdateResFile ,new-refNum))             (when ,close-when-done-p (require-trap #_CloseResFile ,new-refNum)))           (require-trap #_UseResFile ,old-refNum)))))    (defmacro with-res-file ((pathname                               &key                               (if-does-not-exist :error)                               (if-no-rsrc-fork :error)                               (if-not-open :close-when-done)                               (if-open :leave-open)                               (write-changes-p nil))                              &body body)    (let ((close-flag (gensym)))      `(let ((,close-flag (ecase (if (opened-res-file-p ,pathname) ,if-open ,if-not-open)                            (:close-when-done t)                            (:leave-open nil))))         (declare (dynamic-extent ,close-flag))         (with-res-file-refNum ((open-res-file ,pathname                                               :if-does-not-exist ,if-does-not-exist                                               :if-no-rsrc-fork ,if-no-rsrc-fork)                                :close-when-done-p ,close-flag                                :write-changes-p ,write-changes-p)           ,@body))))    (defmacro without-res-load (&body body)    `(unwind-protect       (progn         (require-trap #_SetResLoad nil)         ,@body)       (require-trap #_SetResLoad t)))    (defmacro with-purgeable-resource ((rsrc-handle &key (changed-p nil)) &body body)    (let ((hState (gensym))          (rsrc_h (gensym)))      `(let ((,rsrc_h ,rsrc-handle)             (,hState nil))         (declare (dynamic-extent ,hState ,rsrc_h)                  (fixnum ,hState))         (unwind-protect           (progn             (without-interrupts              (require-trap #_LoadResource ,rsrc_h)              (require-trap #_HNoPurge ,rsrc_h)              (setf ,hState (require-trap #_HGetState ,rsrc_h)))             ,@body)           (when ,changed-p (require-trap #_ChangedResource ,rsrc_h))           (require-trap #_HSetState ,rsrc_h ,hState)))))    );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; individual resources#| this is now defined in library:resources(defun get-resource (rsrc-type rsrc-id-or-name &key (errorp t))  (without-interrupts   (let ((rsrc_h (etypecase rsrc-id-or-name                   (fixnum (#_GetResource rsrc-type rsrc-id-or-name))                   (string (with-pstrs ((name_p rsrc-id-or-name))                             (#_GetNamedResource rsrc-type name_p))))))     (when (and errorp (%null-ptr-p rsrc_h))       (error "Failed to load resource ~s of type ~s (ResError = ~a)."              rsrc-id-or-name rsrc-type (#_ResError)))     rsrc_h)))(defun release-resource (rsrc-handle)  (if (resource-handlep rsrc-handle)    (#_ReleaseResource rsrc-handle)    (error "~s is not a resource handle" rsrc-handle)))|#(defun get-resource-id (rsrc-type rsrc-name &key (errorp t))  (with-returned-pstrs ((name_p rsrc-name))    (%stack-block ((id_p 2) (type_p 4))      (let ((rsrc_h (without-res-load (#_GetNamedResource rsrc-type name_p))))        (without-interrupts         (#_GetResInfo rsrc_h id_p type_p name_p)         (when (and errorp (not (zerop (#_ResError))))           (error "resource ~s of type ~s not found." rsrc-name rsrc-type))))      (%get-signed-word id_p))))(defun resource-handlep (handle)  (and handle       (logbitp 5 (#_HGetState handle))))(defun release-handle (handle)  (when handle    (if (resource-handlep handle)      (#_ReleaseResource handle)      (dispose-record handle))));;;====================================================================;;;Getting resource information =======================================;;;====================================================================(defun get-resource-info (resource-handle)  "Returns values id-number type and name of the resource referenced by<resource-handle>."  (check-resource-handle resource-handle)  (%stack-block ((id-ptr 2)                 (type-ptr 4)                 (name-ptr 256))    (#_GetResInfo :ptr resource-handle     :ptr id-ptr :ptr type-ptr :ptr name-ptr)    (let ((error-code (#_ResError)))      (cond ((zerop error-code)             (values (%get-word id-ptr)                     (%get-ostype type-ptr)                     (%get-string name-ptr)))            (t (error "Code: ~A" error-code))))))(defun size-resource (resource-handle)  "Returns the size of the resource referenced by <resource-handle> in bytes."  (check-resource-handle resource-handle)  (#_SizeResource :ptr resource-handle :long));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; resource files(defun opened-res-file-p (pathname-or-id)  "Determines if the resource fork of the specified resource file is open."  (typecase pathname-or-id    (integer (member pathname-or-id (opened-rsrc-file-refNums)))    (t (when (probe-file pathname-or-id)         (with-pstrs ((fileName (mac-namestring pathname-or-id)))           (rlet ((pb :HParamBlockRec                      :ioNamePtr fileName                      :ioVRefNum 0                      :ioFDirIndex 0                      :ioDirID 0))             (trap-nz-echeck (#_PBHGetFInfo pb))             (logbitp 2 (rref pb :HParamBlockRec.ioFlAttrib))))))))(defun refnum/filename->alist-entry (refnum-or-filename)  "Returns the dotted pair on *open-resource-files* corresponding toREFNUM-OR-FILENAME, which is an integer or a string. Errors ifREFNUM-OR-FILENAME is a file that does not identify an entry on*open-resource-files*. Returns REFNUM-OR-FILENAME if it is an integer thatdoes not identify an entry on *open-resource-files*."  (let ((pair (etypecase refnum-or-filename                (integer (or (rassoc refnum-or-filename                                     *open-resource-files*)                             refnum-or-filename))                (string (or (assoc (full-pathname refnum-or-filename)                                   *open-resource-files* :test #'equal)                            (error "~S does not identify a resource file opened by open-resource-file."                                   refnum-or-filename)))                (pathname (or (assoc (full-pathname refnum-or-filename)                                     *open-resource-files* :test #'equal)                              (error "~S does not identify a resource file opened by open-resource-file."                                     refnum-or-filename))))))    pair))(defun pathname-of-resfile (resfile-id)  (when (opened-res-file-p resfile-id)    (car (refnum/filename->alist-entry resfile-id))))(defun resfile-id-of-file (filename)  (when (opened-res-file-p filename)    (cdr (refnum/filename->alist-entry filename))))(defun open-res-file (pathname &key (if-does-not-exist :error) (if-no-rsrc-fork :error))  "pathnameOpens the resource fork of the the specified file and returns the refNum."  (with-pstrs ((fn (mac-namestring pathname)))    (unless (probe-file pathname)      (when if-does-not-exist        (ecase if-does-not-exist          (:create (#_CreateResFile fn) (open-res-file pathname))          (:error (error "~s does not exist" pathname)))))    (let ((refNum (#_OpenResFile fn)))      (unless (= refNum -1)	;save it if it was opened        (pushnew (cons (full-pathname pathname) refNum)                 *open-resource-files* :test #'equal))      (if (plusp refNum)        refNum        (when if-no-rsrc-fork          (ecase if-no-rsrc-fork            (:create (#_CreateResFile fn) (open-res-file pathname))            (:error (error "~s has no resource fork" pathname))))))))#| the version of mike(defun close-res-file (refNum-or-pathname)  (let ((refNum (etypecase refNum-or-pathname                  (string (when (opened-res-file-p refNum-or-pathname)                            (open-res-file refNum-or-pathname)))                  (pathname (when (opened-res-file-p refNum-or-pathname)                              (open-res-file refNum-or-pathname)))                  (fixnum refNum-or-pathname))))    (when refnum      (without-interrupts       (#_CloseResFile refNum)       (zerop (#_ResError))))))|#(defun close-res-file (refnum-or-filename)  "Closes the resource fork of the file corresponding to <refnum-or-filename>,returning a the result of resource-error. <Refnum> = 0 means close all openresource files."  (when (opened-res-file-p refnum-or-filename)    (let ((pair (refnum/filename->alist-entry refnum-or-filename)))      (etypecase pair        (cons         (setf *open-resource-files* (remove pair *open-resource-files*))         (#_CloseResFile :word (cdr pair))         (when (zerop (cdr pair))           (setf *open-resource-files* ())))        (integer         (#_CloseResFile :word pair)))      (#_ResError))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; resource maps (linked list of resource files)(defun opened-rsrc-file-refNums (&key (start-mapH (%get-ptr (%int-to-ptr #.#$TopMapHndl)))                                          (end-mapH (%get-ptr (%int-to-ptr #.#$SysMapHndl))))  "&key start-mapH end-mapHReturns the refNums of the open resource files.end-mapH specifies the endpoint (non-inclusive) for the search of theresource map linked list. Typically, you want to search till the systemresource file (the default). Use (%null-ptr) for the complete list."  (unless (eql start-mapH end-mapH)    (cons (rref start-mapH :ResourceMap.refnum :storage :handle)          (opened-rsrc-file-refnums :start-mapH (rref start-mapH :ResourceMap.nextMapH :storage :handle)                                    :end-mapH end-mapH))))(defun opened-MCL-rsrc-file-refNums (&optional include-MCL-p)  "&optional include-MCL-pReturns the refNums of open resource files that were opened since MCLbooted. include-MCL-p determines if MCL's refNum is on the list."  (let ((refNums (opened-rsrc-file-refNums)))    (if include-MCL-p refNums (rest refNums))))(defun opened-MCL-rsrc-file-names (&optional include-MCL-p);;Returns the names of open resource files that were opened since MCL;;booted. include-MCL-p determines if MCL's name is on the list."  (with-returned-pstrs ((fn ""))    (rlet ((pb :FCBPBRec               :ioNamePtr fn               :ioVRefNum 0               :ioFCBIndx 0))      (flet ((fRefNum-to-fn (fRefNum)               (pset pb :FCBPBRec.ioRefNum fRefNum)               (trap-nz-echeck (#_PBGetFCBInfo pb))               (%get-string fn)))        (declare (dynamic-extent #'fRefNum-to-fn))        (mapcar #'fRefNum-to-fn (opened-MCL-rsrc-file-refNums include-MCL-p))))));-------------------------------------------------------------------------;-------------------------------------------------------------------------(defmacro check-resource-type (resource-type)  "Ensures <resource-type> is a 4 character string."  ;;  `(unless (and (stringp ,resource-type)                (= (length ,resource-type) 4))     (error "~s not proper type" ,resource-type)))(defun first-resource-word (resource-type)  "Returns the last two characters of <resource-type> in hex format.i.e. if <resource-type> = 'snth', #x7468 is returned."  ;;  (check-resource-type resource-type)  (+ (* (char-code (elt resource-type 2)) 256)     (char-code (elt resource-type 3))))(defun second-resource-word (resource-type)  "Returns the first two characters of <resource-type> in hex format.i.e. if <resource-type> = 'snth', #x736E is returned."  ;;  (check-resource-type resource-type)  (+ (* (char-code (elt resource-type 0)) 256)     (char-code (elt resource-type 1))));------------------------------------------------------------------------#| now defined in kernel; Add resource to the currently used resource(defun add-resource (resource type &key id  (name "") attributes)   (unless id      (setf id (#_UniqueID type)))   (ccl::with-pstr (ps name)    (#_AddResource resource type id ps)    (ccl::res-error)    (when attributes      (#_SetResAttrs resource attributes)      (ccl::res-error))    resource))|#(defun add-resource-to-file (resource filename resource-type &key id name (if-not-open :leave-open))  (when (and (handlep resource)             (probe-file (full-pathname filename)))    (with-res-file ((full-pathname filename)                    :if-not-open if-not-open                    :if-does-not-exist :create                    :if-no-rsrc-fork :create                    :write-changes-p t)      (add-resource resource resource-type id :name name))))(defun delete-resource-from-file (id-or-name resource-type filename)  (when (probe-file (full-pathname filename))    (with-res-file ((full-pathname filename)                    :if-no-rsrc-fork nil                    :write-changes-p t)      (delete-resource resource-type id-or-name))))(defun get-resource-from-file (filename resource-type id-or-name &key (detached-p nil))  (when (and filename             (probe-file (full-pathname filename)))    (with-res-file ((full-pathname filename)                    :if-not-open :leave-open                    :if-does-not-exist nil                    :if-no-rsrc-fork nil)      (let ((res (get-resource resource-type id-or-name)))        (when (and res                   detached-p)          (load-resource res)          (#_DetachResource res))        res))))(defun count-types ()  "Returns the number of resource types in all open resource files."  (#_CountTypes :word))(defun count-resources (resource-type)  "CountResources returns the total number of resources of the given typein all open resource files."  (setf resource-type (string resource-type))	;handles keywords  (check-resource-type resource-type)  (#_CountResources :word (first-resource-word resource-type)   :word (second-resource-word resource-type)   :word))(defun get-indexed-resource (resource-type index)  "Given an index ranging from 1 to CountResources(theType), GetIndResourcereturns a handle to a resource of the given type (see CountResources, above).Called repeatedly over the entire range for the index, it returns handles toall resources of the given type in all open resource files. GetIndResourcereads the resource data into memory if itÕs not already in memory, unlessyouÕve called SetResLoad(FALSE)."  ;;  (setf resource-type (string resource-type))	;handles keywords  (check-resource-type resource-type)  (#_GetIndResource :word (first-resource-word resource-type)   :word (second-resource-word resource-type)   :word index   :ptr))(defun get-resources-from-file (resource-type filename &key (if-not-open :leave-open) (detached-p nil))  "get all resources of the specified type in the specified file"  (when (probe-file (full-pathname filename))    (check-resource-type resource-type)    (with-res-file ((full-pathname filename)                    :if-not-open if-not-open                    :if-does-not-exist nil                    :if-no-rsrc-fork nil)      (let ((resfile-id (resfile-id-of-file filename))            (all-resources nil))        (dotimes (i (count-resources resource-type) all-resources)          (when (< (#_FreeMem) 100000)            (#_DisposeHandle (#_NewHandle 100000)))          (let ((resource (get-indexed-resource resource-type (1+ i))))            (when (= resfile-id (#_HomeResFile resource))              (when detached-p                (load-resource resource)                (#_DetachResource resource))              (push resource all-resources))))))));----------------------------------------------------------------------------------(defun get-all-picts-from-file (filename)  (get-resources-from-file "PICT" filename))(defun get-detached-picts-from-file (filename)  (get-resources-from-file "PICT" filename                            :if-not-open :close-when-done                           :detached-p t))  (defun add-pict-to-file (pict filename id name)  (let ((res-file-open-p (opened-res-file-p filename)))    (when id      (with-res-file (filename :if-does-not-exist :create                               :if-no-rsrc-fork :create                               :if-not-open :leave-open)        (unless (%null-ptr-p (#_GetPicture id))          (delete-resource-from-file id "PICT" filename))))    (let ((res (add-resource-to-file pict filename                                      "PICT"                                      :name name :id id                                     :if-not-open :leave-open)))      (load-resource res)      (#_DetachResource res)      (unless res-file-open-p        (close-res-file filename))      res))) (defun delete-all-picts-from-file (resource-file)  (with-res-file (resource-file                  :if-does-not-exist :create                  :if-no-rsrc-fork :create)    (mapcar #'(lambda (pict-rsrc)                (multiple-value-bind (id type name) (get-resource-info pict-rsrc)                  (declare (ignore type name))                  (delete-resource-from-file id "PICT" resource-file)))            (get-all-picts-from-file resource-file))));----------------------------------------------------------------------------------(defun save-string-in-resource-fork (file string start-res-nr)  (flet ((save-substring (res-nr str)           (with-macptrs (handle)             (%setf-macptr handle (#_NewHandle (1+ (length str))))             (%put-string handle str)             (delete-resource "STR " res-nr t)             (add-resource handle "STR " res-nr)             (ccl::write-resource handle)             (#_DetachResource handle)             (#_ReleaseResource handle)             (dispose-record handle :handle))))    (without-event-processing      (with-open-resource-file (refnum file)        (using-resource-file refnum          (let* ((size (length string))                 (floor (floor size 255)))            (save-substring start-res-nr (ccl::%integer-to-string (1+ floor)))            (dotimes (i floor)              (save-substring (+ start-res-nr 1 i) (subseq string (* i 255) (* (1+ i) 255))))            (save-substring (+ start-res-nr 1 floor) (subseq string (* floor 255) size))))))))(defun get-string-from-resource-fork (file start-res-nr &aux string-segments)  (labels ((get-string-rsrc (name-or-number)             (let ((str (get-resource "STR " name-or-number)))               (when str                 (unwind-protect                   (%get-string str)                   (#_ReleaseResource str))))))    (without-event-processing      (with-open-resource-file (refnum file)        (using-resource-file refnum          (let ((times-string (get-string-rsrc start-res-nr)))            (when times-string              (dotimes (i (read-from-string times-string nil))                (push (get-string-rsrc (+ start-res-nr 1 i))                      string-segments))              (apply #'concatenate 'string (nreverse string-segments)))))))));----------------------------------------------------------------------------------     (defun copy-handle (handle)  "returns a handle whose contents is a copy of the input handle's contents"  (rlet ((var :ptr))    (ccl::%set-ptr var handle)    (let ((errcode (#_HandToHand var)))      (unless (eql 0 errcode)        (ccl::%err-disp errcode))      (%get-ptr var))))(defun get-resource-name (rsrc-type rsrc-id &key (errorp t))  (with-returned-pstrs ((name_p ""))    (rlet ((id_p :integer)           (type_p :OSType))      (with-macptrs ((rsrc_h (without-res-load (#_GetResource rsrc-type rsrc-id))))        (without-interrupts         (#_GetResInfo rsrc_h id_p type_p name_p)         (when (and errorp (not (zerop (#_ResError))))           (error "resource ~s of type ~s not found." rsrc-id rsrc-type))))      (%get-string name_p))))