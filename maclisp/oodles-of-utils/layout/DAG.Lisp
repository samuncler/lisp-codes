;;; ********************************************************************;;; Layout *************************************************************;;; ********************************************************************;;; Written by Michael Hussmann, adapted by Ralf Moeller;;; University of Hamburg, Computer Science Department, December 1991.;;; Copyright (c) 1991 by Michael Hussmann and Ralf Moeller. All rights reserved.;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted, so long as the following;;; conditions are met:;;;      o no fees or compensation are charged for use, copies, or;;;        access to this software;;;      o this copyright notice is included intact.;;; This software is made available AS IS, and no warranty is made about ;;; the software or its performance. ;;; Please send bug reports, comments and suggestions to;;; moeller@informatik.uni-hamburg.de(locally  (declare (optimize (safety 0)                      (speed 3)                      (space 3)                     (compilation-speed 0)                     (debug 0)))(defstruct (node (:print-function print-node)                 (:copier nil))   reference   (daughters nil)   (mothers nil)   (mark nil)   top   (left 0)   width   height   (global-top nil)   global-bottom   left-point   right-point   box-item   layouted-items)(defun print-node (n stream depth)  (declare (ignore depth))  (print-unreadable-object (n stream :type t :identity t)))(defvar *node-distance* 4)(defun filter-cyclic-nodes (x vis-nodes appl-successors)  (remove-if #'(lambda (successor)                 (let ((n (assoc successor                                  vis-nodes)))                   (and n                        (< (node-left (cdr n)) x))))             appl-successors))(defun build-dag-structures (roots                             left top                             successor-fcn                             map-fcn                             n-expansions                             expansion-predicate                             &optional (node-equal-predicate #'eql)                             (layout-scheme ':horizontal))  (let ((nodes nil))    (labels ((build-dag (n x n-expansions                           &aux (a-node (cdr (assoc n nodes                                                    :test node-equal-predicate))))                        (cond (a-node                               (when (> x (node-left a-node))                                 (re-adjust a-node (- x (node-left a-node))))                               a-node)                              (t (let* ((a-node (make-node :reference n                                                           :left x))                                        (box-item (funcall map-fcn                                                           (node-reference a-node)                                                           (= 1 n-expansions)))                                        (width (ecase layout-scheme                                                 (:horizontal (point-h (box-item-size box-item)))                                                 (:vertical (point-v (box-item-size box-item)))))                                        (height (ecase layout-scheme                                                 (:horizontal (point-v (box-item-size box-item)))                                                 (:vertical (point-h (box-item-size box-item))))))                                   (setf (node-width a-node) width)                                   (setf (node-height a-node) height)                                   (push (cons n a-node) nodes)                                   (setf (node-box-item a-node) box-item)                                   (if (and (> n-expansions 1)                                            (funcall expansion-predicate n))                                     (build-daughter-dags (filter-cyclic-nodes                                                           x                                                           nodes                                                            (remove-if-not                                                             expansion-predicate                                                            (funcall successor-fcn                                                                      n                                                                     box-item)))                                                          a-node                                                          (1- n-expansions)                                                          x                                                          width                                                          height))                                   a-node))))            (build-daughter-dags (daughters a-node n-expansions x width height)               (let* ((right (+ x width))                      (x (+ right                            (truncate (* height                                         (max (length daughters) 2)                                         0.3)))))                     (connect-nodes a-node                                    (mapcar #'(lambda (d) (build-dag d x n-expansions))                                            daughters))))            (re-adjust (a-node diff)               (setf (node-left a-node) (+ (node-left a-node) diff))               (dolist (d (node-daughters a-node)) (re-adjust d diff)))            (connect-nodes (a-node daughters)               (setf (node-daughters a-node) daughters)               (dolist (daughter daughters)                  (pushnew a-node (node-mothers daughter)))))      (let ((dags             (sort-dags                 (mapcar #'(lambda (r) (build-dag r left n-expansions)) roots))))        (traverse-dags           dags           top           layout-scheme)        dags))));*--------------------------------------------------------------------------*;*                                                                          *;*                          ENTFLECHTEN DES GRAPHEN                         *;*                          graph decartelization                           *;*                                                                          *;*--------------------------------------------------------------------------*(defun sort-dags (roots)   (labels ((traverse (a-node)               (unless (singlep (node-mothers a-node))                  (mark-mothers a-node)                  (setq roots (group-daughters roots t t))                  (unmark-mothers a-node))               (mapc #'traverse (node-daughters a-node)))            (mark-mothers (a-node)               (setf (node-mark a-node) t)               (mapc #'mark-mothers (node-mothers a-node)))            (unmark-mothers (a-node)               (setf (node-mark a-node) nil)               (mapc #'unmark-mothers (node-mothers a-node))))           (mapc #'traverse roots)           roots))(defun singlep (x) (and (consp x) (null (cdr x))))(defun group-daughters (daughters leftmostp rightmostp)   (labels ((group-daughters-right (daughters marked)               (if (null daughters)                   (progn (when marked                             (sort-daughters (reverse marked)                                             leftmostp                                             rightmostp))                          (reverse marked))                   (let ((first-d (first daughters))                         (rest-d (rest daughters)))                        (if (node-mark first-d)                            (group-daughters-right rest-d                                                   (cons first-d marked))                            (cons first-d                                  (group-daughters-right rest-d marked))))))            (group-daughters-left (daughters marked unmarked)               (if (null daughters)                   (progn (when marked                             (sort-daughters (reverse marked)                                             leftmostp                                             rightmostp))                          (revappend marked (reverse unmarked)))                   (let ((first-d (first daughters))                         (rest-d (rest daughters)))                        (if (node-mark first-d)                            (group-daughters-left rest-d                                                  (cons first-d marked)                                                  unmarked)                            (group-daughters-left rest-d                                                  marked                                                  (cons first-d unmarked))))))            (group-daughters-middle (daughters)               (cond ((null daughters) nil)                     ((node-mark (first daughters))                      (group-daughters-left (rest daughters)                                            (list (first daughters))                                             nil))                     (t (cons (first daughters)                              (group-daughters-middle (rest daughters))))))            (sort-node (a-node leftmostp rightmostp)               (setf (node-daughters a-node)                     (group-daughters (node-daughters a-node)                                      leftmostp                                      rightmostp)))            (sort-daughters (daughters leftmostp rightmostp)               (sort-node (first daughters)                          leftmostp                          (and rightmostp (singlep daughters)))               (mapl #'(lambda (daughters)                        (sort-node (first daughters)                                   nil                                   (if (singlep daughters) rightmostp)))                     (rest daughters))))           (cond ((and leftmostp rightmostp)                  (group-daughters-middle daughters))                 (leftmostp (group-daughters-right daughters nil))                 (rightmostp (group-daughters-left daughters nil nil))                 (t (group-daughters-middle daughters)))));*--------------------------------------------------------------------------*;*                                                                          *;*                       BERECHNUNG DER Y-KOORDINATEN                       *;*                       Computation of the y-coordinates                   *;*                                                                          *;*--------------------------------------------------------------------------*(defun traverse-dags (roots y layout-scheme)   (when roots      (traverse-dags (rest roots)                      (traverse-dag (first roots) y layout-scheme)                     layout-scheme)))(defun traverse-dag (root y layout-scheme)   (labels ((traverse (a-node y &aux (height (node-height a-node)))               (cond ((next-daughters (node-daughters a-node))                      (setf (node-global-top a-node) y)                      (do ((daughters (next-daughters (node-daughters a-node))                                      (next-daughters (rest daughters)))                           (y y                              (+ (node-global-bottom (first daughters))                                 *node-distance*)))                          ((null daughters)                           (setf (node-global-bottom a-node)                                 (- y *node-distance*)))                          (traverse (first daughters) y))                      (setf (node-top a-node)                            (- (truncate (+ y (node-global-bottom a-node)) 2)                               (truncate height 2))))                     (t (setf (node-top a-node) y)                        (setf (node-global-top a-node) y)                        (setf (node-global-bottom a-node)                              (+ y height))))               (calc-left-and-right-points a-node height)               (let ((node-box-item (node-box-item a-node))                     (left (node-left a-node))                     (top (node-top a-node)))                 (cond ((box-item-p node-box-item)                        (setf (box-item-position node-box-item)                              (ecase layout-scheme                                (:horizontal (make-point left top))                                (:vertical (make-point top left))))                        (setf (node-layouted-items a-node)                              (list node-box-item)))                       ((layout-spec-p node-box-item)                        (let ((box-items (items-positioned-in-box                                          node-box-item                                          left                                           top                                          (+ left (node-width a-node))                                          (+ top (node-height a-node)))))                          (setf (node-layouted-items a-node)                                box-items))))))            (calc-left-and-right-points (a-node height)               (let ((left (node-left a-node))                     (top (node-top a-node))                     (width (node-width a-node)))                    (let ((mid (+ top (truncate height 2))))                         (setf (node-left-point a-node)                               (make-point left mid))                         (setf (node-right-point a-node)                               (make-point (+ left width) mid)))))            (next-daughters (daughters)               (do ((daughters daughters (rest daughters)))                   ((null daughters) nil)                   (unless (node-global-top (first daughters))                      (return daughters)))))           (traverse root y)           (+ (node-global-bottom root) *node-distance*)));*--------------------------------------------------------------------------*;*                                                                          *;*                       BERECHNUNG DER ITEMS                               *;*                       Computation of the dag items                       *;*                                                                          *;*--------------------------------------------------------------------------*(defun dags-items (roots connector-fcn reference-1-fcn reference-2-fcn)  (let ((view-items nil))    (labels ((traverse (a-node)                       (if a-node                         (let ((daughters (node-daughters a-node)))                           (mapc #'traverse daughters)                           (mapc #'(lambda (item)                                     (pushnew item view-items))                                 (node-layouted-items a-node))                           (mapc #'(lambda (daughter)                                     (let ((connector (funcall connector-fcn)))                                       (parse-layout-spec                                         (funcall reference-2-fcn                                                 connector                                                 (first (node-layouted-items                                                         a-node))))                                       (parse-layout-spec                                         (funcall reference-1-fcn                                                  connector                                                 (first (node-layouted-items                                                          daughter))))                                       (push connector view-items)))                                 daughters))                         nil)))      (if roots        (progn (setf view-items (append view-items                                        (dags-items (rest roots)                                                     connector-fcn                                                    reference-1-fcn                                                     reference-2-fcn)))               (traverse (first roots)))        nil))    view-items))(defun parse-dag-layout-spec (layout-spec left top)  (let* ((roots (second layout-spec))         (successor-fcn (third layout-spec))         (n-expansions (fourth layout-spec))         (expansion-predicate (fifth layout-spec))         (map-fcn (nth 5 layout-spec))         (connector-fcn (nth 6 layout-spec))         (reference-1-fcn (nth 7 layout-spec))         (reference-2-fcn (nth 8 layout-spec))         (node-equal-predicate (or (nth 9 layout-spec) #'eql))         (layout-scheme (or (nth 10 layout-spec) ':horizontal))         (layouted-nodes (build-dag-structures roots                                               left top                                               successor-fcn                                               map-fcn                                               n-expansions                                               expansion-predicate                                               node-equal-predicate                                               layout-scheme)))      (dags-items layouted-nodes                   connector-fcn                  reference-1-fcn                  reference-2-fcn)))) ; end locally