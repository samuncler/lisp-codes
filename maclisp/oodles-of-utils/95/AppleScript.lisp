;;;-*- Mode: Lisp; Package: cl-user -*-(in-package :cl-user)(require :aestuff)(require :resources);;  APPLESCRIPT.LISP;;	Author T. Bonura, 1994;;	©Apple Computer;;____________________________________________________________;;	Documentation:;;  Revisions from the first version;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  AppleScript.lisp - T. Bonura 2/3/94;;;;;;  Note that this is © Apple Computer, Inc.  1994.  All rights reserved.;;;  Class definitions for creating applescript CLOS instances.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   Note:  This code has been checked with MCL3.0b3 as well as 2.01 -5/24/95;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Maybe to do:;;  ¥  3/29/95  Note for 3.0.  It is possible to have seperate open scripting;;  components for different processes (see 10/21/94 below).  I haven't built any;;  functionality to make this clean and easy but is probably worth doing so.;;  ¥  Could still use some better error handling (sigh);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Changes:;;  ¥  5/24/95  Added LOAD-SCRIPT which loads a compiled script from a named;;  file.  The script can then be executed.  Note now there is a require for;;  resources.lisp;;  ¥  5/24/95  Added open-component to INITIALIZE-INSTANCE ;;  ¥  3/8/95  Created a new slot called the.result.string which is what would;;  appear in the result window of Apple's script editor.  Note: asking an;;  application for its data (getdata event) still returns the data in an aedesc;;  which should get unpacked properly.  This deals with cases where we expect;;  something back from an application (like the finder) indicating that an;;  action has taken place but not necessarily its data. Sometimes the value of;;  this slot is the same as thevalue in the aedesc (e.g., "tell application foo to get;;  word 1 of window 1" would have word 1 stuffed into an aedesc and into;;  the.result.string slot);;  ¥ 11/2/94  Fixed a couple of compiler warnings about current-object not;;  being defined (it is in the editor file) and defined the global for the;;  editor here.;;  ¥ 10/21/94  Changed last-word to trim off trailing whitespace if there is;;   any.;;  ¥ 10/21/94 Single vs. multiple open scripting components;;	According to Inside Mac IAC Chapter 10, an application can;;  maintain several connections to a single scripting component or it can have;;  connections to several components at the same time.  Since AppleScript can;;  only execute a single script at a time per component instance, a;;  multithreaded application has to provide a seperate component instance for;;  each script that it compiles or executes while it is simultaneously;;  executing other scripts. But MCL2.0 is not multi threaded so,   I have;;  defined a global called *multiple-component-instances* which is initialized;;  to NIL.  If NIL there will only be a single scripting component bound to the;;  variable *current-scripting-component*.  When an instance of an AppleScript ;;  object is created, if *multiple-component-instances* is NIL (the default);;  then the value of the component slot will be set to the VALUE of the global;;  *current-scripting-component*. Otherwise the applescript object will get;;  its own instance of a scripting component.  There is more overhead with;;  creating multiple instances of the scripting component, though and they all;;  must be appropriately cleaned up. When lisp is shut down or when the value;;  of *multiple-component-instances* is reset via;;  (use-multiple-component-instances-p) then the *current-scripting-component*;;  is disposed.   ;;  ¥ 10/2/94  Added continuous recording capability.  If the value of the;;  get-recorded-text slot is non-nil, then we call the method;;  handle-recorded-text on the script object.  By default, this;;  method will either send the line of text to the script editor if one is;;  open, or will send it to the listener.  Override the method to do what you;;  will with the text.;;  ¥ 9/28/94 Initialize ASO with a returned.value slot of NIL;;  ¥ Fri, Mar 11, 1994  3:02 PM Changed EXECUTE-APPLESCRIPT to check for an open;;  component and also a compiled script id.;;  Fri, Mar 11, 1994  3:02 PM Changed EXTRACT-THE-RESULT so that it extracts;;  the right thing now - which seems to be an id of 1+ the compiled-script-id.;;  ¥ Fri, Mar 25, 1994  2:30 PM  Added recordability to the  functionality of the ASO. ;;  ¥ 9/12/94;;  Nathan Wilson - changed the extract result method to be a bit more general. ;;  It now extracts the result into a descriptor record of (wild type).  The;;  user is then obliged to dispose of it properly.  Now types other than chars;;  can be gotten from an application.  See the method show-result-as-string to;;  see how to coerce from wild type to a string.;;  ¥ 9/12/94 Put everything in the cl-user package.;;  ¥ 9/12/94 Think memory leak is fixed - see CLEANUP.;;################################################################################(DEFVAR *multiple-component-instances* NIL "Allows for multiple instances of ascripting component.  Set this using the function (use-multiple-component-instances-p t) ")(DEFVAR *AS-SCRIPT-EDITOR* NIL "Points to the applescript editor")(DEFVAR *applescript-dispatcher* nil)(DEFPARAMETER *current-scripting-component* NIL "A pointer to the currentscripting component if the application is only using a single component instance"  )(DEFCONSTANT $AppleScript :|ascr| "The applescript scripting component")(DEFCONSTANT $GeneralScriptingComponent :|cscr| "The general scripting component")(DEFCONSTANT $HyperTalk :|htlk| "The hypertalk scripting component")(DEFUN CLOSE-SCRIPTING-COMPONENT ()  (if (pointerp *current-scripting-component*)           (#_closeComponent *current-scripting-component*)))(pushnew #'close-scripting-component *lisp-cleanup-functions*)(DEFUN USE-MULTIPLE-COMPONENT-INSTANCES-P (boolean)  (cond (boolean         (if (pointerp *current-scripting-component*)           (#_closeComponent *current-scripting-component*))         (setf *multiple-component-instances* t               *current-scripting-component* nil))        ))(DEFUN NULL-AEDESC ()   (let ((result (make-record :aedesc)))      (rset result :aedesc.descriptorType #$typeNull)      (rset result :aedesc.dataHandle (%null-ptr))      result));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	Class:  APPLESCRIPT-OBJECT;;;	** ASO = AppleScriptObject **;;;   INITIALIZE-INSTANCE ((ASO APPLESCRIPT-OBJECT) &rest initargs)  ;;;   OPEN-COMPONENT ((ASO APPLESCRIPT-OBJECT)) "opens a scripting component;;;	and sets the value of the component slot to a pointer";;;   LOAD-SCRIPT ((aso applescript-object) resfile scpt-res-id) "Load a script;;;   from the indicated file with the indicated resource number" ;;;   COMPILE-APPLESCRIPT ((ASO APPLESCRIPT-OBJECT)) "compiles the script;;;	which is in the script slot";;;   EXECUTE-APPLESCRIPT ((ASO APPLESCRIPT-OBJECT)) "What do you think?";;;   EDIT-SCRIPT ((ASO APPLESCRIPT-OBJECT));;;   CLEANUP ((ASO APPLESCRIPT-OBJECT)) ;;;   DISPOSE-SCRIPT ((ASO APPLESCRIPT-OBJECT));;;   DISPLAY-RESULT ((ASO APPLESCRIPT-OBJECT))  - elided - TB 9/12;;;   EXTRACT-THE-RESULT ((ASO APPLESCRIPT-OBJECT));;;	******  Recording *****;;;   START-RECORDING ((ASO APPLESCRIPT-OBJECT));;;   STOP-RECORDING ((ASO APPLESCRIPT-OBJECT)) "When we ;;;   stop recording, we add the decompiled script to the script slot";;;   DECOMPILE-SCRIPT ((ASO APPLESCRIPT-OBJECT));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFCLASS APPLESCRIPT-OBJECT (standard-object)  ((script :initform NIL :initarg :script :accessor script)   (application-name :initform NIL :initarg :application-name :accessor                     application-name)    (scripting.component.type :initform NIL :initarg :scripting-component-type                             :accessor scripting-component-type)   ;;  NOTE:  the as.target slot is not currently used   (as.target :initform NIL :initarg :target :accessor as-target)   (break.on.error :initarg :break-on-error :accessor break-on-error)   (compiled.script :initform NIL :initarg NIL :accessor compiled-script)   (compiled.script.id :initform NIL :initarg NIL :accessor compiled-script-id)    (component :initform nil :initarg :component :accessor component)   (returned.value :initarg :returned-value :accessor returned-value)   ;;  this is what would appear in the applescript editor's result window   (the.result.string :initarg the-result-string :accessor the-result-string)   ;;  Governs whether to get incremental values for scripts when recording is   ;;  on (like what the Script Editor normally does)   (get-recorded-text :initarg :get-recorded-text :initform NIL :accessor                        get-recorded-text )      )  (:default-initargs    :scripting-component-type $AppleScript    :break-on-error t    :returned-value nil    )  )(DEFMETHOD INITIALIZE-INSTANCE ((aso applescript-object) &rest initargs)  (declare (ignore initargs))  (call-next-method)  (open-component aso)  (unless *applescript-dispatcher*    (setf *applescript-dispatcher*          (make-instance 'script-dispatcher)))  (if (get-recorded-text aso)    (setf (active-script-object *applescript-dispatcher*) aso)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFGENERIC OPEN-COMPONENT (APPLESCRIPT-OBJECT)  (:documentation "Opens a scripting component.  We only open a new scriptingcomponent if the global *multiple-component-instances* is t.  Otherwise all thescripts use the same scripting component.")  )(DEFMETHOD OPEN-COMPONENT ((ASO APPLESCRIPT-OBJECT))  ;;  changed to deal with either a single or multiple components  (cond (*multiple-component-instances*         (setf (component ASO)               (#_OpenDefaultComponent #$kOSAComponentType                 (scripting-component-type ASO))))        ((or (null *current-scripting-component*)             (%null-ptr-p *current-scripting-component*))         (setf *current-scripting-component*                (#_OpenDefaultComponent #$kOSAComponentType                 (scripting-component-type ASO)))         (setf (component ASO) *current-scripting-component*))        (t (setf (component ASO) *current-scripting-component*))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFGENERIC LOAD-SCRIPT (APPLESCRIPT-OBJECT resfile scpt-res-id)  (:documentation "Load a script from the indicated file with the indicatedresource number" )  )  (defmethod LOAD-SCRIPT ((aso applescript-object) resfile scpt-res-id)  (let ((hres nil)        (err nil))    (ccl::with-open-resource-file (refnum resfile)      (progn        (setf hres (ccl::get-resource :|scpt| scpt-res-id))        (when (%null-ptr-p hres)               (#_disposePtr hres)               (error "~%Resource ~a not found" scpt-res-id))        (ccl::load-resource hres)        (ccl::detach-resource hres)))    ;;  now hres handle is mine    (with-dereferenced-handles ((scptPtr hres))      (with-aedescs (scriptDesc)        (rlet ((id :OSAID))          (#_AECreateDesc #$typeOSAGenericStorage scptPtr (#_getHandleSize hres)           scriptDesc)          (setf err (#_OSALoad (component aso) scriptDesc #$kOSAModeNull id))          (cond ((zerop err)                 (setf (compiled-script aso) t                       (compiled-script-id ASO) (%get-long id)))                ( t                  (error (script-error (component aso))))))))    (#_disposeHandle hres)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFGENERIC COMPILE-APPLESCRIPT (APPLESCRIPT-OBJECT)  (:documentation "Compile the applescript")  )(DEFMETHOD COMPILE-APPLESCRIPT ((ASO APPLESCRIPT-OBJECT))  (with-pointers ((as (component ASO)))    (let ((text (script ASO)))      (with-aedescs (source)        (let ((size (length text)))          (%vstack-block (buff size)            (dotimes (i size)              (%put-byte buff (char-code (char text i)) i))            (#_AECreateDesc #$typeChar buff size source)))        (rlet ((id :OSAID))          (%put-long id #$kOSANullScript)          (let ((err (#_OSACompile as source 0 id)))            (cond ((zerop err)                   ;;(format t "OK Seems to compile")                   (setf (compiled-script aso) t)                   (setf (compiled-script-id ASO) (%get-long id)))                  (t                   (if (break-on-error ASO)                     (error (script-error as)))                   (values nil err))))))      )    )  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFGENERIC EXECUTE-APPLESCRIPT (APPLESCRIPT-OBJECT)  (:documentation "Execute the script on the target")  );;; Typically returns an AEDesc that the user must dispose.  May return a;;; string or nil if bad things happen.  The AEDESC is put in the returned-value;;; slot of the object;;  T.B.  8 Mar 1995  -  11.12;;  this version of execute uses a new slot on the applescript-object called;;  the.result.string.  The value of this slot should be the same as what the;;  applescript editor shows in its result window.(DEFMETHOD EXECUTE-APPLESCRIPT ((ASO APPLESCRIPT-OBJECT))  ;;  whenever the script is edited in the script editor, the value of  ;;  compiled-script is set to nil   (unless (compiled-script aso)    (compile-applescript ASO))  (let ((id (compiled-script-id ASO))          (err nil)          (result nil)          (as (component ASO)))     (rlet ((result-id :OSAID #$typeChar))        (setq err (#_OSAExecute as id 0 0 result-id))        (cond          ((zerop err)            (unwind-protect               (progn                 (setf result (extract-the-result aso (%get-long result-id))                       (the-result-string aso) (show-result-as-string aso (%get-long result-id))))               (#_OSADispose as (%get-long result-id)))            result)          (t            (if (break-on-error ASO)               (error (script-error as)))            (values nil err))))))(DEFMETHOD EXTRACT-STRING ((aso applescript-object) result-id)   (with-aedescs (source)       (let ((err (#_OSADisplay (component aso) result-id #$typeChar 0 source)))          (cond ((zerop err)                     (setf (returned-value aso)                              (as-get-string (rref source AEDesc.dataHandle))))                   (t (values nil err))))));; EXTRACT-THE-RESULT the result creates a descriptor record containing the data (of any;; type).  THis data might be a pict or just about anything that the target;; sends back.  The following shows how to deal with coercing the descriptor to;; type char so that we can show it as a string.;;; Returns either a string or an AEDesc object.  If the latter, the user is responsible for;;; calling dispose on it.(DEFMETHOD EXTRACT-THE-RESULT ((aso applescript-object) result-id)   (with-pointers ((as (component aso)))      (with-aedescs (resultDesc)          (let ((err (#_OSACoerceToDesc as result-id #$typeWildCard #$kOSAModeNull resultDesc)))             (cond               ((zerop err)                 (let ((final-result (null-aedesc)))                    (setq err (#_AEDuplicateDesc resultDesc final-result))                    (cond                      ((zerop err) (setf (returned-value aso)                             (make-instance 'AEDesc :descRecPtr final-result)))                      (t (unless (eql final-result (%null-ptr))                             (#_AEDisposeDesc final-result))                          (extract-string aso result-id)))))               ;;; If OSACoerceToDesc fails then try to return a string               (t (extract-string aso result-id)))))));;  T.B.  8 Mar 1995  -  11.12;;  Changed the def here to take the result-id in order to do the;;  extract-string.(DEFMETHOD SHOW-RESULT-AS-STRING ((aso applescript-object) result-id)  (if (returned-value aso)    (with-aedescs (coerced.desc)      (let ((err (#_AECoerceDesc (getDescRecPtr (returned-value aso))                  #$typechar coerced.desc)))        (cond         ((zerop err)          (as-get-string (rref coerced.desc AEDesc.dataHandle)))         ;;  error, try to get the result in another way         (t           ;;  check for result-id because the call from dialog-item-action on          ;;  the run-script-btn won't know the result-id.          (if result-id            (extract-string aso result-id)            (if (break-on-error ASO)               (error (script-error (component aso)))))))))))(DEFMETHOD DISPOSE-SCRIPT ((ASO APPLESCRIPT-OBJECT))  (let ((as (component ASO))        (id (compiled-script-id ASO)))  (when (and as id)    (assert (zerop (#_OSADispose as id))))  )  ) (DEFMETHOD CLEANUP ((ASO APPLESCRIPT-OBJECT))  (dispose-script ASO)  ;;  remove from the script-dispatcher  (if (get-recorded-text aso)    (setf (active-script-object *applescript-dispatcher*) nil))  (cond ((and (returned-value aso)              ;;  fix 3/30/95 incorrectly checked to see if the aso was a string              ;;  when I need to check to see if the returned value is a string              ;;  rather than an aedesc.              (not (stringp (returned-value aso))))         (Dispose (returned-value aso))         (setf (returned-value aso) nil)))  (cond (*multiple-component-instances*         (#_CloseComponent (component aso))         (setf (component aso) nil)         )        )  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFGENERIC EDIT-SCRIPT (APPLESCRIPT-OBJECT)  (:documentation "Bring up a script editor on the script")  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Methods for dealing with error conditions;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		Recording From Recordable Applications;;;  The following allows for recording to be turned on. ;;;  Actions are recorded to the compiled script in the;;;  applescript object.;;;	When recording, we have the option of taking the results incrementally.  By;;;  default, we get the recorded text only when the applescript editor is open on;;;  an applescript object.  If it is, we send the string to the script editor. ;;;  Otherwise if the value of the get-recorded-text slot on the;;;object is t, we call handle-recorded-text method on the applescript object. ;;;Since LISP is informed only about a recorded-text ;;;event, there is no way to know what to do with the text.  It might just be;;;displayed (as in the case of the script editor, or one might want to analyze;;;the text for patterns (as in doing PBD).  So the question is which object;;;should be informed about the incoming text.  To do this, we create an;;;instance of a script-dispatcher. Any applescript object can register;;; itself with the script-dispatcher.  The script dispatcher object then;;;informs the applescript object about the current script text.  There is only;;;one script dispatcher object and it is bound to the variable *applescript-dispatcher*;;;  IMPORTANT:;;  If you want to do some thing other than sending the recorded text output to;;  the applescript editor or to the listener, then override the method called;;  HANDLE-RECORDED-TEXT (DEFCLASS SCRIPT-DISPATCHER (standard-object)  ((active-script-object :initarg :active-script-object :initform nil                          :accessor active-script-object))    )(DEFMETHOD HANDLE-RECEIVED-SCRIPT-TEXT ((self script-dispatcher) aevent)  (let ((appleevent (make-instance 'appleEvent :descRecPtr aevent))        (script-object (active-script-object self))        (theDescRec NIL)        (theText NIL))    (cond (script-object           (setf theDescRec (getParamDesc appleevent #$keyDirectObject #$typechar))           (setf theText (as-get-string (getDataHandle theDescRec)))           (handle-recorded-text script-object theText)           (dispose theDescRec))          )    )  )(DEFMETHOD START-RECORDING ((aso APPLESCRIPT-OBJECT))  (with-pointers ((as (component aso)))      (rlet ((id :OSAID))        (%put-long id #$KOSANullScript)        (let ((oserr (#_OSAStartRecording as id)))          (if (zerop oserr)            (progn              (format t "Recording is on.~%")              (setf (compiled-script-id aso) (%get-long id)))            (if (break-on-error ASO)              (error (script-error as))))))))(DEFMETHOD STOP-RECORDING ((aso APPLESCRIPT-OBJECT))  (with-pointers ((as (component aso)))    (let ((oserr (#_OSAStopRecording as (compiled-script-id aso))))            (cond ((zerop oserr)             (decompile-script aso)             (format t "Recording is off.~%"))            (t             (if (break-on-error ASO)               (error (script-error as))))))))(DEFMETHOD DECOMPILE-SCRIPT ((aso applescript-object))  ;;  extract the script from the compiled script.  Most  ;;  useful when doing recording  (with-pointers ((as (component aso)))    (let* ((descObj (make-instance 'aedesc :type #$TypeChar))           (id (compiled-script-id aso))           (err (#_OSAGetSource as id #$typeChar                   (getDescRecPtr descObj))))      (cond ((zerop err)             ;;  extract the text from the descriptor, then             ;;  add the script to the script slot of the             ;;  object and inform the object that the             ;;  script has changed             (setf (script aso)                   (as-get-string (rref (getDescRecPtr descObj)                        AEDesc.dataHandle))                   (compiled-script aso) t))            (t (if (break-on-error ASO)                     (error (script-error as)))               )            )      )    )  )(DEFMETHOD HANDLE-RECORDED-TEXT ((aso APPLESCRIPT-OBJECT) string)  "Tell the object to handle the recorded text.  THis usually means writing thetext to the applescript editor."  ;;  if there is an open applescript editor make sure that the current object  ;;  is aso and send the string there, otherwise go to the lisp listener (or do  ;;  some other thing overriden  (cond ((and (boundp '*AS-SCRIPT-EDITOR*)              *AS-SCRIPT-EDITOR*              (wptr *AS-SCRIPT-EDITOR*))         ;;  this appends to the end of the script         (let ((input.buffer (view-named 'input-buffer *AS-SCRIPT-EDITOR*)))           (setf (slot-value *AS-SCRIPT-EDITOR* 'current.object) aso)           (set-dialog-item-text input.buffer                                  (concatenate 'string                                              (dialog-item-text input.buffer)                                              (format nil "~a~%" string))))         )        (t          (print-to-listener string)))  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Utilities;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(DEFUN PRINT-TO-LISTENER (string)"	Prints string to the listener	"    (format t "~A~%" string)  )(DEFUN EXTRACT-SCRIPT-TEXT (text)  "Remove any tabs and linefeeds from the text if the script should be of shortform, otherwise if the script is of the type 'tell, end tell' just return thewhole thing"  ;;  see if the last word of the text is "tell"  (if (string= "tell" (last-word text))    text    (strip-lf&tab text)))(DEFUN STRIP-LF&TAB (string)  "Removes linefeeds and tabs from a copy of string"  (substitute-if #\space #'(lambda (char)                 (or (char= char #\return)                     (char= char #\tab)))             string))(DEFUN AS-GET-STRING (data)  (let* ((size (#_GetHandleSize data))            (text (make-string size)))     (dotimes (i size)        (setf (char text i) (code-char (%hget-byte data i))))     text))(DEFUN SCRIPT-ERROR (as)  (with-aedescs (err)    (if (/= (#_OSAScriptError as #$kOSAErrorMessage #$typeChar err) #$noErr)      ""      (as-get-string (rref err AEDesc.dataHandle)))))(defun LAST-WORD (text)  "Return the last word from text (downcased)"  (let* ((txt (reverse (STRIP-LF&TAB text))))        (if (whitespacep (char txt 0))      ; whitespace at end      (last-word (subseq text 0 (1-  (length text))))      (string-downcase (reverse (subseq txt 0 (position #\space txt)))))))    ;;  Installing the handler for continuous recording;;  define in the context of the ccl package(let ((*package* (find-package :ccl)))  (defmethod receive-script-text ((a application) aevent reply handler-ref-con)    (declare (ignore reply handler-ref-con))    (if *applescript-dispatcher*      (HANDLE-RECEIVED-SCRIPT-TEXT *applescript-dispatcher* aevent))    )    (install-appleevent-handler #$kOSASuite #$kOSARecordedText #'receive-script-text)    )(provide :appleScript)#|;;  testing junk(setf ttest (make-instance 'applescript-object))(setf ttest (make-instance 'applescript-object :get-recorded-text t))(start-recording ttest)(stop-recording ttest)(inspect ttest)(execute-applescript ttest)(decompile-script ttest)(cleanup ttest);;  this works with the scriptable text editor(setf astest (make-instance 'APPLESCRIPT-OBJECT               :script "tell \"Scriptable Text Editor\" to set the size of word 1 of window 1 of application \"Scriptable Text Editor\" to 48"))(compile-applescript astest)(execute-applescript astest)(edit-script astest)(cleanup astest);;"tell \"Scriptable Text Editor\" to set the size of word 1 of window 1 of application \"Scriptable Text Editor\" to 48""tell \"Scriptable Text Editor\" to get the second word of window 1 of application \"Scriptable Text Editor\"";;  test the loading of a script from the file ccl:testscript - this was created;;  using the standard script editor.(setf testscript (make-instance 'applescript-object))(load-script testscript "ccl:testscript" 128)(execute-applescript testscript)(cleanup testscript)|#