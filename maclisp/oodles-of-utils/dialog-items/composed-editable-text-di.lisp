(in-package :oou)(oou-provide :composed-editable-text-di);----------------------------------------------------------------------------------                                 ;; Copyright © 1991-95 Institut fuer Informatik, University of Basel, Switzerland ; All Rights Reserved;; Author: Dieter Holz;; ;; Changes (worth to be mentioned):; ------------------------------; ; April 1995  Dieter : Minor modifications for MCL 3.0;;-----------------------------------------------------------------------------------;-----------------------------------------------------------------------------------(oou-dependencies :simple-view-ce                  :adjust-size-mixin                  :layout-system)(export '(          ));-----------------------------------------------------------------------------------(locally  (declare (optimize (safety 0)                      (speed 3)                      (space 3)                     (compilation-speed 0)                     (debug 0)))(defclass part-of-composed-editable-text-di (adjust-size-mixin editable-text-dialog-item)  ()  (:default-initargs    :draw-outline t    :view-size #@(5 5)    :view-font '("Monaco" 12 :plain)    :text-edit-sel-p nil))(defmethod install-view-in-window :after ((self part-of-composed-editable-text-di) window)  (declare (ignore window))  (when (null (slot-value self 'ccl::draw-outline))    (setf (outline-margin (view-container self)) 0)))(defmethod view-key-event-handler :around ((self part-of-composed-editable-text-di) char)  (let* ((buff (fred-buffer self))         (container (view-container self))         (all-parts (parts container))         (pos-in-parts (position self all-parts)))    (cond ((and (char= char #\ForwardArrow)                (= (buffer-position buff) (buffer-size buff))                (< pos-in-parts (1- (length all-parts))))           (let ((next-part (elt all-parts (1+ pos-in-parts))))             (set-mark (fred-buffer next-part) 0)             (set-current-key-handler (view-window self) next-part)))          ((and (char= char #\BackArrow)                (= (buffer-position buff) 0)                (/= pos-in-parts 0))           (let ((next-part (elt all-parts (1- pos-in-parts))))             (set-mark (fred-buffer next-part) (buffer-size (fred-buffer next-part)))             (set-current-key-handler (view-window self) next-part)))          (t           (call-next-method)))))(defmethod adjust-size-to-content :after ((self part-of-composed-editable-text-di) &key (redraw-p t))  (declare (ignore redraw-p))   (when (and (wptr self)             (need-to-update self))    (let ((win (view-window self)))      (set-current-key-handler win nil)      (update-layout-and-size (view-container self))      (when (wptr self)        (set-current-key-handler win self)))));-----------------------------------------------------------------------------------------(defclass composed-editable-text-di (layout-mixin view)  ((parts :initform nil          :accessor parts)   (unused-parts :initform nil                 :accessor unused-parts)   (text-parts :initform nil               :accessor text-parts               :initarg :text-parts)   (class-of-parts :initform 'part-of-composed-editable-text-di                   :accessor class-of-parts                   :initarg :class-of-parts)   (number-of-parts :initform 2                    :accessor number-of-parts                    :initarg :number-of-parts)   (distance-between-parts :initform 2                           :accessor distance-between-parts                           :initarg :distance-between-parts)   (top-and-bottom-margin :initform 2                          :accessor top-and-bottom-margin                          :initarg :top-and-bottom-margin)   (outline-margin :initform 3                   :accessor outline-margin                   :initarg :outline-margin)   (draw-outline :initform t                 :accessor draw-outline                 :initarg :draw-outline))  (:default-initargs    :view-size #@(10 10)))(defmethod initialize-instance :after ((self composed-editable-text-di) &rest initargs)  (declare (ignore initargs))  (with-slots (class-of-parts number-of-parts parts text-parts) self    (dotimes (i number-of-parts)      (let ((new-part (make-instance class-of-parts                         :dialog-item-text (elt text-parts (- (1- number-of-parts) i)))))        ;(set-view-container new-part self)        (push new-part parts)))))(defmethod install-view-in-window :after ((self composed-editable-text-di) window)  (declare (ignore window))  (update-layout-and-size self))(defmethod view-draw-contents :after ((self composed-editable-text-di))  (when (draw-outline self)    (view-frame self)))(defmethod update-layout-and-size ((self composed-editable-text-di))  (with-slots (draw-outline adapt-layout-to-size parts class-of-parts number-of-parts distance-between-parts top-and-bottom-margin outline-margin) self    (setf adapt-layout-to-size nil)    (with-focused-view self      (when draw-outline        (with-pen-pattern (*white-pattern* self)          (#_MoveTo (- (view-width self) 1) 1)          (#_Line 0 (- (view-height self) 3))))      (let ((old-draw-outline draw-outline)            (old-width (view-width self))            (old-height (view-height self))            (new-width (+ 1                          distance-between-parts                          (* (+ distance-between-parts (* 2 outline-margin)) number-of-parts)                          (apply #'+ (mapcar #'(lambda (part)                                                 (view-width part))                                             parts))                          1))            (new-height (+ (+ 1 top-and-bottom-margin)                           outline-margin                           (view-height (car parts))                           (- top-and-bottom-margin outline-margin)                           (+ 1 top-and-bottom-margin (- (* 2 outline-margin) top-and-bottom-margin))                           )))        (setf draw-outline nil)         (setf (slot-value self 'view-size) (make-point new-width new-height))        (setf (adapt-layout-to-size self) t)        (setf draw-outline old-draw-outline)        (ccl::make-view-invalid self)         (invalidate-corners (view-container self)                            (view-to-container self (make-point (min old-width new-width) 0))                            (view-to-container self (make-point (max old-width new-width)                                                                (max old-height new-height)))                            t)         (setf (layout self)              (:vbox ()                     (+ 1 top-and-bottom-margin)                     `(:hbox ()                             1                             ,distance-between-parts                             ,@(mapcan #'(lambda (part)                                           (list (:hbox (:width (view-width part)) part)                                                 (+ distance-between-parts (* 2 outline-margin))))                                       parts)                             1)                     (+ 1 top-and-bottom-margin (- (* 2 outline-margin) top-and-bottom-margin))                     ))        (when draw-outline          (with-pen-pattern (*black-pattern* self)            (#_MoveTo (1- (view-width self)) 0)            (#_Line 0 (view-height self))))        ))))(defmethod get-new-part ((self composed-editable-text-di))  (with-slots (unused-parts) self    (let ((new-part (if unused-parts                      (pop unused-parts)                      (initialize-new-part self))))      (set-view-container new-part self)      new-part)))(defmethod initialize-new-part ((self composed-editable-text-di))  (make-instance (class-of-parts self)         :view-size (view-size (car (parts self)))        ))(defmethod distribute-text-parts ((self composed-editable-text-di) &rest text-parts)  (do ((new-text-parts text-parts (cdr new-text-parts))       (editable-parts (parts self) (cdr editable-parts))       (actual-parts))      ((null new-text-parts)       (when editable-parts         (setf (unused-parts self)               (nconc (unused-parts self) editable-parts)))       (setf (parts self)             (nreverse actual-parts))       (setf (number-of-parts self) (length (parts self)))       (when (wptr self)         (update-layout-and-size self)))    (let* ((editable-part (or (car editable-parts)                             (get-new-part self)))           (buffer (fred-buffer editable-part)))      (buffer-delete buffer (buffer-size buffer) 0)      (buffer-insert-substring buffer (car new-text-parts))      (adjust-size-to-content editable-part :redraw-p nil)      (setf (old-modcnt editable-part) (buffer-modcnt buffer))       (push editable-part actual-parts))))(defmethod compute-text-parts ((self composed-editable-text-di))  (let ((all-text-parts nil))    (dolist (part (parts self))      (push (dialog-item-text part)            all-text-parts))    (nreverse all-text-parts)))(defmethod text-parts ((self composed-editable-text-di))  (compute-text-parts self)))#|(make-instance 'window  :view-subviews (list (setf cdi (make-instance 'composed-editable-text-di                         :text-parts (list "hello, hello" "New York")                         :view-position #@(10 10)))))(distribute-text-parts cdi "hello" "hello" )(text-parts cdi)|#                                    