;;;-*- Mode: Lisp; Package: CCL -*-;;	Change History (most recent first):;;  21 1/22/97 akh  dbg doesn't clobber imm0;;  19 5/20/96 akh  add %car;;  7 10/26/95 gb   not sure what changed;;  4 10/13/95 bill ccl3.0x25;;  3 10/7/95  slh  added arith/misc macros at end;;  2 10/6/95  gb   new EVENT-POLL.;;  (do not edit before this line!!);; Mod History;;;; 03/01/97 gb    some fp stuff, eq->boolean.;; 02/25/97 bill  xp-register-image, xp-machine-state, ri-grp, set-ri-gpr, ms-XX, set-ms-XX;; 02/03/97 bill  Gary's fix to check-nargs: twlgt => twlgti;; -------------- 4.0;; akh add %car;; 07/07/96 bill  dbg;; 06/17/96 bill  no-memoize optional arg to svset;; -------------  MCL-PPC 3.9;; 03/27/96 bill  svset memoizes the modified address;; 03/10/96 gb    FP stuff;; 01/25/96 bill  svref, svset;; 01/04/96 bill  fix box-signed-byte-32;; 12/27/95 gb    vpush-argregs.;; 12/13/95 gb    box-[signed,unsigned]-byte-32;; 11/29/95 bill  unbox-base-character, unbox-character, box-character;; 11/15/95 slh   no blr in make-int macro;; 10/25/95 slh   make-int;; 10/19/95 slh   compose-digit here;; 10/12/95 bill  :loa-toplevel -> :load-toplevel;;(eval-when (:compile-toplevel :load-toplevel :execute)  (require "PPC-LAP"))(defppclapmacro dbg (&optional save-lr?)  (if save-lr?    `(progn       (mflr loc-pc)       (stw imm0 -40 sp) ; better than clobbering imm0       (bla .SPbreakpoint)       (lwz imm0 -40 sp)       (mtlr loc-pc))    `(bla .SPbreakpoint)))(defppclapmacro lwi (dest n)  (setq n (logand n #xffffffff))  (let* ((mask #xffff8000)         (masked (logand n mask))         (high (ash n -16))         (low (logand #xffff n)))    (if (or (= 0 masked) (= mask masked))      `(li ,dest ,low)      (if (= low 0)        `(lis ,dest ,high)        `(progn           (lis ,dest ,high)           (ori ,dest ,dest ,low))))))(defppclapmacro set-nargs (n)  (check-type n (unsigned-byte 13))  `(li nargs ',n))(defppclapmacro check-nargs (min &optional (max min))  (if (eq max min)    `(twnei nargs ',min)    (if (null max)      (unless (= min 0)        `(twllti nargs ',min))      (if (= min 0)        `(twlgti nargs ',max)        `(progn           (twllti nargs ',min)           (twlgti nargs ',max)))))); Event-polling involves checking to see if the value of *interrupt-level*; is > 0.  For now, use nargs; this may change to "any register BUT nargs".; (Note that most number-of-args traps use unsigned comparisons.)(defppclapmacro event-poll ()  '(progn     (lwz nargs #.(+ ppc::symbol.vcell (ppc::nrs-offset *interrupt-level*)) rnil)     (twgti nargs 0)));; The general idea is that storing zero N bytes beyond the end of;; a stack pointer will generate a write-protection violation if;; a stack overflow is pending.  "N" should be somewhere around;; the page size.  If a function uses more than N bytes of stack,;; it should poll every time it's pushed around N bytes ...(defppclapmacro stack-probe (stackpointer &optional (n -4096))  `(stw rzero ,n ,stackpointer))(defppclapmacro vstack-probe (&optional (n -4096))  `(stack-probe vsp ,n))(defppclapmacro tstack-probe (&optional (n -4096))  `(stack-probe tsp ,n)); There's no "else"; learn to say "(progn ...)".; Note also that the condition is a CR bit specification (or a "negated" one).; Whatever affected that bit (hopefully) happened earlier in the pipeline.(defppclapmacro if (test then &optional (else nil else-p))  (multiple-value-bind (bitform negated) (ppc-lap-parse-test test)    (let* ((false-label (gensym)))      (if (not else-p)        `(progn           (,(if negated 'bt 'bf) ,bitform ,false-label)           ,then           ,false-label)        (let* ((cont-label (gensym)))          `(progn             (,(if negated 'bt 'bf) ,bitform ,false-label)             ,then             (b ,cont-label)             ,false-label             ,else             ,cont-label))))))(defppclapmacro save-pc ()  `(mflr loc-pc)); This needs to be done if we aren't a leaf function (e.g., if we clobber our; return address or need to reference any constants.  Note that it's not; atomic wrt a preemptive scheduler, but we need to pretend that it will be.); The VSP to be saved is the value of the VSP before any of this function's; arguments were vpushed by its caller; that's not the same as the VSP register; if any non-register arguments were received, but is usually easy to compute.(defppclapmacro save-lisp-context (&optional (vsp 'vsp) (save-pc t))  `(progn     ,@(if save-pc          '((save-pc)))     (stwu sp (- ppc::lisp-frame.size) sp)     (stw fn ppc::lisp-frame.savefn sp)     (mr fn nfn)     (stw loc-pc ppc::lisp-frame.savelr sp)     (stw ,vsp ppc::lisp-frame.savevsp sp))); There are a few cases to deal with when restoring: whether or not to restore the; vsp, whether we need to saved LR back in the LR or whether it only needs to get; as far as loc-pc, etc.  This fully restores everything (letting the caller specify; some register other than the VSP, if that's useful.)  Note that, since FN gets restored,; it's no longer possible to use it to address the current function's constants.(defppclapmacro restore-full-lisp-context (&optional (vsp 'vsp))  `(progn     (lwz loc-pc ppc::lisp-frame.savelr sp)     (lwz ,vsp ppc::lisp-frame.savevsp sp)     (mtlr loc-pc)     (lwz fn ppc::lisp-frame.savefn sp)     (la sp ppc::lisp-frame.size sp)))(defppclapmacro restore-pc ()  `(mtlr loc-pc))(defppclapmacro push (src stack)  `(stwu ,src -4 ,stack))(defppclapmacro vpush (src)  `(push ,src vsp)); You typically don't want to do this to pop a single register (it's better to; do a sequence of loads, and then adjust the stack pointer.)(defppclapmacro pop (dest stack)  `(progn     (lwz ,dest 0 ,stack)     (la ,stack 4 ,stack)))(defppclapmacro vpop (dest)  `(pop ,dest vsp))(defppclapmacro %cdr (dest node)  `(lwz ,dest ppc::cons.cdr ,node))(defppclapmacro %car (dest node)  `(lwz ,dest ppc::cons.car ,node))(defppclapmacro extract-lisptag (dest node)  `(clrlwi ,dest ,node (- 32 ppc::nlisptagbits)))(defppclapmacro extract-fulltag (dest node)  `(clrlwi ,dest ,node (- 32 ppc::ntagbits)))(defppclapmacro extract-subtag (dest node)  `(lbz ,dest ppc::misc-subtag-offset ,node))(defppclapmacro extract-typecode (dest node &optional (crf :cr0))  `(progn     (extract-lisptag ,dest ,node)     (cmpwi ,crf ,dest ppc::tag-misc)     (if (,crf :eq)       (extract-subtag ,dest ,node))))(defppclapmacro trap-unless-lisptag= (node tag &optional (immreg ppc::imm0))  `(progn     (extract-lisptag ,immreg ,node)     (twnei ,immreg ,tag)))(defppclapmacro trap-unless-fulltag= (node tag &optional (immreg ppc::imm0))  `(progn     (extract-fulltag ,immreg ,node)     (twnei ,immreg ,tag)))(defppclapmacro trap-unless-typecode= (node tag &optional (immreg ppc::imm0) (crf :cr0))  `(progn     (extract-typecode ,immreg ,node ,crf)     (twnei ,immreg ,tag)))(defppclapmacro load-constant (dest constant)  `(lwz ,dest ',constant fn));; This is about as hard on the pipeline as anything I can think of.(defppclapmacro call-symbol (function-name)  `(progn     (load-constant fname ,function-name)     (lwz nfn ppc::symbol.fcell fname)     (lwz loc-pc ppc::misc-data-offset nfn)     (mtctr loc-pc)     (bctrl)))(defppclapmacro sp-call-symbol (function-name)  `(progn     (load-constant fname ,function-name)     (bla .SPjmpsym)))(defppclapmacro getvheader (dest src)  `(lwz ,dest ppc::misc-header-offset ,src));; "Size" is unboxed element-count.(defppclapmacro header-size (dest vheader)  `(srwi ,dest ,vheader ppc::num-subtag-bits));; "Length" is fixnum element-count.(defppclapmacro header-length (dest vheader)  `(rlwinm ,dest            ,vheader            (- ppc::nbits-in-word (- ppc::num-subtag-bits ppc::nfixnumtagbits))           (- ppc::num-subtag-bits ppc::nfixnumtagbits)           (- ppc::least-significant-bit ppc::nfixnumtagbits)))(defppclapmacro header-subtag[fixnum] (dest vheader)  `(rlwinm ,dest           ,vheader           ppc::fixnumshift           (- ppc::nbits-in-word (+ ppc::num-subtag-bits ppc::nfixnumtagbits))           (- ppc::least-significant-bit ppc::nfixnumtagbits)))(defppclapmacro vector-size (dest v vheader)  `(progn     (getvheader ,vheader ,v)     (header-size ,dest ,vheader)))(defppclapmacro vector-length (dest v vheader)  `(progn     (getvheader ,vheader ,v)     (header-length ,dest ,vheader)));; Reference a 32-bit miscobj entry at a variable index.;; Make the caller explicitly designate a scratch register;; to use for the scaled index.(defppclapmacro vref32 (dest miscobj index scaled-idx)  `(progn     (la ,scaled-idx ppc::misc-data-offset ,index)     (lwzx ,dest ,miscobj ,scaled-idx)));; The simple (no-memoization) case.(defppclapmacro vset32 (src miscobj index scaled-idx)  `(progn     (la ,scaled-idx ppc::misc-data-offset ,index)     (stwx ,src ,miscobj ,scaled-idx)))(defppclapmacro extract-lowbyte (dest src)  `(clrlwi ,dest ,src (- 32 8)))(defppclapmacro unbox-fixnum (dest src)  `(srawi ,dest ,src ppc::fixnumshift))(defppclapmacro box-fixnum (dest src)  `(slwi ,dest ,src ppc::fixnumshift))(defppclapmacro box-signed-byte-32 (dest src temp)  ; "temp" shouldn't be the same register as "src".  ; "src" and "temp" should be unboxed registers;   ; "dest" should be a boxed register  `(progn     (mcrxr cr0)                        ; avoid this, someday     (addo ,temp ,src ,src)             ; shift left 1 bit, update XER     (addo. ,dest ,temp ,temp)          ; shift left another bit, update XER, CR0[SO]     (if (:cr0 :so)       (uuo_box_signed ,dest ,src))))(defppclapmacro box-unsigned-byte-32 (dest src temp)  ; "temp" shouldn't be the same register as "src".  ; "src" and "temp" should be unboxed registers;   ; "dest" should be a boxed register  `(progn     (clrrwi. ,temp ,src (- ppc::least-significant-bit ppc::nfixnumtagbits))     (box-fixnum ,dest ,src)     (if (:cr0 :ne)       (uuo_box_unsigned ,dest ,src)))); If crf is specified, type checks src(defppclapmacro unbox-base-character (dest src &optional crf)  (if (null crf)    `(srwi ,dest ,src ppc::charcode-shift)    (let ((label (gensym)))      `(progn         (rlwinm ,dest ,src 8 16 31)         (cmpwi ,crf ,dest (ash ppc::subtag-character 8))         (srwi ,dest ,src ppc::charcode-shift)         (beq+ ,crf ,label)         (uuo_interr ppc::error-object-not-base-character ,src)         ,label)))); If crf is specified, type checks src(defppclapmacro unbox-character (dest src &optional crf)  (if (null crf)    `(srwi ,dest ,src ppc::charcode-shift)    (let ((label (gensym)))      `(progn         (clrlwi ,dest ,src 24)         (cmpwi ,crf ,dest ppc::subtag-character)         (srwi ,dest ,src ppc::charcode-shift)         (beq+ ,crf ,label)         (uuo_interr ppc::error-object-not-character ,src)         ,label))))(defppclapmacro box-character (dest src)  `(progn     (li ,dest ppc::subtag-character)     (rlwimi ,dest ,src 16 0 15)))(defppclapmacro ref-global (reg sym)  (let* ((offset (ppc::%kernel-global sym)))    `(lwz ,reg ,offset rnil)))(defppclapmacro set-global (reg sym)  (let* ((offset (ppc::%kernel-global sym)))    `(stw ,reg ,offset rnil))); Set "dest" to those bits in "src" that are other than those; that would be set if "src" is a fixnum and of type (unsigned-byte "width").; If no bits are set in "dest", then "src" is indeed of type (unsigned-byte "width").(defppclapmacro extract-unsigned-byte-bits (dest src width)  `(rlwinm ,dest ,src 0 (- 32 ppc::fixnumshift) (- 31 (+ ,width ppc::fixnumshift)))); As above, but set (:CR0 :EQ) according to the result.(defppclapmacro extract-unsigned-byte-bits. (dest src width)  `(rlwinm. ,dest ,src 0 (- 32 ppc::fixnumshift) (- 31 (+ ,width ppc::fixnumshift))));;; from/blame slh:; setpred depends on this(eval-when (:compile-toplevel :execute :load-toplevel)  (assert (= ppc::t-offset #x11)))(defppclapmacro setpred (dest crf cc-bit &optional (temp 'imm0))  (let ((shift (+ (* (position crf '(:cr0 :cr1 :cr2 :cr3 :cr4 :cr5 :cr6 :cr7)) 4)                  (position cc-bit '(:lt :gt :eq :so))                  1)))    `(progn       (mfcr ,temp)       (rlwinm ,temp ,temp ,shift 31 31)    ; get  1 bit       (rlwimi ,temp ,temp      4 27 27)    ; get 16 bit       (add ,dest ,temp rnil)))); You generally don't want to have to say "mfcr": it crosses functional; units and forces synchronization (all preceding insns must complete,; no subsequent insns may start.); There are often algebraic ways of computing ppc::t-offset:(defppclapmacro eq0->boolean (dest src temp)  `(progn     (cntlzw ,temp ,src)                ; 32 leading zeros if (= rx ry)     (srwi ,temp ,temp 5)               ; temp = (rx == ry), C-wise     (rlwimi ,temp ,temp 4 27 27)       ; temp = ppc::t-offset or 0     (add ,dest ppc::rnil ,temp)))      ; dest = (eq rx ry), lisp-wise(defppclapmacro eq->boolean (dest rx ry temp)  `(progn     (sub ,temp ,rx ,ry)     (eq0->boolean ,dest ,temp ,temp)))  (defppclapmacro get-single-float (dest node)  `(lfs ,dest ppc::single-float.value ,node))(defppclapmacro get-double-float (dest node)  `(lfd ,dest ppc::double-float.value ,node))(defppclapmacro put-single-float (src node)  `(stfs ,src ppc::single-float.value ,node))(defppclapmacro put-double-float (src node)  `(stfd ,src ppc::double-float.value ,node))(defppclapmacro clear-fpu-exceptions ()  `(mtfsf #xfc #.ppc::fp-zero))(defppclapmacro get-boxed-sign (dest src crf)  `(progn     (load-constant ,dest 1)               ; assume positive     (mtcrf ,crf ,src)     (if (,crf :lt)       (load-constant ,dest -1)))); from ppc-bignum.lisp(defppclapmacro digit-h (dest src)  `(rlwinm ,dest ,src (+ 16 ppc::fixnumshift) (- 16 ppc::fixnumshift) (- 31 ppc::fixnumshift))); from ppc-bignum.lisp(defppclapmacro digit-l (dest src)  `(clrlslwi ,dest ,src 16 ppc::fixnumshift))  ; from ppc-bignum.lisp(defppclapmacro compose-digit (dest high low)  `(progn     (rlwinm ,dest ,low (- ppc::nbits-in-word ppc::fixnumshift) 16 31)     (rlwimi ,dest ,high (- 16 ppc::fixnumshift) 0 15)))(defppclapmacro macptr-ptr (dest macptr)  `(lwz ,dest ppc::macptr.address ,macptr))(defppclapmacro svref (dest index vector)  `(lwz ,dest (+ (* 4 ,index) ppc::misc-data-offset) ,vector)); This evals its args in the wrong order.; Can't imagine any code will care.(defppclapmacro svset (new-value index vector &optional no-memoize)  (if no-memoize    `(stw ,new-value (+ (* 4 ,index) ppc::misc-data-offset) ,vector)    `(progn       (la loc-g (+ (* 4 ,index) ppc::misc-data-offset) ,vector)       (stwu loc-g -4 memo)       (stw ,new-value 0 loc-g)))); I don't know if anyone actually calls this with; temp defaulting to src, but that'd be a really bad idea.(defppclapmacro make-int (result src &optional (temp src))  (let ((lbl-done (gensym)))    `(progn       (mcrxr 0)                             ; could insist that XER[ov,so] and CR0[so] are always 0       (addo ,temp ,src ,src)       (addo. ,result ,temp ,temp)       (bns+ ,lbl-done)       (uuo_box_signed ,result ,src)       ,lbl-done       )))(defppclapmacro vpush-argregs ()  (let* ((none (gensym))         (two (gensym))         (one (gensym)))    `(progn       (cmpwi cr1 nargs '2)       (cmpwi cr0 nargs 0)       (beq cr1 ,two)       (beq cr0 ,none)       (blt cr1 ,one)       (vpush arg_x)       ,two       (vpush arg_y)       ,one       (vpush arg_z)       ,none))); Set FP-reg to 0.0 . Using (fsub fp-reg fp-reg fpreg); doesn't work if fp-reg contains a NaN.(defppclapmacro zero-fp-reg (fp-reg)  (let* ((offset (ppc::kernel-global short-float-zero)))    `(lfs ,fp-reg ,offset rnil)))(defppclapmacro fp-check-binop-exception (rt ra rb)  `(progn     (if (:cr1 :gt)                     ; set if enabled exception has occurred       (uuo_fpuXbinop ,rt ,ra ,rb))))(defppclapmacro fp-check-unaryop-exception (rt ra rb)  `(progn     (if (:cr1 :gt)                     ; set if enabled exception has occurred       (uuo_fpuXbinop ,rt ,ra ,rb)))); Functions to access exception frames(defppclapmacro xp-register-image (ri xp)  `(lwz ,ri ,(get-field-offset :ExceptionInformationPowerPC.registerImage) ,xp))(defppclapmacro ri-gpr (dest ri reg)  `(lwz ,dest ,(xp-register-offset (eval reg)) ,ri))(defppclapmacro set-ri-gpr (source ri reg)  `(stw ,source ,(xp-register-offset (eval reg)) ,ri))(defppclapmacro xp-machine-state (ms xp)  `(lwz ,ms ,(get-field-offset :ExceptionInformationPowerPC.machineState) ,xp))(defppclapmacro ms-lr (dest ms)  `(lwz ,dest ,(get-field-offset :MachineInformationPowerPC.lr.lo) ,ms))(defppclapmacro set-ms-lr (source ms)  `(stw ,source ,(get-field-offset :MachineInformationPowerPC.lr.lo) ,ms))(defppclapmacro ms-pc (dest ms)  `(lwz ,dest ,(get-field-offset :MachineInformationPowerPC.pc.lo) ,ms))(defppclapmacro set-ms-pc (source ms)  `(stw ,source ,(get-field-offset :MachineInformationPowerPC.pc.lo) ,ms))(defppclapmacro ms-cr (dest ms)  `(lwz ,dest ,(get-field-offset :MachineInformationPowerPC.cr) ,ms))(defppclapmacro set-ms-cr (source ms)  `(stw ,source ,(get-field-offset :MachineInformationPowerPC.cr) ,ms))(defppclapmacro ms-xer (dest ms)  `(lwz ,dest ,(get-field-offset :MachineInformationPowerPC.xer) ,ms))(defppclapmacro set-ms-xer (source ms)  `(stw ,source ,(get-field-offset :MachineInformationPowerPC.xer) ,ms))(ccl::provide "PPC-LAPMACROS"); end of ppc-lapmacros.lisp